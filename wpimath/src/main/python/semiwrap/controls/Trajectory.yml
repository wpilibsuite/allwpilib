defaults:
  subpackage: trajectory

extra_includes:
- rpy/geometryToString.h

classes:
  wpi::math::Trajectory:
    force_type_casters:
    - wpi::units::curvature_t
    methods:
      Trajectory:
        overloads:
          '':
          const std::vector<State>&:
      TotalTime:
      TransformBy:
      RelativeTo:
      InitialPose:
      operator==:
      Samples:
      Start:
      End:
      SampleAt:
        overloads:
          wpi::units::second_t [const]:
          double [const]:
      Interpolate:
      Concatenate:
    attributes:
      m_samples:
      m_sampleMap:
      m_duration:

inline_code: |
  cls_State
    .def(
      py::init<
        wpi::units::second_t,
        wpi::units::meters_per_second_t,
        wpi::units::meters_per_second_squared_t,
        Pose2d,
        wpi::units::curvature_t
      >(),
      py::arg("t") = 0_s,
      py::arg("velocity") = 0_mps,
      py::arg("acceleration") = 0_mps_sq,
      py::arg("pose") = Pose2d(),
      py::arg("curvature") = 0.0
    )
    .def_property_readonly("velocity_fps", [](wpi::math::Trajectory::State * self) -> wpi::units::feet_per_second_t {
      return self->velocity;
    })
    .def_property_readonly("acceleration_fps", [](wpi::math::Trajectory::State * self) -> wpi::units::feet_per_second_squared_t {
      return self->acceleration;
    })
    .def("__repr__", [](wpi::math::Trajectory::State *self) {
      return "Trajectory.State("
        "t=" + std::to_string(self->t()) + ", "
        "velocity=" + std::to_string(self->velocity()) + ", "
        "acceleration=" + std::to_string(self->acceleration()) + ", "
        "pose=" + rpy::toString(self->pose) + ", "
        "curvature=" + std::to_string(self->curvature()) + ")";
    })
    .def_readwrite("curvature", &wpi::math::Trajectory::State::curvature);
