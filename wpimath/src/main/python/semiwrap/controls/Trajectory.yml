defaults:
  subpackage: trajectory

extra_includes:
- rpy/geometryToString.h

functions:
  to_json:
    ignore: true
  from_json:
    ignore: true
classes:
  wpi::math::Trajectory:
    force_type_casters:
    - wpi::units::curvature_t
    methods:
      Trajectory:
        overloads:
          '':
          const std::vector<State>&:
      TotalTime:
      States:
      Sample:
      TransformBy:
      RelativeTo:
      InitialPose:
      operator+:
      operator==:
  wpi::math::Trajectory::State:
    force_no_default_constructor: true
    attributes:
      t:
      velocity:
      acceleration:
      pose:
      curvature:
    methods:
      operator==:
      Interpolate:

inline_code: |
  cls_State
    .def(
      py::init<
        wpi::units::second_t,
        wpi::units::meters_per_second_t,
        wpi::units::meters_per_second_squared_t,
        Pose2d,
        wpi::units::curvature_t
      >(),
      py::arg("t") = 0_s,
      py::arg("velocity") = 0_mps,
      py::arg("acceleration") = 0_mps_sq,
      py::arg("pose") = Pose2d(),
      py::arg("curvature") = 0.0
    )
    .def_property_readonly("velocity_fps", [](wpi::math::Trajectory::State * self) -> wpi::units::feet_per_second_t {
      return self->velocity;
    })
    .def_property_readonly("acceleration_fps", [](wpi::math::Trajectory::State * self) -> wpi::units::feet_per_second_squared_t {
      return self->acceleration;
    })
    .def("__repr__", [](wpi::math::Trajectory::State *self) {
      return "Trajectory.State("
        "t=" + std::to_string(self->t()) + ", "
        "velocity=" + std::to_string(self->velocity()) + ", "
        "acceleration=" + std::to_string(self->acceleration()) + ", "
        "pose=" + rpy::toString(self->pose) + ", "
        "curvature=" + std::to_string(self->curvature()) + ")";
    })
    .def_readwrite("curvature", &wpi::math::Trajectory::State::curvature);
