From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 26 Apr 2022 15:01:25 -0400
Subject: [PATCH 2/9] Fix missing casts

---
 src/fs-poll.c                  | 10 +++----
 src/idna.c                     |  2 +-
 src/inet.c                     | 11 ++++----
 src/strscpy.c                  |  2 +-
 src/thread-common.c            |  2 +-
 src/threadpool.c               |  2 +-
 src/unix/bsd-ifaddrs.c         |  2 +-
 src/unix/core.c                | 18 ++++++-------
 src/unix/darwin-proctitle.c    |  5 ++--
 src/unix/darwin.c              |  2 +-
 src/unix/freebsd.c             |  4 +--
 src/unix/fs.c                  | 22 ++++++++--------
 src/unix/fsevents.c            | 34 ++++++++++++------------
 src/unix/getaddrinfo.c         |  8 +++---
 src/unix/ibmi.c                |  2 +-
 src/unix/kqueue.c              |  6 ++---
 src/unix/linux.c               | 48 +++++++++++++++++-----------------
 src/unix/loop.c                |  2 +-
 src/unix/netbsd.c              |  4 +--
 src/unix/openbsd.c             |  4 +--
 src/unix/pipe.c                |  8 +++---
 src/unix/poll.c                |  4 +--
 src/unix/posix-poll.c          |  2 +-
 src/unix/process.c             |  4 +--
 src/unix/proctitle.c           |  2 +-
 src/unix/random-sysctl-linux.c |  2 +-
 src/unix/stream.c              | 33 +++++++++++------------
 src/unix/tcp.c                 |  2 +-
 src/unix/thread.c              |  5 ++--
 src/unix/udp.c                 |  8 +++---
 src/uv-common.c                | 16 ++++++------
 src/win/core.c                 |  8 +++---
 src/win/dl.c                   |  2 +-
 src/win/fs-event.c             |  4 +--
 src/win/fs-fd-hash-inl.h       |  2 +-
 src/win/fs.c                   | 38 +++++++++++++--------------
 src/win/getaddrinfo.c          | 10 +++----
 src/win/pipe.c                 | 12 ++++-----
 src/win/process.c              | 20 +++++++-------
 src/win/tcp.c                  |  2 +-
 src/win/thread.c               |  6 ++---
 src/win/tty.c                  |  6 ++---
 src/win/util.c                 | 35 +++++++++++++------------
 43 files changed, 213 insertions(+), 208 deletions(-)

diff --git a/src/fs-poll.c b/src/fs-poll.c
index 1bac1c568e36cadd0b68451926c6f045f88342d2..5a39daed095502b2db34f23fcaf0ab04f31f96ff 100644
--- a/src/fs-poll.c
+++ b/src/fs-poll.c
@@ -77,7 +77,7 @@ int uv_fs_poll_start(uv_fs_poll_t* handle,
 
   loop = handle->loop;
   len = strlen(path);
-  ctx = uv__calloc(1, sizeof(*ctx) + len);
+  ctx = (struct poll_ctx*)uv__calloc(1, sizeof(*ctx) + len);
 
   if (ctx == NULL)
     return UV_ENOMEM;
@@ -101,7 +101,7 @@ int uv_fs_poll_start(uv_fs_poll_t* handle,
     goto error;
 
   if (handle->poll_ctx != NULL)
-    ctx->previous = handle->poll_ctx;
+    ctx->previous = (struct poll_ctx*)handle->poll_ctx;
   handle->poll_ctx = ctx;
   uv__handle_start(handle);
 
@@ -119,7 +119,7 @@ int uv_fs_poll_stop(uv_fs_poll_t* handle) {
   if (!uv_is_active((uv_handle_t*)handle))
     return 0;
 
-  ctx = handle->poll_ctx;
+  ctx = (struct poll_ctx*)handle->poll_ctx;
   assert(ctx != NULL);
   assert(ctx->parent_handle == handle);
 
@@ -144,7 +144,7 @@ int uv_fs_poll_getpath(uv_fs_poll_t* handle, char* buffer, size_t* size) {
     return UV_EINVAL;
   }
 
-  ctx = handle->poll_ctx;
+  ctx = (struct poll_ctx*)handle->poll_ctx;
   assert(ctx != NULL);
 
   required_len = strlen(ctx->path);
@@ -244,7 +244,7 @@ static void timer_close_cb(uv_handle_t* timer) {
     if (handle->poll_ctx == NULL && uv__is_closing(handle))
       uv__make_close_pending((uv_handle_t*)handle);
   } else {
-    for (last = handle->poll_ctx, it = last->previous;
+    for (last = (struct poll_ctx*)handle->poll_ctx, it = last->previous;
          it != ctx;
          last = it, it = it->previous) {
       assert(last->previous != NULL);
diff --git a/src/idna.c b/src/idna.c
index efc5f283ce2ef98c80be023eb2ba5cb9a9a7e8b9..765e12e8f2e030cffa9d498f381c0640aa43a647 100644
--- a/src/idna.c
+++ b/src/idna.c
@@ -482,7 +482,7 @@ int uv_utf16_to_wtf8(const uint16_t* w_source_ptr,
     return 0;
 
   if (*target_ptr == NULL) {
-    target = uv__malloc(target_len + 1);
+    target = (char*)uv__malloc(target_len + 1);
     if (target == NULL) {
       return UV_ENOMEM;
     }
diff --git a/src/inet.c b/src/inet.c
index cd77496846e90e8b8e61c63c10f498f153344fe5..dd94bea3886ca37945fcad7909d765e3700e3c21 100644
--- a/src/inet.c
+++ b/src/inet.c
@@ -35,9 +35,9 @@ static int inet_pton6(const char *src, unsigned char *dst);
 int uv_inet_ntop(int af, const void* src, char* dst, size_t size) {
   switch (af) {
   case AF_INET:
-    return (inet_ntop4(src, dst, size));
+    return (inet_ntop4((const unsigned char*)src, dst, size));
   case AF_INET6:
-    return (inet_ntop6(src, dst, size));
+    return (inet_ntop6((const unsigned char*)src, dst, size));
   default:
     return UV_EAFNOSUPPORT;
   }
@@ -149,10 +149,11 @@ int uv_inet_pton(int af, const char* src, void* dst) {
 
   switch (af) {
   case AF_INET:
-    return (inet_pton4(src, dst));
+    return (inet_pton4(src, (unsigned char*)dst));
   case AF_INET6: {
     int len;
-    char tmp[UV__INET6_ADDRSTRLEN], *s, *p;
+    char tmp[UV__INET6_ADDRSTRLEN], *s;
+    const char *p;
     s = (char*) src;
     p = strchr(src, '%');
     if (p != NULL) {
@@ -163,7 +164,7 @@ int uv_inet_pton(int af, const char* src, void* dst) {
       memcpy(s, src, len);
       s[len] = '\0';
     }
-    return inet_pton6(s, dst);
+    return inet_pton6(s, (unsigned char*)dst);
   }
   default:
     return UV_EAFNOSUPPORT;
diff --git a/src/strscpy.c b/src/strscpy.c
index 20df6fcbed29e9d944c866ddbcd5c09345a426b3..6b4cc3bc741b40b9c2b13d4c06e7090f8083a7ba 100644
--- a/src/strscpy.c
+++ b/src/strscpy.c
@@ -27,7 +27,7 @@ ssize_t uv__strscpy(char* d, const char* s, size_t n) {
 
   for (i = 0; i < n; i++)
     if ('\0' == (d[i] = s[i]))
-      return i > SSIZE_MAX ? UV_E2BIG : (ssize_t) i;
+      return i > SSIZE_MAX ? (ssize_t) UV_E2BIG : (ssize_t) i;
 
   if (i == 0)
     return 0;
diff --git a/src/thread-common.c b/src/thread-common.c
index c67c0a7dd7279af6c67b7d5d4a623c47bdf3fff2..c0e39b543df229dd8cb8492bb695e61e40911453 100644
--- a/src/thread-common.c
+++ b/src/thread-common.c
@@ -49,7 +49,7 @@ int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {
   if (barrier == NULL || count == 0)
     return UV_EINVAL;
 
-  b = uv__malloc(sizeof(*b));
+  b = (struct _uv_barrier *)uv__malloc(sizeof(*b));
   if (b == NULL)
     return UV_ENOMEM;
 #endif
diff --git a/src/threadpool.c b/src/threadpool.c
index 45af50dcd04ea6ab1d0cfd7ed48ced3aac9c562a..ccb5249893df2733fc607fec6e8d3037ebe2e212 100644
--- a/src/threadpool.c
+++ b/src/threadpool.c
@@ -207,7 +207,7 @@ static void init_threads(void) {
 
   threads = default_threads;
   if (nthreads > ARRAY_SIZE(default_threads)) {
-    threads = uv__malloc(nthreads * sizeof(threads[0]));
+    threads = (uv_thread_t*)uv__malloc(nthreads * sizeof(threads[0]));
     if (threads == NULL) {
       nthreads = ARRAY_SIZE(default_threads);
       threads = default_threads;
diff --git a/src/unix/bsd-ifaddrs.c b/src/unix/bsd-ifaddrs.c
index 11ca95591fc38244e931fecd9dd4038d3968af7a..c3dd71a1889bfae08cfdf95acda61e6c3472bd2c 100644
--- a/src/unix/bsd-ifaddrs.c
+++ b/src/unix/bsd-ifaddrs.c
@@ -92,7 +92,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {
   }
 
   /* Make sure the memory is initiallized to zero using calloc() */
-  *addresses = uv__calloc(*count, sizeof(**addresses));
+  *addresses = (uv_interface_address_t*)uv__calloc(*count, sizeof(**addresses));
 
   if (*addresses == NULL) {
     freeifaddrs(addrs);
diff --git a/src/unix/core.c b/src/unix/core.c
index 0c52ccf2ad7b2dcae77a7bc4b3af9d1a1346ce18..b72a24e94b0c70455a8ac748a53556ddefb09f49 100644
--- a/src/unix/core.c
+++ b/src/unix/core.c
@@ -866,7 +866,7 @@ static unsigned int next_power_of_two(unsigned int val) {
 }
 
 static void maybe_resize(uv_loop_t* loop, unsigned int len) {
-  uv__io_t** watchers;
+  void** watchers;
   void* fake_watcher_list;
   void* fake_watcher_count;
   unsigned int nwatchers;
@@ -885,8 +885,8 @@ static void maybe_resize(uv_loop_t* loop, unsigned int len) {
   }
 
   nwatchers = next_power_of_two(len + 2) - 2;
-  watchers = uv__reallocf(loop->watchers,
-                          (nwatchers + 2) * sizeof(loop->watchers[0]));
+  watchers = (void**)
+      uv__reallocf(loop->watchers, (nwatchers + 2) * sizeof(loop->watchers[0]));
 
   if (watchers == NULL)
     abort();
@@ -895,7 +895,7 @@ static void maybe_resize(uv_loop_t* loop, unsigned int len) {
   watchers[nwatchers] = fake_watcher_list;
   watchers[nwatchers + 1] = fake_watcher_count;
 
-  loop->watchers = watchers;
+  loop->watchers = (uv__io_t**)watchers;
   loop->nwatchers = nwatchers;
 }
 
@@ -1227,7 +1227,7 @@ static int uv__getpwuid_r(uv_passwd_t *pwd, uid_t uid) {
    * is frequently 1024 or 4096, so we can just use that directly. The pwent
    * will not usually be large. */
   for (bufsize = 2000;; bufsize *= 2) {
-    buf = uv__malloc(bufsize);
+    buf = (char*)uv__malloc(bufsize);
 
     if (buf == NULL)
       return UV_ENOMEM;
@@ -1253,7 +1253,7 @@ static int uv__getpwuid_r(uv_passwd_t *pwd, uid_t uid) {
   name_size = strlen(pw.pw_name) + 1;
   homedir_size = strlen(pw.pw_dir) + 1;
   shell_size = strlen(pw.pw_shell) + 1;
-  pwd->username = uv__malloc(name_size + homedir_size + shell_size);
+  pwd->username = (char*)uv__malloc(name_size + homedir_size + shell_size);
 
   if (pwd->username == NULL) {
     uv__free(buf);
@@ -1303,7 +1303,7 @@ int uv_os_get_group(uv_group_t* grp, uv_uid_t gid) {
    * is frequently 1024 or 4096, so we can just use that directly. The pwent
    * will not usually be large. */
   for (bufsize = 2000;; bufsize *= 2) {
-    buf = uv__malloc(bufsize);
+    buf = (char*)uv__malloc(bufsize);
 
     if (buf == NULL)
       return UV_ENOMEM;
@@ -1334,7 +1334,7 @@ int uv_os_get_group(uv_group_t* grp, uv_uid_t gid) {
     members++;
   }
 
-  gr_mem = uv__malloc(name_size + mem_size);
+  gr_mem = (char*)uv__malloc(name_size + mem_size);
   if (gr_mem == NULL) {
     uv__free(buf);
     return UV_ENOMEM;
@@ -1391,7 +1391,7 @@ int uv_os_environ(uv_env_item_t** envitems, int* count) {
 
   for (i = 0; environ[i] != NULL; i++);
 
-  *envitems = uv__calloc(i, sizeof(**envitems));
+  *envitems = (uv_env_item_s*)uv__calloc(i, sizeof(**envitems));
 
   if (*envitems == NULL)
     return UV_ENOMEM;
diff --git a/src/unix/darwin-proctitle.c b/src/unix/darwin-proctitle.c
index 5288083ef04fd78d90c34071cc76281adbc310d8..9bd55dd764b845cf8ea441d525b4e136699eb52e 100644
--- a/src/unix/darwin-proctitle.c
+++ b/src/unix/darwin-proctitle.c
@@ -128,8 +128,9 @@ int uv__set_process_title(const char* title) {
   if (pLSSetApplicationInformationItem == NULL)
     goto out;
 
-  display_name_key = pCFBundleGetDataPointerForName(launch_services_bundle,
-                                                    S("_kLSDisplayNameKey"));
+  display_name_key = (CFStringRef*)
+      pCFBundleGetDataPointerForName(launch_services_bundle,
+                                     S("_kLSDisplayNameKey"));
 
   if (display_name_key == NULL || *display_name_key == NULL)
     goto out;
diff --git a/src/unix/darwin.c b/src/unix/darwin.c
index 009efbefaa70ee1e552cf6177893bd412201e276..b1657a2ffdab4e41c7900d6dda92f23bd8d137c2 100644
--- a/src/unix/darwin.c
+++ b/src/unix/darwin.c
@@ -211,7 +211,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
     return UV_EINVAL;  /* FIXME(bnoordhuis) Translate error. */
   }
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos)) {
     vm_deallocate(mach_task_self(), (vm_address_t)info, msg_type);
     return UV_ENOMEM;
diff --git a/src/unix/freebsd.c b/src/unix/freebsd.c
index a6de29c558cde45dacc5bba7d75950fe6e57e857..8fb03c7803cd6d8e3c65558bee0be21f7ad07a3c 100644
--- a/src/unix/freebsd.c
+++ b/src/unix/freebsd.c
@@ -225,7 +225,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
   if (sysctlbyname("hw.ncpu", &numcpus, &size, NULL, 0))
     return UV__ERR(errno);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos))
     return UV_ENOMEM;
 
@@ -242,7 +242,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
 
   size = maxcpus * CPUSTATES * sizeof(long);
 
-  cp_times = uv__malloc(size);
+  cp_times = (long*)uv__malloc(size);
   if (cp_times == NULL) {
     uv__free(*cpu_infos);
     return UV_ENOMEM;
diff --git a/src/unix/fs.c b/src/unix/fs.c
index 239ecda16a7eb9b40453502cf0362ae66366cf72..efd37d78d9216de6ad46633a953f6b292b4af735 100644
--- a/src/unix/fs.c
+++ b/src/unix/fs.c
@@ -126,7 +126,7 @@ extern char *mkdtemp(char *template); /* See issue #740 on AIX < 7 */
       size_t new_path_len;                                                    \
       path_len = strlen(path) + 1;                                            \
       new_path_len = strlen(new_path) + 1;                                    \
-      req->path = uv__malloc(path_len + new_path_len);                        \
+      req->path = (char*)uv__malloc(path_len + new_path_len);                 \
       if (req->path == NULL)                                                  \
         return UV_ENOMEM;                                                     \
       req->new_path = req->path + path_len;                                   \
@@ -483,7 +483,7 @@ static ssize_t uv__preadv_or_pwritev(int fd,
     dlerror();  /* Clear errors. */
 #endif  /* RTLD_DEFAULT */
     if (p == NULL)
-      p = is_pread ? uv__preadv_emul : uv__pwritev_emul;
+      p = (void*)(is_pread ? uv__preadv_emul : uv__pwritev_emul);
     atomic_store_explicit(cache, (uintptr_t) p, memory_order_relaxed);
   }
 
@@ -605,7 +605,7 @@ static ssize_t uv__fs_scandir(uv_fs_t* req) {
 static int uv__fs_opendir(uv_fs_t* req) {
   uv_dir_t* dir;
 
-  dir = uv__malloc(sizeof(*dir));
+  dir = (uv_dir_t*)uv__malloc(sizeof(*dir));
   if (dir == NULL)
     goto error;
 
@@ -629,7 +629,7 @@ static int uv__fs_readdir(uv_fs_t* req) {
   unsigned int dirent_idx;
   unsigned int i;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   dirent_idx = 0;
 
   while (dirent_idx < dir->nentries) {
@@ -671,7 +671,7 @@ error:
 static int uv__fs_closedir(uv_fs_t* req) {
   uv_dir_t* dir;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
 
   if (dir->dir != NULL) {
     closedir(dir->dir);
@@ -700,7 +700,7 @@ static int uv__fs_statfs(uv_fs_t* req) {
 #endif /* defined(__sun) */
     return -1;
 
-  stat_fs = uv__malloc(sizeof(*stat_fs));
+  stat_fs = (uv_statfs_t*)uv__malloc(sizeof(*stat_fs));
   if (stat_fs == NULL) {
     errno = ENOMEM;
     return -1;
@@ -764,7 +764,7 @@ static ssize_t uv__fs_readlink(uv_fs_t* req) {
     maxlen = uv__fs_pathmax_size(req->path);
 #endif
 
-  buf = uv__malloc(maxlen);
+  buf = (char*)uv__malloc(maxlen);
 
   if (buf == NULL) {
     errno = ENOMEM;
@@ -784,7 +784,7 @@ static ssize_t uv__fs_readlink(uv_fs_t* req) {
 
   /* Uncommon case: resize to make room for the trailing nul byte. */
   if (len == maxlen) {
-    buf = uv__reallocf(buf, len + 1);
+    buf = (char*)uv__reallocf(buf, len + 1);
 
     if (buf == NULL)
       return -1;
@@ -816,7 +816,7 @@ static ssize_t uv__fs_realpath(uv_fs_t* req) {
   (void)tmp;
 
   len = uv__fs_pathmax_size(req->path);
-  buf = uv__malloc(len + 1);
+  buf = (char*)uv__malloc(len + 1);
 
   if (buf == NULL) {
     errno = ENOMEM;
@@ -2050,7 +2050,7 @@ int uv_fs_read(uv_loop_t* loop, uv_fs_t* req,
 
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->bufs == NULL)
     return UV_ENOMEM;
@@ -2235,7 +2235,7 @@ int uv_fs_write(uv_loop_t* loop,
   req->nbufs = nbufs;
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->bufs == NULL)
     return UV_ENOMEM;
diff --git a/src/unix/fsevents.c b/src/unix/fsevents.c
index 7fb6bb2ec36ae0b1584a43a2fc0101db54c42f97..0d1c9ebad6f490f3f890d81a66496ff31417e213 100644
--- a/src/unix/fsevents.c
+++ b/src/unix/fsevents.c
@@ -183,7 +183,7 @@ static void (*pFSEventStreamStop)(FSEventStreamRef);
 static void uv__fsevents_cb(uv_async_t* cb) {
   uv_fs_event_t* handle;
 
-  handle = cb->data;
+  handle = (uv_fs_event_t*)cb->data;
 
   UV__FSEVENTS_PROCESS(handle, {
     handle->cb(handle, event->path[0] ? event->path : NULL, event->events, 0);
@@ -231,10 +231,10 @@ static void uv__fsevents_event_cb(const FSEventStreamRef streamRef,
   FSEventStreamEventFlags flags;
   struct uv__queue head;
 
-  loop = info;
-  state = loop->cf_state;
+  loop = (uv_loop_t*)info;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   assert(state != NULL);
-  paths = eventPaths;
+  paths = (char**)eventPaths;
 
   /* For each handle */
   uv_mutex_lock(&state->fsevent_mutex);
@@ -300,7 +300,7 @@ static void uv__fsevents_event_cb(const FSEventStreamRef streamRef,
           continue;
       }
 
-      event = uv__malloc(sizeof(*event) + len);
+      event = (uv__fsevents_event_t*)uv__malloc(sizeof(*event) + len);
       if (event == NULL)
         break;
 
@@ -434,7 +434,7 @@ static void uv__fsevents_reschedule(uv__cf_loop_state_t* state,
   uv_mutex_lock(&state->fsevent_mutex);
   path_count = state->fsevent_handle_count;
   if (path_count != 0) {
-    paths = uv__malloc(sizeof(*paths) * path_count);
+    paths = (CFStringRef*)uv__malloc(sizeof(*paths) * path_count);
     if (paths == NULL) {
       uv_mutex_unlock(&state->fsevent_mutex);
       goto final;
@@ -590,7 +590,7 @@ static int uv__fsevents_loop_init(uv_loop_t* loop) {
   if (err)
     return err;
 
-  state = uv__calloc(1, sizeof(*state));
+  state = (uv__cf_loop_state_t*)uv__calloc(1, sizeof(*state));
   if (state == NULL)
     return UV_ENOMEM;
 
@@ -692,7 +692,7 @@ void uv__fsevents_loop_delete(uv_loop_t* loop) {
   }
 
   /* Destroy state */
-  state = loop->cf_state;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   uv_sem_destroy(&state->fsevent_sem);
   uv_mutex_destroy(&state->fsevent_mutex);
   pCFRelease(state->signal_source);
@@ -706,8 +706,8 @@ static void* uv__cf_loop_runner(void* arg) {
   uv_loop_t* loop;
   uv__cf_loop_state_t* state;
 
-  loop = arg;
-  state = loop->cf_state;
+  loop = (uv_loop_t*)arg;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   state->loop = pCFRunLoopGetCurrent();
 
   pCFRunLoopAddSource(state->loop,
@@ -735,8 +735,8 @@ static void uv__cf_loop_cb(void* arg) {
   struct uv__queue split_head;
   uv__cf_loop_signal_t* s;
 
-  loop = arg;
-  state = loop->cf_state;
+  loop = (uv_loop_t*)arg;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
 
   uv_mutex_lock(&loop->cf_mutex);
   uv__queue_move(&loop->cf_signals, &split_head);
@@ -766,7 +766,7 @@ int uv__cf_loop_signal(uv_loop_t* loop,
   uv__cf_loop_signal_t* item;
   uv__cf_loop_state_t* state;
 
-  item = uv__malloc(sizeof(*item));
+  item = (uv__cf_loop_signal_t*)uv__malloc(sizeof(*item));
   if (item == NULL)
     return UV_ENOMEM;
 
@@ -776,7 +776,7 @@ int uv__cf_loop_signal(uv_loop_t* loop,
   uv_mutex_lock(&loop->cf_mutex);
   uv__queue_insert_tail(&loop->cf_signals, &item->member);
 
-  state = loop->cf_state;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   assert(state != NULL);
   pCFRunLoopSourceSignal(state->signal_source);
   pCFRunLoopWakeUp(state->loop);
@@ -815,7 +815,7 @@ int uv__fsevents_init(uv_fs_event_t* handle) {
    * Events will occur in other thread.
    * Initialize callback for getting them back into event loop's thread
    */
-  handle->cf_cb = uv__malloc(sizeof(*handle->cf_cb));
+  handle->cf_cb = (uv_async_t*)uv__malloc(sizeof(*handle->cf_cb));
   if (handle->cf_cb == NULL) {
     err = UV_ENOMEM;
     goto fail_cf_cb_malloc;
@@ -831,7 +831,7 @@ int uv__fsevents_init(uv_fs_event_t* handle) {
     goto fail_cf_mutex_init;
 
   /* Insert handle into the list */
-  state = handle->loop->cf_state;
+  state = (uv__cf_loop_state_t*)handle->loop->cf_state;
   uv_mutex_lock(&state->fsevent_mutex);
   uv__queue_insert_tail(&state->fsevent_handles, &handle->cf_member);
   state->fsevent_handle_count++;
@@ -871,7 +871,7 @@ int uv__fsevents_close(uv_fs_event_t* handle) {
     return UV_EINVAL;
 
   /* Remove handle from  the list */
-  state = handle->loop->cf_state;
+  state = (uv__cf_loop_state_t*)handle->loop->cf_state;
   uv_mutex_lock(&state->fsevent_mutex);
   uv__queue_remove(&handle->cf_member);
   state->fsevent_handle_count--;
diff --git a/src/unix/getaddrinfo.c b/src/unix/getaddrinfo.c
index b70753436665901c5fc8a4126b9537d01a47ffa0..5a205d0ebd89009472d6062f5173aac1be2f8a87 100644
--- a/src/unix/getaddrinfo.c
+++ b/src/unix/getaddrinfo.c
@@ -172,7 +172,7 @@ int uv_getaddrinfo(uv_loop_t* loop,
   hostname_len = hostname ? strlen(hostname) + 1 : 0;
   service_len = service ? strlen(service) + 1 : 0;
   hints_len = hints ? sizeof(*hints) : 0;
-  buf = uv__malloc(hostname_len + service_len + hints_len);
+  buf = (char*)uv__malloc(hostname_len + service_len + hints_len);
 
   if (buf == NULL)
     return UV_ENOMEM;
@@ -190,17 +190,17 @@ int uv_getaddrinfo(uv_loop_t* loop,
   len = 0;
 
   if (hints) {
-    req->hints = memcpy(buf + len, hints, sizeof(*hints));
+    req->hints = (struct addrinfo*)memcpy(buf + len, hints, sizeof(*hints));
     len += sizeof(*hints);
   }
 
   if (service) {
-    req->service = memcpy(buf + len, service, service_len);
+    req->service = (char*)memcpy(buf + len, service, service_len);
     len += service_len;
   }
 
   if (hostname)
-    req->hostname = memcpy(buf + len, hostname, hostname_len);
+    req->hostname = (char*)memcpy(buf + len, hostname, hostname_len);
 
   if (cb) {
     uv__work_submit(loop,
diff --git a/src/unix/ibmi.c b/src/unix/ibmi.c
index 837bba6e2fef7b834a8d104d263bef47eaed0950..5e0fa98d104428534e5264a1c6358e3f68c58b82 100644
--- a/src/unix/ibmi.c
+++ b/src/unix/ibmi.c
@@ -293,7 +293,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
 
   numcpus = sysconf(_SC_NPROCESSORS_ONLN);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(uv_cpu_info_t));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(uv_cpu_info_t));
   if (!*cpu_infos) {
     return UV_ENOMEM;
   }
diff --git a/src/unix/kqueue.c b/src/unix/kqueue.c
index 66aa166f053f52d363030ef4ce32bfbad4cc4862..b7bd00ea0c45964d8e26d7596d9ad3734fe67237 100644
--- a/src/unix/kqueue.c
+++ b/src/unix/kqueue.c
@@ -336,8 +336,8 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
     nevents = 0;
 
     assert(loop->watchers != NULL);
-    loop->watchers[loop->nwatchers] = (void*) events;
-    loop->watchers[loop->nwatchers + 1] = (void*) (uintptr_t) nfds;
+    loop->watchers[loop->nwatchers] = (uv__io_t*) events;
+    loop->watchers[loop->nwatchers + 1] = (uv__io_t*) (uintptr_t) nfds;
     for (i = 0; i < nfds; i++) {
       ev = events + i;
       fd = ev->ident;
@@ -359,7 +359,7 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
       /* Skip invalidated events, see uv__platform_invalidate_fd */
       if (fd == -1)
         continue;
-      w = loop->watchers[fd];
+      w = (uv__io_t*)loop->watchers[fd];
 
       if (w == NULL) {
         /* File descriptor that we've stopped watching, disarm it. */
diff --git a/src/unix/linux.c b/src/unix/linux.c
index 857a4ef8a6686f789f6f4642d49eba6452441773..22f76054ef0987f215afb9d1e20aa18f97489ea4 100644
--- a/src/unix/linux.c
+++ b/src/unix/linux.c
@@ -515,8 +515,8 @@ static void uv__iou_init(int epollfd,
   int ringfd;
   int no_sqarray;
 
-  sq = MAP_FAILED;
-  sqe = MAP_FAILED;
+  sq = (char*)MAP_FAILED;
+  sqe = (char*)MAP_FAILED;
 
   if (!uv__use_io_uring())
     return;
@@ -559,14 +559,14 @@ static void uv__iou_init(int epollfd,
   maxlen = sqlen < cqlen ? cqlen : sqlen;
   sqelen = params.sq_entries * sizeof(struct uv__io_uring_sqe);
 
-  sq = mmap(0,
+  sq = (char*)mmap(0,
             maxlen,
             PROT_READ | PROT_WRITE,
             MAP_SHARED | MAP_POPULATE,
             ringfd,
             0);  /* IORING_OFF_SQ_RING */
 
-  sqe = mmap(0,
+  sqe = (char*)mmap(0,
              sqelen,
              PROT_READ | PROT_WRITE,
              MAP_SHARED | MAP_POPULATE,
@@ -704,7 +704,7 @@ void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) {
   int i;
 
   lfields = uv__get_internal_fields(loop);
-  inv = lfields->inv;
+  inv = (uv__invalidate*)lfields->inv;
 
   /* Invalidate events with same file descriptor */
   if (inv != NULL)
@@ -790,7 +790,7 @@ static struct uv__io_uring_sqe* uv__iou_get_sqe(struct uv__iou* iou,
     return NULL;  /* No room in ring buffer. TODO(bnoordhuis) maybe flush it? */
 
   slot = tail & mask;
-  sqe = iou->sqe;
+  sqe = (uv__io_uring_sqe*)iou->sqe;
   sqe = &sqe[slot];
   memset(sqe, 0, sizeof(*sqe));
   sqe->user_data = (uintptr_t) req;
@@ -1084,7 +1084,7 @@ int uv__iou_fs_statx(uv_loop_t* loop,
   struct uv__statx* statxbuf;
   struct uv__iou* iou;
 
-  statxbuf = uv__malloc(sizeof(*statxbuf));
+  statxbuf = (struct uv__statx*)uv__malloc(sizeof(*statxbuf));
   if (statxbuf == NULL)
     return 0;
 
@@ -1148,7 +1148,7 @@ static void uv__iou_fs_statx_post(uv_fs_t* req) {
   uv_stat_t* buf;
 
   buf = &req->statbuf;
-  statxbuf = req->ptr;
+  statxbuf = (struct uv__statx*)req->ptr;
   req->ptr = NULL;
 
   if (req->result == 0) {
@@ -1177,7 +1177,7 @@ static void uv__poll_io_uring(uv_loop_t* loop, struct uv__iou* iou) {
   tail = atomic_load_explicit((_Atomic uint32_t*) iou->cqtail,
                               memory_order_acquire);
   mask = iou->cqmask;
-  cqe = iou->cqe;
+  cqe = (uv__io_uring_cqe*)iou->cqe;
   nevents = 0;
 
   for (i = head; i != tail; i++) {
@@ -1262,7 +1262,7 @@ static void uv__epoll_ctl_prep(int epollfd,
   pe = &(*events)[slot];
   *pe = *e;
 
-  sqe = ctl->sqe;
+  sqe = (uv__io_uring_sqe*)ctl->sqe;
   sqe = &sqe[slot];
 
   memset(sqe, 0, sizeof(*sqe));
@@ -1317,7 +1317,7 @@ static void uv__epoll_ctl_flush(int epollfd,
   while (*ctl->cqhead != *ctl->cqtail) {
     slot = (*ctl->cqhead)++ & ctl->cqmask;
 
-    cqe = ctl->cqe;
+    cqe = (uv__io_uring_cqe*)ctl->cqe;
     cqe = &cqe[slot];
 
     if (cqe->res == 0)
@@ -1775,7 +1775,7 @@ int uv_cpu_info(uv_cpu_info_t** ci, int* count) {
   snprintf(*models, sizeof(*models), "unknown");
   maxcpu = 0;
 
-  cpus = uv__calloc(ARRAY_SIZE(*cpus), sizeof(**cpus));
+  cpus = (decltype(cpus))uv__calloc(ARRAY_SIZE(*cpus), sizeof(**cpus));
   if (cpus == NULL)
     return UV_ENOMEM;
 
@@ -1833,9 +1833,9 @@ int uv_cpu_info(uv_cpu_info_t** ci, int* count) {
 
     /* arm64: translate CPU part code to model name. */
     if (*parts) {
-      p = memmem(parts, sizeof(parts) - 1, p, n + 1);
+      p = (char*)memmem(parts, sizeof(parts) - 1, p, n + 1);
       if (p == NULL)
-        p = "unknown";
+        p = const_cast<char*>("unknown");
       else
         p += n + 1;
       n = (int) strcspn(p, "\n");
@@ -1885,7 +1885,7 @@ nocpuinfo:
   }
 
   size = n * sizeof(**ci) + sizeof(models);
-  *ci = uv__malloc(size);
+  *ci = (uv_cpu_info_t*)uv__malloc(size);
   *count = 0;
 
   if (*ci == NULL) {
@@ -1894,7 +1894,7 @@ nocpuinfo:
   }
 
   *count = n;
-  p = memcpy(*ci + n, models, sizeof(models));
+  p = (char*)memcpy(*ci + n, models, sizeof(models));
 
   i = 0;
   for (cpu = 0; cpu < maxcpu; cpu++) {
@@ -1903,19 +1903,19 @@ nocpuinfo:
 
     c = *cpus + cpu;
 
-    (*ci)[i++] = (uv_cpu_info_t) {
+    (*ci)[i++] = uv_cpu_info_t{
       .model     = p + c->model * sizeof(*model),
-      .speed     = c->freq / 1000,
+      .speed     = (int)(c->freq / 1000),
       /* Note: sysconf(_SC_CLK_TCK) is fixed at 100 Hz,
        * therefore the multiplier is always 1000/100 = 10.
        */
-      .cpu_times = (struct uv_cpu_times_s) {
+      .cpu_times = {
         .user = 10 * c->user,
         .nice = 10 * c->nice,
         .sys  = 10 * c->sys,
         .idle = 10 * c->idle,
         .irq  = 10 * c->irq,
-      },
+      }
     };
   }
 
@@ -1965,7 +1965,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {
   }
 
   /* Make sure the memory is initiallized to zero using calloc() */
-  *addresses = uv__calloc(*count, sizeof(**addresses));
+  *addresses = (uv_interface_address_t*)uv__calloc(*count, sizeof(**addresses));
   if (!(*addresses)) {
     freeifaddrs(addrs);
     return UV_ENOMEM;
@@ -2336,7 +2336,7 @@ static int uv__get_cgroupv2_constrained_cpu(const char* cgroup,
 static char* uv__cgroup1_find_cpu_controller(const char* cgroup,
                                              int* cgroup_size) {
   /* Seek to the cpu controller line. */
-  char* cgroup_cpu = strstr(cgroup, ":cpu,");
+  char* cgroup_cpu = (char*)strstr(cgroup, ":cpu,");
 
   if (cgroup_cpu != NULL) {
     /* Skip the controller prefix to the start of the cgroup path. */
@@ -2662,12 +2662,12 @@ int uv_fs_event_start(uv_fs_event_t* handle,
     goto no_insert;
 
   len = strlen(path) + 1;
-  w = uv__malloc(sizeof(*w) + len);
+  w = (watcher_list*)uv__malloc(sizeof(*w) + len);
   if (w == NULL)
     return UV_ENOMEM;
 
   w->wd = wd;
-  w->path = memcpy(w + 1, path, len);
+  w->path = (char*)memcpy(w + 1, path, len);
   uv__queue_init(&w->watchers);
   w->iterating = 0;
   RB_INSERT(watcher_root, uv__inotify_watchers(loop), w);
diff --git a/src/unix/loop.c b/src/unix/loop.c
index 179ee999d8052e779dc692aeb5b673d210aaa997..006db94d0080507bf3d52bf206bffbbc812cc375 100644
--- a/src/unix/loop.c
+++ b/src/unix/loop.c
@@ -148,7 +148,7 @@ int uv_loop_fork(uv_loop_t* loop) {
 
   /* Rearm all the watchers that aren't re-queued by the above. */
   for (i = 0; i < loop->nwatchers; i++) {
-    w = loop->watchers[i];
+    w = (uv__io_t*)loop->watchers[i];
     if (w == NULL)
       continue;
 
diff --git a/src/unix/netbsd.c b/src/unix/netbsd.c
index fa21e98e41aec8b7d8bc46c299c4c20a7a0c3f0c..4c6d5a24fe896d89e3b2f1db1dc2b1dd7d010aec 100644
--- a/src/unix/netbsd.c
+++ b/src/unix/netbsd.c
@@ -211,14 +211,14 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
     cpuspeed = 0;
 
   size = numcpus * CPUSTATES * sizeof(*cp_times);
-  cp_times = uv__malloc(size);
+  cp_times = (u_int64_t*)uv__malloc(size);
   if (cp_times == NULL)
     return UV_ENOMEM;
 
   if (sysctlbyname("kern.cp_time", cp_times, &size, NULL, 0))
     return UV__ERR(errno);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos)) {
     uv__free(cp_times);
     uv__free(*cpu_infos);
diff --git a/src/unix/openbsd.c b/src/unix/openbsd.c
index 9c863b6c90dad9864cb8341c2b6203c1390a9487..2aa61e2ee3321d91ba84887c7ed6dcfa23d00ccf 100644
--- a/src/unix/openbsd.c
+++ b/src/unix/openbsd.c
@@ -72,7 +72,7 @@ int uv_exepath(char* buffer, size_t* size) {
   mypid = getpid();
   for (;;) {
     err = UV_ENOMEM;
-    argsbuf = uv__reallocf(argsbuf, argsbuf_size);
+    argsbuf = (char**)uv__reallocf(argsbuf, argsbuf_size);
     if (argsbuf == NULL)
       goto out;
     mib[0] = CTL_KERN;
@@ -202,7 +202,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
   if (sysctl(which, ARRAY_SIZE(which), &numcpus, &size, NULL, 0))
     return UV__ERR(errno);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos))
     return UV_ENOMEM;
 
diff --git a/src/unix/pipe.c b/src/unix/pipe.c
index 1f9acfac41e9c561cbd823c27863d9a3dc52f7b8..7627ee39c1be869d4d2bbf93dbae0bbd52a4464f 100644
--- a/src/unix/pipe.c
+++ b/src/unix/pipe.c
@@ -109,7 +109,7 @@ int uv_pipe_bind2(uv_pipe_t* handle,
   if (*name == '\0') {
     addrlen = offsetof(struct sockaddr_un, sun_path) + namelen;
   } else {
-    pipe_fname = uv__malloc(namelen + 1);
+    pipe_fname = (char*)uv__malloc(namelen + 1);
     if (pipe_fname == NULL)
       return UV_ENOMEM;
     memcpy(pipe_fname, name, namelen);
@@ -377,7 +377,7 @@ static int uv__pipe_getsockpeername(const uv_pipe_t* handle,
     slop = 0;
     addrlen -= offsetof(struct sockaddr_un, sun_path);
   } else {
-    p = memchr(sa.sun_path, '\0', sizeof(sa.sun_path));
+    p = (char*)memchr(sa.sun_path, '\0', sizeof(sa.sun_path));
     if (p == NULL)
       p = ARRAY_END(sa.sun_path);
     addrlen = p - sa.sun_path;
@@ -425,7 +425,7 @@ int uv_pipe_pending_count(uv_pipe_t* handle) {
   if (handle->queued_fds == NULL)
     return 1;
 
-  queued_fds = handle->queued_fds;
+  queued_fds = (uv__stream_queued_fds_t*)(handle->queued_fds);
   return queued_fds->offset + 1;
 }
 
@@ -462,7 +462,7 @@ int uv_pipe_chmod(uv_pipe_t* handle, int mode) {
   if (r != UV_ENOBUFS)
     return r;
 
-  name_buffer = uv__malloc(name_len);
+  name_buffer = (char*)uv__malloc(name_len);
   if (name_buffer == NULL)
     return UV_ENOMEM;
 
diff --git a/src/unix/poll.c b/src/unix/poll.c
index 7a12e2d1488a9d48712439e62c6637b9e1161f69..c21722b2e8eef4d16c523f7319fb57c3167d8dd9 100644
--- a/src/unix/poll.c
+++ b/src/unix/poll.c
@@ -117,7 +117,7 @@ int uv_poll_stop(uv_poll_t* handle) {
 
 
 int uv_poll_start(uv_poll_t* handle, int pevents, uv_poll_cb poll_cb) {
-  uv__io_t** watchers;
+  void** watchers;
   uv__io_t* w;
   int events;
 
@@ -125,7 +125,7 @@ int uv_poll_start(uv_poll_t* handle, int pevents, uv_poll_cb poll_cb) {
                       UV_PRIORITIZED)) == 0);
   assert(!uv__is_closing(handle));
 
-  watchers = handle->loop->watchers;
+  watchers = (void**)handle->loop->watchers;
   w = &handle->io_watcher;
 
   if (uv__fd_exists(handle->loop, w->fd))
diff --git a/src/unix/posix-poll.c b/src/unix/posix-poll.c
index 2e016c2fbaed2eeccd78080969a86aff821a4251..b71eee3f01a3f30b3b5efef539194139f258009a 100644
--- a/src/unix/posix-poll.c
+++ b/src/unix/posix-poll.c
@@ -61,7 +61,7 @@ static void uv__pollfds_maybe_resize(uv_loop_t* loop) {
     return;
 
   n = loop->poll_fds_size ? loop->poll_fds_size * 2 : 64;
-  p = uv__reallocf(loop->poll_fds, n * sizeof(*loop->poll_fds));
+  p = (struct pollfd*)uv__reallocf(loop->poll_fds, n * sizeof(*loop->poll_fds));
   if (p == NULL)
     abort();
 
diff --git a/src/unix/process.c b/src/unix/process.c
index f2038f2c0e823e1d5ebf3331b1d93c12fe23e83e..e1349689065b4593a929509a3daafa5a48916768 100644
--- a/src/unix/process.c
+++ b/src/unix/process.c
@@ -420,7 +420,7 @@ static int posix_spawn_can_use_setsid;
 static void uv__spawn_init_posix_spawn_fncs(void) {
   /* Try to locate all non-portable functions at runtime */
   posix_spawn_fncs.file_actions.addchdir_np =
-    dlsym(RTLD_DEFAULT, "posix_spawn_file_actions_addchdir_np");
+    (int (*)(void* const*, const char*)) dlsym(RTLD_DEFAULT, "posix_spawn_file_actions_addchdir_np");
 }
 
 
@@ -986,7 +986,7 @@ int uv_spawn(uv_loop_t* loop,
   err = UV_ENOMEM;
   pipes = pipes_storage;
   if (stdio_count > (int) ARRAY_SIZE(pipes_storage))
-    pipes = uv__malloc(stdio_count * sizeof(*pipes));
+    pipes = (int (*)[2])uv__malloc(stdio_count * sizeof(*pipes));
 
   if (pipes == NULL)
     goto error;
diff --git a/src/unix/proctitle.c b/src/unix/proctitle.c
index 9d1f00ddf66e291abd40d0c0052a7f9bd5c03017..8cdec753d003ebe16485db2b47ffb3863a9473ff 100644
--- a/src/unix/proctitle.c
+++ b/src/unix/proctitle.c
@@ -65,7 +65,7 @@ char** uv_setup_args(int argc, char** argv) {
   /* Add space for the argv pointers. */
   size += (argc + 1) * sizeof(char*);
 
-  new_argv = uv__malloc(size);
+  new_argv = (char**)uv__malloc(size);
   if (new_argv == NULL)
     return argv;
 
diff --git a/src/unix/random-sysctl-linux.c b/src/unix/random-sysctl-linux.c
index 66ba8d74ec22b72d318b91d82365f5b9693feb3c..9ef18df01a51aa6a26ae6d1d9660a819d18604d0 100644
--- a/src/unix/random-sysctl-linux.c
+++ b/src/unix/random-sysctl-linux.c
@@ -48,7 +48,7 @@ int uv__random_sysctl(void* buf, size_t buflen) {
   char* pe;
   size_t n;
 
-  p = buf;
+  p = (char*)buf;
   pe = p + buflen;
 
   while (p < pe) {
diff --git a/src/unix/stream.c b/src/unix/stream.c
index 18763b4744c30a93f067a911b8059984bf36eb86..2d2b5d2f45e673d495ac814fbc1c6a877950ab9b 100644
--- a/src/unix/stream.c
+++ b/src/unix/stream.c
@@ -123,7 +123,7 @@ static void uv__stream_osx_interrupt_select(uv_stream_t* stream) {
   uv__stream_select_t* s;
   int r;
 
-  s = stream->select;
+  s = (uv__stream_select_t*)stream->select;
   if (s == NULL)
     return;
 
@@ -152,8 +152,8 @@ static void uv__stream_osx_select(void* arg) {
   int r;
   int max_fd;
 
-  stream = arg;
-  s = stream->select;
+  stream = (uv_stream_t*)arg;
+  s = (uv__stream_select_t*)stream->select;
   fd = s->fd;
 
   if (fd > s->int_fd)
@@ -330,7 +330,7 @@ int uv__stream_try_select(uv_stream_t* stream, int* fd) {
   sread_sz = ROUND_UP(max_fd + 1, sizeof(uint32_t) * NBBY) / NBBY;
   swrite_sz = sread_sz;
 
-  s = uv__malloc(sizeof(*s) + sread_sz + swrite_sz);
+  s = (uv__stream_select_t*)uv__malloc(sizeof(*s) + sread_sz + swrite_sz);
   if (s == NULL) {
     err = UV_ENOMEM;
     goto failed_malloc;
@@ -573,7 +573,7 @@ done:
   if (server->queued_fds != NULL) {
     uv__stream_queued_fds_t* queued_fds;
 
-    queued_fds = server->queued_fds;
+    queued_fds = (uv__stream_queued_fds_t*)(server->queued_fds);
 
     /* Read first */
     server->accepted_fd = queued_fds->fds[0];
@@ -943,11 +943,12 @@ static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {
   uv__stream_queued_fds_t* queued_fds;
   unsigned int queue_size;
 
-  queued_fds = stream->queued_fds;
+  queued_fds = (uv__stream_queued_fds_t*)stream->queued_fds;
   if (queued_fds == NULL) {
     queue_size = 8;
-    queued_fds = uv__malloc((queue_size - 1) * sizeof(*queued_fds->fds) +
-                            sizeof(*queued_fds));
+    queued_fds = (uv__stream_queued_fds_t*)
+        uv__malloc((queue_size - 1) * sizeof(*queued_fds->fds) +
+                   sizeof(*queued_fds));
     if (queued_fds == NULL)
       return UV_ENOMEM;
     queued_fds->size = queue_size;
@@ -957,9 +958,9 @@ static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {
     /* Grow */
   } else if (queued_fds->size == queued_fds->offset) {
     queue_size = queued_fds->size + 8;
-    queued_fds = uv__realloc(queued_fds,
-                             (queue_size - 1) * sizeof(*queued_fds->fds) +
-                              sizeof(*queued_fds));
+    queued_fds = (uv__stream_queued_fds_t*)
+        uv__realloc(queued_fds, (queue_size - 1) * sizeof(*queued_fds->fds) +
+                    sizeof(*queued_fds));
 
     /*
      * Allocation failure, report back.
@@ -999,7 +1000,7 @@ static int uv__stream_recv_cmsg(uv_stream_t* stream, struct msghdr* msg) {
     assert(count % sizeof(fd) == 0);
     count /= sizeof(fd);
 
-    p = (void*) CMSG_DATA(cmsg);
+    p = (char*) CMSG_DATA(cmsg);
     pe = p + count * sizeof(fd);
 
     while (p < pe) {
@@ -1361,7 +1362,7 @@ int uv_write2(uv_write_t* req,
 
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(bufs[0]));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(bufs[0]));
 
   if (req->bufs == NULL)
     return UV_ENOMEM;
@@ -1495,7 +1496,7 @@ int uv___stream_fd(const uv_stream_t* handle) {
          handle->type == UV_TTY ||
          handle->type == UV_NAMED_PIPE);
 
-  s = handle->select;
+  s = (const uv__stream_select_t*)handle->select;
   if (s != NULL)
     return s->fd;
 
@@ -1513,7 +1514,7 @@ void uv__stream_close(uv_stream_t* handle) {
   if (handle->select != NULL) {
     uv__stream_select_t* s;
 
-    s = handle->select;
+    s = (uv__stream_select_t*)handle->select;
 
     uv_sem_post(&s->close_sem);
     uv_sem_post(&s->async_sem);
@@ -1548,7 +1549,7 @@ void uv__stream_close(uv_stream_t* handle) {
 
   /* Close all queued fds */
   if (handle->queued_fds != NULL) {
-    queued_fds = handle->queued_fds;
+    queued_fds = (uv__stream_queued_fds_t*)(handle->queued_fds);
     for (i = 0; i < queued_fds->offset; i++)
       uv__close(queued_fds->fds[i]);
     uv__free(handle->queued_fds);
diff --git a/src/unix/tcp.c b/src/unix/tcp.c
index 98970d75278e312578facdfd06e349fdf51c0ba3..018ec144c78e9dcc7cbebcdaa432b31832f6e902 100644
--- a/src/unix/tcp.c
+++ b/src/unix/tcp.c
@@ -301,7 +301,7 @@ int uv__tcp_connect(uv_connect_t* req,
     memcpy(&tmp6, addr, sizeof(tmp6));
     if (tmp6.sin6_scope_id == 0) {
       tmp6.sin6_scope_id = uv__ipv6_link_local_scope_id();
-      addr = (void*) &tmp6;
+      addr = (const struct sockaddr*) &tmp6;
     }
   }
 
diff --git a/src/unix/thread.c b/src/unix/thread.c
index f05e6fe0f7dd5ac579f6a9d6f93bffb99e1bcbc2..20409541de3cb300504b823472a73bc95fa38f62 100644
--- a/src/unix/thread.c
+++ b/src/unix/thread.c
@@ -168,8 +168,7 @@ int uv_thread_create_ex(uv_thread_t* tid,
       abort();
   }
 
-  f.in = entry;
-  err = pthread_create(tid, attr, f.out, arg);
+  err = pthread_create(tid, attr, (void*(*)(void*)) (void(*)(void)) entry, arg);
 
   if (attr != NULL)
     pthread_attr_destroy(attr);
@@ -540,7 +539,7 @@ static int uv__custom_sem_init(uv_sem_t* sem_, unsigned int value) {
   int err;
   uv_semaphore_t* sem;
 
-  sem = uv__malloc(sizeof(*sem));
+  sem = (uv_semaphore_t*)uv__malloc(sizeof(*sem));
   if (sem == NULL)
     return UV_ENOMEM;
 
diff --git a/src/unix/udp.c b/src/unix/udp.c
index f6640fc72318635d9c1aba6015646cf241747774..50506752d0b168aec9507cd36ac81586bb912981 100644
--- a/src/unix/udp.c
+++ b/src/unix/udp.c
@@ -198,11 +198,11 @@ static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf) {
       if (msgs[k].msg_hdr.msg_flags & MSG_TRUNC)
         flags |= UV_UDP_PARTIAL;
 
-      chunk_buf = uv_buf_init(iov[k].iov_base, iov[k].iov_len);
+      chunk_buf = uv_buf_init((char*) iov[k].iov_base, iov[k].iov_len);
       handle->recv_cb(handle,
                       msgs[k].msg_len,
                       &chunk_buf,
-                      msgs[k].msg_hdr.msg_name,
+                      (const sockaddr*) msgs[k].msg_hdr.msg_name,
                       flags);
     }
 
@@ -252,7 +252,7 @@ static void uv__udp_recvmsg(uv_udp_t* handle) {
     memset(&peer, 0, sizeof(peer));
     h.msg_name = &peer;
     h.msg_namelen = sizeof(peer);
-    h.msg_iov = (void*) &buf;
+    h.msg_iov = (iovec*) &buf;
     h.msg_iovlen = 1;
 
     do {
@@ -754,7 +754,7 @@ int uv__udp_send(uv_udp_send_t* req,
 
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(bufs[0]));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(bufs[0]));
 
   if (req->bufs == NULL) {
     uv__req_unregister(handle->loop);
diff --git a/src/uv-common.c b/src/uv-common.c
index 2200fe3f0a41e295acb426f39ccc9f0133994675..69e95801a18104ea910abf86db236d85f62afb66 100644
--- a/src/uv-common.c
+++ b/src/uv-common.c
@@ -54,10 +54,10 @@ static uv__allocator_t uv__allocator = {
 
 char* uv__strdup(const char* s) {
   size_t len = strlen(s) + 1;
-  char* m = uv__malloc(len);
+  char* m = (char*)uv__malloc(len);
   if (m == NULL)
     return NULL;
-  return memcpy(m, s, len);
+  return (char*)memcpy(m, s, len);
 }
 
 char* uv__strndup(const char* s, size_t n) {
@@ -65,11 +65,11 @@ char* uv__strndup(const char* s, size_t n) {
   size_t len = strlen(s);
   if (n < len)
     len = n;
-  m = uv__malloc(len + 1);
+  m = (char*)uv__malloc(len + 1);
   if (m == NULL)
     return NULL;
   m[len] = '\0';
-  return memcpy(m, s, len);
+  return (char*)memcpy(m, s, len);
 }
 
 void* uv__malloc(size_t size) {
@@ -691,7 +691,7 @@ void uv__fs_scandir_cleanup(uv_fs_t* req) {
   unsigned int n;
 
   if (req->result >= 0) {
-    dents = req->ptr;
+    dents = (uv__dirent_t**)(req->ptr);
     nbufs = uv__get_nbufs(req);
 
     i = 0;
@@ -724,7 +724,7 @@ int uv_fs_scandir_next(uv_fs_t* req, uv_dirent_t* ent) {
   nbufs = uv__get_nbufs(req);
   assert(nbufs);
 
-  dents = req->ptr;
+  dents = (uv__dirent_t**)(req->ptr);
 
   /* Free previous entity */
   if (*nbufs > 0)
@@ -789,7 +789,7 @@ void uv__fs_readdir_cleanup(uv_fs_t* req) {
   if (req->ptr == NULL)
     return;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   dirents = dir->dirents;
   req->ptr = NULL;
 
@@ -835,7 +835,7 @@ uv_loop_t* uv_default_loop(void) {
 uv_loop_t* uv_loop_new(void) {
   uv_loop_t* loop;
 
-  loop = uv__malloc(sizeof(*loop));
+  loop = (uv_loop_t*)uv__malloc(sizeof(*loop));
   if (loop == NULL)
     return NULL;
 
diff --git a/src/win/core.c b/src/win/core.c
index e9885a0f1ff3890a8d957c8793e22b01cedc0e97..87ade7ad65243ee3ff940320f84e1960390300e1 100644
--- a/src/win/core.c
+++ b/src/win/core.c
@@ -98,7 +98,8 @@ static int uv__loops_add(uv_loop_t* loop) {
 
   if (uv__loops_size == uv__loops_capacity) {
     new_capacity = uv__loops_capacity + UV__LOOPS_CHUNK_SIZE;
-    new_loops = uv__realloc(uv__loops, sizeof(uv_loop_t*) * new_capacity);
+    new_loops = (uv_loop_t**)
+        uv__realloc(uv__loops, sizeof(uv_loop_t*) * new_capacity);
     if (!new_loops)
       goto failed_loops_realloc;
     uv__loops = new_loops;
@@ -152,7 +153,8 @@ static void uv__loops_remove(uv_loop_t* loop) {
   smaller_capacity = uv__loops_capacity / 2;
   if (uv__loops_size >= smaller_capacity)
     goto loop_removed;
-  new_loops = uv__realloc(uv__loops, sizeof(uv_loop_t*) * smaller_capacity);
+  new_loops = (uv_loop_t**)
+      uv__realloc(uv__loops, sizeof(uv_loop_t*) * smaller_capacity);
   if (!new_loops)
     goto loop_removed;
   uv__loops = new_loops;
@@ -264,7 +266,7 @@ int uv_loop_init(uv_loop_t* loop) {
 
   loop->endgame_handles = NULL;
 
-  loop->timer_heap = timer_heap = uv__malloc(sizeof(*timer_heap));
+  loop->timer_heap = timer_heap = (heap*)uv__malloc(sizeof(*timer_heap));
   if (timer_heap == NULL) {
     err = UV_ENOMEM;
     goto fail_timers_alloc;
diff --git a/src/win/dl.c b/src/win/dl.c
index 7880c9595be1f66ea0dcbdbcc4a91ce40577587f..d88400f0e819d74998e13f60f13c67a606dec398 100644
--- a/src/win/dl.c
+++ b/src/win/dl.c
@@ -37,7 +37,7 @@ int uv_dlopen(const char* filename, uv_lib_t* lib) {
     return uv__dlerror(lib, filename, ERROR_NO_UNICODE_TRANSLATION);
   if ((size_t) r > ARRAY_SIZE(filename_w))
     return uv__dlerror(lib, filename, ERROR_INSUFFICIENT_BUFFER);
-  uv_wtf8_to_utf16(filename, filename_w, r);
+  uv_wtf8_to_utf16(filename, (uint16_t*)filename_w, r);
 
   lib->handle = LoadLibraryExW(filename_w, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
   if (lib->handle == NULL) {
diff --git a/src/win/fs-event.c b/src/win/fs-event.c
index 7ab407e05345f96a2c5f577e51dc9b21b2f610b9..3754437b4989d67f688153e066ef047268911708 100644
--- a/src/win/fs-event.c
+++ b/src/win/fs-event.c
@@ -73,7 +73,7 @@ static void uv__relative_path(const WCHAR* filename,
   if (dirlen > 0 && dir[dirlen - 1] == '\\')
     dirlen--;
   relpathlen = filenamelen - dirlen - 1;
-  *relpath = uv__malloc((relpathlen + 1) * sizeof(WCHAR));
+  *relpath = (WCHAR*)uv__malloc((relpathlen + 1) * sizeof(WCHAR));
   if (!*relpath)
     uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
   wcsncpy(*relpath, filename + dirlen + 1, relpathlen);
@@ -229,7 +229,7 @@ int uv_fs_event_start(uv_fs_event_t* handle,
     if (short_path_buffer_len == 0) {
       goto short_path_done;
     }
-    short_path_buffer = uv__malloc(short_path_buffer_len * sizeof(WCHAR));
+    short_path_buffer = (WCHAR*)uv__malloc(short_path_buffer_len * sizeof(WCHAR));
     if (short_path_buffer == NULL) {
       goto short_path_done;
     }
diff --git a/src/win/fs-fd-hash-inl.h b/src/win/fs-fd-hash-inl.h
index 0b532af12d4371c2311bd50a66913287a0716f43..703a8d8f87de1089ac8b18bd817d416d48dc442e 100644
--- a/src/win/fs-fd-hash-inl.h
+++ b/src/win/fs-fd-hash-inl.h
@@ -146,7 +146,7 @@ INLINE static void uv__fd_hash_add(int fd, struct uv__fd_info_s* info) {
 
     if (bucket_ptr->size != 0 && i == 0) {
       struct uv__fd_hash_entry_group_s* new_group_ptr =
-        uv__malloc(sizeof(*new_group_ptr));
+        (struct uv__fd_hash_entry_group_s*)uv__malloc(sizeof(*new_group_ptr));
       if (new_group_ptr == NULL) {
         uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
       }
diff --git a/src/win/fs.c b/src/win/fs.c
index f2215bb3082178193d37f8429536bfe7b707dd0d..cc095491d7ff14a7f7a850005f02a45860636446 100644
--- a/src/win/fs.c
+++ b/src/win/fs.c
@@ -302,7 +302,7 @@ INLINE static int fs__readlink_handle(HANDLE handle,
   }
 
   assert(target_ptr == NULL || *target_ptr == NULL);
-  return uv_utf16_to_wtf8(w_target, w_target_len, target_ptr, target_len_ptr);
+  return uv_utf16_to_wtf8((const uint16_t*)w_target, w_target_len, target_ptr, target_len_ptr);
 }
 
 
@@ -345,7 +345,7 @@ INLINE static int fs__capture_path(uv_fs_t* req, const char* path,
     return 0;
   }
 
-  buf = uv__malloc(buf_sz);
+  buf = (WCHAR*)uv__malloc(buf_sz);
   if (buf == NULL) {
     return ERROR_OUTOFMEMORY;
   }
@@ -353,7 +353,7 @@ INLINE static int fs__capture_path(uv_fs_t* req, const char* path,
   pos = buf;
 
   if (path != NULL) {
-    uv_wtf8_to_utf16(path, pos, pathw_len);
+    uv_wtf8_to_utf16(path, (uint16_t*)pos, pathw_len);
     req->file.pathw = pos;
     pos += pathw_len;
   } else {
@@ -361,7 +361,7 @@ INLINE static int fs__capture_path(uv_fs_t* req, const char* path,
   }
 
   if (new_path != NULL) {
-    uv_wtf8_to_utf16(new_path, pos, new_pathw_len);
+    uv_wtf8_to_utf16(new_path, (uint16_t*)pos, new_pathw_len);
     req->fs.info.new_pathw = pos;
     pos += new_pathw_len;
   } else {
@@ -1448,13 +1448,13 @@ void fs__scandir(uv_fs_t* req) {
         continue;
 
       /* Compute the space required to store the filename as WTF-8. */
-      wtf8_len = uv_utf16_length_as_wtf8(&info->FileName[0], wchar_len);
+      wtf8_len = uv_utf16_length_as_wtf8((const uint16_t*)&info->FileName[0], wchar_len);
 
       /* Resize the dirent array if needed. */
       if (dirents_used >= dirents_size) {
         size_t new_dirents_size =
             dirents_size == 0 ? dirents_initial_size : dirents_size << 1;
-        uv__dirent_t** new_dirents =
+        uv__dirent_t** new_dirents = (uv__dirent_t**)
             uv__realloc(dirents, new_dirents_size * sizeof *dirents);
 
         if (new_dirents == NULL)
@@ -1468,7 +1468,7 @@ void fs__scandir(uv_fs_t* req) {
        * includes room for the first character of the filename, but `utf8_len`
        * doesn't count the NULL terminator at this point.
        */
-      dirent = uv__malloc(sizeof *dirent + wtf8_len);
+      dirent = (uv__dirent_t*)uv__malloc(sizeof *dirent + wtf8_len);
       if (dirent == NULL)
         goto out_of_memory_error;
 
@@ -1476,7 +1476,7 @@ void fs__scandir(uv_fs_t* req) {
 
       /* Convert file name to UTF-8. */
       wtf8 = &dirent->d_name[0];
-      if (uv_utf16_to_wtf8(&info->FileName[0], wchar_len, &wtf8, &wtf8_len) != 0)
+      if (uv_utf16_to_wtf8((const uint16_t*)&info->FileName[0], wchar_len, &wtf8, &wtf8_len) != 0)
         goto out_of_memory_error;
 
       /* Fill out the type field. */
@@ -1570,7 +1570,7 @@ void fs__opendir(uv_fs_t* req) {
     goto error;
   }
 
-  dir = uv__malloc(sizeof(*dir));
+  dir = (uv_dir_t*)uv__malloc(sizeof(*dir));
   if (dir == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
     goto error;
@@ -1585,7 +1585,7 @@ void fs__opendir(uv_fs_t* req) {
   else
     fmt = L"%s\\*";
 
-  find_path = uv__malloc(sizeof(WCHAR) * (len + 4));
+  find_path = (WCHAR*)uv__malloc(sizeof(WCHAR) * (len + 4));
   if (find_path == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
     goto error;
@@ -1622,7 +1622,7 @@ void fs__readdir(uv_fs_t* req) {
   int r;
 
   req->flags |= UV_FS_FREE_PTR;
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   dirents = dir->dirents;
   memset(dirents, 0, dir->nentries * sizeof(*dir->dirents));
   find_data = &dir->find_data;
@@ -1679,7 +1679,7 @@ error:
 void fs__closedir(uv_fs_t* req) {
   uv_dir_t* dir;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   FindClose(dir->dir_handle);
   uv__free(req->ptr);
   SET_REQ_RESULT(req, 0);
@@ -2756,7 +2756,7 @@ static ssize_t fs__realpath_handle(HANDLE handle, char** realpath_ptr) {
     return -1;
   }
 
-  w_realpath_buf = uv__malloc((w_realpath_len + 1) * sizeof(WCHAR));
+  w_realpath_buf = (WCHAR*)uv__malloc((w_realpath_len + 1) * sizeof(WCHAR));
   if (w_realpath_buf == NULL) {
     SetLastError(ERROR_OUTOFMEMORY);
     return -1;
@@ -2789,7 +2789,7 @@ static ssize_t fs__realpath_handle(HANDLE handle, char** realpath_ptr) {
   }
 
   assert(*realpath_ptr == NULL);
-  r = uv_utf16_to_wtf8(w_realpath_ptr, w_realpath_len, realpath_ptr, NULL);
+  r = uv_utf16_to_wtf8((const uint16_t*)w_realpath_ptr, w_realpath_len, realpath_ptr, NULL);
   uv__free(w_realpath_buf);
   return r;
 }
@@ -2869,7 +2869,7 @@ retry_get_disk_free_space:
     }
 
     len = MAX_PATH + 1;
-    pathw = uv__malloc(len * sizeof(*pathw));
+    pathw = (WCHAR*)uv__malloc(len * sizeof(*pathw));
     if (pathw == NULL) {
       SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
       return;
@@ -2885,7 +2885,7 @@ retry_get_full_path_name:
       return;
     } else if (ret > len) {
       len = ret;
-      pathw = uv__reallocf(pathw, len * sizeof(*pathw));
+      pathw = (WCHAR*)uv__reallocf(pathw, len * sizeof(*pathw));
       if (pathw == NULL) {
         SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
         return;
@@ -2901,7 +2901,7 @@ retry_get_full_path_name:
     uv__free(pathw);
   }
 
-  stat_fs = uv__malloc(sizeof(*stat_fs));
+  stat_fs = (uv_statfs_t*)uv__malloc(sizeof(*stat_fs));
   if (stat_fs == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
     return;
@@ -3060,7 +3060,7 @@ int uv_fs_read(uv_loop_t* loop,
   req->fs.info.nbufs = nbufs;
   req->fs.info.bufs = req->fs.info.bufsml;
   if (nbufs > ARRAY_SIZE(req->fs.info.bufsml))
-    req->fs.info.bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->fs.info.bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->fs.info.bufs == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
@@ -3093,7 +3093,7 @@ int uv_fs_write(uv_loop_t* loop,
   req->fs.info.nbufs = nbufs;
   req->fs.info.bufs = req->fs.info.bufsml;
   if (nbufs > ARRAY_SIZE(req->fs.info.bufsml))
-    req->fs.info.bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->fs.info.bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->fs.info.bufs == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
diff --git a/src/win/getaddrinfo.c b/src/win/getaddrinfo.c
index 4b8ee75a0622f6b138ea366c7f42306960b61b3d..68d456cb773630a44daa1fba2b3d551695005b19 100644
--- a/src/win/getaddrinfo.c
+++ b/src/win/getaddrinfo.c
@@ -129,7 +129,7 @@ static void uv__getaddrinfo_done(struct uv__work* w, int status) {
       cur_off += addrinfow_ptr->ai_addrlen;
       if (addrinfow_ptr->ai_canonname != NULL) {
         ssize_t name_len =
-            uv_utf16_length_as_wtf8(addrinfow_ptr->ai_canonname, -1);
+            uv_utf16_length_as_wtf8((const uint16_t*)addrinfow_ptr->ai_canonname, -1);
         if (name_len < 0) {
           req->retcode = name_len;
           goto complete;
@@ -141,7 +141,7 @@ static void uv__getaddrinfo_done(struct uv__work* w, int status) {
 
     /* allocate memory for addrinfo results */
     addrinfo_len = cur_off;
-    alloc_ptr = uv__malloc(addrinfo_len);
+    alloc_ptr = (char*)uv__malloc(addrinfo_len);
 
     /* do conversions */
     if (alloc_ptr != NULL) {
@@ -293,7 +293,7 @@ int uv_getaddrinfo(uv_loop_t* loop,
   }
 
   /* allocate memory for inputs, and partition it as needed */
-  req->alloc = uv__malloc(off);
+  req->alloc = (char*)uv__malloc(off);
   if (!req->alloc)
     return UV_ENOMEM;
 
@@ -301,7 +301,7 @@ int uv_getaddrinfo(uv_loop_t* loop,
    * request. The node here has been converted to ascii. */
   if (node != NULL) {
     req->node = (WCHAR*) req->alloc;
-    uv_wtf8_to_utf16(node, req->node, nodesize);
+    uv_wtf8_to_utf16(node, (uint16_t*)req->node, nodesize);
   } else {
     req->node = NULL;
   }
@@ -310,7 +310,7 @@ int uv_getaddrinfo(uv_loop_t* loop,
    * the req. */
   if (service != NULL) {
     req->service = (WCHAR*) ((char*) req->alloc + serviceoff);
-    uv_wtf8_to_utf16(service, req->service, servicesize);
+    uv_wtf8_to_utf16(service, (uint16_t*)req->service, servicesize);
   } else {
     req->service = NULL;
   }
diff --git a/src/win/pipe.c b/src/win/pipe.c
index d46ecb9fc702e62b3445c42711d93a92b7004dfe..9b2723320b72691d5ada0f8e97f0589ce53e82f8 100644
--- a/src/win/pipe.c
+++ b/src/win/pipe.c
@@ -739,7 +739,7 @@ int uv_pipe_bind2(uv_pipe_t* handle,
     return UV_EINVAL;
   }
 
-  name_copy = uv__malloc(namelen + 1);
+  name_copy = (char*)uv__malloc(namelen + 1);
   if (name_copy == NULL) {
     return UV_ENOMEM;
   }
@@ -910,7 +910,7 @@ int uv_pipe_connect2(uv_connect_t* req,
     return UV_EINVAL;
   }
 
-  name_copy = uv__malloc(namelen + 1);
+  name_copy = (char*)uv__malloc(namelen + 1);
   if (name_copy == NULL) {
     return UV_ENOMEM;
   }
@@ -942,7 +942,7 @@ int uv_pipe_connect2(uv_connect_t* req,
   if (pipeHandle == INVALID_HANDLE_VALUE) {
     if (GetLastError() == ERROR_PIPE_BUSY) {
       nameSize = (wcslen(handle->name) + 1) * sizeof(WCHAR);
-      req->u.connect.name = uv__malloc(nameSize);
+      req->u.connect.name = (WCHAR *)uv__malloc(nameSize);
       if (!req->u.connect.name) {
         uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
       }
@@ -1547,7 +1547,7 @@ static int uv__build_coalesced_write_req(uv_write_t* user_req,
                        data_length;                  /* (c) */
 
   /* Allocate buffer. */
-  heap_buffer = uv__malloc(heap_buffer_length);
+  heap_buffer = (char*)uv__malloc(heap_buffer_length);
   if (heap_buffer == NULL)
     return ERROR_NOT_ENOUGH_MEMORY; /* Maps to UV_ENOMEM. */
 
@@ -1796,7 +1796,7 @@ int uv__pipe_write_ipc(uv_loop_t* loop,
     bufs = stack_bufs;
   } else {
     /* Use heap-allocated buffer array. */
-    bufs = uv__calloc(buf_count, sizeof(uv_buf_t));
+    bufs = (uv_buf_t*)uv__calloc(buf_count, sizeof(uv_buf_t));
     if (bufs == NULL)
       return ERROR_NOT_ENOUGH_MEMORY; /* Maps to UV_ENOMEM. */
   }
@@ -2541,7 +2541,7 @@ static int uv__pipe_getname(const uv_pipe_t* handle, char* buffer, size_t* size)
                                       FileNameInformation);
   if (nt_status == STATUS_BUFFER_OVERFLOW) {
     name_size = sizeof(*name_info) + tmp_name_info.FileNameLength;
-    name_info = uv__malloc(name_size);
+    name_info = (FILE_NAME_INFORMATION*)uv__malloc(name_size);
     if (!name_info) {
       *size = 0;
       return UV_ENOMEM;
diff --git a/src/win/process.c b/src/win/process.c
index 79bec0090cc94bfe20dab722cf2d8135ddd03cb8..5a648494ae03688f6a56705f2c3d65b026605818 100644
--- a/src/win/process.c
+++ b/src/win/process.c
@@ -546,14 +546,14 @@ int make_program_args(char** args, int verbatim_arguments, WCHAR** dst_ptr) {
   dst_len = dst_len * 2 + arg_count * 2;
 
   /* Allocate buffer for the final command line. */
-  dst = uv__malloc(dst_len * sizeof(WCHAR));
+  dst = (WCHAR*)uv__malloc(dst_len * sizeof(WCHAR));
   if (dst == NULL) {
     err = UV_ENOMEM;
     goto error;
   }
 
   /* Allocate temporary working buffer. */
-  temp_buffer = uv__malloc(temp_buffer_len * sizeof(WCHAR));
+  temp_buffer = (WCHAR*)uv__malloc(temp_buffer_len * sizeof(WCHAR));
   if (temp_buffer == NULL) {
     err = UV_ENOMEM;
     goto error;
@@ -567,7 +567,7 @@ int make_program_args(char** args, int verbatim_arguments, WCHAR** dst_ptr) {
     arg_len = uv_wtf8_length_as_utf16(*arg);
     assert(arg_len > 0);
     assert(temp_buffer_len >= (size_t) arg_len);
-    uv_wtf8_to_utf16(*arg, temp_buffer, arg_len);
+    uv_wtf8_to_utf16(*arg, (uint16_t*)temp_buffer, arg_len);
 
     if (verbatim_arguments) {
       /* Copy verbatim. */
@@ -595,8 +595,8 @@ error:
 
 
 static int env_strncmp(const wchar_t* a, int na, const wchar_t* b) {
-  wchar_t* a_eq;
-  wchar_t* b_eq;
+  const wchar_t* a_eq;
+  const wchar_t* b_eq;
   int nb;
   int r;
 
@@ -668,12 +668,12 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
 
   /* second pass: copy to UTF-16 environment block */
   len = env_block_count * sizeof(WCHAR*);
-  p = uv__malloc(len + env_len * sizeof(WCHAR));
+  p = (char*)uv__malloc(len + env_len * sizeof(WCHAR));
   if (p == NULL) {
     return UV_ENOMEM;
   }
-  env_copy = (void*) &p[0];
-  dst_copy = (void*) &p[len];
+  env_copy = (WCHAR**) &p[0];
+  dst_copy = (WCHAR*) &p[len];
 
   ptr = dst_copy;
   ptr_copy = env_copy;
@@ -683,7 +683,7 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
       len = uv_wtf8_length_as_utf16(*env);
       assert(len > 0);
       assert((size_t) len <= env_len - (ptr - dst_copy));
-      uv_wtf8_to_utf16(*env, ptr, len);
+      uv_wtf8_to_utf16(*env, (uint16_t*)ptr, len);
       *ptr_copy++ = ptr;
       ptr += len;
     }
@@ -721,7 +721,7 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
   }
 
   /* final pass: copy, in sort order, and inserting required variables */
-  dst = uv__malloc((1+env_len) * sizeof(WCHAR));
+  dst = (WCHAR*)uv__malloc((1+env_len) * sizeof(WCHAR));
   if (!dst) {
     uv__free(p);
     return UV_ENOMEM;
diff --git a/src/win/tcp.c b/src/win/tcp.c
index c452c12e8f06f13e519a198f786eec63faebe2bf..2b43d03ea227b87a717b128ed0d8f0767c8233fd 100644
--- a/src/win/tcp.c
+++ b/src/win/tcp.c
@@ -597,7 +597,7 @@ int uv__tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {
 
   if (handle->tcp.serv.accept_reqs == NULL) {
     handle->tcp.serv.accept_reqs =
-      uv__malloc(uv_simultaneous_server_accepts * sizeof(uv_tcp_accept_t));
+      (uv_tcp_accept_t*)uv__malloc(uv_simultaneous_server_accepts * sizeof(uv_tcp_accept_t));
     if (!handle->tcp.serv.accept_reqs) {
       uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
     }
diff --git a/src/win/thread.c b/src/win/thread.c
index bf39b88633b0d87de02b56579121d384aa5f2d3e..dd958ccd782772869d5448d788a563c1526a89f6 100644
--- a/src/win/thread.c
+++ b/src/win/thread.c
@@ -39,7 +39,7 @@ typedef struct {
 } uv__once_data_t;
 
 static BOOL WINAPI uv__once_inner(INIT_ONCE *once, void* param, void** context) {
-  uv__once_data_t* data = param;
+  uv__once_data_t* data = (uv__once_data_t*)param;
 
   data->callback();
 
@@ -76,7 +76,7 @@ static UINT __stdcall uv__thread_start(void* arg) {
   struct thread_ctx *ctx_p;
   struct thread_ctx ctx;
 
-  ctx_p = arg;
+  ctx_p = (struct thread_ctx*)arg;
   ctx = *ctx_p;
   uv__free(ctx_p);
 
@@ -119,7 +119,7 @@ int uv_thread_create_ex(uv_thread_t* tid,
       return UV_EINVAL;
   }
 
-  ctx = uv__malloc(sizeof(*ctx));
+  ctx = (struct thread_ctx*)uv__malloc(sizeof(*ctx));
   if (ctx == NULL)
     return UV_ENOMEM;
 
diff --git a/src/win/tty.c b/src/win/tty.c
index c0339ded2e4b763c3b09331e3acd58bf43dccc28..145706e27a7b596dc003d43d94b54f6ceb0eabee 100644
--- a/src/win/tty.c
+++ b/src/win/tty.c
@@ -528,7 +528,7 @@ static DWORD CALLBACK uv_tty_line_read_thread(void* data) {
 
   if (read_console_success) {
     read_bytes = bytes;
-    uv_utf16_to_wtf8(utf16,
+    uv_utf16_to_wtf8((const uint16_t*)utf16,
                      read_chars,
                      &handle->tty.rd.read_line_buffer.base,
                      &read_bytes);
@@ -827,7 +827,7 @@ void uv_process_tty_read_raw_req(uv_loop_t* loop, uv_tty_t* handle,
           WCHAR utf16_buffer[2];
           utf16_buffer[0] = handle->tty.rd.last_utf16_high_surrogate;
           utf16_buffer[1] = KEV.uChar.UnicodeChar;
-          if (uv_utf16_to_wtf8(utf16_buffer,
+          if (uv_utf16_to_wtf8((const uint16_t*)utf16_buffer,
                                2,
                                &last_key_buf,
                                &char_len))
@@ -835,7 +835,7 @@ void uv_process_tty_read_raw_req(uv_loop_t* loop, uv_tty_t* handle,
           handle->tty.rd.last_utf16_high_surrogate = 0;
         } else {
           /* Single UTF-16 character */
-          if (uv_utf16_to_wtf8(&KEV.uChar.UnicodeChar,
+          if (uv_utf16_to_wtf8((const uint16_t*)&KEV.uChar.UnicodeChar,
                                1,
                                &last_key_buf,
                                &char_len))
diff --git a/src/win/util.c b/src/win/util.c
index e0dba1aaa94e285a6e10f57d3b923b53126767d8..1aca4e9a081cd7e4481503d59f39872acbbc6a9c 100644
--- a/src/win/util.c
+++ b/src/win/util.c
@@ -124,7 +124,7 @@ int uv_exepath(char* buffer, size_t* size_ptr) {
 
   /* Convert to UTF-8 */
   utf8_len = *size_ptr - 1; /* Reserve space for NUL */
-  err = uv_utf16_to_wtf8(utf16_buffer, utf16_len, &buffer, &utf8_len);
+  err = uv_utf16_to_wtf8((const uint16_t*)utf16_buffer, utf16_len, &buffer, &utf8_len);
   if (err == UV_ENOBUFS) {
     utf8_len = *size_ptr - 1;
     err = 0;
@@ -152,7 +152,7 @@ static int uv__cwd(WCHAR** buf, DWORD *len) {
       return uv_translate_sys_error(GetLastError());
 
     /* |t| is the size of the buffer _including_ nul. */
-    p = uv__malloc(t * sizeof(*p));
+    p = (WCHAR *)uv__malloc(t * sizeof(*p));
     if (p == NULL)
       return UV_ENOMEM;
 
@@ -546,14 +546,14 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos_ptr, int* cpu_count_ptr) {
   GetSystemInfo(&system_info);
   cpu_count = system_info.dwNumberOfProcessors;
 
-  cpu_infos = uv__calloc(cpu_count, sizeof *cpu_infos);
+  cpu_infos = (uv_cpu_info_t*)uv__calloc(cpu_count, sizeof *cpu_infos);
   if (cpu_infos == NULL) {
     err = ERROR_OUTOFMEMORY;
     goto error;
   }
 
   sppi_size = cpu_count * sizeof(*sppi);
-  sppi = uv__malloc(sppi_size);
+  sppi = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION*)uv__malloc(sppi_size);
   if (sppi == NULL) {
     err = ERROR_OUTOFMEMORY;
     goto error;
@@ -697,7 +697,8 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
       case ERROR_BUFFER_OVERFLOW:
         /* This happens when win_address_buf is NULL or too small to hold all
          * adapters. */
-        win_address_buf = uv__malloc(win_address_buf_size);
+        win_address_buf =
+            (IP_ADAPTER_ADDRESSES*)uv__malloc(win_address_buf_size);
         if (win_address_buf == NULL)
           return UV_ENOMEM;
 
@@ -705,7 +706,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
 
       case ERROR_NO_DATA: {
         /* No adapters were found. */
-        uv_address_buf = uv__malloc(1);
+        uv_address_buf = (uv_interface_address_t*)uv__malloc(1);
         if (uv_address_buf == NULL)
           return UV_ENOMEM;
 
@@ -756,7 +757,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
       continue;
 
     /* Compute the size of the interface name. */
-    name_size = uv_utf16_length_as_wtf8(adapter->FriendlyName, -1);
+    name_size = uv_utf16_length_as_wtf8((const uint16_t*)adapter->FriendlyName, -1);
     uv_address_buf_size += name_size + 1;
 
     /* Count the number of addresses associated with this interface, and
@@ -771,7 +772,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
   }
 
   /* Allocate space to store interface data plus adapter names. */
-  uv_address_buf = uv__malloc(uv_address_buf_size);
+  uv_address_buf = (uv_interface_address_t*)uv__malloc(uv_address_buf_size);
   if (uv_address_buf == NULL) {
     uv__free(win_address_buf);
     return UV_ENOMEM;
@@ -991,7 +992,7 @@ int uv_os_tmpdir(char* buffer, size_t* size) {
 
   /* Include space for terminating null char. */
   len += 1;
-  path = uv__malloc(len * sizeof(wchar_t));
+  path = (wchar_t*)uv__malloc(len * sizeof(wchar_t));
   if (path == NULL) {
     return UV_ENOMEM;
   }
@@ -1028,7 +1029,7 @@ int uv__convert_utf16_to_utf8(const WCHAR* utf16, size_t utf16len, char** utf8)
     return UV_EINVAL;
 
    *utf8 = NULL;
-   return uv_utf16_to_wtf8(utf16, utf16len, utf8, &utf8_len);
+   return uv_utf16_to_wtf8((const uint16_t*)utf16, utf16len, utf8, &utf8_len);
 }
 
 
@@ -1048,13 +1049,13 @@ int uv__convert_utf8_to_utf16(const char* utf8, WCHAR** utf16) {
     return UV__EINVAL;
 
   /* Allocate the destination buffer. */
-  *utf16 = uv__malloc(sizeof(WCHAR) * bufsize);
+  *utf16 = (WCHAR*)uv__malloc(sizeof(WCHAR) * bufsize);
 
   if (*utf16 == NULL)
     return UV_ENOMEM;
 
   /* Convert to UTF-16 */
-  uv_wtf8_to_utf16(utf8, *utf16, bufsize);
+  uv_wtf8_to_utf16(utf8, (uint16_t*)*utf16, bufsize);
 
   return 0;
 }
@@ -1074,11 +1075,11 @@ int uv__copy_utf16_to_utf8(const WCHAR* utf16buffer, size_t utf16len, char* utf8
     return UV_EINVAL;
 
   if (*size == 0) {
-    *size = uv_utf16_length_as_wtf8(utf16buffer, utf16len);
+    *size = uv_utf16_length_as_wtf8((const uint16_t*)utf16buffer, utf16len);
     r = UV_ENOBUFS;
   } else {
     *size -= 1; /* Reserve space for NUL. */
-    r = uv_utf16_to_wtf8(utf16buffer, utf16len, &utf8, size);
+    r = uv_utf16_to_wtf8((const uint16_t*)utf16buffer, utf16len, &utf8, size);
   }
   if (r == UV_ENOBUFS)
     *size += 1; /* Add space for NUL. */
@@ -1108,7 +1109,7 @@ static int uv__getpwuid_r(uv_passwd_t* pwd) {
     return uv_translate_sys_error(r);
   }
 
-  path = uv__malloc(bufsize * sizeof(wchar_t));
+  path = (wchar_t*)uv__malloc(bufsize * sizeof(wchar_t));
   if (path == NULL) {
     CloseHandle(token);
     return UV_ENOMEM;
@@ -1189,7 +1190,7 @@ int uv_os_environ(uv_env_item_t** envitems, int* count) {
 
   for (penv = env, i = 0; *penv != L'\0'; penv += wcslen(penv) + 1, i++);
 
-  *envitems = uv__calloc(i, sizeof(**envitems));
+  *envitems = (uv_env_item_t*)uv__calloc(i, sizeof(**envitems));
   if (*envitems == NULL) {
     FreeEnvironmentStringsW(env);
     return UV_ENOMEM;
@@ -1281,7 +1282,7 @@ int uv_os_getenv(const char* name, char* buffer, size_t* size) {
       uv__free(var);
 
     varlen = 1 + len;
-    var = uv__malloc(varlen * sizeof(*var));
+    var = (wchar_t*)uv__malloc(varlen * sizeof(*var));
 
     if (var == NULL) {
       r = UV_ENOMEM;
