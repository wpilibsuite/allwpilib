From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Sat, 7 May 2022 22:09:18 -0400
Subject: [PATCH 01/37] Remove StringRef, ArrayRef, and Optional

---
 llvm/include/llvm/ADT/PointerUnion.h          |   1 -
 llvm/include/llvm/ADT/SmallSet.h              |   2 +-
 llvm/include/llvm/ADT/SmallString.h           | 101 ++++++++++--------
 llvm/include/llvm/ADT/SmallVector.h           |   7 +-
 llvm/include/llvm/Support/Chrono.h            |  10 +-
 llvm/include/llvm/Support/Compiler.h          |   2 +-
 llvm/include/llvm/Support/ConvertUTF.h        |  31 +++---
 llvm/include/llvm/Support/ErrorHandling.h     |   9 +-
 .../llvm/Support/SmallVectorMemoryBuffer.h    |   6 +-
 llvm/include/llvm/Support/VersionTuple.h      |   6 --
 .../llvm/Support/Windows/WindowsSupport.h     |   4 +-
 llvm/include/llvm/Support/raw_ostream.h       |  46 ++++----
 llvm/include/llvm/Support/xxhash.h            |  18 ++--
 llvm/lib/Support/ConvertUTFWrapper.cpp        |  38 +++----
 llvm/lib/Support/ErrorHandling.cpp            |  13 ++-
 llvm/lib/Support/SmallVector.cpp              |   5 +-
 llvm/lib/Support/raw_ostream.cpp              |  25 +++--
 llvm/lib/Support/xxhash.cpp                   |  12 +--
 llvm/unittests/ADT/DenseMapTest.cpp           |  29 +----
 llvm/unittests/ADT/FunctionExtrasTest.cpp     |  12 +--
 llvm/unittests/ADT/SmallPtrSetTest.cpp        |   1 -
 llvm/unittests/ADT/SmallStringTest.cpp        |  50 ++++-----
 llvm/unittests/ADT/SmallVectorTest.cpp        |  30 ++----
 llvm/unittests/Support/ConvertUTFTest.cpp     |  41 ++++---
 llvm/unittests/Support/xxhashTest.cpp         |   6 +-
 25 files changed, 232 insertions(+), 273 deletions(-)

diff --git a/llvm/include/llvm/ADT/PointerUnion.h b/llvm/include/llvm/ADT/PointerUnion.h
index 7d4ed02b622626bb8043acb57b8ce7ed97a5f949..8ac68dbc0a791b8ac0e0ca865e69024cb642aa70 100644
--- a/llvm/include/llvm/ADT/PointerUnion.h
+++ b/llvm/include/llvm/ADT/PointerUnion.h
@@ -17,7 +17,6 @@
 
 #include "llvm/ADT/DenseMapInfo.h"
 #include "llvm/ADT/PointerIntPair.h"
-#include "llvm/ADT/STLExtras.h"
 #include "llvm/Support/Casting.h"
 #include "llvm/Support/PointerLikeTypeTraits.h"
 #include <algorithm>
diff --git a/llvm/include/llvm/ADT/SmallSet.h b/llvm/include/llvm/ADT/SmallSet.h
index a16e8ac6f07552d98250e808190b00ee270f12b3..aeee5f97799aea7e7588d7afba1e47b4fa3d8c7b 100644
--- a/llvm/include/llvm/ADT/SmallSet.h
+++ b/llvm/include/llvm/ADT/SmallSet.h
@@ -16,12 +16,12 @@
 
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/iterator.h"
 #include "llvm/Support/Compiler.h"
 #include "llvm/Support/type_traits.h"
 #include <cstddef>
 #include <functional>
+#include <optional>
 #include <set>
 #include <type_traits>
 #include <utility>
diff --git a/llvm/include/llvm/ADT/SmallString.h b/llvm/include/llvm/ADT/SmallString.h
index be3193c6ef9beba622f39e3e76cd0f0c6dd422b0..9fab1a7726bc6745296f5ebb24aee4055408e5f5 100644
--- a/llvm/include/llvm/ADT/SmallString.h
+++ b/llvm/include/llvm/ADT/SmallString.h
@@ -15,8 +15,9 @@
 #define LLVM_ADT_SMALLSTRING_H
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
 #include <cstddef>
+#include <string>
+#include <string_view>
 
 namespace llvm {
 
@@ -28,11 +29,11 @@ public:
   /// Default ctor - Initialize to empty.
   SmallString() = default;
 
-  /// Initialize from a StringRef.
-  SmallString(StringRef S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}
+  /// Initialize from a std::string_view.
+  SmallString(std::string_view S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}
 
-  /// Initialize by concatenating a list of StringRefs.
-  SmallString(std::initializer_list<StringRef> Refs)
+  /// Initialize by concatenating a list of std::string_views.
+  SmallString(std::initializer_list<std::string_view> Refs)
       : SmallVector<char, InternalLen>() {
     this->append(Refs);
   }
@@ -47,13 +48,13 @@ public:
 
   using SmallVector<char, InternalLen>::assign;
 
-  /// Assign from a StringRef.
-  void assign(StringRef RHS) {
+  /// Assign from a std::string_view.
+  void assign(std::string_view RHS) {
     SmallVectorImpl<char>::assign(RHS.begin(), RHS.end());
   }
 
-  /// Assign from a list of StringRefs.
-  void assign(std::initializer_list<StringRef> Refs) {
+  /// Assign from a list of std::string_views.
+  void assign(std::initializer_list<std::string_view> Refs) {
     this->clear();
     append(Refs);
   }
@@ -64,19 +65,19 @@ public:
 
   using SmallVector<char, InternalLen>::append;
 
-  /// Append from a StringRef.
-  void append(StringRef RHS) {
+  /// Append from a std::string_view.
+  void append(std::string_view RHS) {
     SmallVectorImpl<char>::append(RHS.begin(), RHS.end());
   }
 
-  /// Append from a list of StringRefs.
-  void append(std::initializer_list<StringRef> Refs) {
+  /// Append from a list of std::string_views.
+  void append(std::initializer_list<std::string_view> Refs) {
     size_t CurrentSize = this->size();
     size_t SizeNeeded = CurrentSize;
-    for (const StringRef &Ref : Refs)
+    for (const std::string_view &Ref : Refs)
       SizeNeeded += Ref.size();
     this->resize_for_overwrite(SizeNeeded);
-    for (const StringRef &Ref : Refs) {
+    for (const std::string_view &Ref : Refs) {
       std::copy(Ref.begin(), Ref.end(), this->begin() + CurrentSize);
       CurrentSize += Ref.size();
     }
@@ -89,26 +90,28 @@ public:
 
   /// Check for string equality.  This is more efficient than compare() when
   /// the relative ordering of inequal strings isn't needed.
-  [[nodiscard]] bool equals(StringRef RHS) const { return str() == RHS; }
+  [[nodiscard]] bool equals(std::string_view RHS) const { return str() == RHS; }
 
   /// Check for string equality, ignoring case.
-  [[nodiscard]] bool equals_insensitive(StringRef RHS) const {
+  [[nodiscard]] bool equals_insensitive(std::string_view RHS) const {
     return str().equals_insensitive(RHS);
   }
 
   /// compare - Compare two strings; the result is negative, zero, or positive
   /// if this string is lexicographically less than, equal to, or greater than
   /// the \p RHS.
-  [[nodiscard]] int compare(StringRef RHS) const { return str().compare(RHS); }
+  [[nodiscard]] int compare(std::string_view RHS) const {
+    return str().compare(RHS);
+  }
 
   /// compare_insensitive - Compare two strings, ignoring case.
-  [[nodiscard]] int compare_insensitive(StringRef RHS) const {
+  [[nodiscard]] int compare_insensitive(std::string_view RHS) const {
     return str().compare_insensitive(RHS);
   }
 
   /// compare_numeric - Compare two strings, treating sequences of digits as
   /// numbers.
-  [[nodiscard]] int compare_numeric(StringRef RHS) const {
+  [[nodiscard]] int compare_numeric(std::string_view RHS) const {
     return str().compare_numeric(RHS);
   }
 
@@ -116,14 +119,14 @@ public:
   /// @name String Predicates
   /// @{
 
-  /// starts_with - Check if this string starts with the given \p Prefix.
-  [[nodiscard]] bool starts_with(StringRef Prefix) const {
-    return str().starts_with(Prefix);
+  /// startswith - Check if this string starts with the given \p Prefix.
+  [[nodiscard]] bool startswith(std::string_view Prefix) const {
+    return str().startswith(Prefix);
   }
 
-  /// ends_with - Check if this string ends with the given \p Suffix.
-  [[nodiscard]] bool ends_with(StringRef Suffix) const {
-    return str().ends_with(Suffix);
+  /// endswith - Check if this string ends with the given \p Suffix.
+  [[nodiscard]] bool endswith(std::string_view Suffix) const {
+    return str().endswith(Suffix);
   }
 
   /// @}
@@ -142,7 +145,7 @@ public:
   ///
   /// \returns The index of the first occurrence of \p Str, or npos if not
   /// found.
-  [[nodiscard]] size_t find(StringRef Str, size_t From = 0) const {
+  [[nodiscard]] size_t find(std::string_view Str, size_t From = 0) const {
     return str().find(Str, From);
   }
 
@@ -150,7 +153,8 @@ public:
   ///
   /// \returns The index of the last occurrence of \p C, or npos if not
   /// found.
-  [[nodiscard]] size_t rfind(char C, size_t From = StringRef::npos) const {
+  [[nodiscard]] size_t rfind(char C,
+                             size_t From = std::string_view::npos) const {
     return str().rfind(C, From);
   }
 
@@ -158,7 +162,9 @@ public:
   ///
   /// \returns The index of the last occurrence of \p Str, or npos if not
   /// found.
-  [[nodiscard]] size_t rfind(StringRef Str) const { return str().rfind(Str); }
+  [[nodiscard]] size_t rfind(std::string_view Str) const {
+    return str().rfind(Str);
+  }
 
   /// Find the first character in the string that is \p C, or npos if not
   /// found. Same as find.
@@ -170,7 +176,8 @@ public:
   /// not found.
   ///
   /// Complexity: O(size() + Chars.size())
-  [[nodiscard]] size_t find_first_of(StringRef Chars, size_t From = 0) const {
+  [[nodiscard]] size_t find_first_of(std::string_view Chars,
+                                     size_t From = 0) const {
     return str().find_first_of(Chars, From);
   }
 
@@ -184,15 +191,15 @@ public:
   /// \p Chars, or npos if not found.
   ///
   /// Complexity: O(size() + Chars.size())
-  [[nodiscard]] size_t find_first_not_of(StringRef Chars,
+  [[nodiscard]] size_t find_first_not_of(std::string_view Chars,
                                          size_t From = 0) const {
     return str().find_first_not_of(Chars, From);
   }
 
   /// Find the last character in the string that is \p C, or npos if not
   /// found.
-  [[nodiscard]] size_t find_last_of(char C,
-                                    size_t From = StringRef::npos) const {
+  [[nodiscard]] size_t find_last_of(
+      char C, size_t From = std::string_view::npos) const {
     return str().find_last_of(C, From);
   }
 
@@ -200,8 +207,8 @@ public:
   /// found.
   ///
   /// Complexity: O(size() + Chars.size())
-  [[nodiscard]] size_t find_last_of(StringRef Chars,
-                                    size_t From = StringRef::npos) const {
+  [[nodiscard]] size_t find_last_of(
+      std::string_view Chars, size_t From = std::string_view::npos) const {
     return str().find_last_of(Chars, From);
   }
 
@@ -214,7 +221,9 @@ public:
 
   /// Return the number of non-overlapped occurrences of \p Str in the
   /// string.
-  [[nodiscard]] size_t count(StringRef Str) const { return str().count(Str); }
+  [[nodiscard]] size_t count(std::string_view Str) const {
+    return str().count(Str);
+  }
 
   /// @}
   /// @name Substring Operations
@@ -229,8 +238,8 @@ public:
   /// \param N The number of characters to included in the substring. If \p N
   /// exceeds the number of characters remaining in the string, the string
   /// suffix (starting with \p Start) will be returned.
-  [[nodiscard]] StringRef substr(size_t Start,
-                                 size_t N = StringRef::npos) const {
+  [[nodiscard]] std::string_view substr(
+      size_t Start, size_t N = std::string_view::npos) const {
     return str().substr(Start, N);
   }
 
@@ -244,15 +253,15 @@ public:
   /// substring. If this is npos, or less than \p Start, or exceeds the
   /// number of characters remaining in the string, the string suffix
   /// (starting with \p Start) will be returned.
-  [[nodiscard]] StringRef slice(size_t Start, size_t End) const {
+  [[nodiscard]] std::string_view slice(size_t Start, size_t End) const {
     return str().slice(Start, End);
   }
 
   // Extra methods.
 
-  /// Explicit conversion to StringRef.
-  [[nodiscard]] StringRef str() const {
-    return StringRef(this->data(), this->size());
+  /// Explicit conversion to std::string_view.
+  [[nodiscard]] std::string_view str() const {
+    return std::string_view(this->begin(), this->size());
   }
 
   // TODO: Make this const, if it's safe...
@@ -262,20 +271,20 @@ public:
     return this->data();
   }
 
-  /// Implicit conversion to StringRef.
-  operator StringRef() const { return str(); }
+  /// Implicit conversion to std::string_view.
+  operator std::string_view() const { return str(); }
 
   explicit operator std::string() const {
     return std::string(this->data(), this->size());
   }
 
   // Extra operators.
-  SmallString &operator=(StringRef RHS) {
+  SmallString &operator=(std::string_view RHS) {
     this->assign(RHS);
     return *this;
   }
 
-  SmallString &operator+=(StringRef RHS) {
+  SmallString &operator+=(std::string_view RHS) {
     this->append(RHS.begin(), RHS.end());
     return *this;
   }
diff --git a/llvm/include/llvm/ADT/SmallVector.h b/llvm/include/llvm/ADT/SmallVector.h
index 17444147b102a9636fe4f0f48cfb647aaaf3ed6b..94d8da059f4f8bad50039b0d0b7993396707829c 100644
--- a/llvm/include/llvm/ADT/SmallVector.h
+++ b/llvm/include/llvm/ADT/SmallVector.h
@@ -28,13 +28,12 @@
 #include <limits>
 #include <memory>
 #include <new>
+#include <span>
 #include <type_traits>
 #include <utility>
 
 namespace llvm {
 
-template <typename T> class ArrayRef;
-
 template <typename IteratorT> class iterator_range;
 
 template <class Iterator>
@@ -128,7 +127,7 @@ template <class T, typename = void> struct SmallVectorAlignmentAndSize {
 };
 
 /// This is the part of SmallVectorTemplateBase which does not depend on whether
-/// the type T is a POD. The extra dummy template argument is used by ArrayRef
+/// the type T is a POD. The extra dummy template argument is used by span
 /// to avoid unnecessarily requiring T to be complete.
 template <typename T, typename = void>
 class SmallVectorTemplateCommon
@@ -1243,7 +1242,7 @@ public:
 
   template <typename U,
             typename = std::enable_if_t<std::is_convertible<U, T>::value>>
-  explicit SmallVector(ArrayRef<U> A) : SmallVectorImpl<T>(N) {
+  explicit SmallVector(span<const U> A) : SmallVectorImpl<T>(N) {
     this->append(A.begin(), A.end());
   }
 
diff --git a/llvm/include/llvm/Support/Chrono.h b/llvm/include/llvm/Support/Chrono.h
index 71859af7c7e4a595140475daf356744f52d14d24..9c9ba7002310eba5113c14957f769702c61f4326 100644
--- a/llvm/include/llvm/Support/Chrono.h
+++ b/llvm/include/llvm/Support/Chrono.h
@@ -91,7 +91,7 @@ raw_ostream &operator<<(raw_ostream &OS, sys::UtcTime<> TP);
 template <>
 struct format_provider<sys::TimePoint<>> {
   static void format(const sys::TimePoint<> &TP, llvm::raw_ostream &OS,
-                     StringRef Style);
+                     std::string_view Style);
 };
 
 template <> struct format_provider<sys::UtcTime<std::chrono::seconds>> {
@@ -148,7 +148,7 @@ private:
     return duration_cast<duration<InternalRep, AsPeriod>>(D).count();
   }
 
-  static std::pair<InternalRep, StringRef> consumeUnit(StringRef &Style,
+  static std::pair<InternalRep, std::string_view> consumeUnit(std::string_view &Style,
                                                         const Dur &D) {
     using namespace std::chrono;
     if (Style.consume_front("ns"))
@@ -166,7 +166,7 @@ private:
     return {D.count(), detail::unit<Period>::value};
   }
 
-  static bool consumeShowUnit(StringRef &Style) {
+  static bool consumeShowUnit(std::string_view &Style) {
     if (Style.empty())
       return true;
     if (Style.consume_front("-"))
@@ -178,9 +178,9 @@ private:
   }
 
 public:
-  static void format(const Dur &D, llvm::raw_ostream &Stream, StringRef Style) {
+  static void format(const Dur &D, llvm::raw_ostream &Stream, std::string_view Style) {
     InternalRep count;
-    StringRef unit;
+    std::string_view unit;
     std::tie(count, unit) = consumeUnit(Style, D);
     bool show_unit = consumeShowUnit(Style);
 
diff --git a/llvm/include/llvm/Support/Compiler.h b/llvm/include/llvm/Support/Compiler.h
index d8e3794babc7449b436fa1d0bd858dab5198664b..7710bd9a08148289b5ba3b1f2dae5cccc4f26d4d 100644
--- a/llvm/include/llvm/Support/Compiler.h
+++ b/llvm/include/llvm/Support/Compiler.h
@@ -327,7 +327,7 @@
 #endif
 
 /// LLVM_GSL_POINTER - Apply this to non-owning classes like
-/// StringRef to enable lifetime warnings.
+/// std::string_view to enable lifetime warnings.
 #if LLVM_HAS_CPP_ATTRIBUTE(gsl::Pointer)
 #define LLVM_GSL_POINTER [[gsl::Pointer]]
 #else
diff --git a/llvm/include/llvm/Support/ConvertUTF.h b/llvm/include/llvm/Support/ConvertUTF.h
index c892bb3c03cb569994429649bdbb96e4118dcef1..5c0e3009c25446a34882fb98329b1d955231bb39 100644
--- a/llvm/include/llvm/Support/ConvertUTF.h
+++ b/llvm/include/llvm/Support/ConvertUTF.h
@@ -107,10 +107,9 @@
 
 #include <cstddef>
 #include <string>
-
-#if defined(_WIN32)
+#include <span>
+#include <string_view>
 #include <system_error>
-#endif
 
 // Wrap everything in namespace llvm so that programs can link with llvm and
 // their own version of the unicode libraries.
@@ -204,12 +203,10 @@ unsigned getNumBytesForUTF8(UTF8 firstByte);
 /*************************************************************************/
 /* Below are LLVM-specific wrappers of the functions above. */
 
-template <typename T> class ArrayRef;
 template <typename T> class SmallVectorImpl;
-class StringRef;
 
 /**
- * Convert an UTF8 StringRef to UTF8, UTF16, or UTF32 depending on
+ * Convert an UTF8 string_view to UTF8, UTF16, or UTF32 depending on
  * WideCharWidth. The converted data is written to ResultPtr, which needs to
  * point to at least WideCharWidth * (Source.Size() + 1) bytes. On success,
  * ResultPtr will point one after the end of the copied string. On failure,
@@ -217,14 +214,14 @@ class StringRef;
  * the first character which could not be converted.
  * \return true on success.
  */
-bool ConvertUTF8toWide(unsigned WideCharWidth, llvm::StringRef Source,
+bool ConvertUTF8toWide(unsigned WideCharWidth, std::string_view Source,
                        char *&ResultPtr, const UTF8 *&ErrorPtr);
 
 /**
-* Converts a UTF-8 StringRef to a std::wstring.
+* Converts a UTF-8 string_view to a std::wstring.
 * \return true on success.
 */
-bool ConvertUTF8toWide(llvm::StringRef Source, std::wstring &Result);
+bool ConvertUTF8toWide(std::string_view Source, std::wstring &Result);
 
 /**
 * Converts a UTF-8 C-string to a std::wstring.
@@ -282,7 +279,7 @@ inline ConversionResult convertUTF8Sequence(const UTF8 **source,
  * Returns true if a blob of text starts with a UTF-16 big or little endian byte
  * order mark.
  */
-bool hasUTF16ByteOrderMark(ArrayRef<char> SrcBytes);
+bool hasUTF16ByteOrderMark(span<const char> SrcBytes);
 
 /**
  * Converts a stream of raw bytes assumed to be UTF16 into a UTF8 std::string.
@@ -291,7 +288,7 @@ bool hasUTF16ByteOrderMark(ArrayRef<char> SrcBytes);
  * \param [out] Out Converted UTF-8 is stored here on success.
  * \returns true on success
  */
-bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
+bool convertUTF16ToUTF8String(span<const char> SrcBytes, std::string &Out);
 
 /**
 * Converts a UTF16 string into a UTF8 std::string.
@@ -300,7 +297,7 @@ bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
 * \param [out] Out Converted UTF-8 is stored here on success.
 * \returns true on success
 */
-bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out);
+bool convertUTF16ToUTF8String(span<const UTF16> Src, std::string &Out);
 
 /**
  * Converts a stream of raw bytes assumed to be UTF32 into a UTF8 std::string.
@@ -309,7 +306,7 @@ bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out);
  * \param [out] Out Converted UTF-8 is stored here on success.
  * \returns true on success
  */
-bool convertUTF32ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
+bool convertUTF32ToUTF8String(span<const char> SrcBytes, std::string &Out);
 
 /**
  * Converts a UTF32 string into a UTF8 std::string.
@@ -318,22 +315,22 @@ bool convertUTF32ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
  * \param [out] Out Converted UTF-8 is stored here on success.
  * \returns true on success
  */
-bool convertUTF32ToUTF8String(ArrayRef<UTF32> Src, std::string &Out);
+bool convertUTF32ToUTF8String(span<const UTF32> Src, std::string &Out);
 
 /**
  * Converts a UTF-8 string into a UTF-16 string with native endianness.
  *
  * \returns true on success
  */
-bool convertUTF8ToUTF16String(StringRef SrcUTF8,
+bool convertUTF8ToUTF16String(std::string_view SrcUTF8,
                               SmallVectorImpl<UTF16> &DstUTF16);
 
 #if defined(_WIN32)
 namespace sys {
 namespace windows {
-std::error_code UTF8ToUTF16(StringRef utf8, SmallVectorImpl<wchar_t> &utf16);
+std::error_code UTF8ToUTF16(std::string_view utf8, SmallVectorImpl<wchar_t> &utf16);
 /// Convert to UTF16 from the current code page used in the system
-std::error_code CurCPToUTF16(StringRef utf8, SmallVectorImpl<wchar_t> &utf16);
+std::error_code CurCPToUTF16(std::string_view utf8, SmallVectorImpl<wchar_t> &utf16);
 std::error_code UTF16ToUTF8(const wchar_t *utf16, size_t utf16_len,
                             SmallVectorImpl<char> &utf8);
 /// Convert from UTF16 to the current code page used in the system
diff --git a/llvm/include/llvm/Support/ErrorHandling.h b/llvm/include/llvm/Support/ErrorHandling.h
index 9c8e3448f3a03e3540adb8b9dd730c77dd9b20ba..68c27a8c67c4f378b92cfa726659ef7824b56dea 100644
--- a/llvm/include/llvm/Support/ErrorHandling.h
+++ b/llvm/include/llvm/Support/ErrorHandling.h
@@ -15,10 +15,10 @@
 #define LLVM_SUPPORT_ERRORHANDLING_H
 
 #include "llvm/Support/Compiler.h"
+#include <string>
+#include <string_view>
 
 namespace llvm {
-  class StringRef;
-  class Twine;
 
   /// An error handler callback.
   typedef void (*fatal_error_handler_t)(void *user_data,
@@ -67,12 +67,11 @@ namespace llvm {
 /// standard error, followed by a newline.
 /// After the error handler is called this function will call abort(), it
 /// does not return.
-/// NOTE: The std::string variant was removed to avoid a <string> dependency.
 [[noreturn]] void report_fatal_error(const char *reason,
                                      bool gen_crash_diag = true);
-[[noreturn]] void report_fatal_error(StringRef reason,
+[[noreturn]] void report_fatal_error(const std::string &reason,
                                      bool gen_crash_diag = true);
-[[noreturn]] void report_fatal_error(const Twine &reason,
+[[noreturn]] void report_fatal_error(std::string_view reason,
                                      bool gen_crash_diag = true);
 
 /// Installs a new bad alloc error handler that should be used whenever a
diff --git a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
index f7f2d4e54e705d6f29812dc93d1fb0a3ca2dee12..b5e321b5f74ce35940649b9d1342b3cdf0c4931f 100644
--- a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
+++ b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
@@ -35,8 +35,8 @@ public:
                                 RequiresNullTerminator) {}
 
   /// Construct a named SmallVectorMemoryBuffer from the given SmallVector
-  /// r-value and StringRef.
-  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, StringRef Name,
+  /// r-value and std::string_view.
+  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, std::string_view Name,
                           bool RequiresNullTerminator = true)
       : SV(std::move(SV)), BufferName(std::string(Name)) {
     if (RequiresNullTerminator) {
@@ -49,7 +49,7 @@ public:
   // Key function.
   ~SmallVectorMemoryBuffer() override;
 
-  StringRef getBufferIdentifier() const override { return BufferName; }
+  std::string_view getBufferIdentifier() const override { return BufferName; }
 
   BufferKind getBufferKind() const override { return MemoryBuffer_Malloc; }
 
diff --git a/llvm/include/llvm/Support/VersionTuple.h b/llvm/include/llvm/Support/VersionTuple.h
index 0a4623f049d28825530bf50c8acfe85deaed96ba..e1cdce77ce8659305c99a21e01f9b3cc3481a5fd 100644
--- a/llvm/include/llvm/Support/VersionTuple.h
+++ b/llvm/include/llvm/Support/VersionTuple.h
@@ -23,7 +23,6 @@
 namespace llvm {
 template <typename HasherT, llvm::endianness Endianness> class HashBuilder;
 class raw_ostream;
-class StringRef;
 
 /// Represents a version number in the form major[.minor[.subminor[.build]]].
 class VersionTuple {
@@ -180,11 +179,6 @@ public:
 
   /// Retrieve a string representation of the version number.
   std::string getAsString() const;
-
-  /// Try to parse the given string as a version number.
-  /// \returns \c true if the string does not match the regular expression
-  ///   [0-9]+(\.[0-9]+){0,3}
-  bool tryParse(StringRef string);
 };
 
 /// Print a version number.
diff --git a/llvm/include/llvm/Support/Windows/WindowsSupport.h b/llvm/include/llvm/Support/Windows/WindowsSupport.h
index d3aacd14b2097b1e7e13c1003987c1fd52e0cf76..aabdb2f14668a990329b57f5454a0d7db73e12ce 100644
--- a/llvm/include/llvm/Support/Windows/WindowsSupport.h
+++ b/llvm/include/llvm/Support/Windows/WindowsSupport.h
@@ -35,8 +35,6 @@
 
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringExtras.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Config/llvm-config.h" // Get build system configuration settings
 #include "llvm/Support/Allocator.h"
 #include "llvm/Support/Chrono.h"
@@ -74,7 +72,7 @@ bool MakeErrMsg(std::string *ErrMsg, const std::string &prefix);
 [[noreturn]] inline void ReportLastErrorFatal(const char *Msg) {
   std::string ErrMsg;
   MakeErrMsg(&ErrMsg, Msg);
-  llvm::report_fatal_error(Twine(ErrMsg));
+  llvm::report_fatal_error(ErrMsg);
 }
 
 template <typename HandleTraits>
diff --git a/llvm/include/llvm/Support/raw_ostream.h b/llvm/include/llvm/Support/raw_ostream.h
index df9ee2e5a78586d2a2e0eb6e0698953169f7bc58..18bdf4b7d3b96d42d93ca1e4800233b34be42a78 100644
--- a/llvm/include/llvm/Support/raw_ostream.h
+++ b/llvm/include/llvm/Support/raw_ostream.h
@@ -14,13 +14,12 @@
 #define LLVM_SUPPORT_RAW_OSTREAM_H
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/Support/DataTypes.h"
 #include <cassert>
 #include <cstddef>
 #include <cstdint>
 #include <cstring>
 #include <optional>
+#include <span>
 #include <string>
 #include <string_view>
 #include <system_error>
@@ -221,7 +220,22 @@ public:
     return *this;
   }
 
-  raw_ostream &operator<<(StringRef Str) {
+  raw_ostream &operator<<(span<const uint8_t> Arr) {
+    // Inline fast path, particularly for arrays with a known length.
+    size_t Size = Arr.size();
+
+    // Make sure we can use the fast path.
+    if (Size > (size_t)(OutBufEnd - OutBufCur))
+      return write(Arr.data(), Size);
+
+    if (Size) {
+      memcpy(OutBufCur, Arr.data(), Size);
+      OutBufCur += Size;
+    }
+    return *this;
+  }
+
+  raw_ostream &operator<<(std::string_view Str) {
     // Inline fast path, particularly for strings with a known length.
     size_t Size = Str.size();
 
@@ -254,7 +268,7 @@ public:
     // Inline fast path, particularly for constant strings where a sufficiently
     // smart compiler will simplify strlen.
 
-    return this->operator<<(StringRef(Str));
+    return this->operator<<(std::string_view(Str));
   }
 
   raw_ostream &operator<<(const std::string &Str) {
@@ -262,10 +276,6 @@ public:
     return write(Str.data(), Str.length());
   }
 
-  raw_ostream &operator<<(const std::string_view &Str) {
-    return write(Str.data(), Str.length());
-  }
-
   raw_ostream &operator<<(const SmallVectorImpl<char> &Str) {
     return write(Str.data(), Str.size());
   }
@@ -298,7 +308,7 @@ public:
 
   /// Output \p Str, turning '\\', '\t', '\n', '"', and anything that doesn't
   /// satisfy llvm::isPrint into an escape sequence.
-  raw_ostream &write_escaped(StringRef Str, bool UseHexEscapes = false);
+  raw_ostream &write_escaped(std::string_view Str, bool UseHexEscapes = false);
 
   raw_ostream &write(unsigned char C);
   raw_ostream &write(const char *Ptr, size_t Size);
@@ -511,14 +521,14 @@ public:
   /// As a special case, if Filename is "-", then the stream will use
   /// STDOUT_FILENO instead of opening a file. This will not close the stdout
   /// descriptor.
-  raw_fd_ostream(StringRef Filename, std::error_code &EC);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC);
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::FileAccess Access);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::OpenFlags Flags);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                  sys::fs::OpenFlags Flags);
 
@@ -630,7 +640,7 @@ public:
   /// Open the specified file for reading/writing/seeking. If an error occurs,
   /// information about the error is put into EC, and the stream should be
   /// immediately destroyed.
-  raw_fd_stream(StringRef Filename, std::error_code &EC);
+  raw_fd_stream(std::string_view Filename, std::error_code &EC);
 
   raw_fd_stream(int fd, bool shouldClose);
 
@@ -716,8 +726,8 @@ public:
 
   void flush() = delete;
 
-  /// Return a StringRef for the vector contents.
-  StringRef str() const { return StringRef(OS.data(), OS.size()); }
+  /// Return a std::string_view for the vector contents.
+  std::string_view str() const { return std::string_view(OS.data(), OS.size()); }
   SmallVectorImpl<char> &buffer() { return OS; }
 
   void reserveExtraSpace(uint64_t ExtraSize) override {
@@ -777,7 +787,7 @@ class Error;
 /// for other names. For raw_fd_ostream instances, the stream writes to
 /// a temporary file. The final output file is atomically replaced with the
 /// temporary file after the \p Write function is finished.
-Error writeToOutput(StringRef OutputFileName,
+Error writeToOutput(std::string_view OutputFileName,
                     std::function<Error(raw_ostream &)> Write);
 
 raw_ostream &operator<<(raw_ostream &OS, std::nullopt_t);
diff --git a/llvm/include/llvm/Support/xxhash.h b/llvm/include/llvm/Support/xxhash.h
index 5f8a7ab360abe24e86286b2bd6b83df7ca5fa7d3..5267e22a45f6c0c6e3bc9ca1966ed9842772918e 100644
--- a/llvm/include/llvm/Support/xxhash.h
+++ b/llvm/include/llvm/Support/xxhash.h
@@ -38,17 +38,19 @@
 #ifndef LLVM_SUPPORT_XXHASH_H
 #define LLVM_SUPPORT_XXHASH_H
 
-#include "llvm/ADT/ArrayRef.h"
-#include "llvm/ADT/StringRef.h"
+#include <stdint.h>
+
+#include <span>
+#include <string_view>
 
 namespace llvm {
 
-uint64_t xxHash64(llvm::StringRef Data);
-uint64_t xxHash64(llvm::ArrayRef<uint8_t> Data);
+uint64_t xxHash64(std::string_view Data);
+uint64_t xxHash64(span<const uint8_t> Data);
 
-uint64_t xxh3_64bits(ArrayRef<uint8_t> data);
-inline uint64_t xxh3_64bits(StringRef data) {
-  return xxh3_64bits(ArrayRef(data.bytes_begin(), data.size()));
+uint64_t xxh3_64bits(span<const uint8_t> data);
+inline uint64_t xxh3_64bits(std::string_view data) {
+  return xxh3_64bits(span(reinterpret_cast<const uint8_t*>(data.data()), data.size()));
 }
 
 /*-**********************************************************************
@@ -72,7 +74,7 @@ struct XXH128_hash_t {
 };
 
 /// XXH3's 128-bit variant.
-XXH128_hash_t xxh3_128bits(ArrayRef<uint8_t> data);
+XXH128_hash_t xxh3_128bits(span<const uint8_t> data);
 
 } // namespace llvm
 
diff --git a/llvm/lib/Support/ConvertUTFWrapper.cpp b/llvm/lib/Support/ConvertUTFWrapper.cpp
index 3fa7365e72d34a5db941d1cbe2b1beebad5c10e6..d53462e742e61d3476915d5b2c5aa63772e78a8a 100644
--- a/llvm/lib/Support/ConvertUTFWrapper.cpp
+++ b/llvm/lib/Support/ConvertUTFWrapper.cpp
@@ -6,24 +6,24 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "llvm/ADT/ArrayRef.h"
-#include "llvm/ADT/StringRef.h"
 #include "llvm/Support/ConvertUTF.h"
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/SwapByteOrder.h"
+#include <span>
 #include <string>
+#include <string_view>
 #include <vector>
 
 namespace llvm {
 
-bool ConvertUTF8toWide(unsigned WideCharWidth, llvm::StringRef Source,
+bool ConvertUTF8toWide(unsigned WideCharWidth, std::string_view Source,
                        char *&ResultPtr, const UTF8 *&ErrorPtr) {
   assert(WideCharWidth == 1 || WideCharWidth == 2 || WideCharWidth == 4);
   ConversionResult result = conversionOK;
   // Copy the character span over.
   if (WideCharWidth == 1) {
-    const UTF8 *Pos = reinterpret_cast<const UTF8*>(Source.begin());
-    if (!isLegalUTF8String(&Pos, reinterpret_cast<const UTF8*>(Source.end()))) {
+    const UTF8 *Pos = reinterpret_cast<const UTF8*>(Source.data());
+    if (!isLegalUTF8String(&Pos, reinterpret_cast<const UTF8*>(Source.data() + Source.size()))) {
       result = sourceIllegal;
       ErrorPtr = Pos;
     } else {
@@ -76,12 +76,12 @@ bool ConvertCodePointToUTF8(unsigned Source, char *&ResultPtr) {
   return true;
 }
 
-bool hasUTF16ByteOrderMark(ArrayRef<char> S) {
+bool hasUTF16ByteOrderMark(span<const char> S) {
   return (S.size() >= 2 && ((S[0] == '\xff' && S[1] == '\xfe') ||
                             (S[0] == '\xfe' && S[1] == '\xff')));
 }
 
-bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
+bool convertUTF16ToUTF8String(span<const char> SrcBytes, std::string &Out) {
   assert(Out.empty());
 
   // Error out on an uneven byte count.
@@ -132,14 +132,14 @@ bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
   return true;
 }
 
-bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out) {
+bool convertUTF16ToUTF8String(span<const UTF16> Src, std::string &Out) {
   return convertUTF16ToUTF8String(
-      llvm::ArrayRef<char>(reinterpret_cast<const char *>(Src.data()),
+      span<const char>(reinterpret_cast<const char *>(Src.data()),
                            Src.size() * sizeof(UTF16)),
       Out);
 }
 
-bool convertUTF32ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
+bool convertUTF32ToUTF8String(span<const char> SrcBytes, std::string &Out) {
   assert(Out.empty());
 
   // Error out on an uneven byte count.
@@ -190,14 +190,14 @@ bool convertUTF32ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
   return true;
 }
 
-bool convertUTF32ToUTF8String(ArrayRef<UTF32> Src, std::string &Out) {
+bool convertUTF32ToUTF8String(span<const UTF32> Src, std::string &Out) {
   return convertUTF32ToUTF8String(
-      llvm::ArrayRef<char>(reinterpret_cast<const char *>(Src.data()),
+      span<const char>(reinterpret_cast<const char *>(Src.data()),
                            Src.size() * sizeof(UTF32)),
       Out);
 }
 
-bool convertUTF8ToUTF16String(StringRef SrcUTF8,
+bool convertUTF8ToUTF16String(std::string_view SrcUTF8,
                               SmallVectorImpl<UTF16> &DstUTF16) {
   assert(DstUTF16.empty());
 
@@ -208,8 +208,8 @@ bool convertUTF8ToUTF16String(StringRef SrcUTF8,
     return true;
   }
 
-  const UTF8 *Src = reinterpret_cast<const UTF8 *>(SrcUTF8.begin());
-  const UTF8 *SrcEnd = reinterpret_cast<const UTF8 *>(SrcUTF8.end());
+  const UTF8 *Src = reinterpret_cast<const UTF8 *>(SrcUTF8.data());
+  const UTF8 *SrcEnd = reinterpret_cast<const UTF8 *>(SrcUTF8.data() + SrcUTF8.size());
 
   // Allocate the same number of UTF-16 code units as UTF-8 code units. Encoding
   // as UTF-16 should always require the same amount or less code units than the
@@ -240,7 +240,7 @@ static_assert(sizeof(wchar_t) == 1 || sizeof(wchar_t) == 2 ||
               "Expected wchar_t to be 1, 2, or 4 bytes");
 
 template <typename TResult>
-static inline bool ConvertUTF8toWideInternal(llvm::StringRef Source,
+static inline bool ConvertUTF8toWideInternal(std::string_view Source,
                                              TResult &Result) {
   // Even in the case of UTF-16, the number of bytes in a UTF-8 string is
   // at least as large as the number of elements in the resulting wide
@@ -256,7 +256,7 @@ static inline bool ConvertUTF8toWideInternal(llvm::StringRef Source,
   return true;
 }
 
-bool ConvertUTF8toWide(llvm::StringRef Source, std::wstring &Result) {
+bool ConvertUTF8toWide(std::string_view Source, std::wstring &Result) {
   return ConvertUTF8toWideInternal(Source, Result);
 }
 
@@ -265,7 +265,7 @@ bool ConvertUTF8toWide(const char *Source, std::wstring &Result) {
     Result.clear();
     return true;
   }
-  return ConvertUTF8toWide(llvm::StringRef(Source), Result);
+  return ConvertUTF8toWide(std::string_view(Source), Result);
 }
 
 bool convertWideToUTF8(const std::wstring &Source, std::string &Result) {
@@ -280,7 +280,7 @@ bool convertWideToUTF8(const std::wstring &Source, std::string &Result) {
     return true;
   } else if (sizeof(wchar_t) == 2) {
     return convertUTF16ToUTF8String(
-        llvm::ArrayRef<UTF16>(reinterpret_cast<const UTF16 *>(Source.data()),
+        span<const UTF16>(reinterpret_cast<const UTF16 *>(Source.data()),
                               Source.size()),
         Result);
   } else if (sizeof(wchar_t) == 4) {
diff --git a/llvm/lib/Support/ErrorHandling.cpp b/llvm/lib/Support/ErrorHandling.cpp
index cb42e28c04a86dd60deae6fdb0b87850c1bf3727..561509e0efdf15f6e534f0621a5964d92511114c 100644
--- a/llvm/lib/Support/ErrorHandling.cpp
+++ b/llvm/lib/Support/ErrorHandling.cpp
@@ -14,7 +14,6 @@
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm-c/ErrorHandling.h"
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Config/config.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/Errc.h"
@@ -80,14 +79,14 @@ void llvm::remove_fatal_error_handler() {
 }
 
 void llvm::report_fatal_error(const char *Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
+  report_fatal_error(std::string_view(Reason), GenCrashDiag);
 }
 
-void llvm::report_fatal_error(StringRef Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
+void llvm::report_fatal_error(const std::string &Reason, bool GenCrashDiag) {
+  report_fatal_error(std::string_view(Reason), GenCrashDiag);
 }
 
-void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
+void llvm::report_fatal_error(std::string_view Reason, bool GenCrashDiag) {
   llvm::fatal_error_handler_t handler = nullptr;
   void* handlerData = nullptr;
   {
@@ -101,7 +100,7 @@ void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
   }
 
   if (handler) {
-    handler(handlerData, Reason.str().c_str(), GenCrashDiag);
+    handler(handlerData, std::string{Reason}.c_str(), GenCrashDiag);
   } else {
     // Blast the result out to stderr.  We don't try hard to make sure this
     // succeeds (e.g. handling EINTR) and we can't use errs() here because
@@ -109,7 +108,7 @@ void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
     SmallVector<char, 64> Buffer;
     raw_svector_ostream OS(Buffer);
     OS << "LLVM ERROR: " << Reason << "\n";
-    StringRef MessageStr = OS.str();
+    std::string_view MessageStr = OS.str();
     ssize_t written = ::write(2, MessageStr.data(), MessageStr.size());
     (void)written; // If something went wrong, we deliberately just give up.
   }
diff --git a/llvm/lib/Support/SmallVector.cpp b/llvm/lib/Support/SmallVector.cpp
index b6ce37842040b36fc79770ca0296255f2bb42a1a..4f6fee18b659adcbfd79822832f914170cbb1635 100644
--- a/llvm/lib/Support/SmallVector.cpp
+++ b/llvm/lib/Support/SmallVector.cpp
@@ -11,7 +11,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Support/MemAlloc.h"
 #include <cstdint>
 #ifdef LLVM_ENABLE_EXCEPTIONS
@@ -67,7 +66,7 @@ static void report_size_overflow(size_t MinSize, size_t MaxSize) {
 #ifdef LLVM_ENABLE_EXCEPTIONS
   throw std::length_error(Reason);
 #else
-  report_fatal_error(Twine(Reason));
+  report_fatal_error(Reason);
 #endif
 }
 
@@ -81,7 +80,7 @@ static void report_at_maximum_capacity(size_t MaxSize) {
 #ifdef LLVM_ENABLE_EXCEPTIONS
   throw std::length_error(Reason);
 #else
-  report_fatal_error(Twine(Reason));
+  report_fatal_error(Reason);
 #endif
 }
 
diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
index 2ce54faa9857e68d9c7de4ad28f6cfa5bae86908..2dbb0674406e1860fdd0c266df64003e45b12fa3 100644
--- a/llvm/lib/Support/raw_ostream.cpp
+++ b/llvm/lib/Support/raw_ostream.cpp
@@ -167,7 +167,7 @@ raw_ostream &raw_ostream::write_uuid(const uuid_t UUID) {
 }
 
 
-raw_ostream &raw_ostream::write_escaped(StringRef Str,
+raw_ostream &raw_ostream::write_escaped(std::string_view Str,
                                         bool UseHexEscapes) {
   for (unsigned char c : Str) {
     switch (c) {
@@ -564,7 +564,7 @@ void format_object_base::home() {
 //  raw_fd_ostream
 //===----------------------------------------------------------------------===//
 
-static int getFD(StringRef Filename, std::error_code &EC,
+static int getFD(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                  sys::fs::OpenFlags Flags) {
   assert((Access & sys::fs::FA_Write) &&
@@ -590,25 +590,25 @@ static int getFD(StringRef Filename, std::error_code &EC,
   return FD;
 }
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC)
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, sys::fs::FA_Write,
                      sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::CreationDisposition Disp)
     : raw_fd_ostream(Filename, EC, Disp, sys::fs::FA_Write, sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::FileAccess Access)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, Access,
                      sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::OpenFlags Flags)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, sys::fs::FA_Write,
                      Flags) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::CreationDisposition Disp,
                                sys::fs::FileAccess Access,
                                sys::fs::OpenFlags Flags)
@@ -680,8 +680,7 @@ raw_fd_ostream::~raw_fd_ostream() {
   // has_error() and clear the error flag with clear_error() before
   // destructing raw_ostream objects which may have errors.
   if (has_error())
-    report_fatal_error(Twine("IO failure on output stream: ") +
-                           error().message(),
+    report_fatal_error("IO failure on output stream: " + error().message(),
                        /*gen_crash_diag=*/false);
 }
 
@@ -700,7 +699,7 @@ raw_fd_ostream::~raw_fd_ostream() {
 // the input is UTF-8 or transcode from the local codepage to UTF-8 before
 // quoting it. If they don't, this may mess up the encoding, but this is still
 // probably the best compromise we can make.
-static bool write_console_impl(int FD, StringRef Data) {
+static bool write_console_impl(int FD, std::string_view Data) {
   SmallVector<wchar_t, 256> WideText;
 
   // Fall back to ::write if it wasn't valid UTF-8.
@@ -746,7 +745,7 @@ void raw_fd_ostream::write_impl(const char *Ptr, size_t Size) {
   // If this is a Windows console device, try re-encoding from UTF-8 to UTF-16
   // and using WriteConsoleW. If that fails, fall back to plain write().
   if (IsWindowsConsole)
-    if (write_console_impl(FD, StringRef(Ptr, Size)))
+    if (write_console_impl(FD, std::string_view(Ptr, Size)))
       return;
 #endif
 
@@ -922,7 +921,7 @@ raw_ostream &llvm::nulls() {
 // File Streams
 //===----------------------------------------------------------------------===//
 
-raw_fd_stream::raw_fd_stream(StringRef Filename, std::error_code &EC)
+raw_fd_stream::raw_fd_stream(std::string_view Filename, std::error_code &EC)
     : raw_fd_ostream(getFD(Filename, EC, sys::fs::CD_CreateAlways,
                            sys::fs::FA_Write | sys::fs::FA_Read,
                            sys::fs::OF_None),
@@ -1007,7 +1006,7 @@ void buffer_ostream::anchor() {}
 
 void buffer_unique_ostream::anchor() {}
 
-Error llvm::writeToOutput(StringRef OutputFileName,
+Error llvm::writeToOutput(std::string_view OutputFileName,
                           std::function<Error(raw_ostream &)> Write) {
   if (OutputFileName == "-")
     return Write(outs());
diff --git a/llvm/lib/Support/xxhash.cpp b/llvm/lib/Support/xxhash.cpp
index cdb76d57e2c1df67e07c39f5e59284ab0ce07984..2496050eef7349ad82b54ffa6fb6bff8278c8364 100644
--- a/llvm/lib/Support/xxhash.cpp
+++ b/llvm/lib/Support/xxhash.cpp
@@ -100,11 +100,11 @@ static uint64_t XXH64_avalanche(uint64_t hash) {
   return hash;
 }
 
-uint64_t llvm::xxHash64(StringRef Data) {
+uint64_t llvm::xxHash64(std::string_view Data) {
   size_t Len = Data.size();
   uint64_t Seed = 0;
-  const unsigned char *P = Data.bytes_begin();
-  const unsigned char *const BEnd = Data.bytes_end();
+  const unsigned char *P = reinterpret_cast<const unsigned char*>(Data.data());
+  const unsigned char *const BEnd = P + Data.size();
   uint64_t H64;
 
   if (Len >= 32) {
@@ -160,7 +160,7 @@ uint64_t llvm::xxHash64(StringRef Data) {
   return XXH64_avalanche(H64);
 }
 
-uint64_t llvm::xxHash64(ArrayRef<uint8_t> Data) {
+uint64_t llvm::xxHash64(span<const uint8_t> Data) {
   return xxHash64({(const char *)Data.data(), Data.size()});
 }
 
@@ -550,7 +550,7 @@ static uint64_t XXH3_hashLong_64b(const uint8_t *input, size_t len,
                         (uint64_t)len * PRIME64_1);
 }
 
-uint64_t llvm::xxh3_64bits(ArrayRef<uint8_t> data) {
+uint64_t llvm::xxh3_64bits(span<const uint8_t> data) {
   auto *in = data.data();
   size_t len = data.size();
   if (len <= 16)
@@ -1020,7 +1020,7 @@ XXH3_hashLong_128b(const uint8_t *input, size_t len, const uint8_t *secret,
   return h128;
 }
 
-llvm::XXH128_hash_t llvm::xxh3_128bits(ArrayRef<uint8_t> data) {
+llvm::XXH128_hash_t llvm::xxh3_128bits(span<const uint8_t> data) {
   size_t len = data.size();
   const uint8_t *input = data.data();
 
diff --git a/llvm/unittests/ADT/DenseMapTest.cpp b/llvm/unittests/ADT/DenseMapTest.cpp
index d1bbdde8dfc267770b9d98808de54381571f2785..e93e18423507655ce8275a0718d8e5d01915985f 100644
--- a/llvm/unittests/ADT/DenseMapTest.cpp
+++ b/llvm/unittests/ADT/DenseMapTest.cpp
@@ -10,11 +10,11 @@
 #include "CountCopyAndMove.h"
 #include "llvm/ADT/DenseMapInfo.h"
 #include "llvm/ADT/DenseMapInfoVariant.h"
-#include "llvm/ADT/StringRef.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include <map>
 #include <set>
+#include <string_view>
 #include <utility>
 #include <variant>
 
@@ -523,31 +523,6 @@ TEST(DenseMapCustomTest, InsertOrAssignTest) {
   EXPECT_EQ(1, CountCopyAndMove::MoveAssignments);
 }
 
-// Make sure DenseMap works with StringRef keys.
-TEST(DenseMapCustomTest, StringRefTest) {
-  DenseMap<StringRef, int> M;
-
-  M["a"] = 1;
-  M["b"] = 2;
-  M["c"] = 3;
-
-  EXPECT_EQ(3u, M.size());
-  EXPECT_EQ(1, M.lookup("a"));
-  EXPECT_EQ(2, M.lookup("b"));
-  EXPECT_EQ(3, M.lookup("c"));
-
-  EXPECT_EQ(0, M.lookup("q"));
-
-  // Test the empty string, spelled various ways.
-  EXPECT_EQ(0, M.lookup(""));
-  EXPECT_EQ(0, M.lookup(StringRef()));
-  EXPECT_EQ(0, M.lookup(StringRef("a", 0)));
-  M[""] = 42;
-  EXPECT_EQ(42, M.lookup(""));
-  EXPECT_EQ(42, M.lookup(StringRef()));
-  EXPECT_EQ(42, M.lookup(StringRef("a", 0)));
-}
-
 // Key traits that allows lookup with either an unsigned or char* key;
 // In the latter case, "a" == 0, "b" == 1 and so on.
 struct TestDenseMapInfo {
@@ -785,7 +760,7 @@ TEST(DenseMapCustomTest, VariantSupport) {
 // Test that gTest prints map entries as pairs instead of opaque objects.
 // See third-party/unittest/googletest/internal/custom/gtest-printers.h
 TEST(DenseMapCustomTest, PairPrinting) {
-  DenseMap<int, StringRef> Map = {{1, "one"}, {2, "two"}};
+  DenseMap<int, std::string_view> Map = {{1, "one"}, {2, "two"}};
   EXPECT_EQ(R"({ (1, "one"), (2, "two") })", ::testing::PrintToString(Map));
 }
 
diff --git a/llvm/unittests/ADT/FunctionExtrasTest.cpp b/llvm/unittests/ADT/FunctionExtrasTest.cpp
index fc856a976946bf6decda9b6724cac66afc7bdcd6..aff9d61c7f0d48834123b04b74a2e4f7c86a56d8 100644
--- a/llvm/unittests/ADT/FunctionExtrasTest.cpp
+++ b/llvm/unittests/ADT/FunctionExtrasTest.cpp
@@ -249,23 +249,23 @@ TEST(UniqueFunctionTest, Const) {
 
   // Overloaded call operator correctly resolved.
   struct ChooseCorrectOverload {
-    StringRef operator()() { return "non-const"; }
-    StringRef operator()() const { return "const"; }
+    std::string_view operator()() { return "non-const"; }
+    std::string_view operator()() const { return "const"; }
   };
-  unique_function<StringRef()> ChooseMutable = ChooseCorrectOverload();
+  unique_function<std::string_view()> ChooseMutable = ChooseCorrectOverload();
   ChooseCorrectOverload A;
   EXPECT_EQ("non-const", ChooseMutable());
   EXPECT_EQ("non-const", A());
-  unique_function<StringRef() const> ChooseConst = ChooseCorrectOverload();
+  unique_function<std::string_view() const> ChooseConst = ChooseCorrectOverload();
   const ChooseCorrectOverload &X = A;
   EXPECT_EQ("const", ChooseConst());
   EXPECT_EQ("const", X());
 }
 
 // Test that overloads on unique_functions are resolved as expected.
-std::string returns(StringRef) { return "not a function"; }
+std::string returns(std::string_view) { return "not a function"; }
 std::string returns(unique_function<double()> F) { return "number"; }
-std::string returns(unique_function<StringRef()> F) { return "string"; }
+std::string returns(unique_function<std::string_view()> F) { return "string"; }
 
 TEST(UniqueFunctionTest, SFINAE) {
   EXPECT_EQ("not a function", returns("boo!"));
diff --git a/llvm/unittests/ADT/SmallPtrSetTest.cpp b/llvm/unittests/ADT/SmallPtrSetTest.cpp
index b45318d076a3d846b7810ce8cdaed7d2d97eca87..a39b11b9f82156a78b9ad7ce7b8c28855829e611 100644
--- a/llvm/unittests/ADT/SmallPtrSetTest.cpp
+++ b/llvm/unittests/ADT/SmallPtrSetTest.cpp
@@ -12,7 +12,6 @@
 
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/PointerIntPair.h"
-#include "llvm/ADT/STLExtras.h"
 #include "llvm/Support/PointerLikeTypeTraits.h"
 #include "gtest/gtest.h"
 
diff --git a/llvm/unittests/ADT/SmallStringTest.cpp b/llvm/unittests/ADT/SmallStringTest.cpp
index 2f4df8afeafa592cb9616bb78feb4964187786f2..6cf14700b34739420cd3dc4ff8a4c16ce162f715 100644
--- a/llvm/unittests/ADT/SmallStringTest.cpp
+++ b/llvm/unittests/ADT/SmallStringTest.cpp
@@ -50,43 +50,43 @@ TEST_F(SmallStringTest, AssignRepeated) {
 }
 
 TEST_F(SmallStringTest, AssignIterPair) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.assign(abc.begin(), abc.end());
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AssignStringRef) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, AssignStringView) {
+  std::string_view abc = "abc";
   theString.assign(abc);
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
 TEST_F(SmallStringTest, AssignSmallVector) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   SmallVector<char, 10> abcVec(abc.begin(), abc.end());
   theString.assign(abcVec);
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AssignStringRefs) {
+TEST_F(SmallStringTest, AssignStringViews) {
   theString.assign({"abc", "def", "ghi"});
   EXPECT_EQ(9u, theString.size());
   EXPECT_STREQ("abcdefghi", theString.c_str());
 }
 
 TEST_F(SmallStringTest, AppendIterPair) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.append(abc.begin(), abc.end());
   theString.append(abc.begin(), abc.end());
   EXPECT_EQ(6u, theString.size());
   EXPECT_STREQ("abcabc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AppendStringRef) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, AppendStringView) {
+  std::string_view abc = "abc";
   theString.append(abc);
   theString.append(abc);
   EXPECT_EQ(6u, theString.size());
@@ -94,7 +94,7 @@ TEST_F(SmallStringTest, AppendStringRef) {
 }
 
 TEST_F(SmallStringTest, AppendSmallVector) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   SmallVector<char, 10> abcVec(abc.begin(), abc.end());
   theString.append(abcVec);
   theString.append(abcVec);
@@ -102,11 +102,11 @@ TEST_F(SmallStringTest, AppendSmallVector) {
   EXPECT_STREQ("abcabc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AppendStringRefs) {
+TEST_F(SmallStringTest, AppendStringViews) {
   theString.append({"abc", "def", "ghi"});
   EXPECT_EQ(9u, theString.size());
   EXPECT_STREQ("abcdefghi", theString.c_str());
-  StringRef Jkl = "jkl";
+  std::string_view Jkl = "jkl";
   std::string Mno = "mno";
   SmallString<4> Pqr("pqr");
   const char *Stu = "stu";
@@ -115,15 +115,15 @@ TEST_F(SmallStringTest, AppendStringRefs) {
   EXPECT_STREQ("abcdefghijklmnopqrstu", theString.c_str());
 }
 
-TEST_F(SmallStringTest, StringRefConversion) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, StringViewConversion) {
+  std::string_view abc = "abc";
   theString.assign(abc.begin(), abc.end());
-  StringRef theStringRef = theString;
-  EXPECT_EQ("abc", theStringRef);
+  std::string_view theStringView = theString;
+  EXPECT_EQ("abc", theStringView);
 }
 
 TEST_F(SmallStringTest, StdStringConversion) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.assign(abc.begin(), abc.end());
   std::string theStdString = std::string(theString);
   EXPECT_EQ("abc", theStdString);
@@ -149,29 +149,29 @@ TEST_F(SmallStringTest, Slice) {
 TEST_F(SmallStringTest, Find) {
   theString = "hello";
   EXPECT_EQ(2U, theString.find('l'));
-  EXPECT_EQ(StringRef::npos, theString.find('z'));
-  EXPECT_EQ(StringRef::npos, theString.find("helloworld"));
+  EXPECT_EQ(std::string_view::npos, theString.find('z'));
+  EXPECT_EQ(std::string_view::npos, theString.find("helloworld"));
   EXPECT_EQ(0U, theString.find("hello"));
   EXPECT_EQ(1U, theString.find("ello"));
-  EXPECT_EQ(StringRef::npos, theString.find("zz"));
+  EXPECT_EQ(std::string_view::npos, theString.find("zz"));
   EXPECT_EQ(2U, theString.find("ll", 2));
-  EXPECT_EQ(StringRef::npos, theString.find("ll", 3));
+  EXPECT_EQ(std::string_view::npos, theString.find("ll", 3));
   EXPECT_EQ(0U, theString.find(""));
 
   EXPECT_EQ(3U, theString.rfind('l'));
-  EXPECT_EQ(StringRef::npos, theString.rfind('z'));
-  EXPECT_EQ(StringRef::npos, theString.rfind("helloworld"));
+  EXPECT_EQ(std::string_view::npos, theString.rfind('z'));
+  EXPECT_EQ(std::string_view::npos, theString.rfind("helloworld"));
   EXPECT_EQ(0U, theString.rfind("hello"));
   EXPECT_EQ(1U, theString.rfind("ello"));
-  EXPECT_EQ(StringRef::npos, theString.rfind("zz"));
+  EXPECT_EQ(std::string_view::npos, theString.rfind("zz"));
 
   EXPECT_EQ(2U, theString.find_first_of('l'));
   EXPECT_EQ(1U, theString.find_first_of("el"));
-  EXPECT_EQ(StringRef::npos, theString.find_first_of("xyz"));
+  EXPECT_EQ(std::string_view::npos, theString.find_first_of("xyz"));
 
   EXPECT_EQ(1U, theString.find_first_not_of('h'));
   EXPECT_EQ(4U, theString.find_first_not_of("hel"));
-  EXPECT_EQ(StringRef::npos, theString.find_first_not_of("hello"));
+  EXPECT_EQ(std::string_view::npos, theString.find_first_not_of("hello"));
 
   theString = "hellx xello hell ello world foo bar hello";
   EXPECT_EQ(36U, theString.find("hello"));
diff --git a/llvm/unittests/ADT/SmallVectorTest.cpp b/llvm/unittests/ADT/SmallVectorTest.cpp
index 137dd43b473068eae34b39edc4b9b8b9633bab95..7029038d18d433cef987bedbfa4fda269b24fb8f 100644
--- a/llvm/unittests/ADT/SmallVectorTest.cpp
+++ b/llvm/unittests/ADT/SmallVectorTest.cpp
@@ -11,10 +11,10 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/ArrayRef.h"
 #include "llvm/Support/Compiler.h"
 #include "gtest/gtest.h"
 #include <list>
+#include <span>
 #include <stdarg.h>
 
 using namespace llvm;
@@ -252,11 +252,11 @@ TYPED_TEST(SmallVectorTest, ConstructorIterTest) {
 }
 
 // Constructor test.
-TYPED_TEST(SmallVectorTest, ConstructorFromArrayRefSimpleTest) {
-  SCOPED_TRACE("ConstructorFromArrayRefSimpleTest");
+TYPED_TEST(SmallVectorTest, ConstructorFromSpanSimpleTest) {
+  SCOPED_TRACE("ConstructorFromSpanSimpleTest");
   std::array<Constructable, 3> StdArray = {Constructable(1), Constructable(2),
                                            Constructable(3)};
-  ArrayRef<Constructable> Array = StdArray;
+  span<const Constructable> Array = StdArray;
   auto &V = this->theVector;
   V = SmallVector<Constructable, 4>(Array);
   assertValuesInOrder(V, 3u, 1, 2, 3);
@@ -1129,24 +1129,6 @@ TEST(SmallVectorTest, DefaultInlinedElements) {
   EXPECT_EQ(NestedV[0][0][0], 42);
 }
 
-TEST(SmallVectorTest, InitializerList) {
-  SmallVector<int, 2> V1 = {};
-  EXPECT_TRUE(V1.empty());
-  V1 = {0, 0};
-  EXPECT_TRUE(ArrayRef(V1).equals({0, 0}));
-  V1 = {-1, -1};
-  EXPECT_TRUE(ArrayRef(V1).equals({-1, -1}));
-
-  SmallVector<int, 2> V2 = {1, 2, 3, 4};
-  EXPECT_TRUE(ArrayRef(V2).equals({1, 2, 3, 4}));
-  V2.assign({4});
-  EXPECT_TRUE(ArrayRef(V2).equals({4}));
-  V2.append({3, 2});
-  EXPECT_TRUE(ArrayRef(V2).equals({4, 3, 2}));
-  V2.insert(V2.begin() + 1, 5);
-  EXPECT_TRUE(ArrayRef(V2).equals({4, 5, 3, 2}));
-}
-
 TEST(SmallVectorTest, ToVector) {
   {
     std::vector<char> v = {'a', 'b', 'c'};
@@ -1183,10 +1165,10 @@ private:
   To T;
 };
 
-TEST(SmallVectorTest, ConstructFromArrayRefOfConvertibleType) {
+TEST(SmallVectorTest, ConstructFromSpanOfConvertibleType) {
   To to1{1}, to2{2}, to3{3};
   std::vector<From> StdVector = {From(to1), From(to2), From(to3)};
-  ArrayRef<From> Array = StdVector;
+  span<const From> Array = StdVector;
   {
     llvm::SmallVector<To> Vector(Array);
 
diff --git a/llvm/unittests/Support/ConvertUTFTest.cpp b/llvm/unittests/Support/ConvertUTFTest.cpp
index 6e75fbae0969ba1bf0a76c4d79a123e405a8dae7..3b07d344f15a555f11ad5f8177a0a65b8a4fa472 100644
--- a/llvm/unittests/Support/ConvertUTFTest.cpp
+++ b/llvm/unittests/Support/ConvertUTFTest.cpp
@@ -7,7 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/Support/ConvertUTF.h"
-#include "llvm/ADT/ArrayRef.h"
 #include "gtest/gtest.h"
 #include <string>
 #include <vector>
@@ -17,7 +16,7 @@ using namespace llvm;
 TEST(ConvertUTFTest, ConvertUTF16LittleEndianToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF16) static const char Src[] = "\xff\xfe\xa0\x0c_\x00\xa0\x0c";
-  ArrayRef<char> Ref(Src, sizeof(Src) - 1);
+  span<const char> Ref(Src, sizeof(Src) - 1);
   std::string Result;
   bool Success = convertUTF16ToUTF8String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -29,7 +28,7 @@ TEST(ConvertUTFTest, ConvertUTF32LittleEndianToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF32) static const char Src[] =
       "\xFF\xFE\x00\x00\xA0\x0C\x00\x00\x5F\x00\x00\x00\xA0\x0C\x00\x00";
-  ArrayRef<char> Ref(Src, sizeof(Src) - 1);
+  span<const char> Ref(Src, sizeof(Src) - 1);
   std::string Result;
   bool Success = convertUTF32ToUTF8String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -40,7 +39,7 @@ TEST(ConvertUTFTest, ConvertUTF32LittleEndianToUTF8String) {
 TEST(ConvertUTFTest, ConvertUTF16BigEndianToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF16) static const char Src[] = "\xfe\xff\x0c\xa0\x00_\x0c\xa0";
-  ArrayRef<char> Ref(Src, sizeof(Src) - 1);
+  span<const char> Ref(Src, sizeof(Src) - 1);
   std::string Result;
   bool Success = convertUTF16ToUTF8String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -52,7 +51,7 @@ TEST(ConvertUTFTest, ConvertUTF32BigEndianToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF32) static const char Src[] =
       "\x00\x00\xFE\xFF\x00\x00\x0C\xA0\x00\x00\x00\x5F\x00\x00\x0C\xA0";
-  ArrayRef<char> Ref(Src, sizeof(Src) - 1);
+  span<const char> Ref(Src, sizeof(Src) - 1);
   std::string Result;
   bool Success = convertUTF32ToUTF8String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -63,7 +62,7 @@ TEST(ConvertUTFTest, ConvertUTF32BigEndianToUTF8String) {
 TEST(ConvertUTFTest, ConvertUTF8ToUTF16String) {
   // Src is the look of disapproval.
   static const char Src[] = "\xe0\xb2\xa0_\xe0\xb2\xa0";
-  StringRef Ref(Src, sizeof(Src) - 1);
+  std::string_view Ref(Src, sizeof(Src) - 1);
   SmallVector<UTF16, 5> Result;
   bool Success = convertUTF8ToUTF16String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -75,38 +74,38 @@ TEST(ConvertUTFTest, ConvertUTF8ToUTF16String) {
 
 TEST(ConvertUTFTest, OddLengthInput) {
   std::string Result;
-  bool Success = convertUTF16ToUTF8String(ArrayRef("xxxxx", 5), Result);
+  bool Success = convertUTF16ToUTF8String(span<const char>("xxxxx", 5), Result);
   EXPECT_FALSE(Success);
 }
 
 TEST(ConvertUTFTest, Empty) {
   std::string Result;
   bool Success =
-      convertUTF16ToUTF8String(llvm::ArrayRef<char>(std::nullopt), Result);
+      convertUTF16ToUTF8String(span<const char>(), Result);
   EXPECT_TRUE(Success);
   EXPECT_TRUE(Result.empty());
 }
 
 TEST(ConvertUTFTest, HasUTF16BOM) {
-  bool HasBOM = hasUTF16ByteOrderMark(ArrayRef("\xff\xfe", 2));
+  bool HasBOM = hasUTF16ByteOrderMark("\xff\xfe");
   EXPECT_TRUE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(ArrayRef("\xfe\xff", 2));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff");
   EXPECT_TRUE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(ArrayRef("\xfe\xff ", 3));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff ");
   EXPECT_TRUE(HasBOM); // Don't care about odd lengths.
-  HasBOM = hasUTF16ByteOrderMark(ArrayRef("\xfe\xff\x00asdf", 6));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff\x00asdf");
   EXPECT_TRUE(HasBOM);
 
-  HasBOM = hasUTF16ByteOrderMark(std::nullopt);
+  HasBOM = hasUTF16ByteOrderMark("");
   EXPECT_FALSE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(ArrayRef("\xfe", 1));
+  HasBOM = hasUTF16ByteOrderMark("\xfe");
   EXPECT_FALSE(HasBOM);
 }
 
 TEST(ConvertUTFTest, UTF16WrappersForConvertUTF16ToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF16) static const char Src[] = "\xff\xfe\xa0\x0c_\x00\xa0\x0c";
-  ArrayRef<UTF16> SrcRef = ArrayRef((const UTF16 *)Src, 4);
+  span<const UTF16> SrcRef((const UTF16 *)Src, 4);
   std::string Result;
   bool Success = convertUTF16ToUTF8String(SrcRef, Result);
   EXPECT_TRUE(Success);
@@ -123,7 +122,7 @@ TEST(ConvertUTFTest, ConvertUTF8toWide) {
   std::wstring Expected(L"\x0ca0_\x0ca0");
   EXPECT_EQ(Expected, Result);
   Result.clear();
-  Success = ConvertUTF8toWide(StringRef(Src, 7), Result);
+  Success = ConvertUTF8toWide(Src, Result);
   EXPECT_TRUE(Success);
   EXPECT_EQ(Expected, Result);
 }
@@ -172,7 +171,7 @@ struct ConvertUTFResultContainer {
 };
 
 std::pair<ConversionResult, std::vector<unsigned>>
-ConvertUTF8ToUnicodeScalarsLenient(StringRef S) {
+ConvertUTF8ToUnicodeScalarsLenient(std::string_view S) {
   const UTF8 *SourceStart = reinterpret_cast<const UTF8 *>(S.data());
 
   const UTF8 *SourceNext = SourceStart;
@@ -189,7 +188,7 @@ ConvertUTF8ToUnicodeScalarsLenient(StringRef S) {
 }
 
 std::pair<ConversionResult, std::vector<unsigned>>
-ConvertUTF8ToUnicodeScalarsPartialLenient(StringRef S) {
+ConvertUTF8ToUnicodeScalarsPartialLenient(std::string_view S) {
   const UTF8 *SourceStart = reinterpret_cast<const UTF8 *>(S.data());
 
   const UTF8 *SourceNext = SourceStart;
@@ -207,7 +206,7 @@ ConvertUTF8ToUnicodeScalarsPartialLenient(StringRef S) {
 
 ::testing::AssertionResult
 CheckConvertUTF8ToUnicodeScalars(ConvertUTFResultContainer Expected,
-                                 StringRef S, bool Partial = false) {
+                                 std::string_view S, bool Partial = false) {
   ConversionResult ErrorCode;
   std::vector<unsigned> Decoded;
   if (!Partial)
@@ -302,7 +301,7 @@ TEST(ConvertUTFTest, UTF8ToUTF32Lenient) {
   // U+0000 NULL
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
       ConvertUTFResultContainer(conversionOK).withScalars(0x0000),
-      StringRef("\x00", 1)));
+      std::string_view("\x00", 1)));
 
   // U+0080 PADDING CHARACTER
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
@@ -1076,7 +1075,7 @@ TEST(ConvertUTFTest, UTF8ToUTF32Lenient) {
   // U+0000 NULL
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
       ConvertUTFResultContainer(conversionOK).withScalars(0x0000),
-      StringRef("\x00", 1)));
+      std::string_view("\x00", 1)));
 
   // Overlong sequences of the above.
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
diff --git a/llvm/unittests/Support/xxhashTest.cpp b/llvm/unittests/Support/xxhashTest.cpp
index 84308ce130e72818b553ea4185e8542d13182b3c..ef9a43690974ba586acc681e9f8ac49d4661031e 100644
--- a/llvm/unittests/Support/xxhashTest.cpp
+++ b/llvm/unittests/Support/xxhashTest.cpp
@@ -32,7 +32,7 @@ static void fillTestBuffer(uint8_t *buffer, size_t len) {
 }
 
 TEST(xxhashTest, Basic) {
-  EXPECT_EQ(0xef46db3751d8e999U, xxHash64(StringRef()));
+  EXPECT_EQ(0xef46db3751d8e999U, xxHash64(std::string_view()));
   EXPECT_EQ(0x33bf00a859c4ba3fU, xxHash64("foo"));
   EXPECT_EQ(0x48a37c90ad27a659U, xxHash64("bar"));
   EXPECT_EQ(0x69196c1b3af0bff9U,
@@ -51,7 +51,7 @@ TEST(xxhashTest, xxh3) {
   }
 
 #define F(len, expected)                                                       \
-  EXPECT_EQ(uint64_t(expected), xxh3_64bits(ArrayRef(a, size_t(len))))
+  EXPECT_EQ(uint64_t(expected), xxh3_64bits(span(a, size_t(len))))
   F(0, 0x2d06800538d394c2);
   F(1, 0xd0d496e05c553485);
   F(2, 0x84d625edb7055eac);
@@ -90,7 +90,7 @@ TEST(xxhashTest, xxh3_128bits) {
 
 #define F(len, expected)                                                       \
   EXPECT_EQ(XXH128_hash_t(expected),                                           \
-            xxh3_128bits(ArrayRef(sanityBuffer, size_t(len))))
+            xxh3_128bits(span(sanityBuffer, size_t(len))))
 
   F(0, (XXH128_hash_t{0x6001C324468D497FULL,
                       0x99AA06D3014798D8ULL})); /* empty string */
