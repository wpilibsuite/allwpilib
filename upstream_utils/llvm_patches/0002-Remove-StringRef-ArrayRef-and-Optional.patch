From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Sat, 7 May 2022 22:09:18 -0400
Subject: [PATCH 02/29] Remove StringRef, ArrayRef, and Optional

---
 llvm/include/llvm/ADT/PointerUnion.h          |  1 -
 llvm/include/llvm/ADT/SmallSet.h              |  2 +-
 llvm/include/llvm/ADT/SmallString.h           | 77 ++++++++++---------
 llvm/include/llvm/ADT/SmallVector.h           |  7 +-
 llvm/include/llvm/ADT/StringMap.h             | 34 ++++----
 llvm/include/llvm/ADT/StringMapEntry.h        | 20 ++---
 llvm/include/llvm/Support/Chrono.h            | 10 +--
 llvm/include/llvm/Support/Compiler.h          |  2 +-
 llvm/include/llvm/Support/ConvertUTF.h        | 31 ++++----
 llvm/include/llvm/Support/DJB.h               |  6 +-
 llvm/include/llvm/Support/ErrorHandling.h     |  9 +--
 .../llvm/Support/SmallVectorMemoryBuffer.h    |  6 +-
 llvm/include/llvm/Support/VersionTuple.h      |  6 --
 .../llvm/Support/Windows/WindowsSupport.h     |  4 +-
 llvm/include/llvm/Support/raw_ostream.h       | 46 ++++++-----
 llvm/lib/Support/ConvertUTFWrapper.cpp        | 38 ++++-----
 llvm/lib/Support/ErrorHandling.cpp            | 13 ++--
 llvm/lib/Support/SmallVector.cpp              |  5 +-
 llvm/lib/Support/StringMap.cpp                | 12 +--
 llvm/lib/Support/raw_ostream.cpp              | 25 +++---
 llvm/unittests/ADT/DenseMapTest.cpp           | 25 ------
 llvm/unittests/ADT/FunctionExtrasTest.cpp     | 12 +--
 llvm/unittests/ADT/HashingTest.cpp            |  2 +-
 llvm/unittests/ADT/SmallPtrSetTest.cpp        |  1 -
 llvm/unittests/ADT/SmallStringTest.cpp        | 50 ++++++------
 llvm/unittests/ADT/SmallVectorTest.cpp        | 30 ++------
 llvm/unittests/ADT/StringMapTest.cpp          | 32 ++++----
 llvm/unittests/Support/ConvertUTFTest.cpp     | 41 +++++-----
 28 files changed, 247 insertions(+), 300 deletions(-)

diff --git a/llvm/include/llvm/ADT/PointerUnion.h b/llvm/include/llvm/ADT/PointerUnion.h
index 061c4000fcb3532f8d24bf015dffd0e1f58120d2..6abec033a4008057f30d445d47ab22ebbb046a2f 100644
--- a/llvm/include/llvm/ADT/PointerUnion.h
+++ b/llvm/include/llvm/ADT/PointerUnion.h
@@ -17,7 +17,6 @@
 
 #include "llvm/ADT/DenseMapInfo.h"
 #include "llvm/ADT/PointerIntPair.h"
-#include "llvm/ADT/STLExtras.h"
 #include "llvm/Support/Casting.h"
 #include "llvm/Support/PointerLikeTypeTraits.h"
 #include <algorithm>
diff --git a/llvm/include/llvm/ADT/SmallSet.h b/llvm/include/llvm/ADT/SmallSet.h
index 5ac868d58314ce42476bee5aa08dee5c7a9d1c17..06bc9b5556dd76432552ee79aa916b850f829f4d 100644
--- a/llvm/include/llvm/ADT/SmallSet.h
+++ b/llvm/include/llvm/ADT/SmallSet.h
@@ -16,12 +16,12 @@
 
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/iterator.h"
 #include "llvm/Support/Compiler.h"
 #include "llvm/Support/type_traits.h"
 #include <cstddef>
 #include <functional>
+#include <optional>
 #include <set>
 #include <type_traits>
 #include <utility>
diff --git a/llvm/include/llvm/ADT/SmallString.h b/llvm/include/llvm/ADT/SmallString.h
index 0052c86fb37b82dcdf577a7acf06e3a47f54da61..4d673cc8b1c49cf8a3f19653de53881cd12662ee 100644
--- a/llvm/include/llvm/ADT/SmallString.h
+++ b/llvm/include/llvm/ADT/SmallString.h
@@ -15,8 +15,9 @@
 #define LLVM_ADT_SMALLSTRING_H
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
 #include <cstddef>
+#include <string>
+#include <string_view>
 
 namespace llvm {
 
@@ -28,11 +29,11 @@ public:
   /// Default ctor - Initialize to empty.
   SmallString() = default;
 
-  /// Initialize from a StringRef.
-  SmallString(StringRef S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}
+  /// Initialize from a std::string_view.
+  SmallString(std::string_view S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}
 
-  /// Initialize by concatenating a list of StringRefs.
-  SmallString(std::initializer_list<StringRef> Refs)
+  /// Initialize by concatenating a list of std::string_views.
+  SmallString(std::initializer_list<std::string_view> Refs)
       : SmallVector<char, InternalLen>() {
     this->append(Refs);
   }
@@ -47,13 +48,13 @@ public:
 
   using SmallVector<char, InternalLen>::assign;
 
-  /// Assign from a StringRef.
-  void assign(StringRef RHS) {
+  /// Assign from a std::string_view.
+  void assign(std::string_view RHS) {
     SmallVectorImpl<char>::assign(RHS.begin(), RHS.end());
   }
 
-  /// Assign from a list of StringRefs.
-  void assign(std::initializer_list<StringRef> Refs) {
+  /// Assign from a list of std::string_views.
+  void assign(std::initializer_list<std::string_view> Refs) {
     this->clear();
     append(Refs);
   }
@@ -64,19 +65,19 @@ public:
 
   using SmallVector<char, InternalLen>::append;
 
-  /// Append from a StringRef.
-  void append(StringRef RHS) {
+  /// Append from a std::string_view.
+  void append(std::string_view RHS) {
     SmallVectorImpl<char>::append(RHS.begin(), RHS.end());
   }
 
-  /// Append from a list of StringRefs.
-  void append(std::initializer_list<StringRef> Refs) {
+  /// Append from a list of std::string_views.
+  void append(std::initializer_list<std::string_view> Refs) {
     size_t CurrentSize = this->size();
     size_t SizeNeeded = CurrentSize;
-    for (const StringRef &Ref : Refs)
+    for (const std::string_view &Ref : Refs)
       SizeNeeded += Ref.size();
     this->resize_for_overwrite(SizeNeeded);
-    for (const StringRef &Ref : Refs) {
+    for (const std::string_view &Ref : Refs) {
       std::copy(Ref.begin(), Ref.end(), this->begin() + CurrentSize);
       CurrentSize += Ref.size();
     }
@@ -89,30 +90,30 @@ public:
 
   /// Check for string equality.  This is more efficient than compare() when
   /// the relative ordering of inequal strings isn't needed.
-  bool equals(StringRef RHS) const {
+  bool equals(std::string_view RHS) const {
     return str().equals(RHS);
   }
 
   /// Check for string equality, ignoring case.
-  bool equals_insensitive(StringRef RHS) const {
+  bool equals_insensitive(std::string_view RHS) const {
     return str().equals_insensitive(RHS);
   }
 
   /// compare - Compare two strings; the result is negative, zero, or positive
   /// if this string is lexicographically less than, equal to, or greater than
   /// the \p RHS.
-  int compare(StringRef RHS) const {
+  int compare(std::string_view RHS) const {
     return str().compare(RHS);
   }
 
   /// compare_insensitive - Compare two strings, ignoring case.
-  int compare_insensitive(StringRef RHS) const {
+  int compare_insensitive(std::string_view RHS) const {
     return str().compare_insensitive(RHS);
   }
 
   /// compare_numeric - Compare two strings, treating sequences of digits as
   /// numbers.
-  int compare_numeric(StringRef RHS) const {
+  int compare_numeric(std::string_view RHS) const {
     return str().compare_numeric(RHS);
   }
 
@@ -121,12 +122,12 @@ public:
   /// @{
 
   /// startswith - Check if this string starts with the given \p Prefix.
-  bool startswith(StringRef Prefix) const {
+  bool startswith(std::string_view Prefix) const {
     return str().startswith(Prefix);
   }
 
   /// endswith - Check if this string ends with the given \p Suffix.
-  bool endswith(StringRef Suffix) const {
+  bool endswith(std::string_view Suffix) const {
     return str().endswith(Suffix);
   }
 
@@ -146,7 +147,7 @@ public:
   ///
   /// \returns The index of the first occurrence of \p Str, or npos if not
   /// found.
-  size_t find(StringRef Str, size_t From = 0) const {
+  size_t find(std::string_view Str, size_t From = 0) const {
     return str().find(Str, From);
   }
 
@@ -154,7 +155,7 @@ public:
   ///
   /// \returns The index of the last occurrence of \p C, or npos if not
   /// found.
-  size_t rfind(char C, size_t From = StringRef::npos) const {
+  size_t rfind(char C, size_t From = std::string_view::npos) const {
     return str().rfind(C, From);
   }
 
@@ -162,7 +163,7 @@ public:
   ///
   /// \returns The index of the last occurrence of \p Str, or npos if not
   /// found.
-  size_t rfind(StringRef Str) const {
+  size_t rfind(std::string_view Str) const {
     return str().rfind(Str);
   }
 
@@ -176,7 +177,7 @@ public:
   /// not found.
   ///
   /// Complexity: O(size() + Chars.size())
-  size_t find_first_of(StringRef Chars, size_t From = 0) const {
+  size_t find_first_of(std::string_view Chars, size_t From = 0) const {
     return str().find_first_of(Chars, From);
   }
 
@@ -190,13 +191,13 @@ public:
   /// \p Chars, or npos if not found.
   ///
   /// Complexity: O(size() + Chars.size())
-  size_t find_first_not_of(StringRef Chars, size_t From = 0) const {
+  size_t find_first_not_of(std::string_view Chars, size_t From = 0) const {
     return str().find_first_not_of(Chars, From);
   }
 
   /// Find the last character in the string that is \p C, or npos if not
   /// found.
-  size_t find_last_of(char C, size_t From = StringRef::npos) const {
+  size_t find_last_of(char C, size_t From = std::string_view::npos) const {
     return str().find_last_of(C, From);
   }
 
@@ -205,7 +206,7 @@ public:
   ///
   /// Complexity: O(size() + Chars.size())
   size_t find_last_of(
-      StringRef Chars, size_t From = StringRef::npos) const {
+      std::string_view Chars, size_t From = std::string_view::npos) const {
     return str().find_last_of(Chars, From);
   }
 
@@ -220,7 +221,7 @@ public:
 
   /// Return the number of non-overlapped occurrences of \p Str in the
   /// string.
-  size_t count(StringRef Str) const {
+  size_t count(std::string_view Str) const {
     return str().count(Str);
   }
 
@@ -237,7 +238,7 @@ public:
   /// \param N The number of characters to included in the substring. If \p N
   /// exceeds the number of characters remaining in the string, the string
   /// suffix (starting with \p Start) will be returned.
-  StringRef substr(size_t Start, size_t N = StringRef::npos) const {
+  std::string_view substr(size_t Start, size_t N = std::string_view::npos) const {
     return str().substr(Start, N);
   }
 
@@ -251,14 +252,14 @@ public:
   /// substring. If this is npos, or less than \p Start, or exceeds the
   /// number of characters remaining in the string, the string suffix
   /// (starting with \p Start) will be returned.
-  StringRef slice(size_t Start, size_t End) const {
+  std::string_view slice(size_t Start, size_t End) const {
     return str().slice(Start, End);
   }
 
   // Extra methods.
 
-  /// Explicit conversion to StringRef.
-  StringRef str() const { return StringRef(this->data(), this->size()); }
+  /// Explicit conversion to std::string_view.
+  std::string_view str() const { return std::string_view(this->begin(), this->size()); }
 
   // TODO: Make this const, if it's safe...
   const char* c_str() {
@@ -267,20 +268,20 @@ public:
     return this->data();
   }
 
-  /// Implicit conversion to StringRef.
-  operator StringRef() const { return str(); }
+  /// Implicit conversion to std::string_view.
+  operator std::string_view() const { return str(); }
 
   explicit operator std::string() const {
     return std::string(this->data(), this->size());
   }
 
   // Extra operators.
-  SmallString &operator=(StringRef RHS) {
+  SmallString &operator=(std::string_view RHS) {
     this->assign(RHS);
     return *this;
   }
 
-  SmallString &operator+=(StringRef RHS) {
+  SmallString &operator+=(std::string_view RHS) {
     this->append(RHS.begin(), RHS.end());
     return *this;
   }
diff --git a/llvm/include/llvm/ADT/SmallVector.h b/llvm/include/llvm/ADT/SmallVector.h
index 98dce891688dac9530c968e99440e239148faece..92cccb130466a47127fbf8092286f9c5052dd26c 100644
--- a/llvm/include/llvm/ADT/SmallVector.h
+++ b/llvm/include/llvm/ADT/SmallVector.h
@@ -27,13 +27,12 @@
 #include <limits>
 #include <memory>
 #include <new>
+#include <span>
 #include <type_traits>
 #include <utility>
 
 namespace llvm {
 
-template <typename T> class ArrayRef;
-
 template <typename IteratorT> class iterator_range;
 
 template <class Iterator>
@@ -117,7 +116,7 @@ template <class T, typename = void> struct SmallVectorAlignmentAndSize {
 };
 
 /// This is the part of SmallVectorTemplateBase which does not depend on whether
-/// the type T is a POD. The extra dummy template argument is used by ArrayRef
+/// the type T is a POD. The extra dummy template argument is used by span
 /// to avoid unnecessarily requiring T to be complete.
 template <typename T, typename = void>
 class SmallVectorTemplateCommon
@@ -1228,7 +1227,7 @@ public:
 
   template <typename U,
             typename = std::enable_if_t<std::is_convertible<U, T>::value>>
-  explicit SmallVector(ArrayRef<U> A) : SmallVectorImpl<T>(N) {
+  explicit SmallVector(span<const U> A) : SmallVectorImpl<T>(N) {
     this->append(A.begin(), A.end());
   }
 
diff --git a/llvm/include/llvm/ADT/StringMap.h b/llvm/include/llvm/ADT/StringMap.h
index 0849bef53ba164dbe524972f6ca5a761c7c10603..1c8cda7ef0f8e2984f2d7960260f2a109a2986f7 100644
--- a/llvm/include/llvm/ADT/StringMap.h
+++ b/llvm/include/llvm/ADT/StringMap.h
@@ -60,12 +60,12 @@ protected:
   /// specified bucket will be non-null.  Otherwise, it will be null.  In either
   /// case, the FullHashValue field of the bucket will be set to the hash value
   /// of the string.
-  unsigned LookupBucketFor(StringRef Key);
+  unsigned LookupBucketFor(std::string_view Key);
 
   /// FindKey - Look up the bucket that contains the specified key. If it exists
   /// in the map, return the bucket number of the key.  Otherwise return -1.
   /// This does not modify the map.
-  int FindKey(StringRef Key) const;
+  int FindKey(std::string_view Key) const;
 
   /// RemoveKey - Remove the specified StringMapEntry from the table, but do not
   /// delete it.  This aborts if the value isn't in the table.
@@ -73,7 +73,7 @@ protected:
 
   /// RemoveKey - Remove the StringMapEntry for the specified key from the
   /// table, returning it.  If the key is not in the table, this returns null.
-  StringMapEntryBase *RemoveKey(StringRef Key);
+  StringMapEntryBase *RemoveKey(std::string_view Key);
 
   /// Allocate the table with the specified number of buckets and otherwise
   /// setup the map as empty.
@@ -126,7 +126,7 @@ public:
       : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))),
         AllocTy(A) {}
 
-  StringMap(std::initializer_list<std::pair<StringRef, ValueTy>> List)
+  StringMap(std::initializer_list<std::pair<std::string_view, ValueTy>> List)
       : StringMapImpl(List.size(), static_cast<unsigned>(sizeof(MapEntryTy))) {
     insert(List);
   }
@@ -214,14 +214,14 @@ public:
                       StringMapKeyIterator<ValueTy>(end()));
   }
 
-  iterator find(StringRef Key) {
+  iterator find(std::string_view Key) {
     int Bucket = FindKey(Key);
     if (Bucket == -1)
       return end();
     return iterator(TheTable + Bucket, true);
   }
 
-  const_iterator find(StringRef Key) const {
+  const_iterator find(std::string_view Key) const {
     int Bucket = FindKey(Key);
     if (Bucket == -1)
       return end();
@@ -230,7 +230,7 @@ public:
 
   /// lookup - Return the entry for the specified key, or a default
   /// constructed value if no such entry exists.
-  ValueTy lookup(StringRef Key) const {
+  ValueTy lookup(std::string_view Key) const {
     const_iterator it = find(Key);
     if (it != end())
       return it->second;
@@ -239,10 +239,10 @@ public:
 
   /// Lookup the ValueTy for the \p Key, or create a default constructed value
   /// if the key is not in the map.
-  ValueTy &operator[](StringRef Key) { return try_emplace(Key).first->second; }
+  ValueTy &operator[](std::string_view Key) { return try_emplace(Key).first->second; }
 
   /// count - Return 1 if the element is in the map, 0 otherwise.
-  size_type count(StringRef Key) const { return find(Key) == end() ? 0 : 1; }
+  size_type count(std::string_view Key) const { return find(Key) == end() ? 0 : 1; }
 
   template <typename InputTy>
   size_type count(const StringMapEntry<InputTy> &MapEntry) const {
@@ -292,7 +292,7 @@ public:
   /// isn't already in the map. The bool component of the returned pair is true
   /// if and only if the insertion takes place, and the iterator component of
   /// the pair points to the element with key equivalent to the key of the pair.
-  std::pair<iterator, bool> insert(std::pair<StringRef, ValueTy> KV) {
+  std::pair<iterator, bool> insert(std::pair<std::string_view, ValueTy> KV) {
     return try_emplace(KV.first, std::move(KV.second));
   }
 
@@ -307,14 +307,14 @@ public:
   ///  Inserts elements from initializer list ilist. If multiple elements in
   /// the range have keys that compare equivalent, it is unspecified which
   /// element is inserted
-  void insert(std::initializer_list<std::pair<StringRef, ValueTy>> List) {
+  void insert(std::initializer_list<std::pair<std::string_view, ValueTy>> List) {
     insert(List.begin(), List.end());
   }
 
   /// Inserts an element or assigns to the current element if the key already
   /// exists. The return type is the same as try_emplace.
   template <typename V>
-  std::pair<iterator, bool> insert_or_assign(StringRef Key, V &&Val) {
+  std::pair<iterator, bool> insert_or_assign(std::string_view Key, V &&Val) {
     auto Ret = try_emplace(Key, std::forward<V>(Val));
     if (!Ret.second)
       Ret.first->second = std::forward<V>(Val);
@@ -326,7 +326,7 @@ public:
   /// if and only if the insertion takes place, and the iterator component of
   /// the pair points to the element with key equivalent to the key of the pair.
   template <typename... ArgsTy>
-  std::pair<iterator, bool> try_emplace(StringRef Key, ArgsTy &&...Args) {
+  std::pair<iterator, bool> try_emplace(std::string_view Key, ArgsTy &&...Args) {
     unsigned BucketNo = LookupBucketFor(Key);
     StringMapEntryBase *&Bucket = TheTable[BucketNo];
     if (Bucket && Bucket != getTombstoneVal())
@@ -373,7 +373,7 @@ public:
     V.Destroy(getAllocator());
   }
 
-  bool erase(StringRef Key) {
+  bool erase(std::string_view Key) {
     iterator I = find(Key);
     if (I == end())
       return false;
@@ -470,17 +470,17 @@ template <typename ValueTy>
 class StringMapKeyIterator
     : public iterator_adaptor_base<StringMapKeyIterator<ValueTy>,
                                    StringMapConstIterator<ValueTy>,
-                                   std::forward_iterator_tag, StringRef> {
+                                   std::forward_iterator_tag, std::string_view> {
   using base = iterator_adaptor_base<StringMapKeyIterator<ValueTy>,
                                      StringMapConstIterator<ValueTy>,
-                                     std::forward_iterator_tag, StringRef>;
+                                     std::forward_iterator_tag, std::string_view>;
 
 public:
   StringMapKeyIterator() = default;
   explicit StringMapKeyIterator(StringMapConstIterator<ValueTy> Iter)
       : base(std::move(Iter)) {}
 
-  StringRef operator*() const { return this->wrapped()->getKey(); }
+  std::string_view operator*() const { return this->wrapped()->getKey(); }
 };
 
 } // end namespace llvm
diff --git a/llvm/include/llvm/ADT/StringMapEntry.h b/llvm/include/llvm/ADT/StringMapEntry.h
index 98b51cc1aebd59eba20076e6d8a4eebc0eebb982..388e81c361642113937f7d5680de73a50635b07d 100644
--- a/llvm/include/llvm/ADT/StringMapEntry.h
+++ b/llvm/include/llvm/ADT/StringMapEntry.h
@@ -16,8 +16,8 @@
 #ifndef LLVM_ADT_STRINGMAPENTRY_H
 #define LLVM_ADT_STRINGMAPENTRY_H
 
-#include "llvm/ADT/StringRef.h"
 #include <optional>
+#include <string_view>
 
 namespace llvm {
 
@@ -36,13 +36,13 @@ protected:
   /// type-erase the allocator and put it in a source file.
   template <typename AllocatorTy>
   static void *allocateWithKey(size_t EntrySize, size_t EntryAlign,
-                               StringRef Key, AllocatorTy &Allocator);
+                               std::string_view Key, AllocatorTy &Allocator);
 };
 
 // Define out-of-line to dissuade inlining.
 template <typename AllocatorTy>
 void *StringMapEntryBase::allocateWithKey(size_t EntrySize, size_t EntryAlign,
-                                          StringRef Key,
+                                          std::string_view Key,
                                           AllocatorTy &Allocator) {
   size_t KeyLength = Key.size();
 
@@ -105,8 +105,8 @@ public:
 
   using ValueType = ValueTy;
 
-  StringRef getKey() const {
-    return StringRef(getKeyData(), this->getKeyLength());
+  std::string_view getKey() const {
+    return std::string_view(getKeyData(), this->getKeyLength());
   }
 
   /// getKeyData - Return the start of the string data that is the key for this
@@ -116,15 +116,15 @@ public:
     return reinterpret_cast<const char *>(this + 1);
   }
 
-  StringRef first() const {
-    return StringRef(getKeyData(), this->getKeyLength());
+  std::string_view first() const {
+    return std::string_view(getKeyData(), this->getKeyLength());
   }
 
   /// Create a StringMapEntry for the specified key construct the value using
   /// \p InitiVals.
   template <typename AllocatorTy, typename... InitTy>
-  static StringMapEntry *create(StringRef key, AllocatorTy &allocator,
-                                InitTy &&...initVals) {
+  static StringMapEntry *create(std::string_view key, AllocatorTy &allocator,
+                                InitTy &&... initVals) {
     return new (StringMapEntryBase::allocateWithKey(
         sizeof(StringMapEntry), alignof(StringMapEntry), key, allocator))
         StringMapEntry(key.size(), std::forward<InitTy>(initVals)...);
@@ -167,7 +167,7 @@ struct tuple_size<llvm::StringMapEntry<ValueTy>>
 
 template <std::size_t I, typename ValueTy>
 struct tuple_element<I, llvm::StringMapEntry<ValueTy>>
-    : std::conditional<I == 0, llvm::StringRef, ValueTy> {};
+    : std::conditional<I == 0, std::string_view, ValueTy> {};
 } // namespace std
 
 #endif // LLVM_ADT_STRINGMAPENTRY_H
diff --git a/llvm/include/llvm/Support/Chrono.h b/llvm/include/llvm/Support/Chrono.h
index 9c2bd45d2803e56ed316d8552d899d87f2fbbb07..a7dea19d9193bcff4bc6b553b80a10b2bc7b64af 100644
--- a/llvm/include/llvm/Support/Chrono.h
+++ b/llvm/include/llvm/Support/Chrono.h
@@ -70,7 +70,7 @@ raw_ostream &operator<<(raw_ostream &OS, sys::TimePoint<> TP);
 template <>
 struct format_provider<sys::TimePoint<>> {
   static void format(const sys::TimePoint<> &TP, llvm::raw_ostream &OS,
-                     StringRef Style);
+                     std::string_view Style);
 };
 
 namespace detail {
@@ -122,7 +122,7 @@ private:
     return duration_cast<duration<InternalRep, AsPeriod>>(D).count();
   }
 
-  static std::pair<InternalRep, StringRef> consumeUnit(StringRef &Style,
+  static std::pair<InternalRep, std::string_view> consumeUnit(std::string_view &Style,
                                                         const Dur &D) {
     using namespace std::chrono;
     if (Style.consume_front("ns"))
@@ -140,7 +140,7 @@ private:
     return {D.count(), detail::unit<Period>::value};
   }
 
-  static bool consumeShowUnit(StringRef &Style) {
+  static bool consumeShowUnit(std::string_view &Style) {
     if (Style.empty())
       return true;
     if (Style.consume_front("-"))
@@ -152,9 +152,9 @@ private:
   }
 
 public:
-  static void format(const Dur &D, llvm::raw_ostream &Stream, StringRef Style) {
+  static void format(const Dur &D, llvm::raw_ostream &Stream, std::string_view Style) {
     InternalRep count;
-    StringRef unit;
+    std::string_view unit;
     std::tie(count, unit) = consumeUnit(Style, D);
     bool show_unit = consumeShowUnit(Style);
 
diff --git a/llvm/include/llvm/Support/Compiler.h b/llvm/include/llvm/Support/Compiler.h
index cf330662cf4b4d2ec759f1d8d253e20210602a95..4a54933031baa90c6f21138fb1f04c5da89878a4 100644
--- a/llvm/include/llvm/Support/Compiler.h
+++ b/llvm/include/llvm/Support/Compiler.h
@@ -288,7 +288,7 @@
 #endif
 
 /// LLVM_GSL_POINTER - Apply this to non-owning classes like
-/// StringRef to enable lifetime warnings.
+/// std::string_view to enable lifetime warnings.
 #if LLVM_HAS_CPP_ATTRIBUTE(gsl::Pointer)
 #define LLVM_GSL_POINTER [[gsl::Pointer]]
 #else
diff --git a/llvm/include/llvm/Support/ConvertUTF.h b/llvm/include/llvm/Support/ConvertUTF.h
index c892bb3c03cb569994429649bdbb96e4118dcef1..5c0e3009c25446a34882fb98329b1d955231bb39 100644
--- a/llvm/include/llvm/Support/ConvertUTF.h
+++ b/llvm/include/llvm/Support/ConvertUTF.h
@@ -107,10 +107,9 @@
 
 #include <cstddef>
 #include <string>
-
-#if defined(_WIN32)
+#include <span>
+#include <string_view>
 #include <system_error>
-#endif
 
 // Wrap everything in namespace llvm so that programs can link with llvm and
 // their own version of the unicode libraries.
@@ -204,12 +203,10 @@ unsigned getNumBytesForUTF8(UTF8 firstByte);
 /*************************************************************************/
 /* Below are LLVM-specific wrappers of the functions above. */
 
-template <typename T> class ArrayRef;
 template <typename T> class SmallVectorImpl;
-class StringRef;
 
 /**
- * Convert an UTF8 StringRef to UTF8, UTF16, or UTF32 depending on
+ * Convert an UTF8 string_view to UTF8, UTF16, or UTF32 depending on
  * WideCharWidth. The converted data is written to ResultPtr, which needs to
  * point to at least WideCharWidth * (Source.Size() + 1) bytes. On success,
  * ResultPtr will point one after the end of the copied string. On failure,
@@ -217,14 +214,14 @@ class StringRef;
  * the first character which could not be converted.
  * \return true on success.
  */
-bool ConvertUTF8toWide(unsigned WideCharWidth, llvm::StringRef Source,
+bool ConvertUTF8toWide(unsigned WideCharWidth, std::string_view Source,
                        char *&ResultPtr, const UTF8 *&ErrorPtr);
 
 /**
-* Converts a UTF-8 StringRef to a std::wstring.
+* Converts a UTF-8 string_view to a std::wstring.
 * \return true on success.
 */
-bool ConvertUTF8toWide(llvm::StringRef Source, std::wstring &Result);
+bool ConvertUTF8toWide(std::string_view Source, std::wstring &Result);
 
 /**
 * Converts a UTF-8 C-string to a std::wstring.
@@ -282,7 +279,7 @@ inline ConversionResult convertUTF8Sequence(const UTF8 **source,
  * Returns true if a blob of text starts with a UTF-16 big or little endian byte
  * order mark.
  */
-bool hasUTF16ByteOrderMark(ArrayRef<char> SrcBytes);
+bool hasUTF16ByteOrderMark(span<const char> SrcBytes);
 
 /**
  * Converts a stream of raw bytes assumed to be UTF16 into a UTF8 std::string.
@@ -291,7 +288,7 @@ bool hasUTF16ByteOrderMark(ArrayRef<char> SrcBytes);
  * \param [out] Out Converted UTF-8 is stored here on success.
  * \returns true on success
  */
-bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
+bool convertUTF16ToUTF8String(span<const char> SrcBytes, std::string &Out);
 
 /**
 * Converts a UTF16 string into a UTF8 std::string.
@@ -300,7 +297,7 @@ bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
 * \param [out] Out Converted UTF-8 is stored here on success.
 * \returns true on success
 */
-bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out);
+bool convertUTF16ToUTF8String(span<const UTF16> Src, std::string &Out);
 
 /**
  * Converts a stream of raw bytes assumed to be UTF32 into a UTF8 std::string.
@@ -309,7 +306,7 @@ bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out);
  * \param [out] Out Converted UTF-8 is stored here on success.
  * \returns true on success
  */
-bool convertUTF32ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
+bool convertUTF32ToUTF8String(span<const char> SrcBytes, std::string &Out);
 
 /**
  * Converts a UTF32 string into a UTF8 std::string.
@@ -318,22 +315,22 @@ bool convertUTF32ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
  * \param [out] Out Converted UTF-8 is stored here on success.
  * \returns true on success
  */
-bool convertUTF32ToUTF8String(ArrayRef<UTF32> Src, std::string &Out);
+bool convertUTF32ToUTF8String(span<const UTF32> Src, std::string &Out);
 
 /**
  * Converts a UTF-8 string into a UTF-16 string with native endianness.
  *
  * \returns true on success
  */
-bool convertUTF8ToUTF16String(StringRef SrcUTF8,
+bool convertUTF8ToUTF16String(std::string_view SrcUTF8,
                               SmallVectorImpl<UTF16> &DstUTF16);
 
 #if defined(_WIN32)
 namespace sys {
 namespace windows {
-std::error_code UTF8ToUTF16(StringRef utf8, SmallVectorImpl<wchar_t> &utf16);
+std::error_code UTF8ToUTF16(std::string_view utf8, SmallVectorImpl<wchar_t> &utf16);
 /// Convert to UTF16 from the current code page used in the system
-std::error_code CurCPToUTF16(StringRef utf8, SmallVectorImpl<wchar_t> &utf16);
+std::error_code CurCPToUTF16(std::string_view utf8, SmallVectorImpl<wchar_t> &utf16);
 std::error_code UTF16ToUTF8(const wchar_t *utf16, size_t utf16_len,
                             SmallVectorImpl<char> &utf8);
 /// Convert from UTF16 to the current code page used in the system
diff --git a/llvm/include/llvm/Support/DJB.h b/llvm/include/llvm/Support/DJB.h
index 8a04a324a5dc6cccaaa6af7b0e9b340f0755587e..8737cd144c37f9041a781a74e9f2b43384e85761 100644
--- a/llvm/include/llvm/Support/DJB.h
+++ b/llvm/include/llvm/Support/DJB.h
@@ -13,13 +13,13 @@
 #ifndef LLVM_SUPPORT_DJB_H
 #define LLVM_SUPPORT_DJB_H
 
-#include "llvm/ADT/StringRef.h"
+#include <string_view>
 
 namespace llvm {
 
 /// The Bernstein hash function used by the DWARF accelerator tables.
-inline uint32_t djbHash(StringRef Buffer, uint32_t H = 5381) {
-  for (unsigned char C : Buffer.bytes())
+inline uint32_t djbHash(std::string_view Buffer, uint32_t H = 5381) {
+  for (unsigned char C : Buffer)
     H = (H << 5) + H + C;
   return H;
 }
diff --git a/llvm/include/llvm/Support/ErrorHandling.h b/llvm/include/llvm/Support/ErrorHandling.h
index dd1384a63af71b50ba1ccbb5933a1e472f50a39b..67e889fe26ac5ba1f4f81dc407210b76d507a517 100644
--- a/llvm/include/llvm/Support/ErrorHandling.h
+++ b/llvm/include/llvm/Support/ErrorHandling.h
@@ -15,10 +15,10 @@
 #define LLVM_SUPPORT_ERRORHANDLING_H
 
 #include "llvm/Support/Compiler.h"
+#include <string>
+#include <string_view>
 
 namespace llvm {
-  class StringRef;
-  class Twine;
 
   /// An error handler callback.
   typedef void (*fatal_error_handler_t)(void *user_data,
@@ -67,12 +67,11 @@ namespace llvm {
 /// standard error, followed by a newline.
 /// After the error handler is called this function will call abort(), it
 /// does not return.
-/// NOTE: The std::string variant was removed to avoid a <string> dependency.
 [[noreturn]] void report_fatal_error(const char *reason,
                                      bool gen_crash_diag = true);
-[[noreturn]] void report_fatal_error(StringRef reason,
+[[noreturn]] void report_fatal_error(const std::string &reason,
                                      bool gen_crash_diag = true);
-[[noreturn]] void report_fatal_error(const Twine &reason,
+[[noreturn]] void report_fatal_error(std::string_view reason,
                                      bool gen_crash_diag = true);
 
 /// Installs a new bad alloc error handler that should be used whenever a
diff --git a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
index f7f2d4e54e705d6f29812dc93d1fb0a3ca2dee12..b5e321b5f74ce35940649b9d1342b3cdf0c4931f 100644
--- a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
+++ b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
@@ -35,8 +35,8 @@ public:
                                 RequiresNullTerminator) {}
 
   /// Construct a named SmallVectorMemoryBuffer from the given SmallVector
-  /// r-value and StringRef.
-  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, StringRef Name,
+  /// r-value and std::string_view.
+  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, std::string_view Name,
                           bool RequiresNullTerminator = true)
       : SV(std::move(SV)), BufferName(std::string(Name)) {
     if (RequiresNullTerminator) {
@@ -49,7 +49,7 @@ public:
   // Key function.
   ~SmallVectorMemoryBuffer() override;
 
-  StringRef getBufferIdentifier() const override { return BufferName; }
+  std::string_view getBufferIdentifier() const override { return BufferName; }
 
   BufferKind getBufferKind() const override { return MemoryBuffer_Malloc; }
 
diff --git a/llvm/include/llvm/Support/VersionTuple.h b/llvm/include/llvm/Support/VersionTuple.h
index 828a6db54708dfa9a1a4b4456a92945a92ad80cb..953b40701dc934c1a356b5413c9c6c692d5f5679 100644
--- a/llvm/include/llvm/Support/VersionTuple.h
+++ b/llvm/include/llvm/Support/VersionTuple.h
@@ -25,7 +25,6 @@ namespace llvm {
 template <typename HasherT, support::endianness Endianness>
 class HashBuilderImpl;
 class raw_ostream;
-class StringRef;
 
 /// Represents a version number in the form major[.minor[.subminor[.build]]].
 class VersionTuple {
@@ -182,11 +181,6 @@ public:
 
   /// Retrieve a string representation of the version number.
   std::string getAsString() const;
-
-  /// Try to parse the given string as a version number.
-  /// \returns \c true if the string does not match the regular expression
-  ///   [0-9]+(\.[0-9]+){0,3}
-  bool tryParse(StringRef string);
 };
 
 /// Print a version number.
diff --git a/llvm/include/llvm/Support/Windows/WindowsSupport.h b/llvm/include/llvm/Support/Windows/WindowsSupport.h
index d3aacd14b2097b1e7e13c1003987c1fd52e0cf76..aabdb2f14668a990329b57f5454a0d7db73e12ce 100644
--- a/llvm/include/llvm/Support/Windows/WindowsSupport.h
+++ b/llvm/include/llvm/Support/Windows/WindowsSupport.h
@@ -35,8 +35,6 @@
 
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringExtras.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Config/llvm-config.h" // Get build system configuration settings
 #include "llvm/Support/Allocator.h"
 #include "llvm/Support/Chrono.h"
@@ -74,7 +72,7 @@ bool MakeErrMsg(std::string *ErrMsg, const std::string &prefix);
 [[noreturn]] inline void ReportLastErrorFatal(const char *Msg) {
   std::string ErrMsg;
   MakeErrMsg(&ErrMsg, Msg);
-  llvm::report_fatal_error(Twine(ErrMsg));
+  llvm::report_fatal_error(ErrMsg);
 }
 
 template <typename HandleTraits>
diff --git a/llvm/include/llvm/Support/raw_ostream.h b/llvm/include/llvm/Support/raw_ostream.h
index 7c42f355fd431791116226f6c6934213a130141c..c8a94f46fab18dabc123fd709974138c8b0b0beb 100644
--- a/llvm/include/llvm/Support/raw_ostream.h
+++ b/llvm/include/llvm/Support/raw_ostream.h
@@ -14,13 +14,12 @@
 #define LLVM_SUPPORT_RAW_OSTREAM_H
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/Support/DataTypes.h"
 #include <cassert>
 #include <cstddef>
 #include <cstdint>
 #include <cstring>
 #include <optional>
+#include <span>
 #include <string>
 #include <string_view>
 #include <system_error>
@@ -208,7 +207,22 @@ public:
     return *this;
   }
 
-  raw_ostream &operator<<(StringRef Str) {
+  raw_ostream &operator<<(span<const uint8_t> Arr) {
+    // Inline fast path, particularly for arrays with a known length.
+    size_t Size = Arr.size();
+
+    // Make sure we can use the fast path.
+    if (Size > (size_t)(OutBufEnd - OutBufCur))
+      return write(Arr.data(), Size);
+
+    if (Size) {
+      memcpy(OutBufCur, Arr.data(), Size);
+      OutBufCur += Size;
+    }
+    return *this;
+  }
+
+  raw_ostream &operator<<(std::string_view Str) {
     // Inline fast path, particularly for strings with a known length.
     size_t Size = Str.size();
 
@@ -241,7 +255,7 @@ public:
     // Inline fast path, particularly for constant strings where a sufficiently
     // smart compiler will simplify strlen.
 
-    return this->operator<<(StringRef(Str));
+    return this->operator<<(std::string_view(Str));
   }
 
   raw_ostream &operator<<(const std::string &Str) {
@@ -249,10 +263,6 @@ public:
     return write(Str.data(), Str.length());
   }
 
-  raw_ostream &operator<<(const std::string_view &Str) {
-    return write(Str.data(), Str.length());
-  }
-
   raw_ostream &operator<<(const SmallVectorImpl<char> &Str) {
     return write(Str.data(), Str.size());
   }
@@ -285,7 +295,7 @@ public:
 
   /// Output \p Str, turning '\\', '\t', '\n', '"', and anything that doesn't
   /// satisfy llvm::isPrint into an escape sequence.
-  raw_ostream &write_escaped(StringRef Str, bool UseHexEscapes = false);
+  raw_ostream &write_escaped(std::string_view Str, bool UseHexEscapes = false);
 
   raw_ostream &write(unsigned char C);
   raw_ostream &write(const char *Ptr, size_t Size);
@@ -501,14 +511,14 @@ public:
   /// As a special case, if Filename is "-", then the stream will use
   /// STDOUT_FILENO instead of opening a file. This will not close the stdout
   /// descriptor.
-  raw_fd_ostream(StringRef Filename, std::error_code &EC);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC);
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::FileAccess Access);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::OpenFlags Flags);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                  sys::fs::OpenFlags Flags);
 
@@ -613,7 +623,7 @@ public:
   /// Open the specified file for reading/writing/seeking. If an error occurs,
   /// information about the error is put into EC, and the stream should be
   /// immediately destroyed.
-  raw_fd_stream(StringRef Filename, std::error_code &EC);
+  raw_fd_stream(std::string_view Filename, std::error_code &EC);
 
   /// This reads the \p Size bytes into a buffer pointed by \p Ptr.
   ///
@@ -693,8 +703,8 @@ public:
 
   void flush() = delete;
 
-  /// Return a StringRef for the vector contents.
-  StringRef str() const { return StringRef(OS.data(), OS.size()); }
+  /// Return a std::string_view for the vector contents.
+  std::string_view str() const { return std::string_view(OS.data(), OS.size()); }
 
   void reserveExtraSpace(uint64_t ExtraSize) override {
     OS.reserve(tell() + ExtraSize);
@@ -751,7 +761,7 @@ class Error;
 /// for other names. For raw_fd_ostream instances, the stream writes to
 /// a temporary file. The final output file is atomically replaced with the
 /// temporary file after the \p Write function is finished.
-Error writeToOutput(StringRef OutputFileName,
+Error writeToOutput(std::string_view OutputFileName,
                     std::function<Error(raw_ostream &)> Write);
 
 raw_ostream &operator<<(raw_ostream &OS, std::nullopt_t);
diff --git a/llvm/lib/Support/ConvertUTFWrapper.cpp b/llvm/lib/Support/ConvertUTFWrapper.cpp
index 9bf3f8f8b897c4f2c49fa65d8036412675526369..bb5164ff9dce0271cafc5889a049b5d343530f8d 100644
--- a/llvm/lib/Support/ConvertUTFWrapper.cpp
+++ b/llvm/lib/Support/ConvertUTFWrapper.cpp
@@ -6,24 +6,24 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "llvm/ADT/ArrayRef.h"
-#include "llvm/ADT/StringRef.h"
 #include "llvm/Support/ConvertUTF.h"
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/SwapByteOrder.h"
+#include <span>
 #include <string>
+#include <string_view>
 #include <vector>
 
 namespace llvm {
 
-bool ConvertUTF8toWide(unsigned WideCharWidth, llvm::StringRef Source,
+bool ConvertUTF8toWide(unsigned WideCharWidth, std::string_view Source,
                        char *&ResultPtr, const UTF8 *&ErrorPtr) {
   assert(WideCharWidth == 1 || WideCharWidth == 2 || WideCharWidth == 4);
   ConversionResult result = conversionOK;
   // Copy the character span over.
   if (WideCharWidth == 1) {
-    const UTF8 *Pos = reinterpret_cast<const UTF8*>(Source.begin());
-    if (!isLegalUTF8String(&Pos, reinterpret_cast<const UTF8*>(Source.end()))) {
+    const UTF8 *Pos = reinterpret_cast<const UTF8*>(Source.data());
+    if (!isLegalUTF8String(&Pos, reinterpret_cast<const UTF8*>(Source.data() + Source.size()))) {
       result = sourceIllegal;
       ErrorPtr = Pos;
     } else {
@@ -76,12 +76,12 @@ bool ConvertCodePointToUTF8(unsigned Source, char *&ResultPtr) {
   return true;
 }
 
-bool hasUTF16ByteOrderMark(ArrayRef<char> S) {
+bool hasUTF16ByteOrderMark(span<const char> S) {
   return (S.size() >= 2 && ((S[0] == '\xff' && S[1] == '\xfe') ||
                             (S[0] == '\xfe' && S[1] == '\xff')));
 }
 
-bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
+bool convertUTF16ToUTF8String(span<const char> SrcBytes, std::string &Out) {
   assert(Out.empty());
 
   // Error out on an uneven byte count.
@@ -132,14 +132,14 @@ bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
   return true;
 }
 
-bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out) {
+bool convertUTF16ToUTF8String(span<const UTF16> Src, std::string &Out) {
   return convertUTF16ToUTF8String(
-      llvm::ArrayRef<char>(reinterpret_cast<const char *>(Src.data()),
+      span<const char>(reinterpret_cast<const char *>(Src.data()),
                            Src.size() * sizeof(UTF16)),
       Out);
 }
 
-bool convertUTF32ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
+bool convertUTF32ToUTF8String(span<const char> SrcBytes, std::string &Out) {
   assert(Out.empty());
 
   // Error out on an uneven byte count.
@@ -190,14 +190,14 @@ bool convertUTF32ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
   return true;
 }
 
-bool convertUTF32ToUTF8String(ArrayRef<UTF32> Src, std::string &Out) {
+bool convertUTF32ToUTF8String(span<const UTF32> Src, std::string &Out) {
   return convertUTF32ToUTF8String(
-      llvm::ArrayRef<char>(reinterpret_cast<const char *>(Src.data()),
+      span<const char>(reinterpret_cast<const char *>(Src.data()),
                            Src.size() * sizeof(UTF32)),
       Out);
 }
 
-bool convertUTF8ToUTF16String(StringRef SrcUTF8,
+bool convertUTF8ToUTF16String(std::string_view SrcUTF8,
                               SmallVectorImpl<UTF16> &DstUTF16) {
   assert(DstUTF16.empty());
 
@@ -208,8 +208,8 @@ bool convertUTF8ToUTF16String(StringRef SrcUTF8,
     return true;
   }
 
-  const UTF8 *Src = reinterpret_cast<const UTF8 *>(SrcUTF8.begin());
-  const UTF8 *SrcEnd = reinterpret_cast<const UTF8 *>(SrcUTF8.end());
+  const UTF8 *Src = reinterpret_cast<const UTF8 *>(SrcUTF8.data());
+  const UTF8 *SrcEnd = reinterpret_cast<const UTF8 *>(SrcUTF8.data() + SrcUTF8.size());
 
   // Allocate the same number of UTF-16 code units as UTF-8 code units. Encoding
   // as UTF-16 should always require the same amount or less code units than the
@@ -240,7 +240,7 @@ static_assert(sizeof(wchar_t) == 1 || sizeof(wchar_t) == 2 ||
               "Expected wchar_t to be 1, 2, or 4 bytes");
 
 template <typename TResult>
-static inline bool ConvertUTF8toWideInternal(llvm::StringRef Source,
+static inline bool ConvertUTF8toWideInternal(std::string_view Source,
                                              TResult &Result) {
   // Even in the case of UTF-16, the number of bytes in a UTF-8 string is
   // at least as large as the number of elements in the resulting wide
@@ -256,7 +256,7 @@ static inline bool ConvertUTF8toWideInternal(llvm::StringRef Source,
   return true;
 }
 
-bool ConvertUTF8toWide(llvm::StringRef Source, std::wstring &Result) {
+bool ConvertUTF8toWide(std::string_view Source, std::wstring &Result) {
   return ConvertUTF8toWideInternal(Source, Result);
 }
 
@@ -265,7 +265,7 @@ bool ConvertUTF8toWide(const char *Source, std::wstring &Result) {
     Result.clear();
     return true;
   }
-  return ConvertUTF8toWide(llvm::StringRef(Source), Result);
+  return ConvertUTF8toWide(std::string_view(Source), Result);
 }
 
 bool convertWideToUTF8(const std::wstring &Source, std::string &Result) {
@@ -280,7 +280,7 @@ bool convertWideToUTF8(const std::wstring &Source, std::string &Result) {
     return true;
   } else if (sizeof(wchar_t) == 2) {
     return convertUTF16ToUTF8String(
-        llvm::ArrayRef<UTF16>(reinterpret_cast<const UTF16 *>(Source.data()),
+        span<const UTF16>(reinterpret_cast<const UTF16 *>(Source.data()),
                               Source.size()),
         Result);
   } else if (sizeof(wchar_t) == 4) {
diff --git a/llvm/lib/Support/ErrorHandling.cpp b/llvm/lib/Support/ErrorHandling.cpp
index b8b3b7424ac6b1de782e739782f9671194ce77a1..0aa13a0f78eb370b2a673ca4a773f26820575052 100644
--- a/llvm/lib/Support/ErrorHandling.cpp
+++ b/llvm/lib/Support/ErrorHandling.cpp
@@ -14,7 +14,6 @@
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm-c/ErrorHandling.h"
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Config/config.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/Errc.h"
@@ -80,14 +79,14 @@ void llvm::remove_fatal_error_handler() {
 }
 
 void llvm::report_fatal_error(const char *Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
+  report_fatal_error(std::string_view(Reason), GenCrashDiag);
 }
 
-void llvm::report_fatal_error(StringRef Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
+void llvm::report_fatal_error(const std::string &Reason, bool GenCrashDiag) {
+  report_fatal_error(std::string_view(Reason), GenCrashDiag);
 }
 
-void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
+void llvm::report_fatal_error(std::string_view Reason, bool GenCrashDiag) {
   llvm::fatal_error_handler_t handler = nullptr;
   void* handlerData = nullptr;
   {
@@ -101,7 +100,7 @@ void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
   }
 
   if (handler) {
-    handler(handlerData, Reason.str().c_str(), GenCrashDiag);
+    handler(handlerData, std::string{Reason}.c_str(), GenCrashDiag);
   } else {
     // Blast the result out to stderr.  We don't try hard to make sure this
     // succeeds (e.g. handling EINTR) and we can't use errs() here because
@@ -109,7 +108,7 @@ void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
     SmallVector<char, 64> Buffer;
     raw_svector_ostream OS(Buffer);
     OS << "LLVM ERROR: " << Reason << "\n";
-    StringRef MessageStr = OS.str();
+    std::string_view MessageStr = OS.str();
     ssize_t written = ::write(2, MessageStr.data(), MessageStr.size());
     (void)written; // If something went wrong, we deliberately just give up.
   }
diff --git a/llvm/lib/Support/SmallVector.cpp b/llvm/lib/Support/SmallVector.cpp
index f7e7e80332cc337f6dfa388d1e218e6f3ec95cf2..6cefdff7c28060ca18b522acf5279af3a206e23a 100644
--- a/llvm/lib/Support/SmallVector.cpp
+++ b/llvm/lib/Support/SmallVector.cpp
@@ -11,7 +11,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Support/MemAlloc.h"
 #include <cstdint>
 #ifdef LLVM_ENABLE_EXCEPTIONS
@@ -67,7 +66,7 @@ static void report_size_overflow(size_t MinSize, size_t MaxSize) {
 #ifdef LLVM_ENABLE_EXCEPTIONS
   throw std::length_error(Reason);
 #else
-  report_fatal_error(Twine(Reason));
+  report_fatal_error(Reason);
 #endif
 }
 
@@ -81,7 +80,7 @@ static void report_at_maximum_capacity(size_t MaxSize) {
 #ifdef LLVM_ENABLE_EXCEPTIONS
   throw std::length_error(Reason);
 #else
-  report_fatal_error(Twine(Reason));
+  report_fatal_error(Reason);
 #endif
 }
 
diff --git a/llvm/lib/Support/StringMap.cpp b/llvm/lib/Support/StringMap.cpp
index 9b2f96fca2cd035963f88dc462c5d723b7adf164..3c790039bffbc11b2db28cbf13c248fdccec4383 100644
--- a/llvm/lib/Support/StringMap.cpp
+++ b/llvm/lib/Support/StringMap.cpp
@@ -80,7 +80,7 @@ void StringMapImpl::init(unsigned InitSize) {
 /// specified bucket will be non-null.  Otherwise, it will be null.  In either
 /// case, the FullHashValue field of the bucket will be set to the hash value
 /// of the string.
-unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
+unsigned StringMapImpl::LookupBucketFor(std::string_view Name) {
   // Hash table unallocated so far?
   if (NumBuckets == 0)
     init(16);
@@ -118,7 +118,7 @@ unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
       // Do the comparison like this because Name isn't necessarily
       // null-terminated!
       char *ItemStr = (char *)BucketItem + ItemSize;
-      if (Name == StringRef(ItemStr, BucketItem->getKeyLength())) {
+      if (Name == std::string_view(ItemStr, BucketItem->getKeyLength())) {
         // We found a match!
         return BucketNo;
       }
@@ -136,7 +136,7 @@ unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
 /// FindKey - Look up the bucket that contains the specified key. If it exists
 /// in the map, return the bucket number of the key.  Otherwise return -1.
 /// This does not modify the map.
-int StringMapImpl::FindKey(StringRef Key) const {
+int StringMapImpl::FindKey(std::string_view Key) const {
   if (NumBuckets == 0)
     return -1; // Really empty table?
   unsigned FullHashValue = djbHash(Key, 0);
@@ -161,7 +161,7 @@ int StringMapImpl::FindKey(StringRef Key) const {
       // Do the comparison like this because NameStart isn't necessarily
       // null-terminated!
       char *ItemStr = (char *)BucketItem + ItemSize;
-      if (Key == StringRef(ItemStr, BucketItem->getKeyLength())) {
+      if (Key == std::string_view(ItemStr, BucketItem->getKeyLength())) {
         // We found a match!
         return BucketNo;
       }
@@ -180,14 +180,14 @@ int StringMapImpl::FindKey(StringRef Key) const {
 /// delete it.  This aborts if the value isn't in the table.
 void StringMapImpl::RemoveKey(StringMapEntryBase *V) {
   const char *VStr = (char *)V + ItemSize;
-  StringMapEntryBase *V2 = RemoveKey(StringRef(VStr, V->getKeyLength()));
+  StringMapEntryBase *V2 = RemoveKey(std::string_view(VStr, V->getKeyLength()));
   (void)V2;
   assert(V == V2 && "Didn't find key?");
 }
 
 /// RemoveKey - Remove the StringMapEntry for the specified key from the
 /// table, returning it.  If the key is not in the table, this returns null.
-StringMapEntryBase *StringMapImpl::RemoveKey(StringRef Key) {
+StringMapEntryBase *StringMapImpl::RemoveKey(std::string_view Key) {
   int Bucket = FindKey(Key);
   if (Bucket == -1)
     return nullptr;
diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
index fae4a4308fd7fdc2126932a097d8c9a366d0840b..ce3ffa575995b9f00f8d569176c7aeae7892d30d 100644
--- a/llvm/lib/Support/raw_ostream.cpp
+++ b/llvm/lib/Support/raw_ostream.cpp
@@ -166,7 +166,7 @@ raw_ostream &raw_ostream::write_uuid(const uuid_t UUID) {
 }
 
 
-raw_ostream &raw_ostream::write_escaped(StringRef Str,
+raw_ostream &raw_ostream::write_escaped(std::string_view Str,
                                         bool UseHexEscapes) {
   for (unsigned char c : Str) {
     switch (c) {
@@ -569,7 +569,7 @@ void format_object_base::home() {
 //  raw_fd_ostream
 //===----------------------------------------------------------------------===//
 
-static int getFD(StringRef Filename, std::error_code &EC,
+static int getFD(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                  sys::fs::OpenFlags Flags) {
   assert((Access & sys::fs::FA_Write) &&
@@ -595,25 +595,25 @@ static int getFD(StringRef Filename, std::error_code &EC,
   return FD;
 }
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC)
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, sys::fs::FA_Write,
                      sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::CreationDisposition Disp)
     : raw_fd_ostream(Filename, EC, Disp, sys::fs::FA_Write, sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::FileAccess Access)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, Access,
                      sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::OpenFlags Flags)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, sys::fs::FA_Write,
                      Flags) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::CreationDisposition Disp,
                                sys::fs::FileAccess Access,
                                sys::fs::OpenFlags Flags)
@@ -685,8 +685,7 @@ raw_fd_ostream::~raw_fd_ostream() {
   // has_error() and clear the error flag with clear_error() before
   // destructing raw_ostream objects which may have errors.
   if (has_error())
-    report_fatal_error(Twine("IO failure on output stream: ") +
-                           error().message(),
+    report_fatal_error("IO failure on output stream: " + error().message(),
                        /*gen_crash_diag=*/false);
 }
 
@@ -705,7 +704,7 @@ raw_fd_ostream::~raw_fd_ostream() {
 // the input is UTF-8 or transcode from the local codepage to UTF-8 before
 // quoting it. If they don't, this may mess up the encoding, but this is still
 // probably the best compromise we can make.
-static bool write_console_impl(int FD, StringRef Data) {
+static bool write_console_impl(int FD, std::string_view Data) {
   SmallVector<wchar_t, 256> WideText;
 
   // Fall back to ::write if it wasn't valid UTF-8.
@@ -748,7 +747,7 @@ void raw_fd_ostream::write_impl(const char *Ptr, size_t Size) {
   // If this is a Windows console device, try re-encoding from UTF-8 to UTF-16
   // and using WriteConsoleW. If that fails, fall back to plain write().
   if (IsWindowsConsole)
-    if (write_console_impl(FD, StringRef(Ptr, Size)))
+    if (write_console_impl(FD, std::string_view(Ptr, Size)))
       return;
 #endif
 
@@ -919,7 +918,7 @@ raw_ostream &llvm::nulls() {
 // File Streams
 //===----------------------------------------------------------------------===//
 
-raw_fd_stream::raw_fd_stream(StringRef Filename, std::error_code &EC)
+raw_fd_stream::raw_fd_stream(std::string_view Filename, std::error_code &EC)
     : raw_fd_ostream(getFD(Filename, EC, sys::fs::CD_CreateAlways,
                            sys::fs::FA_Write | sys::fs::FA_Read,
                            sys::fs::OF_None),
@@ -997,7 +996,7 @@ void buffer_ostream::anchor() {}
 
 void buffer_unique_ostream::anchor() {}
 
-Error llvm::writeToOutput(StringRef OutputFileName,
+Error llvm::writeToOutput(std::string_view OutputFileName,
                           std::function<Error(raw_ostream &)> Write) {
   if (OutputFileName == "-")
     return Write(outs());
diff --git a/llvm/unittests/ADT/DenseMapTest.cpp b/llvm/unittests/ADT/DenseMapTest.cpp
index 2d01316e658b8dbb6b77b8158da11701fedb9e94..ab575dfe920e314489025bb68e6113f6227fe41f 100644
--- a/llvm/unittests/ADT/DenseMapTest.cpp
+++ b/llvm/unittests/ADT/DenseMapTest.cpp
@@ -486,31 +486,6 @@ TEST(DenseMapCustomTest, ReserveTest) {
   }
 }
 
-// Make sure DenseMap works with StringRef keys.
-TEST(DenseMapCustomTest, StringRefTest) {
-  DenseMap<StringRef, int> M;
-
-  M["a"] = 1;
-  M["b"] = 2;
-  M["c"] = 3;
-
-  EXPECT_EQ(3u, M.size());
-  EXPECT_EQ(1, M.lookup("a"));
-  EXPECT_EQ(2, M.lookup("b"));
-  EXPECT_EQ(3, M.lookup("c"));
-
-  EXPECT_EQ(0, M.lookup("q"));
-
-  // Test the empty string, spelled various ways.
-  EXPECT_EQ(0, M.lookup(""));
-  EXPECT_EQ(0, M.lookup(StringRef()));
-  EXPECT_EQ(0, M.lookup(StringRef("a", 0)));
-  M[""] = 42;
-  EXPECT_EQ(42, M.lookup(""));
-  EXPECT_EQ(42, M.lookup(StringRef()));
-  EXPECT_EQ(42, M.lookup(StringRef("a", 0)));
-}
-
 // Key traits that allows lookup with either an unsigned or char* key;
 // In the latter case, "a" == 0, "b" == 1 and so on.
 struct TestDenseMapInfo {
diff --git a/llvm/unittests/ADT/FunctionExtrasTest.cpp b/llvm/unittests/ADT/FunctionExtrasTest.cpp
index fc856a976946bf6decda9b6724cac66afc7bdcd6..aff9d61c7f0d48834123b04b74a2e4f7c86a56d8 100644
--- a/llvm/unittests/ADT/FunctionExtrasTest.cpp
+++ b/llvm/unittests/ADT/FunctionExtrasTest.cpp
@@ -249,23 +249,23 @@ TEST(UniqueFunctionTest, Const) {
 
   // Overloaded call operator correctly resolved.
   struct ChooseCorrectOverload {
-    StringRef operator()() { return "non-const"; }
-    StringRef operator()() const { return "const"; }
+    std::string_view operator()() { return "non-const"; }
+    std::string_view operator()() const { return "const"; }
   };
-  unique_function<StringRef()> ChooseMutable = ChooseCorrectOverload();
+  unique_function<std::string_view()> ChooseMutable = ChooseCorrectOverload();
   ChooseCorrectOverload A;
   EXPECT_EQ("non-const", ChooseMutable());
   EXPECT_EQ("non-const", A());
-  unique_function<StringRef() const> ChooseConst = ChooseCorrectOverload();
+  unique_function<std::string_view() const> ChooseConst = ChooseCorrectOverload();
   const ChooseCorrectOverload &X = A;
   EXPECT_EQ("const", ChooseConst());
   EXPECT_EQ("const", X());
 }
 
 // Test that overloads on unique_functions are resolved as expected.
-std::string returns(StringRef) { return "not a function"; }
+std::string returns(std::string_view) { return "not a function"; }
 std::string returns(unique_function<double()> F) { return "number"; }
-std::string returns(unique_function<StringRef()> F) { return "string"; }
+std::string returns(unique_function<std::string_view()> F) { return "string"; }
 
 TEST(UniqueFunctionTest, SFINAE) {
   EXPECT_EQ("not a function", returns("boo!"));
diff --git a/llvm/unittests/ADT/HashingTest.cpp b/llvm/unittests/ADT/HashingTest.cpp
index 01a8a962b8e2e33ca8f189c049e9548ced42ec3a..62aff9c3b21eea785ca71c6e290c9c4f3a20ae00 100644
--- a/llvm/unittests/ADT/HashingTest.cpp
+++ b/llvm/unittests/ADT/HashingTest.cpp
@@ -295,7 +295,7 @@ TEST(HashingTest, HashCombineRangeGoldenTest) {
 #endif
   };
   for (unsigned i = 0; i < sizeof(golden_data)/sizeof(*golden_data); ++i) {
-    StringRef str = golden_data[i].s;
+    std::string_view str = golden_data[i].s;
     hash_code hash = hash_combine_range(str.begin(), str.end());
 #if 0 // Enable this to generate paste-able text for the above structure.
     std::string member_str = "\"" + str.str() + "\",";
diff --git a/llvm/unittests/ADT/SmallPtrSetTest.cpp b/llvm/unittests/ADT/SmallPtrSetTest.cpp
index a97f2617cbf70783f3569709f7ee1bff03baebd2..7ed8670fd31ea2a14e6ba7f59a8ac8e35046890c 100644
--- a/llvm/unittests/ADT/SmallPtrSetTest.cpp
+++ b/llvm/unittests/ADT/SmallPtrSetTest.cpp
@@ -12,7 +12,6 @@
 
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/PointerIntPair.h"
-#include "llvm/ADT/STLExtras.h"
 #include "llvm/Support/PointerLikeTypeTraits.h"
 #include "gtest/gtest.h"
 
diff --git a/llvm/unittests/ADT/SmallStringTest.cpp b/llvm/unittests/ADT/SmallStringTest.cpp
index 2f4df8afeafa592cb9616bb78feb4964187786f2..6cf14700b34739420cd3dc4ff8a4c16ce162f715 100644
--- a/llvm/unittests/ADT/SmallStringTest.cpp
+++ b/llvm/unittests/ADT/SmallStringTest.cpp
@@ -50,43 +50,43 @@ TEST_F(SmallStringTest, AssignRepeated) {
 }
 
 TEST_F(SmallStringTest, AssignIterPair) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.assign(abc.begin(), abc.end());
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AssignStringRef) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, AssignStringView) {
+  std::string_view abc = "abc";
   theString.assign(abc);
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
 TEST_F(SmallStringTest, AssignSmallVector) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   SmallVector<char, 10> abcVec(abc.begin(), abc.end());
   theString.assign(abcVec);
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AssignStringRefs) {
+TEST_F(SmallStringTest, AssignStringViews) {
   theString.assign({"abc", "def", "ghi"});
   EXPECT_EQ(9u, theString.size());
   EXPECT_STREQ("abcdefghi", theString.c_str());
 }
 
 TEST_F(SmallStringTest, AppendIterPair) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.append(abc.begin(), abc.end());
   theString.append(abc.begin(), abc.end());
   EXPECT_EQ(6u, theString.size());
   EXPECT_STREQ("abcabc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AppendStringRef) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, AppendStringView) {
+  std::string_view abc = "abc";
   theString.append(abc);
   theString.append(abc);
   EXPECT_EQ(6u, theString.size());
@@ -94,7 +94,7 @@ TEST_F(SmallStringTest, AppendStringRef) {
 }
 
 TEST_F(SmallStringTest, AppendSmallVector) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   SmallVector<char, 10> abcVec(abc.begin(), abc.end());
   theString.append(abcVec);
   theString.append(abcVec);
@@ -102,11 +102,11 @@ TEST_F(SmallStringTest, AppendSmallVector) {
   EXPECT_STREQ("abcabc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AppendStringRefs) {
+TEST_F(SmallStringTest, AppendStringViews) {
   theString.append({"abc", "def", "ghi"});
   EXPECT_EQ(9u, theString.size());
   EXPECT_STREQ("abcdefghi", theString.c_str());
-  StringRef Jkl = "jkl";
+  std::string_view Jkl = "jkl";
   std::string Mno = "mno";
   SmallString<4> Pqr("pqr");
   const char *Stu = "stu";
@@ -115,15 +115,15 @@ TEST_F(SmallStringTest, AppendStringRefs) {
   EXPECT_STREQ("abcdefghijklmnopqrstu", theString.c_str());
 }
 
-TEST_F(SmallStringTest, StringRefConversion) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, StringViewConversion) {
+  std::string_view abc = "abc";
   theString.assign(abc.begin(), abc.end());
-  StringRef theStringRef = theString;
-  EXPECT_EQ("abc", theStringRef);
+  std::string_view theStringView = theString;
+  EXPECT_EQ("abc", theStringView);
 }
 
 TEST_F(SmallStringTest, StdStringConversion) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.assign(abc.begin(), abc.end());
   std::string theStdString = std::string(theString);
   EXPECT_EQ("abc", theStdString);
@@ -149,29 +149,29 @@ TEST_F(SmallStringTest, Slice) {
 TEST_F(SmallStringTest, Find) {
   theString = "hello";
   EXPECT_EQ(2U, theString.find('l'));
-  EXPECT_EQ(StringRef::npos, theString.find('z'));
-  EXPECT_EQ(StringRef::npos, theString.find("helloworld"));
+  EXPECT_EQ(std::string_view::npos, theString.find('z'));
+  EXPECT_EQ(std::string_view::npos, theString.find("helloworld"));
   EXPECT_EQ(0U, theString.find("hello"));
   EXPECT_EQ(1U, theString.find("ello"));
-  EXPECT_EQ(StringRef::npos, theString.find("zz"));
+  EXPECT_EQ(std::string_view::npos, theString.find("zz"));
   EXPECT_EQ(2U, theString.find("ll", 2));
-  EXPECT_EQ(StringRef::npos, theString.find("ll", 3));
+  EXPECT_EQ(std::string_view::npos, theString.find("ll", 3));
   EXPECT_EQ(0U, theString.find(""));
 
   EXPECT_EQ(3U, theString.rfind('l'));
-  EXPECT_EQ(StringRef::npos, theString.rfind('z'));
-  EXPECT_EQ(StringRef::npos, theString.rfind("helloworld"));
+  EXPECT_EQ(std::string_view::npos, theString.rfind('z'));
+  EXPECT_EQ(std::string_view::npos, theString.rfind("helloworld"));
   EXPECT_EQ(0U, theString.rfind("hello"));
   EXPECT_EQ(1U, theString.rfind("ello"));
-  EXPECT_EQ(StringRef::npos, theString.rfind("zz"));
+  EXPECT_EQ(std::string_view::npos, theString.rfind("zz"));
 
   EXPECT_EQ(2U, theString.find_first_of('l'));
   EXPECT_EQ(1U, theString.find_first_of("el"));
-  EXPECT_EQ(StringRef::npos, theString.find_first_of("xyz"));
+  EXPECT_EQ(std::string_view::npos, theString.find_first_of("xyz"));
 
   EXPECT_EQ(1U, theString.find_first_not_of('h'));
   EXPECT_EQ(4U, theString.find_first_not_of("hel"));
-  EXPECT_EQ(StringRef::npos, theString.find_first_not_of("hello"));
+  EXPECT_EQ(std::string_view::npos, theString.find_first_not_of("hello"));
 
   theString = "hellx xello hell ello world foo bar hello";
   EXPECT_EQ(36U, theString.find("hello"));
diff --git a/llvm/unittests/ADT/SmallVectorTest.cpp b/llvm/unittests/ADT/SmallVectorTest.cpp
index fd3780a42ce50404216f248bedf79002e69d4070..e1090e6f605696f60a82d1708605ddd45f4e15f8 100644
--- a/llvm/unittests/ADT/SmallVectorTest.cpp
+++ b/llvm/unittests/ADT/SmallVectorTest.cpp
@@ -11,10 +11,10 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/ArrayRef.h"
 #include "llvm/Support/Compiler.h"
 #include "gtest/gtest.h"
 #include <list>
+#include <span>
 #include <stdarg.h>
 
 using namespace llvm;
@@ -247,11 +247,11 @@ TYPED_TEST(SmallVectorTest, ConstructorIterTest) {
 }
 
 // Constructor test.
-TYPED_TEST(SmallVectorTest, ConstructorFromArrayRefSimpleTest) {
-  SCOPED_TRACE("ConstructorFromArrayRefSimpleTest");
+TYPED_TEST(SmallVectorTest, ConstructorFromSpanSimpleTest) {
+  SCOPED_TRACE("ConstructorFromSpanSimpleTest");
   std::array<Constructable, 3> StdArray = {Constructable(1), Constructable(2),
                                            Constructable(3)};
-  ArrayRef<Constructable> Array = StdArray;
+  span<const Constructable> Array = StdArray;
   auto &V = this->theVector;
   V = SmallVector<Constructable, 4>(Array);
   assertValuesInOrder(V, 3u, 1, 2, 3);
@@ -1124,24 +1124,6 @@ TEST(SmallVectorTest, DefaultInlinedElements) {
   EXPECT_EQ(NestedV[0][0][0], 42);
 }
 
-TEST(SmallVectorTest, InitializerList) {
-  SmallVector<int, 2> V1 = {};
-  EXPECT_TRUE(V1.empty());
-  V1 = {0, 0};
-  EXPECT_TRUE(ArrayRef(V1).equals({0, 0}));
-  V1 = {-1, -1};
-  EXPECT_TRUE(ArrayRef(V1).equals({-1, -1}));
-
-  SmallVector<int, 2> V2 = {1, 2, 3, 4};
-  EXPECT_TRUE(ArrayRef(V2).equals({1, 2, 3, 4}));
-  V2.assign({4});
-  EXPECT_TRUE(ArrayRef(V2).equals({4}));
-  V2.append({3, 2});
-  EXPECT_TRUE(ArrayRef(V2).equals({4, 3, 2}));
-  V2.insert(V2.begin() + 1, 5);
-  EXPECT_TRUE(ArrayRef(V2).equals({4, 5, 3, 2}));
-}
-
 TEST(SmallVectorTest, ToVector) {
   {
     std::vector<char> v = {'a', 'b', 'c'};
@@ -1178,10 +1160,10 @@ private:
   To T;
 };
 
-TEST(SmallVectorTest, ConstructFromArrayRefOfConvertibleType) {
+TEST(SmallVectorTest, ConstructFromSpanOfConvertibleType) {
   To to1{1}, to2{2}, to3{3};
   std::vector<From> StdVector = {From(to1), From(to2), From(to3)};
-  ArrayRef<From> Array = StdVector;
+  span<const From> Array = StdVector;
   {
     llvm::SmallVector<To> Vector(Array);
 
diff --git a/llvm/unittests/ADT/StringMapTest.cpp b/llvm/unittests/ADT/StringMapTest.cpp
index f40f22ad140cbe7c2d2dd1ea6697cc2570ed51c3..ff68c66bd1eda0aa4fb78702875ff734557eb07d 100644
--- a/llvm/unittests/ADT/StringMapTest.cpp
+++ b/llvm/unittests/ADT/StringMapTest.cpp
@@ -7,8 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/StringMap.h"
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Support/DataTypes.h"
 #include "gtest/gtest.h"
 #include <limits>
@@ -42,10 +40,10 @@ protected:
 
     // Lookup tests
     EXPECT_EQ(0u, testMap.count(testKey));
-    EXPECT_EQ(0u, testMap.count(StringRef(testKeyFirst, testKeyLength)));
+    EXPECT_EQ(0u, testMap.count(std::string_view(testKeyFirst, testKeyLength)));
     EXPECT_EQ(0u, testMap.count(testKeyStr));
     EXPECT_TRUE(testMap.find(testKey) == testMap.end());
-    EXPECT_TRUE(testMap.find(StringRef(testKeyFirst, testKeyLength)) ==
+    EXPECT_TRUE(testMap.find(std::string_view(testKeyFirst, testKeyLength)) ==
                 testMap.end());
     EXPECT_TRUE(testMap.find(testKeyStr) == testMap.end());
   }
@@ -65,10 +63,10 @@ protected:
 
     // Lookup tests
     EXPECT_EQ(1u, testMap.count(testKey));
-    EXPECT_EQ(1u, testMap.count(StringRef(testKeyFirst, testKeyLength)));
+    EXPECT_EQ(1u, testMap.count(std::string_view(testKeyFirst, testKeyLength)));
     EXPECT_EQ(1u, testMap.count(testKeyStr));
     EXPECT_TRUE(testMap.find(testKey) == testMap.begin());
-    EXPECT_TRUE(testMap.find(StringRef(testKeyFirst, testKeyLength)) ==
+    EXPECT_TRUE(testMap.find(std::string_view(testKeyFirst, testKeyLength)) ==
                 testMap.begin());
     EXPECT_TRUE(testMap.find(testKeyStr) == testMap.begin());
   }
@@ -106,10 +104,10 @@ TEST_F(StringMapTest, ConstEmptyMapTest) {
 
   // Lookup tests
   EXPECT_EQ(0u, constTestMap.count(testKey));
-  EXPECT_EQ(0u, constTestMap.count(StringRef(testKeyFirst, testKeyLength)));
+  EXPECT_EQ(0u, constTestMap.count(std::string_view(testKeyFirst, testKeyLength)));
   EXPECT_EQ(0u, constTestMap.count(testKeyStr));
   EXPECT_TRUE(constTestMap.find(testKey) == constTestMap.end());
-  EXPECT_TRUE(constTestMap.find(StringRef(testKeyFirst, testKeyLength)) ==
+  EXPECT_TRUE(constTestMap.find(std::string_view(testKeyFirst, testKeyLength)) ==
               constTestMap.end());
   EXPECT_TRUE(constTestMap.find(testKeyStr) == constTestMap.end());
 }
@@ -237,7 +235,7 @@ TEST_F(StringMapTest, StringMapEntryTest) {
   MallocAllocator Allocator;
   StringMap<uint32_t>::value_type *entry =
       StringMap<uint32_t>::value_type::create(
-          StringRef(testKeyFirst, testKeyLength), Allocator, 1u);
+          std::string_view(testKeyFirst, testKeyLength), Allocator, 1u);
   EXPECT_STREQ(testKey, entry->first().data());
   EXPECT_EQ(1u, entry->second);
   entry->Destroy(Allocator);
@@ -247,7 +245,7 @@ TEST_F(StringMapTest, StringMapEntryTest) {
 TEST_F(StringMapTest, InsertTest) {
   SCOPED_TRACE("InsertTest");
   testMap.insert(StringMap<uint32_t>::value_type::create(
-      StringRef(testKeyFirst, testKeyLength), testMap.getAllocator(), 1u));
+      std::string_view(testKeyFirst, testKeyLength), testMap.getAllocator(), 1u));
   assertSingleItemMap();
 }
 
@@ -316,10 +314,10 @@ TEST_F(StringMapTest, IterMapKeysVector) {
   Map["C"] = 3;
   Map["D"] = 3;
 
-  std::vector<StringRef> Keys{Map.keys().begin(), Map.keys().end()};
+  std::vector<std::string_view> Keys{Map.keys().begin(), Map.keys().end()};
   llvm::sort(Keys);
 
-  std::vector<StringRef> Expected{{"A", "B", "C", "D"}};
+  std::vector<std::string_view> Expected{{"A", "B", "C", "D"}};
   EXPECT_EQ(Expected, Keys);
 }
 
@@ -333,7 +331,7 @@ TEST_F(StringMapTest, IterMapKeysSmallVector) {
   auto Keys = to_vector<4>(Map.keys());
   llvm::sort(Keys);
 
-  SmallVector<StringRef, 4> Expected = {"A", "B", "C", "D"};
+  SmallVector<std::string_view, 4> Expected = {"A", "B", "C", "D"};
   EXPECT_EQ(Expected, Keys);
 }
 
@@ -375,13 +373,13 @@ private:
 TEST_F(StringMapTest, MoveOnly) {
   StringMap<MoveOnly> t;
   t.insert(std::make_pair("Test", MoveOnly(42)));
-  StringRef Key = "Test";
+  std::string_view Key = "Test";
   StringMapEntry<MoveOnly>::create(Key, t.getAllocator(), MoveOnly(42))
       ->Destroy(t.getAllocator());
 }
 
 TEST_F(StringMapTest, CtorArg) {
-  StringRef Key = "Test";
+  std::string_view Key = "Test";
   MallocAllocator Allocator;
   StringMapEntry<MoveOnly>::create(Key, Allocator, Immovable())
       ->Destroy(Allocator);
@@ -566,7 +564,7 @@ TEST(StringMapCustomTest, InitialSizeTest) {
     CountCtorCopyAndMove::Copy = 0;
     for (int i = 0; i < Size; ++i)
       Map.insert(std::pair<std::string, CountCtorCopyAndMove>(
-          std::piecewise_construct, std::forward_as_tuple(Twine(i).str()),
+          std::piecewise_construct, std::forward_as_tuple(std::to_string(i)),
           std::forward_as_tuple(i)));
     // After the initial move, the map will move the Elts in the Entry.
     EXPECT_EQ((unsigned)Size * 2, CountCtorCopyAndMove::Move);
@@ -635,7 +633,7 @@ TEST(StringMapCustomTest, StringMapEntrySize) {
   else
     LargeValue = std::numeric_limits<unsigned>::max() + 1ULL;
   StringMapEntry<int> LargeEntry(LargeValue);
-  StringRef Key = LargeEntry.getKey();
+  std::string_view Key = LargeEntry.getKey();
   EXPECT_EQ(LargeValue, Key.size());
 
   // Test that the entry can hold at least max size_t.
diff --git a/llvm/unittests/Support/ConvertUTFTest.cpp b/llvm/unittests/Support/ConvertUTFTest.cpp
index 6e75fbae0969ba1bf0a76c4d79a123e405a8dae7..3b07d344f15a555f11ad5f8177a0a65b8a4fa472 100644
--- a/llvm/unittests/Support/ConvertUTFTest.cpp
+++ b/llvm/unittests/Support/ConvertUTFTest.cpp
@@ -7,7 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/Support/ConvertUTF.h"
-#include "llvm/ADT/ArrayRef.h"
 #include "gtest/gtest.h"
 #include <string>
 #include <vector>
@@ -17,7 +16,7 @@ using namespace llvm;
 TEST(ConvertUTFTest, ConvertUTF16LittleEndianToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF16) static const char Src[] = "\xff\xfe\xa0\x0c_\x00\xa0\x0c";
-  ArrayRef<char> Ref(Src, sizeof(Src) - 1);
+  span<const char> Ref(Src, sizeof(Src) - 1);
   std::string Result;
   bool Success = convertUTF16ToUTF8String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -29,7 +28,7 @@ TEST(ConvertUTFTest, ConvertUTF32LittleEndianToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF32) static const char Src[] =
       "\xFF\xFE\x00\x00\xA0\x0C\x00\x00\x5F\x00\x00\x00\xA0\x0C\x00\x00";
-  ArrayRef<char> Ref(Src, sizeof(Src) - 1);
+  span<const char> Ref(Src, sizeof(Src) - 1);
   std::string Result;
   bool Success = convertUTF32ToUTF8String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -40,7 +39,7 @@ TEST(ConvertUTFTest, ConvertUTF32LittleEndianToUTF8String) {
 TEST(ConvertUTFTest, ConvertUTF16BigEndianToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF16) static const char Src[] = "\xfe\xff\x0c\xa0\x00_\x0c\xa0";
-  ArrayRef<char> Ref(Src, sizeof(Src) - 1);
+  span<const char> Ref(Src, sizeof(Src) - 1);
   std::string Result;
   bool Success = convertUTF16ToUTF8String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -52,7 +51,7 @@ TEST(ConvertUTFTest, ConvertUTF32BigEndianToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF32) static const char Src[] =
       "\x00\x00\xFE\xFF\x00\x00\x0C\xA0\x00\x00\x00\x5F\x00\x00\x0C\xA0";
-  ArrayRef<char> Ref(Src, sizeof(Src) - 1);
+  span<const char> Ref(Src, sizeof(Src) - 1);
   std::string Result;
   bool Success = convertUTF32ToUTF8String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -63,7 +62,7 @@ TEST(ConvertUTFTest, ConvertUTF32BigEndianToUTF8String) {
 TEST(ConvertUTFTest, ConvertUTF8ToUTF16String) {
   // Src is the look of disapproval.
   static const char Src[] = "\xe0\xb2\xa0_\xe0\xb2\xa0";
-  StringRef Ref(Src, sizeof(Src) - 1);
+  std::string_view Ref(Src, sizeof(Src) - 1);
   SmallVector<UTF16, 5> Result;
   bool Success = convertUTF8ToUTF16String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -75,38 +74,38 @@ TEST(ConvertUTFTest, ConvertUTF8ToUTF16String) {
 
 TEST(ConvertUTFTest, OddLengthInput) {
   std::string Result;
-  bool Success = convertUTF16ToUTF8String(ArrayRef("xxxxx", 5), Result);
+  bool Success = convertUTF16ToUTF8String(span<const char>("xxxxx", 5), Result);
   EXPECT_FALSE(Success);
 }
 
 TEST(ConvertUTFTest, Empty) {
   std::string Result;
   bool Success =
-      convertUTF16ToUTF8String(llvm::ArrayRef<char>(std::nullopt), Result);
+      convertUTF16ToUTF8String(span<const char>(), Result);
   EXPECT_TRUE(Success);
   EXPECT_TRUE(Result.empty());
 }
 
 TEST(ConvertUTFTest, HasUTF16BOM) {
-  bool HasBOM = hasUTF16ByteOrderMark(ArrayRef("\xff\xfe", 2));
+  bool HasBOM = hasUTF16ByteOrderMark("\xff\xfe");
   EXPECT_TRUE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(ArrayRef("\xfe\xff", 2));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff");
   EXPECT_TRUE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(ArrayRef("\xfe\xff ", 3));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff ");
   EXPECT_TRUE(HasBOM); // Don't care about odd lengths.
-  HasBOM = hasUTF16ByteOrderMark(ArrayRef("\xfe\xff\x00asdf", 6));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff\x00asdf");
   EXPECT_TRUE(HasBOM);
 
-  HasBOM = hasUTF16ByteOrderMark(std::nullopt);
+  HasBOM = hasUTF16ByteOrderMark("");
   EXPECT_FALSE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(ArrayRef("\xfe", 1));
+  HasBOM = hasUTF16ByteOrderMark("\xfe");
   EXPECT_FALSE(HasBOM);
 }
 
 TEST(ConvertUTFTest, UTF16WrappersForConvertUTF16ToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF16) static const char Src[] = "\xff\xfe\xa0\x0c_\x00\xa0\x0c";
-  ArrayRef<UTF16> SrcRef = ArrayRef((const UTF16 *)Src, 4);
+  span<const UTF16> SrcRef((const UTF16 *)Src, 4);
   std::string Result;
   bool Success = convertUTF16ToUTF8String(SrcRef, Result);
   EXPECT_TRUE(Success);
@@ -123,7 +122,7 @@ TEST(ConvertUTFTest, ConvertUTF8toWide) {
   std::wstring Expected(L"\x0ca0_\x0ca0");
   EXPECT_EQ(Expected, Result);
   Result.clear();
-  Success = ConvertUTF8toWide(StringRef(Src, 7), Result);
+  Success = ConvertUTF8toWide(Src, Result);
   EXPECT_TRUE(Success);
   EXPECT_EQ(Expected, Result);
 }
@@ -172,7 +171,7 @@ struct ConvertUTFResultContainer {
 };
 
 std::pair<ConversionResult, std::vector<unsigned>>
-ConvertUTF8ToUnicodeScalarsLenient(StringRef S) {
+ConvertUTF8ToUnicodeScalarsLenient(std::string_view S) {
   const UTF8 *SourceStart = reinterpret_cast<const UTF8 *>(S.data());
 
   const UTF8 *SourceNext = SourceStart;
@@ -189,7 +188,7 @@ ConvertUTF8ToUnicodeScalarsLenient(StringRef S) {
 }
 
 std::pair<ConversionResult, std::vector<unsigned>>
-ConvertUTF8ToUnicodeScalarsPartialLenient(StringRef S) {
+ConvertUTF8ToUnicodeScalarsPartialLenient(std::string_view S) {
   const UTF8 *SourceStart = reinterpret_cast<const UTF8 *>(S.data());
 
   const UTF8 *SourceNext = SourceStart;
@@ -207,7 +206,7 @@ ConvertUTF8ToUnicodeScalarsPartialLenient(StringRef S) {
 
 ::testing::AssertionResult
 CheckConvertUTF8ToUnicodeScalars(ConvertUTFResultContainer Expected,
-                                 StringRef S, bool Partial = false) {
+                                 std::string_view S, bool Partial = false) {
   ConversionResult ErrorCode;
   std::vector<unsigned> Decoded;
   if (!Partial)
@@ -302,7 +301,7 @@ TEST(ConvertUTFTest, UTF8ToUTF32Lenient) {
   // U+0000 NULL
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
       ConvertUTFResultContainer(conversionOK).withScalars(0x0000),
-      StringRef("\x00", 1)));
+      std::string_view("\x00", 1)));
 
   // U+0080 PADDING CHARACTER
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
@@ -1076,7 +1075,7 @@ TEST(ConvertUTFTest, UTF8ToUTF32Lenient) {
   // U+0000 NULL
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
       ConvertUTFResultContainer(conversionOK).withScalars(0x0000),
-      StringRef("\x00", 1)));
+      std::string_view("\x00", 1)));
 
   // Overlong sequences of the above.
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
