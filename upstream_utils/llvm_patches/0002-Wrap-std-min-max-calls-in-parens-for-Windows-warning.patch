From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Sat, 7 May 2022 22:12:41 -0400
Subject: [PATCH 02/36] Wrap std::min/max calls in parens, for Windows warnings

---
 llvm/include/llvm/ADT/DenseMap.h       |  4 ++--
 llvm/include/llvm/ADT/SmallPtrSet.h    |  2 +-
 llvm/include/llvm/ADT/SmallVector.h    |  6 +++---
 llvm/include/llvm/Support/ConvertUTF.h |  2 +-
 llvm/include/llvm/Support/MathExtras.h | 20 ++++++++++----------
 5 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/llvm/include/llvm/ADT/DenseMap.h b/llvm/include/llvm/ADT/DenseMap.h
index f0f992f8eac389e36156e369ea24e0387bdf0057..4c852d2b142b4a3de76a1ce4049822cc449287f7 100644
--- a/llvm/include/llvm/ADT/DenseMap.h
+++ b/llvm/include/llvm/ADT/DenseMap.h
@@ -400,7 +400,7 @@ protected:
       return 0;
     // +1 is required because of the strict equality.
     // For example if NumEntries is 48, we need to return 401.
-    return NextPowerOf2(NumEntries * 4 / 3 + 1);
+    return static_cast<unsigned>(NextPowerOf2(NumEntries * 4 / 3 + 1));
   }
 
   void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {
@@ -837,7 +837,7 @@ public:
     // Reduce the number of buckets.
     unsigned NewNumBuckets = 0;
     if (OldNumEntries)
-      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));
+      NewNumBuckets = (std::max)(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));
     if (NewNumBuckets == NumBuckets) {
       this->BaseT::initEmpty();
       return;
diff --git a/llvm/include/llvm/ADT/SmallPtrSet.h b/llvm/include/llvm/ADT/SmallPtrSet.h
index cf6abc9129b40eed6749213eb23439ec91621005..9115fc74363a9cccd0579427d88fa9edf5baae1b 100644
--- a/llvm/include/llvm/ADT/SmallPtrSet.h
+++ b/llvm/include/llvm/ADT/SmallPtrSet.h
@@ -126,7 +126,7 @@ public:
     size_type NewSize = NumEntries + (NumEntries / 3);
     NewSize = 1 << (Log2_32_Ceil(NewSize) + 1);
     // Like insert_imp_big, always allocate at least 128 elements.
-    NewSize = std::max(128u, NewSize);
+    NewSize = (std::max)(128u, NewSize);
     Grow(NewSize);
   }
 
diff --git a/llvm/include/llvm/ADT/SmallVector.h b/llvm/include/llvm/ADT/SmallVector.h
index be06bb817e24e723265f9a8038d94123de1fc53c..2232b741d5359a129adb0e5b3f0f70110c38e90d 100644
--- a/llvm/include/llvm/ADT/SmallVector.h
+++ b/llvm/include/llvm/ADT/SmallVector.h
@@ -55,7 +55,7 @@ protected:
 
   /// The maximum value of the Size_T used.
   static constexpr size_t SizeTypeMax() {
-    return std::numeric_limits<Size_T>::max();
+    return (std::numeric_limits<Size_T>::max)();
   }
 
   SmallVectorBase() = delete;
@@ -276,7 +276,7 @@ public:
 
   size_type size_in_bytes() const { return size() * sizeof(T); }
   size_type max_size() const {
-    return std::min(this->SizeTypeMax(), size_type(-1) / sizeof(T));
+    return (std::min)(this->SizeTypeMax(), size_type(-1) / sizeof(T));
   }
 
   size_t capacity_in_bytes() const { return capacity() * sizeof(T); }
@@ -708,7 +708,7 @@ public:
     }
 
     // Assign over existing elements.
-    std::fill_n(this->begin(), std::min(NumElts, this->size()), Elt);
+    std::fill_n(this->begin(), (std::min)(NumElts, this->size()), Elt);
     if (NumElts > this->size())
       std::uninitialized_fill_n(this->end(), NumElts - this->size(), Elt);
     else if (NumElts < this->size())
diff --git a/llvm/include/llvm/Support/ConvertUTF.h b/llvm/include/llvm/Support/ConvertUTF.h
index 5c0e3009c25446a34882fb98329b1d955231bb39..72321022beb373945f7935ed72944fd68eb7d02f 100644
--- a/llvm/include/llvm/Support/ConvertUTF.h
+++ b/llvm/include/llvm/Support/ConvertUTF.h
@@ -127,7 +127,7 @@ namespace llvm {
 typedef unsigned int    UTF32;  /* at least 32 bits */
 typedef unsigned short  UTF16;  /* at least 16 bits */
 typedef unsigned char   UTF8;   /* typically 8 bits */
-typedef unsigned char   Boolean; /* 0 or 1 */
+typedef bool   Boolean; /* 0 or 1 */
 
 /* Some fundamental constants */
 #define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD
diff --git a/llvm/include/llvm/Support/MathExtras.h b/llvm/include/llvm/Support/MathExtras.h
index 5a6f51adc07f3976bdf8f3412bdb119b220a0e9b..5db59bb848024fca622b2919efd773d185a93f1e 100644
--- a/llvm/include/llvm/Support/MathExtras.h
+++ b/llvm/include/llvm/Support/MathExtras.h
@@ -339,26 +339,26 @@ template <> constexpr size_t CTLog2<1>() { return 0; }
 /// (32 bit edition.)
 /// Ex. Log2_32(32) == 5, Log2_32(1) == 0, Log2_32(0) == -1, Log2_32(6) == 2
 inline unsigned Log2_32(uint32_t Value) {
-  return 31 - llvm::countl_zero(Value);
+  return static_cast<unsigned>(31 - llvm::countl_zero(Value));
 }
 
 /// Return the floor log base 2 of the specified value, -1 if the value is zero.
 /// (64 bit edition.)
 inline unsigned Log2_64(uint64_t Value) {
-  return 63 - llvm::countl_zero(Value);
+  return static_cast<unsigned>(63 - llvm::countl_zero(Value));
 }
 
 /// Return the ceil log base 2 of the specified value, 32 if the value is zero.
 /// (32 bit edition).
 /// Ex. Log2_32_Ceil(32) == 5, Log2_32_Ceil(1) == 0, Log2_32_Ceil(6) == 3
 inline unsigned Log2_32_Ceil(uint32_t Value) {
-  return 32 - llvm::countl_zero(Value - 1);
+  return static_cast<unsigned>(32 - llvm::countl_zero(Value - 1));
 }
 
 /// Return the ceil log base 2 of the specified value, 64 if the value is zero.
 /// (64 bit edition.)
 inline unsigned Log2_64_Ceil(uint64_t Value) {
-  return 64 - llvm::countl_zero(Value - 1);
+  return static_cast<unsigned>(64 - llvm::countl_zero(Value - 1));
 }
 
 /// A and B are either alignments or offsets. Return the minimum alignment that
@@ -418,7 +418,7 @@ constexpr uint64_t divideCeil(uint64_t Numerator, uint64_t Denominator) {
 // happens only when Numerator = INT_MIN and Denominator = -1.
 template <typename U, typename V>
 constexpr bool divideSignedWouldOverflow(U Numerator, V Denominator) {
-  return Numerator == std::numeric_limits<U>::min() && Denominator == -1;
+  return Numerator == (std::numeric_limits<U>::min)() && Denominator == -1;
 }
 
 /// Returns the integer ceil(Numerator / Denominator). Signed version.
@@ -614,7 +614,7 @@ SaturatingAdd(T X, T Y, bool *ResultOverflowed = nullptr) {
   T Z = X + Y;
   Overflowed = (Z < X || Z < Y);
   if (Overflowed)
-    return std::numeric_limits<T>::max();
+    return (std::numeric_limits<T>::max)();
   else
     return Z;
 }
@@ -627,7 +627,7 @@ std::enable_if_t<std::is_unsigned_v<T>, T> SaturatingAdd(T X, T Y, T Z,
   bool Overflowed = false;
   T XY = SaturatingAdd(X, Y, &Overflowed);
   if (Overflowed)
-    return SaturatingAdd(std::numeric_limits<T>::max(), T(1), Args...);
+    return SaturatingAdd((std::numeric_limits<T>::max)(), T(1), Args...);
   return SaturatingAdd(XY, Z, Args...);
 }
 
@@ -651,7 +651,7 @@ SaturatingMultiply(T X, T Y, bool *ResultOverflowed = nullptr) {
   // Special case: if X or Y is 0, Log2_64 gives -1, and Log2Z
   // will necessarily be less than Log2Max as desired.
   int Log2Z = Log2_64(X) + Log2_64(Y);
-  const T Max = std::numeric_limits<T>::max();
+  const T Max = (std::numeric_limits<T>::max)();
   int Log2Max = Log2_64(Max);
   if (Log2Z < Log2Max) {
     return X * Y;
@@ -773,9 +773,9 @@ std::enable_if_t<std::is_signed_v<T>, T> MulOverflow(T X, T Y, T &Result) {
   // Check how the max allowed absolute value (2^n for negative, 2^(n-1) for
   // positive) divided by an argument compares to the other.
   if (IsNegative)
-    return UX > (static_cast<U>(std::numeric_limits<T>::max()) + U(1)) / UY;
+    return UX > (static_cast<U>((std::numeric_limits<T>::max)()) + U(1)) / UY;
   else
-    return UX > (static_cast<U>(std::numeric_limits<T>::max())) / UY;
+    return UX > (static_cast<U>((std::numeric_limits<T>::max)())) / UY;
 #endif
 }
 
