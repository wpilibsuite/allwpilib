From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tyler Veness <calcmogul@gmail.com>
Date: Sat, 12 Apr 2025 16:28:47 -0700
Subject: [PATCH 8/8] Revert "Use multidimensional array subscript operator
 (#843)"

This reverts commit f9b2c450bbbf6f14b194b8b81708d032a6431ee0.
---
 include/sleipnir/autodiff/hessian.hpp         |   4 +-
 include/sleipnir/autodiff/jacobian.hpp        |   4 +-
 include/sleipnir/autodiff/variable.hpp        |  27 +--
 include/sleipnir/autodiff/variable_block.hpp  |  72 ++++----
 include/sleipnir/autodiff/variable_matrix.hpp | 166 ++++++++----------
 include/sleipnir/optimization/ocp.hpp         |  14 +-
 include/sleipnir/optimization/problem.hpp     |   6 +-
 7 files changed, 131 insertions(+), 162 deletions(-)

diff --git a/include/sleipnir/autodiff/hessian.hpp b/include/sleipnir/autodiff/hessian.hpp
index f187d7f7ee141b0ed9ce46b4078658fa8a2e4107..008e35b82d29d9ef2bd4836f9239b84f50400b86 100644
--- a/include/sleipnir/autodiff/hessian.hpp
+++ b/include/sleipnir/autodiff/hessian.hpp
@@ -106,9 +106,9 @@ class Hessian {
       auto grad = m_graphs[row].generate_gradient_tree(m_wrt);
       for (int col = 0; col < m_wrt.rows(); ++col) {
         if (grad[col].expr != nullptr) {
-          result[row, col] = std::move(grad[col]);
+          result(row, col) = std::move(grad[col]);
         } else {
-          result[row, col] = Variable{Scalar(0)};
+          result(row, col) = Variable{Scalar(0)};
         }
       }
     }
diff --git a/include/sleipnir/autodiff/jacobian.hpp b/include/sleipnir/autodiff/jacobian.hpp
index 9d201da9f8981b332bb5d03a3302283b0deae21f..74ecbd712481120a1122a9c58c18c57ae567d3e6 100644
--- a/include/sleipnir/autodiff/jacobian.hpp
+++ b/include/sleipnir/autodiff/jacobian.hpp
@@ -114,9 +114,9 @@ class Jacobian {
       auto grad = m_graphs[row].generate_gradient_tree(m_wrt);
       for (int col = 0; col < m_wrt.rows(); ++col) {
         if (grad[col].expr != nullptr) {
-          result[row, col] = std::move(grad[col]);
+          result(row, col) = std::move(grad[col]);
         } else {
-          result[row, col] = Variable{Scalar(0)};
+          result(row, col) = Variable{Scalar(0)};
         }
       }
     }
diff --git a/include/sleipnir/autodiff/variable.hpp b/include/sleipnir/autodiff/variable.hpp
index 7923585de3ebad6503ceeeface6855a4b6af7236..93f68231d92bd4191d9337c1dc413d2e0cecdf4c 100644
--- a/include/sleipnir/autodiff/variable.hpp
+++ b/include/sleipnir/autodiff/variable.hpp
@@ -80,7 +80,7 @@ class Variable : public SleipnirBase {
    * @param value The value of the Variable.
    */
   // NOLINTNEXTLINE (google-explicit-constructor)
-  Variable(SleipnirMatrixLike<Scalar> auto value) : expr{value[0, 0].expr} {
+  Variable(SleipnirMatrixLike<Scalar> auto value) : expr{value(0, 0).expr} {
     slp_assert(value.rows() == 1 && value.cols() == 1);
   }
 
@@ -740,11 +740,7 @@ auto make_constraints(LHS&& lhs, RHS&& rhs) {
   for (int row = 0; row < rhs.rows(); ++row) {
     for (int col = 0; col < rhs.cols(); ++col) {
       // Make right-hand side zero
-      if constexpr (EigenMatrixLike<decltype(rhs)>) {
-        constraints.emplace_back(lhs - rhs(row, col));
-      } else {
-        constraints.emplace_back(lhs - rhs[row, col]);
-      }
+      constraints.emplace_back(lhs - rhs(row, col));
     }
   }
 
@@ -760,11 +756,7 @@ auto make_constraints(LHS&& lhs, RHS&& rhs) {
   for (int row = 0; row < lhs.rows(); ++row) {
     for (int col = 0; col < lhs.cols(); ++col) {
       // Make right-hand side zero
-      if constexpr (EigenMatrixLike<decltype(lhs)>) {
-        constraints.emplace_back(lhs(row, col) - rhs);
-      } else {
-        constraints.emplace_back(lhs[row, col] - rhs);
-      }
+      constraints.emplace_back(lhs(row, col) - rhs);
     }
   }
 
@@ -782,18 +774,7 @@ auto make_constraints(LHS&& lhs, RHS&& rhs) {
   for (int row = 0; row < lhs.rows(); ++row) {
     for (int col = 0; col < lhs.cols(); ++col) {
       // Make right-hand side zero
-      if constexpr (EigenMatrixLike<LHS> && EigenMatrixLike<RHS>) {
-        constraints.emplace_back(lhs(row, col) - rhs(row, col));
-      } else if constexpr (EigenMatrixLike<LHS> &&
-                           SleipnirMatrixLike<RHS, Scalar>) {
-        constraints.emplace_back(lhs(row, col) - rhs[row, col]);
-      } else if constexpr (SleipnirMatrixLike<LHS, Scalar> &&
-                           EigenMatrixLike<RHS>) {
-        constraints.emplace_back(lhs[row, col] - rhs(row, col));
-      } else if constexpr (SleipnirMatrixLike<LHS, Scalar> &&
-                           SleipnirMatrixLike<RHS, Scalar>) {
-        constraints.emplace_back(lhs[row, col] - rhs[row, col]);
-      }
+      constraints.emplace_back(lhs(row, col) - rhs(row, col));
     }
   }
 
diff --git a/include/sleipnir/autodiff/variable_block.hpp b/include/sleipnir/autodiff/variable_block.hpp
index 87b047bf7f5df24594e44edc3b24c10b5a192baa..c5351fec9f18f47e2fdfd724699036165c5b8506 100644
--- a/include/sleipnir/autodiff/variable_block.hpp
+++ b/include/sleipnir/autodiff/variable_block.hpp
@@ -57,7 +57,7 @@ class VariableBlock : public SleipnirBase {
 
       for (int row = 0; row < rows(); ++row) {
         for (int col = 0; col < cols(); ++col) {
-          (*this)[row, col] = values[row, col];
+          (*this)(row, col) = values(row, col);
         }
       }
     }
@@ -92,7 +92,7 @@ class VariableBlock : public SleipnirBase {
 
       for (int row = 0; row < rows(); ++row) {
         for (int col = 0; col < cols(); ++col) {
-          (*this)[row, col] = values[row, col];
+          (*this)(row, col) = values(row, col);
         }
       }
     }
@@ -155,7 +155,7 @@ class VariableBlock : public SleipnirBase {
   VariableBlock<Mat>& operator=(ScalarLike auto value) {
     slp_assert(rows() == 1 && cols() == 1);
 
-    (*this)[0, 0] = value;
+    (*this)(0, 0) = value;
 
     return *this;
   }
@@ -170,7 +170,7 @@ class VariableBlock : public SleipnirBase {
   void set_value(Scalar value) {
     slp_assert(rows() == 1 && cols() == 1);
 
-    (*this)[0, 0].set_value(value);
+    (*this)(0, 0).set_value(value);
   }
 
   /**
@@ -185,7 +185,7 @@ class VariableBlock : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] = values(row, col);
+        (*this)(row, col) = values(row, col);
       }
     }
 
@@ -204,7 +204,7 @@ class VariableBlock : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col].set_value(values(row, col));
+        (*this)(row, col).set_value(values(row, col));
       }
     }
   }
@@ -220,7 +220,7 @@ class VariableBlock : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] = values[row, col];
+        (*this)(row, col) = values(row, col);
       }
     }
     return *this;
@@ -237,7 +237,7 @@ class VariableBlock : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] = std::move(values[row, col]);
+        (*this)(row, col) = std::move(values(row, col));
       }
     }
     return *this;
@@ -250,13 +250,13 @@ class VariableBlock : public SleipnirBase {
    * @param col The scalar subblock's column.
    * @return A scalar subblock at the given row and column.
    */
-  Variable<Scalar>& operator[](int row, int col)
+  Variable<Scalar>& operator()(int row, int col)
     requires(!std::is_const_v<Mat>)
   {
     slp_assert(row >= 0 && row < rows());
     slp_assert(col >= 0 && col < cols());
-    return (*m_mat)[m_row_slice.start + row * m_row_slice.step,
-                    m_col_slice.start + col * m_col_slice.step];
+    return (*m_mat)(m_row_slice.start + row * m_row_slice.step,
+                    m_col_slice.start + col * m_col_slice.step);
   }
 
   /**
@@ -266,11 +266,11 @@ class VariableBlock : public SleipnirBase {
    * @param col The scalar subblock's column.
    * @return A scalar subblock at the given row and column.
    */
-  const Variable<Scalar>& operator[](int row, int col) const {
+  const Variable<Scalar>& operator()(int row, int col) const {
     slp_assert(row >= 0 && row < rows());
     slp_assert(col >= 0 && col < cols());
-    return (*m_mat)[m_row_slice.start + row * m_row_slice.step,
-                    m_col_slice.start + col * m_col_slice.step];
+    return (*m_mat)(m_row_slice.start + row * m_row_slice.step,
+                    m_col_slice.start + col * m_col_slice.step);
   }
 
   /**
@@ -283,7 +283,7 @@ class VariableBlock : public SleipnirBase {
     requires(!std::is_const_v<Mat>)
   {
     slp_assert(index >= 0 && index < rows() * cols());
-    return (*this)[index / cols(), index % cols()];
+    return (*this)(index / cols(), index % cols());
   }
 
   /**
@@ -294,7 +294,7 @@ class VariableBlock : public SleipnirBase {
    */
   const Variable<Scalar>& operator[](int index) const {
     slp_assert(index >= 0 && index < rows() * cols());
-    return (*this)[index / cols(), index % cols()];
+    return (*this)(index / cols(), index % cols());
   }
 
   /**
@@ -312,8 +312,8 @@ class VariableBlock : public SleipnirBase {
     slp_assert(col_offset >= 0 && col_offset <= cols());
     slp_assert(block_rows >= 0 && block_rows <= rows() - row_offset);
     slp_assert(block_cols >= 0 && block_cols <= cols() - col_offset);
-    return (*this)[Slice{row_offset, row_offset + block_rows, 1},
-                   Slice{col_offset, col_offset + block_cols, 1}];
+    return (*this)({row_offset, row_offset + block_rows, 1},
+                   {col_offset, col_offset + block_cols, 1});
   }
 
   /**
@@ -331,8 +331,8 @@ class VariableBlock : public SleipnirBase {
     slp_assert(col_offset >= 0 && col_offset <= cols());
     slp_assert(block_rows >= 0 && block_rows <= rows() - row_offset);
     slp_assert(block_cols >= 0 && block_cols <= cols() - col_offset);
-    return (*this)[Slice{row_offset, row_offset + block_rows, 1},
-                   Slice{col_offset, col_offset + block_cols, 1}];
+    return (*this)({row_offset, row_offset + block_rows, 1},
+                   {col_offset, col_offset + block_cols, 1});
   }
 
   /**
@@ -342,10 +342,10 @@ class VariableBlock : public SleipnirBase {
    * @param col_slice The column slice.
    * @return A slice of the variable matrix.
    */
-  VariableBlock<Mat> operator[](Slice row_slice, Slice col_slice) {
+  VariableBlock<Mat> operator()(Slice row_slice, Slice col_slice) {
     int row_slice_length = row_slice.adjust(m_row_slice_length);
     int col_slice_length = col_slice.adjust(m_col_slice_length);
-    return (*this)[row_slice, row_slice_length, col_slice, col_slice_length];
+    return (*this)(row_slice, row_slice_length, col_slice, col_slice_length);
   }
 
   /**
@@ -355,11 +355,11 @@ class VariableBlock : public SleipnirBase {
    * @param col_slice The column slice.
    * @return A slice of the variable matrix.
    */
-  const VariableBlock<const Mat> operator[](Slice row_slice,
+  const VariableBlock<const Mat> operator()(Slice row_slice,
                                             Slice col_slice) const {
     int row_slice_length = row_slice.adjust(m_row_slice_length);
     int col_slice_length = col_slice.adjust(m_col_slice_length);
-    return (*this)[row_slice, row_slice_length, col_slice, col_slice_length];
+    return (*this)(row_slice, row_slice_length, col_slice, col_slice_length);
   }
 
   /**
@@ -374,7 +374,7 @@ class VariableBlock : public SleipnirBase {
    * @param col_slice_length The column slice length.
    * @return A slice of the variable matrix.
    */
-  VariableBlock<Mat> operator[](Slice row_slice, int row_slice_length,
+  VariableBlock<Mat> operator()(Slice row_slice, int row_slice_length,
                                 Slice col_slice, int col_slice_length) {
     return VariableBlock{
         *m_mat,
@@ -400,7 +400,7 @@ class VariableBlock : public SleipnirBase {
    * @param col_slice_length The column slice length.
    * @return A slice of the variable matrix.
    */
-  const VariableBlock<const Mat> operator[](Slice row_slice,
+  const VariableBlock<const Mat> operator()(Slice row_slice,
                                             int row_slice_length,
                                             Slice col_slice,
                                             int col_slice_length) const {
@@ -519,7 +519,7 @@ class VariableBlock : public SleipnirBase {
   VariableBlock<Mat>& operator*=(const ScalarLike auto& rhs) {
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] *= rhs;
+        (*this)(row, col) *= rhs;
       }
     }
 
@@ -537,7 +537,7 @@ class VariableBlock : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] /= rhs[0, 0];
+        (*this)(row, col) /= rhs(0, 0);
       }
     }
 
@@ -553,7 +553,7 @@ class VariableBlock : public SleipnirBase {
   VariableBlock<Mat>& operator/=(const ScalarLike auto& rhs) {
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] /= rhs;
+        (*this)(row, col) /= rhs;
       }
     }
 
@@ -571,7 +571,7 @@ class VariableBlock : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] += rhs[row, col];
+        (*this)(row, col) += rhs(row, col);
       }
     }
 
@@ -589,7 +589,7 @@ class VariableBlock : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] += rhs;
+        (*this)(row, col) += rhs;
       }
     }
 
@@ -607,7 +607,7 @@ class VariableBlock : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] -= rhs[row, col];
+        (*this)(row, col) -= rhs(row, col);
       }
     }
 
@@ -625,7 +625,7 @@ class VariableBlock : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] -= rhs;
+        (*this)(row, col) -= rhs;
       }
     }
 
@@ -651,7 +651,7 @@ class VariableBlock : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        result[col, row] = (*this)[row, col];
+        result(col, row) = (*this)(row, col);
       }
     }
 
@@ -679,7 +679,7 @@ class VariableBlock : public SleipnirBase {
    * @param col The column of the element to return.
    * @return An element of the variable matrix.
    */
-  Scalar value(int row, int col) { return (*this)[row, col].value(); }
+  Scalar value(int row, int col) { return (*this)(row, col).value(); }
 
   /**
    * Returns an element of the variable block.
@@ -723,7 +723,7 @@ class VariableBlock : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        result[row, col] = unary_op((*this)[row, col]);
+        result(row, col) = unary_op((*this)(row, col));
       }
     }
 
diff --git a/include/sleipnir/autodiff/variable_matrix.hpp b/include/sleipnir/autodiff/variable_matrix.hpp
index 4e386abfe0436cebbd2386275ab2a89e867d4786..55788ce18fcfaa8631ea46b021ee867024ecddb2 100644
--- a/include/sleipnir/autodiff/variable_matrix.hpp
+++ b/include/sleipnir/autodiff/variable_matrix.hpp
@@ -232,7 +232,7 @@ class VariableMatrix : public SleipnirBase {
     m_storage.reserve(rows() * cols());
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        m_storage.emplace_back(values[row, col]);
+        m_storage.emplace_back(values(row, col));
       }
     }
   }
@@ -248,7 +248,7 @@ class VariableMatrix : public SleipnirBase {
     m_storage.reserve(rows() * cols());
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        m_storage.emplace_back(values[row, col]);
+        m_storage.emplace_back(values(row, col));
       }
     }
   }
@@ -298,7 +298,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < values.rows(); ++row) {
       for (int col = 0; col < values.cols(); ++col) {
-        (*this)[row, col] = values(row, col);
+        (*this)(row, col) = values(row, col);
       }
     }
 
@@ -316,7 +316,7 @@ class VariableMatrix : public SleipnirBase {
   VariableMatrix& operator=(ScalarLike auto value) {
     slp_assert(rows() == 1 && cols() == 1);
 
-    (*this)[0, 0] = value;
+    (*this)(0, 0) = value;
 
     return *this;
   }
@@ -333,7 +333,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < values.rows(); ++row) {
       for (int col = 0; col < values.cols(); ++col) {
-        (*this)[row, col].set_value(values(row, col));
+        (*this)(row, col).set_value(values(row, col));
       }
     }
   }
@@ -345,7 +345,7 @@ class VariableMatrix : public SleipnirBase {
    * @param col The column.
    * @return The element at the given row and column.
    */
-  Variable<Scalar>& operator[](int row, int col) {
+  Variable<Scalar>& operator()(int row, int col) {
     slp_assert(row >= 0 && row < rows());
     slp_assert(col >= 0 && col < cols());
     return m_storage[row * cols() + col];
@@ -358,7 +358,7 @@ class VariableMatrix : public SleipnirBase {
    * @param col The column.
    * @return The element at the given row and column.
    */
-  const Variable<Scalar>& operator[](int row, int col) const {
+  const Variable<Scalar>& operator()(int row, int col) const {
     slp_assert(row >= 0 && row < rows());
     slp_assert(col >= 0 && col < cols());
     return m_storage[row * cols() + col];
@@ -431,7 +431,7 @@ class VariableMatrix : public SleipnirBase {
    * @param col_slice The column slice.
    * @return A slice of the variable matrix.
    */
-  VariableBlock<VariableMatrix> operator[](Slice row_slice, Slice col_slice) {
+  VariableBlock<VariableMatrix> operator()(Slice row_slice, Slice col_slice) {
     int row_slice_length = row_slice.adjust(rows());
     int col_slice_length = col_slice.adjust(cols());
     return VariableBlock{*this, std::move(row_slice), row_slice_length,
@@ -445,7 +445,7 @@ class VariableMatrix : public SleipnirBase {
    * @param col_slice The column slice.
    * @return A slice of the variable matrix.
    */
-  const VariableBlock<const VariableMatrix> operator[](Slice row_slice,
+  const VariableBlock<const VariableMatrix> operator()(Slice row_slice,
                                                        Slice col_slice) const {
     int row_slice_length = row_slice.adjust(rows());
     int col_slice_length = col_slice.adjust(cols());
@@ -466,7 +466,7 @@ class VariableMatrix : public SleipnirBase {
    * @return A slice of the variable matrix.
    *
    */
-  VariableBlock<VariableMatrix> operator[](Slice row_slice,
+  VariableBlock<VariableMatrix> operator()(Slice row_slice,
                                            int row_slice_length,
                                            Slice col_slice,
                                            int col_slice_length) {
@@ -486,7 +486,7 @@ class VariableMatrix : public SleipnirBase {
    * @param col_slice_length The column slice length.
    * @return A slice of the variable matrix.
    */
-  const VariableBlock<const VariableMatrix> operator[](
+  const VariableBlock<const VariableMatrix> operator()(
       Slice row_slice, int row_slice_length, Slice col_slice,
       int col_slice_length) const {
     return VariableBlock{*this, std::move(row_slice), row_slice_length,
@@ -586,9 +586,9 @@ class VariableMatrix : public SleipnirBase {
       for (int j = 0; j < rhs.cols(); ++j) {
         Variable sum{Scalar(0)};
         for (int k = 0; k < lhs.cols(); ++k) {
-          sum += lhs(i, k) * rhs[k, j];
+          sum += lhs(i, k) * rhs(k, j);
         }
-        result[i, j] = sum;
+        result(i, j) = sum;
       }
     }
 
@@ -611,9 +611,9 @@ class VariableMatrix : public SleipnirBase {
       for (int j = 0; j < rhs.cols(); ++j) {
         Variable sum{Scalar(0)};
         for (int k = 0; k < lhs.cols(); ++k) {
-          sum += lhs[i, k] * rhs(k, j);
+          sum += lhs(i, k) * rhs(k, j);
         }
-        result[i, j] = sum;
+        result(i, j) = sum;
       }
     }
 
@@ -636,9 +636,9 @@ class VariableMatrix : public SleipnirBase {
       for (int j = 0; j < rhs.cols(); ++j) {
         Variable sum{Scalar(0)};
         for (int k = 0; k < lhs.cols(); ++k) {
-          sum += lhs[i, k] * rhs[k, j];
+          sum += lhs(i, k) * rhs(k, j);
         }
-        result[i, j] = sum;
+        result(i, j) = sum;
       }
     }
 #if __GNUC__ >= 12
@@ -661,7 +661,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = lhs(row, col) * rhs;
+        result(row, col) = lhs(row, col) * rhs;
       }
     }
 
@@ -680,7 +680,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = lhs[row, col] * rhs;
+        result(row, col) = lhs(row, col) * rhs;
       }
     }
 
@@ -700,7 +700,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = rhs(row, col) * lhs;
+        result(row, col) = rhs(row, col) * lhs;
       }
     }
 
@@ -719,7 +719,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = rhs[row, col] * lhs;
+        result(row, col) = rhs(row, col) * lhs;
       }
     }
 
@@ -739,13 +739,9 @@ class VariableMatrix : public SleipnirBase {
       for (int j = 0; j < rhs.cols(); ++j) {
         Variable sum{Scalar(0)};
         for (int k = 0; k < cols(); ++k) {
-          if constexpr (SleipnirMatrixLike<decltype(rhs), Scalar>) {
-            sum += (*this)[i, k] * rhs[k, j];
-          } else {
-            sum += (*this)[i, k] * rhs(k, j);
-          }
+          sum += (*this)(i, k) * rhs(k, j);
         }
-        (*this)[i, j] = sum;
+        (*this)(i, j) = sum;
       }
     }
 
@@ -761,7 +757,7 @@ class VariableMatrix : public SleipnirBase {
   VariableMatrix& operator*=(const ScalarLike auto& rhs) {
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < rhs.cols(); ++col) {
-        (*this)[row, col] *= rhs;
+        (*this)(row, col) *= rhs;
       }
     }
 
@@ -782,7 +778,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = lhs(row, col) / rhs;
+        result(row, col) = lhs(row, col) / rhs;
       }
     }
 
@@ -803,7 +799,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = lhs[row, col] / rhs;
+        result(row, col) = lhs(row, col) / rhs;
       }
     }
 
@@ -824,7 +820,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = lhs[row, col] / rhs;
+        result(row, col) = lhs(row, col) / rhs;
       }
     }
 
@@ -840,7 +836,7 @@ class VariableMatrix : public SleipnirBase {
   VariableMatrix& operator/=(const ScalarLike auto& rhs) {
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] /= rhs;
+        (*this)(row, col) /= rhs;
       }
     }
 
@@ -862,7 +858,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = lhs(row, col) + rhs[row, col];
+        result(row, col) = lhs(row, col) + rhs(row, col);
       }
     }
 
@@ -884,7 +880,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = lhs[row, col] + rhs(row, col);
+        result(row, col) = lhs(row, col) + rhs(row, col);
       }
     }
 
@@ -906,7 +902,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = lhs[row, col] + rhs[row, col];
+        result(row, col) = lhs(row, col) + rhs(row, col);
       }
     }
 
@@ -924,11 +920,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        if constexpr (SleipnirMatrixLike<decltype(rhs), Scalar>) {
-          (*this)[row, col] += rhs[row, col];
-        } else {
-          (*this)[row, col] += rhs(row, col);
-        }
+        (*this)(row, col) += rhs(row, col);
       }
     }
 
@@ -946,7 +938,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] += rhs;
+        (*this)(row, col) += rhs;
       }
     }
 
@@ -968,7 +960,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = lhs(row, col) - rhs[row, col];
+        result(row, col) = lhs(row, col) - rhs(row, col);
       }
     }
 
@@ -990,7 +982,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = lhs[row, col] - rhs(row, col);
+        result(row, col) = lhs(row, col) - rhs(row, col);
       }
     }
 
@@ -1012,7 +1004,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = lhs[row, col] - rhs[row, col];
+        result(row, col) = lhs(row, col) - rhs(row, col);
       }
     }
 
@@ -1030,11 +1022,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        if constexpr (SleipnirMatrixLike<decltype(rhs), Scalar>) {
-          (*this)[row, col] -= rhs[row, col];
-        } else {
-          (*this)[row, col] -= rhs(row, col);
-        }
+        (*this)(row, col) -= rhs(row, col);
       }
     }
 
@@ -1052,7 +1040,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        (*this)[row, col] -= rhs;
+        (*this)(row, col) -= rhs;
       }
     }
 
@@ -1070,7 +1058,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < result.rows(); ++row) {
       for (int col = 0; col < result.cols(); ++col) {
-        result[row, col] = -lhs[row, col];
+        result(row, col) = -lhs(row, col);
       }
     }
 
@@ -1083,7 +1071,7 @@ class VariableMatrix : public SleipnirBase {
   // NOLINTNEXTLINE (google-explicit-constructor)
   operator Variable<Scalar>() const {
     slp_assert(rows() == 1 && cols() == 1);
-    return (*this)[0, 0];
+    return (*this)(0, 0);
   }
 
   /**
@@ -1096,7 +1084,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        result[col, row] = (*this)[row, col];
+        result(col, row) = (*this)(row, col);
       }
     }
 
@@ -1124,7 +1112,7 @@ class VariableMatrix : public SleipnirBase {
    * @param col The column of the element to return.
    * @return An element of the variable matrix.
    */
-  Scalar value(int row, int col) { return (*this)[row, col].value(); }
+  Scalar value(int row, int col) { return (*this)(row, col).value(); }
 
   /**
    * Returns an element of the variable matrix.
@@ -1165,7 +1153,7 @@ class VariableMatrix : public SleipnirBase {
 
     for (int row = 0; row < rows(); ++row) {
       for (int col = 0; col < cols(); ++col) {
-        result[row, col] = unary_op((*this)[row, col]);
+        result(row, col) = unary_op((*this)(row, col));
       }
     }
 
@@ -1434,7 +1422,7 @@ VariableMatrix<Scalar> cwise_reduce(
 
   for (int row = 0; row < lhs.rows(); ++row) {
     for (int col = 0; col < lhs.cols(); ++col) {
-      result[row, col] = binary_op(lhs[row, col], rhs[row, col]);
+      result(row, col) = binary_op(lhs(row, col), rhs(row, col));
     }
   }
 
@@ -1573,17 +1561,17 @@ VariableMatrix<Scalar> solve(const VariableMatrix<Scalar>& A,
 
   if (A.rows() == 1 && A.cols() == 1) {
     // Compute optimal inverse instead of using Eigen's general solver
-    return B[0, 0] / A[0, 0];
+    return B(0, 0) / A(0, 0);
   } else if (A.rows() == 2 && A.cols() == 2) {
     // Compute optimal inverse instead of using Eigen's general solver
     //
     // [a  b]⁻¹  ___1___ [ d  −b]
     // [c  d]  = ad − bc [−c   a]
 
-    const auto& a = A[0, 0];
-    const auto& b = A[0, 1];
-    const auto& c = A[1, 0];
-    const auto& d = A[1, 1];
+    const auto& a = A(0, 0);
+    const auto& b = A(0, 1);
+    const auto& c = A(1, 0);
+    const auto& d = A(1, 1);
 
     VariableMatrix adj_A{{d, -b}, {-c, a}};
     auto det_A = a * d - b * c;
@@ -1600,15 +1588,15 @@ VariableMatrix<Scalar> solve(const VariableMatrix<Scalar>& A,
     //
     // https://www.wolframalpha.com/input?i=inverse+%7B%7Ba%2C+b%2C+c%7D%2C+%7Bd%2C+e%2C+f%7D%2C+%7Bg%2C+h%2C+i%7D%7D
 
-    const auto& a = A[0, 0];
-    const auto& b = A[0, 1];
-    const auto& c = A[0, 2];
-    const auto& d = A[1, 0];
-    const auto& e = A[1, 1];
-    const auto& f = A[1, 2];
-    const auto& g = A[2, 0];
-    const auto& h = A[2, 1];
-    const auto& i = A[2, 2];
+    const auto& a = A(0, 0);
+    const auto& b = A(0, 1);
+    const auto& c = A(0, 2);
+    const auto& d = A(1, 0);
+    const auto& e = A(1, 1);
+    const auto& f = A(1, 2);
+    const auto& g = A(2, 0);
+    const auto& h = A(2, 1);
+    const auto& i = A(2, 2);
 
     auto ae = a * e;
     auto af = a * f;
@@ -1648,22 +1636,22 @@ VariableMatrix<Scalar> solve(const VariableMatrix<Scalar>& A,
     //
     // https://www.wolframalpha.com/input?i=inverse+%7B%7Ba%2C+b%2C+c%2C+d%7D%2C+%7Be%2C+f%2C+g%2C+h%7D%2C+%7Bi%2C+j%2C+k%2C+l%7D%2C+%7Bm%2C+n%2C+o%2C+p%7D%7D
 
-    const auto& a = A[0, 0];
-    const auto& b = A[0, 1];
-    const auto& c = A[0, 2];
-    const auto& d = A[0, 3];
-    const auto& e = A[1, 0];
-    const auto& f = A[1, 1];
-    const auto& g = A[1, 2];
-    const auto& h = A[1, 3];
-    const auto& i = A[2, 0];
-    const auto& j = A[2, 1];
-    const auto& k = A[2, 2];
-    const auto& l = A[2, 3];
-    const auto& m = A[3, 0];
-    const auto& n = A[3, 1];
-    const auto& o = A[3, 2];
-    const auto& p = A[3, 3];
+    const auto& a = A(0, 0);
+    const auto& b = A(0, 1);
+    const auto& c = A(0, 2);
+    const auto& d = A(0, 3);
+    const auto& e = A(1, 0);
+    const auto& f = A(1, 1);
+    const auto& g = A(1, 2);
+    const auto& h = A(1, 3);
+    const auto& i = A(2, 0);
+    const auto& j = A(2, 1);
+    const auto& k = A(2, 2);
+    const auto& l = A(2, 3);
+    const auto& m = A(3, 0);
+    const auto& n = A(3, 1);
+    const auto& o = A(3, 2);
+    const auto& p = A(3, 3);
 
     auto afk = a * f * k;
     auto afl = a * f * l;
@@ -1794,14 +1782,14 @@ VariableMatrix<Scalar> solve(const VariableMatrix<Scalar>& A,
     MatrixXv eigen_A{A.rows(), A.cols()};
     for (int row = 0; row < A.rows(); ++row) {
       for (int col = 0; col < A.cols(); ++col) {
-        eigen_A(row, col) = A[row, col];
+        eigen_A(row, col) = A(row, col);
       }
     }
 
     MatrixXv eigen_B{B.rows(), B.cols()};
     for (int row = 0; row < B.rows(); ++row) {
       for (int col = 0; col < B.cols(); ++col) {
-        eigen_B(row, col) = B[row, col];
+        eigen_B(row, col) = B(row, col);
       }
     }
 
@@ -1810,7 +1798,7 @@ VariableMatrix<Scalar> solve(const VariableMatrix<Scalar>& A,
     VariableMatrix<Scalar> X{detail::empty, A.cols(), B.cols()};
     for (int row = 0; row < X.rows(); ++row) {
       for (int col = 0; col < X.cols(); ++col) {
-        X[row, col] = eigen_X(row, col);
+        X(row, col) = eigen_X(row, col);
       }
     }
 
diff --git a/include/sleipnir/optimization/ocp.hpp b/include/sleipnir/optimization/ocp.hpp
index 88316894362ff3004627308c81c8f251291eae97..d62432a67af1c75b5cc0bbab54df1d785aec2846 100644
--- a/include/sleipnir/optimization/ocp.hpp
+++ b/include/sleipnir/optimization/ocp.hpp
@@ -125,7 +125,7 @@ class OCP : public Problem<Scalar> {
     if (timestep_method == TimestepMethod::FIXED) {
       m_DT = VariableMatrix<Scalar>{1, m_num_steps + 1};
       for (int i = 0; i < num_steps + 1; ++i) {
-        m_DT[0, i] = dt.count();
+        m_DT(0, i) = dt.count();
       }
     } else if (timestep_method == TimestepMethod::VARIABLE_SINGLE) {
       Variable single_dt = this->decision_variable();
@@ -134,12 +134,12 @@ class OCP : public Problem<Scalar> {
       // Set the member variable matrix to track the decision variable
       m_DT = VariableMatrix<Scalar>{1, m_num_steps + 1};
       for (int i = 0; i < num_steps + 1; ++i) {
-        m_DT[0, i] = single_dt;
+        m_DT(0, i) = single_dt;
       }
     } else if (timestep_method == TimestepMethod::VARIABLE) {
       m_DT = this->decision_variable(1, m_num_steps + 1);
       for (int i = 0; i < num_steps + 1; ++i) {
-        m_DT[0, i].set_value(dt.count());
+        m_DT(0, i).set_value(dt.count());
       }
     }
 
@@ -216,7 +216,7 @@ class OCP : public Problem<Scalar> {
     for (int i = 0; i < m_num_steps + 1; ++i) {
       auto x = X().col(i);
       auto u = U().col(i);
-      auto dt = this->dt()[0, i];
+      auto dt = this->dt()(0, i);
       callback(time, x, u, dt);
 
       time += dt;
@@ -358,7 +358,7 @@ class OCP : public Problem<Scalar> {
 
     // Derivation at https://mec560sbu.github.io/2016/09/30/direct_collocation/
     for (int i = 0; i < m_num_steps; ++i) {
-      Variable h = dt()[0, i];
+      Variable h = dt()(0, i);
 
       auto& f = m_dynamics;
 
@@ -397,7 +397,7 @@ class OCP : public Problem<Scalar> {
       auto x_begin = X().col(i);
       auto x_end = X().col(i + 1);
       auto u = U().col(i);
-      Variable dt = this->dt()[0, i];
+      Variable dt = this->dt()(0, i);
 
       if (m_dynamics_type == DynamicsType::EXPLICIT_ODE) {
         this->subject_to(
@@ -422,7 +422,7 @@ class OCP : public Problem<Scalar> {
       auto x_begin = X().col(i);
       auto x_end = X().col(i + 1);
       auto u = U().col(i);
-      Variable dt = this->dt()[0, i];
+      Variable dt = this->dt()(0, i);
 
       if (m_dynamics_type == DynamicsType::EXPLICIT_ODE) {
         x_end = rk4<const decltype(m_dynamics)&, VariableMatrix<Scalar>,
diff --git a/include/sleipnir/optimization/problem.hpp b/include/sleipnir/optimization/problem.hpp
index 03a2f057527a110ff2bec317402b06759c6c5a80..82ddb337d6ebf2cac9d3434ce837da09f447f0dc 100644
--- a/include/sleipnir/optimization/problem.hpp
+++ b/include/sleipnir/optimization/problem.hpp
@@ -98,7 +98,7 @@ class Problem {
     for (int row = 0; row < rows; ++row) {
       for (int col = 0; col < cols; ++col) {
         m_decision_variables.emplace_back();
-        vars[row, col] = m_decision_variables.back();
+        vars(row, col) = m_decision_variables.back();
       }
     }
 
@@ -133,8 +133,8 @@ class Problem {
     for (int row = 0; row < rows; ++row) {
       for (int col = 0; col <= row; ++col) {
         m_decision_variables.emplace_back();
-        vars[row, col] = m_decision_variables.back();
-        vars[col, row] = m_decision_variables.back();
+        vars(row, col) = m_decision_variables.back();
+        vars(col, row) = m_decision_variables.back();
       }
     }
 
