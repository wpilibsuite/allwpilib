From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tyler Veness <calcmogul@gmail.com>
Date: Wed, 29 May 2024 16:29:55 -0700
Subject: [PATCH 1/9] Use fmtlib

---
 include/sleipnir/autodiff/expression_type.hpp |  9 ++++---
 include/sleipnir/optimization/problem.hpp     |  1 +
 .../optimization/solver/exit_status.hpp       |  9 ++++---
 include/sleipnir/util/assert.hpp              |  5 ++--
 include/sleipnir/util/print.hpp               | 27 ++++++++++---------
 5 files changed, 28 insertions(+), 23 deletions(-)

diff --git a/include/sleipnir/autodiff/expression_type.hpp b/include/sleipnir/autodiff/expression_type.hpp
index 200324a2c38c58dbe07e96c061658c9e65aacce6..2fde6bdf3cf72f46fb633b72e29e66209e9f6a83 100644
--- a/include/sleipnir/autodiff/expression_type.hpp
+++ b/include/sleipnir/autodiff/expression_type.hpp
@@ -4,9 +4,10 @@
 
 #include <stdint.h>
 
-#include <format>
 #include <utility>
 
+#include <fmt/base.h>
+
 namespace slp {
 
 /// Expression type.
@@ -29,12 +30,12 @@ enum class ExpressionType : uint8_t {
 
 /// Formatter for ExpressionType.
 template <>
-struct std::formatter<slp::ExpressionType> {
+struct fmt::formatter<slp::ExpressionType> {
   /// Parse format string.
   ///
   /// @param ctx Format parse context.
   /// @return Format parse context iterator.
-  constexpr auto parse(std::format_parse_context& ctx) {
+  constexpr auto parse(fmt::format_parse_context& ctx) {
     return m_underlying.parse(ctx);
   }
 
@@ -65,5 +66,5 @@ struct std::formatter<slp::ExpressionType> {
   }
 
  private:
-  std::formatter<const char*> m_underlying;
+  fmt::formatter<const char*> m_underlying;
 };
diff --git a/include/sleipnir/optimization/problem.hpp b/include/sleipnir/optimization/problem.hpp
index 59acc732dbc5bfe520745089abd156da9a8a2e51..ba45ead1500b45616b74e1d108959127484cf4d6 100644
--- a/include/sleipnir/optimization/problem.hpp
+++ b/include/sleipnir/optimization/problem.hpp
@@ -15,6 +15,7 @@
 
 #include <Eigen/Core>
 #include <Eigen/SparseCore>
+#include <fmt/chrono.h>
 #include <gch/small_vector.hpp>
 
 #include "sleipnir/autodiff/expression_type.hpp"
diff --git a/include/sleipnir/optimization/solver/exit_status.hpp b/include/sleipnir/optimization/solver/exit_status.hpp
index e17f4490cc0f6704f0b5d29340ec6dfbbcbb8aee..c1e4d319c197bdad2ace19500fb3a0426060e87b 100644
--- a/include/sleipnir/optimization/solver/exit_status.hpp
+++ b/include/sleipnir/optimization/solver/exit_status.hpp
@@ -4,9 +4,10 @@
 
 #include <stdint.h>
 
-#include <format>
 #include <utility>
 
+#include <fmt/base.h>
+
 namespace slp {
 
 /// Solver exit status. Negative values indicate failure.
@@ -43,12 +44,12 @@ enum class ExitStatus : int8_t {
 
 /// Formatter for ExitStatus.
 template <>
-struct std::formatter<slp::ExitStatus> {
+struct fmt::formatter<slp::ExitStatus> {
   /// Parse format string.
   ///
   /// @param ctx Format parse context.
   /// @return Format parse context iterator.
-  constexpr auto parse(std::format_parse_context& ctx) {
+  constexpr auto parse(fmt::format_parse_context& ctx) {
     return m_underlying.parse(ctx);
   }
 
@@ -92,5 +93,5 @@ struct std::formatter<slp::ExitStatus> {
   }
 
  private:
-  std::formatter<const char*> m_underlying;
+  fmt::formatter<const char*> m_underlying;
 };
diff --git a/include/sleipnir/util/assert.hpp b/include/sleipnir/util/assert.hpp
index dd479f11080d67b03dbe72475be974908e96fc2f..4f0203a4b8df2f86e1e15cf1102a51c340665722 100644
--- a/include/sleipnir/util/assert.hpp
+++ b/include/sleipnir/util/assert.hpp
@@ -3,16 +3,17 @@
 #pragma once
 
 #ifdef SLEIPNIR_PYTHON
-#include <format>
 #include <source_location>
 #include <stdexcept>
 
+#include <fmt/format.h>
+
 /// Throw an exception in Python.
 #define slp_assert(condition)                                        \
   do {                                                               \
     if (!(condition)) {                                              \
       auto location = std::source_location::current();               \
-      throw std::invalid_argument(std::format(                       \
+      throw std::invalid_argument(fmt::format(                       \
           "{}:{}: {}: Assertion `{}' failed.", location.file_name(), \
           location.line(), location.function_name(), #condition));   \
     }                                                                \
diff --git a/include/sleipnir/util/print.hpp b/include/sleipnir/util/print.hpp
index d436bf297b85cf84fad642fa43aa97063e7d6ebb..b2920580eea0297fc387b5168df78a1515a5dd60 100644
--- a/include/sleipnir/util/print.hpp
+++ b/include/sleipnir/util/print.hpp
@@ -4,47 +4,48 @@
 
 #ifndef SLEIPNIR_DISABLE_DIAGNOSTICS
 #include <cstdio>
-#include <print>
 #include <system_error>
 #include <utility>
+
+#include <fmt/base.h>
 #endif
 
 namespace slp {
 
 #ifndef SLEIPNIR_DISABLE_DIAGNOSTICS
 
-/// Wrapper around std::print() that squelches write failure exceptions.
+/// Wrapper around fmt::print() that squelches write failure exceptions.
 template <typename... T>
-void print(std::format_string<T...> fmt, T&&... args) {
+void print(fmt::format_string<T...> fmt, T&&... args) {
   try {
-    std::print(fmt, std::forward<T>(args)...);
+    fmt::print(fmt, std::forward<T>(args)...);
   } catch (const std::system_error&) {
   }
 }
 
-/// Wrapper around std::print() that squelches write failure exceptions.
+/// Wrapper around fmt::print() that squelches write failure exceptions.
 template <typename... T>
-void print(std::FILE* f, std::format_string<T...> fmt, T&&... args) {
+void print(std::FILE* f, fmt::format_string<T...> fmt, T&&... args) {
   try {
-    std::print(f, fmt, std::forward<T>(args)...);
+    fmt::print(f, fmt, std::forward<T>(args)...);
   } catch (const std::system_error&) {
   }
 }
 
-/// Wrapper around std::println() that squelches write failure exceptions.
+/// Wrapper around fmt::println() that squelches write failure exceptions.
 template <typename... T>
-void println(std::format_string<T...> fmt, T&&... args) {
+void println(fmt::format_string<T...> fmt, T&&... args) {
   try {
-    std::println(fmt, std::forward<T>(args)...);
+    fmt::println(fmt, std::forward<T>(args)...);
   } catch (const std::system_error&) {
   }
 }
 
-/// Wrapper around std::println() that squelches write failure exceptions.
+/// Wrapper around fmt::println() that squelches write failure exceptions.
 template <typename... T>
-void println(std::FILE* f, std::format_string<T...> fmt, T&&... args) {
+void println(std::FILE* f, fmt::format_string<T...> fmt, T&&... args) {
   try {
-    std::println(f, fmt, std::forward<T>(args)...);
+    fmt::println(f, fmt, std::forward<T>(args)...);
   } catch (const std::system_error&) {
   }
 }
