ext {
    addHalDependency = { binary, shared->
        binary.tasks.withType(AbstractNativeSourceCompileTask) {
            it.dependsOn generateUsageReporting
        }
        binary.lib project: ':hal', library: 'hal', linkage: shared
    }

    addHalJniDependency = { binary->
        binary.tasks.withType(AbstractNativeSourceCompileTask) {
            it.dependsOn generateUsageReporting
        }
        binary.lib project: ':hal', library: 'halJNIShared', linkage: 'shared'
    }

    nativeName = 'hal'
    setBaseName = 'wpiHal'
    devMain = 'edu.wpi.first.hal.DevMain'
    niLibraries = true
    generatedHeaders = "src/generated/main/native/include"
    jniSplitSetup = {
        it.tasks.withType(AbstractNativeSourceCompileTask) {
            it.dependsOn generateUsageReporting
        }
    }
    splitSetup = {
        it.tasks.withType(AbstractNativeSourceCompileTask) {
            it.dependsOn generateUsageReporting
        }
        if (it.targetPlatform.name == nativeUtils.wpi.platforms.roborio) {
            it.sources {
                athenaCpp(CppSourceSet) {
                    source {
                        srcDirs = ['src/main/native/athena']
                        include '**/*.cpp'
                    }
                    exportedHeaders {
                        srcDir 'src/main/native/include'
                        srcDir generatedHeaders
                    }
                }
            }
        } else {
            it.sources {
                simCpp(CppSourceSet) {
                    source {
                        srcDirs 'src/main/native/sim'
                        include '**/*.cpp'
                    }
                    exportedHeaders {
                        srcDir 'src/main/native/include'
                        srcDir generatedHeaders
                    }
                }
            }
        }
    }
    exeSplitSetup = {
        if (it.targetPlatform.name == nativeUtils.wpi.platforms.roborio) {
            nativeUtils.useRequiredLibrary(it, 'ni_link_libraries', 'ni_runtime_libraries')
        }
    }
}

apply from: "${rootDir}/shared/jni/setupBuild.gradle"

sourceSets.main.java.srcDir "src/generated/main/java/"

compileJava {
    dependsOn generateUsageReporting
}

cppSourcesZip {
    from('src/main/native/athena') {
        into '/athena'
    }

    from('src/main/native/sim') {
        into '/sim'
    }
}

cppHeadersZip {
    dependsOn generateUsageReporting
    from(generatedHeaders) {
        into '/'
    }
}

Action<List<String>> symbolFilter = { symbols ->
    symbols.removeIf({ !it.startsWith('HAL_') && !it.startsWith('HALSIM_') })
} as Action<List<String>>;

nativeUtils.exportsConfigs {
    hal {
        x64ExcludeSymbols = [
            '_CT??_R0?AV_System_error',
            '_CT??_R0?AVexception',
            '_CT??_R0?AVfailure',
            '_CT??_R0?AVruntime_error',
            '_CT??_R0?AVsystem_error',
            '_CTA5?AVfailure',
            '_TI5?AVfailure',
            '_CT??_R0?AVout_of_range',
            '_CTA3?AVout_of_range',
            '_TI3?AVout_of_range',
            '_CT??_R0?AVbad_cast'
        ]
    }
    halJNI {
        x64SymbolFilter = symbolFilter
    }
}

model {
    binaries {
        all {
            it.tasks.withType(AbstractNativeSourceCompileTask) {
                it.dependsOn generateUsageReporting
            }
            if (!(it instanceof NativeBinarySpec)) return
                if (it.component.name != 'hal' && it.component.name != 'halBase') return
                if (it.targetPlatform.name != nativeUtils.wpi.platforms.roborio) return
                nativeUtils.useRequiredLibrary(it, 'ni_link_libraries')
        }
    }
}
