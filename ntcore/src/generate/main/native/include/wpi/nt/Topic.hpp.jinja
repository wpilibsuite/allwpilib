// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

// THIS FILE WAS AUTO-GENERATED BY ./ntcore/generate_topics.py. DO NOT MODIFY

#pragma once

#include <stdint.h>

{{ cpp.INCLUDES }}
#include <span>
#include <string_view>
#include <vector>

#include <wpi/json_fwd.h>

#include "networktables/NetworkTableType.h"
#include "networktables/Topic.h"
#include "ntcore_cpp.h"

namespace wpi {
template <typename T>
class SmallVectorImpl;
}  // namespace wpi

namespace nt {

class {{ TypeName }}Topic;

/**
 * NetworkTables {{ TypeName }} subscriber.
 */
class {{ TypeName }}Subscriber : public Subscriber {
 public:
  using TopicType = {{ TypeName }}Topic;
  using ValueType = {{ cpp.ValueType }};
  using ParamType = {{ cpp.ParamType }};
  using TimestampedValueType = Timestamped{{ TypeName }};
{% if cpp.SmallRetType and cpp.SmallElemType %}
  using SmallRetType = {{ cpp.SmallRetType }};
  using SmallElemType = {{ cpp.SmallElemType }};
  using TimestampedValueViewType = Timestamped{{ TypeName }}View;
{% endif %}

  {{ TypeName }}Subscriber() = default;

  /**
   * Construct from a subscriber handle; recommended to use
   * {{TypeName}}Topic::Subscribe() instead.
   *
   * @param handle Native handle
   * @param defaultValue Default value
   */
  {{ TypeName }}Subscriber(NT_Subscriber handle, ParamType defaultValue)
      : Subscriber{handle},
        m_defaultValue{{ '{' }}{{ cpp.DefaultValueCopy|default('defaultValue') }}} {}

  /**
   * Get the last published value.
   * If no value has been published, returns the stored default value.
   *
   * @return value
   */
  ValueType Get() const {
    return Get(m_defaultValue);
  }

  /**
   * Get the last published value.
   * If no value has been published, returns the passed defaultValue.
   *
   * @param defaultValue default value to return if no value has been published
   * @return value
   */
  ValueType Get(ParamType defaultValue) const {
    return ::nt::Get{{ TypeName }}(m_subHandle, defaultValue);
  }
{% if cpp.SmallRetType and cpp.SmallElemType %}
  /**
   * Get the last published value.
   * If no value has been published, returns the stored default value.
   *
   * @param buf storage for returned value
   * @return value
   */
  SmallRetType Get(wpi::SmallVectorImpl<SmallElemType>& buf) const {
    return Get(buf, m_defaultValue);
  }

  /**
   * Get the last published value.
   * If no value has been published, returns the passed defaultValue.
   *
   * @param buf storage for returned value
   * @param defaultValue default value to return if no value has been published
   * @return value
   */
  SmallRetType Get(wpi::SmallVectorImpl<SmallElemType>& buf, ParamType defaultValue) const {
    return nt::Get{{ TypeName }}(m_subHandle, buf, defaultValue);
  }
{% endif %}
  /**
   * Get the last published value along with its timestamp
   * If no value has been published, returns the stored default value and a
   * timestamp of 0.
   *
   * @return timestamped value
   */
  TimestampedValueType GetAtomic() const {
    return GetAtomic(m_defaultValue);
  }

  /**
   * Get the last published value along with its timestamp.
   * If no value has been published, returns the passed defaultValue and a
   * timestamp of 0.
   *
   * @param defaultValue default value to return if no value has been published
   * @return timestamped value
   */
  TimestampedValueType GetAtomic(ParamType defaultValue) const {
    return ::nt::GetAtomic{{ TypeName }}(m_subHandle, defaultValue);
  }
{% if cpp.SmallRetType and cpp.SmallElemType %}
  /**
   * Get the last published value along with its timestamp.
   * If no value has been published, returns the stored default value and a
   * timestamp of 0.
   *
   * @param buf storage for returned value
   * @return timestamped value
   */
  TimestampedValueViewType GetAtomic(
      wpi::SmallVectorImpl<SmallElemType>& buf) const {
    return GetAtomic(buf, m_defaultValue);
  }

  /**
   * Get the last published value along with its timestamp.
   * If no value has been published, returns the passed defaultValue and a
   * timestamp of 0.
   *
   * @param buf storage for returned value
   * @param defaultValue default value to return if no value has been published
   * @return timestamped value
   */
  TimestampedValueViewType GetAtomic(
      wpi::SmallVectorImpl<SmallElemType>& buf,
      ParamType defaultValue) const {
    return nt::GetAtomic{{ TypeName }}(m_subHandle, buf, defaultValue);
  }
{% endif %}
  /**
   * Get an array of all value changes since the last call to ReadQueue.
   * Also provides a timestamp for each value.
   *
   * @note The "poll storage" subscribe option can be used to set the queue
   *     depth.
   *
   * @return Array of timestamped values; empty array if no new changes have
   *     been published since the previous call.
   */
  std::vector<TimestampedValueType> ReadQueue() {
    return ::nt::ReadQueue{{ TypeName }}(m_subHandle);
  }

  /**
   * Get the corresponding topic.
   *
   * @return Topic
   */
  TopicType GetTopic() const;

 private:
  ValueType m_defaultValue;
};

/**
 * NetworkTables {{ TypeName }} publisher.
 */
class {{ TypeName }}Publisher : public Publisher {
 public:
  using TopicType = {{ TypeName }}Topic;
  using ValueType = {{ cpp.ValueType }};
  using ParamType = {{ cpp.ParamType }};
{% if cpp.SmallRetType and cpp.SmallElemType %}
  using SmallRetType = {{ cpp.SmallRetType }};
  using SmallElemType = {{ cpp.SmallElemType }};
{% endif %}
  using TimestampedValueType = Timestamped{{ TypeName }};

  {{ TypeName }}Publisher() = default;

  /**
   * Construct from a publisher handle; recommended to use
   * {{TypeName}}Topic::Publish() instead.
   *
   * @param handle Native handle
   */
  explicit {{ TypeName }}Publisher(NT_Publisher handle) : Publisher{handle} {}

  /**
   * Publish a new value.
   *
   * @param value value to publish
   * @param time timestamp; 0 indicates current NT time should be used
   */
  void Set(ParamType value, int64_t time = 0) {
    ::nt::Set{{ TypeName }}(m_pubHandle, value, time);
  }

  /**
   * Publish a default value.
   * On reconnect, a default value will never be used in preference to a
   * published value.
   *
   * @param value value
   */
  void SetDefault(ParamType value) {
    ::nt::SetDefault{{ TypeName }}(m_pubHandle, value);
  }

  /**
   * Get the corresponding topic.
   *
   * @return Topic
   */
  TopicType GetTopic() const;
};

/**
 * NetworkTables {{ TypeName }} entry.
 *
 * @note Unlike NetworkTableEntry, the entry goes away when this is destroyed.
 */
class {{ TypeName }}Entry final : public {{ TypeName }}Subscriber,
                                  public {{ TypeName }}Publisher {
 public:
  using SubscriberType = {{ TypeName }}Subscriber;
  using PublisherType = {{ TypeName }}Publisher;
  using TopicType = {{ TypeName }}Topic;
  using ValueType = {{ cpp.ValueType }};
  using ParamType = {{ cpp.ParamType }};
{% if cpp.SmallRetType and cpp.SmallElemType %}
  using SmallRetType = {{ cpp.SmallRetType }};
  using SmallElemType = {{ cpp.SmallElemType }};
{% endif %}
  using TimestampedValueType = Timestamped{{ TypeName }};

  {{ TypeName }}Entry() = default;

  /**
   * Construct from an entry handle; recommended to use
   * {{TypeName}}Topic::GetEntry() instead.
   *
   * @param handle Native handle
   * @param defaultValue Default value
   */
  {{ TypeName }}Entry(NT_Entry handle, ParamType defaultValue)
      : {{ TypeName }}Subscriber{handle, defaultValue},
        {{ TypeName }}Publisher{handle} {}

  /**
   * Determines if the native handle is valid.
   *
   * @return True if the native handle is valid, false otherwise.
   */
  explicit operator bool() const { return m_subHandle != 0; }

  /**
   * Gets the native handle for the entry.
   *
   * @return Native handle
   */
  NT_Entry GetHandle() const { return m_subHandle; }

  /**
   * Get the corresponding topic.
   *
   * @return Topic
   */
  TopicType GetTopic() const;

  /**
   * Stops publishing the entry if it's published.
   */
  void Unpublish() {
    ::nt::Unpublish(m_pubHandle);
  }
};

/**
 * NetworkTables {{ TypeName }} topic.
 */
class {{ TypeName }}Topic final : public Topic {
 public:
  using SubscriberType = {{ TypeName }}Subscriber;
  using PublisherType = {{ TypeName }}Publisher;
  using EntryType = {{ TypeName }}Entry;
  using ValueType = {{ cpp.ValueType }};
  using ParamType = {{ cpp.ParamType }};
  using TimestampedValueType = Timestamped{{ TypeName }};
{%- if TypeString %}
  /** The default type string for this topic type. */
  static constexpr std::string_view kTypeString = {{ TypeString }};
{%- endif %}

  {{ TypeName }}Topic() = default;

  /**
   * Construct from a topic handle; recommended to use
   * NetworkTableInstance::Get{{TypeName}}Topic() instead.
   *
   * @param handle Native handle
   */
  explicit {{ TypeName }}Topic(NT_Topic handle) : Topic{handle} {}

  /**
   * Construct from a generic topic.
   *
   * @param topic Topic
   */
  explicit {{ TypeName }}Topic(Topic topic) : Topic{topic} {}

  /**
   * Create a new subscriber to the topic.
   *
   * <p>The subscriber is only active as long as the returned object
   * is not destroyed.
   *
   * @note Subscribers that do not match the published data type do not return
   *     any values. To determine if the data type matches, use the appropriate
   *     Topic functions.
   *
{%- if not TypeString %}
   * @param typeString type string
{% endif %}
   * @param defaultValue default value used when a default is not provided to a
   *        getter function
   * @param options subscribe options
   * @return subscriber
   */
  [[nodiscard]]
  SubscriberType Subscribe(
      {% if not TypeString %}std::string_view typeString, {% endif %}ParamType defaultValue,
      const PubSubOptions& options = kDefaultPubSubOptions) {
    return {{ TypeName }}Subscriber{
        ::nt::Subscribe(m_handle, NT_{{ cpp.TYPE_NAME }}, {{ TypeString|default('typeString') }}, options),
        defaultValue};
  }
{%- if TypeString %}
  /**
   * Create a new subscriber to the topic, with specific type string.
   *
   * <p>The subscriber is only active as long as the returned object
   * is not destroyed.
   *
   * @note Subscribers that do not match the published data type do not return
   *     any values. To determine if the data type matches, use the appropriate
   *     Topic functions.
   *
   * @param typeString type string
   * @param defaultValue default value used when a default is not provided to a
   *        getter function
   * @param options subscribe options
   * @return subscriber
   */
  [[nodiscard]]
  SubscriberType SubscribeEx(
      std::string_view typeString, ParamType defaultValue,
      const PubSubOptions& options = kDefaultPubSubOptions) {
    return {{ TypeName }}Subscriber{
        ::nt::Subscribe(m_handle, NT_{{ cpp.TYPE_NAME }}, typeString, options),
        defaultValue};
  }
{% endif %}
  /**
   * Create a new publisher to the topic.
   *
   * The publisher is only active as long as the returned object
   * is not destroyed.
   *
   * @note It is not possible to publish two different data types to the same
   *     topic. Conflicts between publishers are typically resolved by the
   *     server on a first-come, first-served basis. Any published values that
   *     do not match the topic's data type are dropped (ignored). To determine
   *     if the data type matches, use the appropriate Topic functions.
   *
{%- if not TypeString %}
   * @param typeString type string
{% endif %}
   * @param options publish options
   * @return publisher
   */
  [[nodiscard]]
  PublisherType Publish({% if not TypeString %}std::string_view typeString, {% endif %}const PubSubOptions& options = kDefaultPubSubOptions) {
    return {{ TypeName }}Publisher{
        ::nt::Publish(m_handle, NT_{{ cpp.TYPE_NAME }}, {{ TypeString|default('typeString') }}, options)};
  }

  /**
   * Create a new publisher to the topic, with type string and initial
   * properties.
   *
   * The publisher is only active as long as the returned object
   * is not destroyed.
   *
   * @note It is not possible to publish two different data types to the same
   *     topic. Conflicts between publishers are typically resolved by the
   *     server on a first-come, first-served basis. Any published values that
   *     do not match the topic's data type are dropped (ignored). To determine
   *     if the data type matches, use the appropriate Topic functions.
   *
   * @param typeString type string
   * @param properties JSON properties
   * @param options publish options
   * @return publisher
   */
  [[nodiscard]]
  PublisherType PublishEx(std::string_view typeString,
    const wpi::json& properties, const PubSubOptions& options = kDefaultPubSubOptions) {
    return {{ TypeName }}Publisher{
        ::nt::PublishEx(m_handle, NT_{{ cpp.TYPE_NAME }}, typeString, properties, options)};
  }

  /**
   * Create a new entry for the topic.
   *
   * Entries act as a combination of a subscriber and a weak publisher. The
   * subscriber is active as long as the entry is not destroyed. The publisher
   * is created when the entry is first written to, and remains active until
   * either Unpublish() is called or the entry is destroyed.
   *
   * @note It is not possible to use two different data types with the same
   *     topic. Conflicts between publishers are typically resolved by the
   *     server on a first-come, first-served basis. Any published values that
   *     do not match the topic's data type are dropped (ignored), and the entry
   *     will show no new values if the data type does not match. To determine
   *     if the data type matches, use the appropriate Topic functions.
   *
{%- if not TypeString %}
   * @param typeString type string
{% endif %}
   * @param defaultValue default value used when a default is not provided to a
   *        getter function
   * @param options publish and/or subscribe options
   * @return entry
   */
  [[nodiscard]]
  EntryType GetEntry({% if not TypeString %}std::string_view typeString, {% endif %}ParamType defaultValue,
                     const PubSubOptions& options = kDefaultPubSubOptions) {
    return {{ TypeName }}Entry{
        ::nt::GetEntry(m_handle, NT_{{ cpp.TYPE_NAME }}, {{ TypeString|default('typeString') }}, options),
        defaultValue};
  }
{%- if TypeString %}
  /**
   * Create a new entry for the topic, with specific type string.
   *
   * Entries act as a combination of a subscriber and a weak publisher. The
   * subscriber is active as long as the entry is not destroyed. The publisher
   * is created when the entry is first written to, and remains active until
   * either Unpublish() is called or the entry is destroyed.
   *
   * @note It is not possible to use two different data types with the same
   *     topic. Conflicts between publishers are typically resolved by the
   *     server on a first-come, first-served basis. Any published values that
   *     do not match the topic's data type are dropped (ignored), and the entry
   *     will show no new values if the data type does not match. To determine
   *     if the data type matches, use the appropriate Topic functions.
   *
   * @param typeString type string
   * @param defaultValue default value used when a default is not provided to a
   *        getter function
   * @param options publish and/or subscribe options
   * @return entry
   */
  [[nodiscard]]
  EntryType GetEntryEx(std::string_view typeString, ParamType defaultValue,
                       const PubSubOptions& options = kDefaultPubSubOptions) {
    return {{ TypeName }}Entry{
        ::nt::GetEntry(m_handle, NT_{{ cpp.TYPE_NAME }}, typeString, options),
        defaultValue};
  }
{% endif %}
};

inline {{ TypeName }}Topic {{ TypeName }}Subscriber::GetTopic() const {
  return {{ TypeName }}Topic{::nt::GetTopicFromHandle(m_subHandle)};
}

inline {{ TypeName }}Topic {{ TypeName }}Publisher::GetTopic() const {
  return {{ TypeName }}Topic{::nt::GetTopicFromHandle(m_pubHandle)};
}

inline {{ TypeName }}Topic {{ TypeName }}Entry::GetTopic() const {
  return {{ TypeName }}Topic{::nt::GetTopicFromHandle(m_subHandle)};
}

}  // namespace nt

