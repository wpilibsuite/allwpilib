import org.wpilib.toolchain.*

buildscript {
    repositories {
        maven {
            url = 'https://frcmaven.wpi.edu/artifactory/ex-mvn'
        }
    }
}

plugins {
    id 'base'
    id 'idea'
    id 'visual-studio'

    alias(libs.plugins.wpilib.versioning)
    alias(libs.plugins.wpilib.repositories)
    // NativeUtils and GradleVsCode are on the classpath for buildSrc, which doesn't carry version information.
    // We're forced to use the string-based syntax here instead.
    id 'org.wpilib.NativeUtils' apply false
    id 'org.wpilib.GradleVsCode' apply false
    // alias(libs.plugins.wpilib.native.utils) apply false
    // alias(libs.plugins.wpilib.gradle.vscode)
    alias(libs.plugins.wpilib.gradle.jni)

    alias(libs.plugins.build.shadow) apply false
    alias(libs.plugins.lint.errorprone) apply false
    alias(libs.plugins.lint.spotbugs) apply false
    alias(libs.plugins.lint.spotless) apply false
}

wpilibVersioning.buildServerMode = project.hasProperty('buildServer')
wpilibVersioning.releaseMode = project.hasProperty('releaseMode')

allprojects {
    repositories {
        maven {
        url = 'https://frcmaven.wpi.edu/artifactory/ex-mvn'
    }
    }
    wpilibRepositories.use2027Repos()
    if (project.hasProperty('releaseMode')) {
        wpilibRepositories.addAllReleaseRepositories(it)
    } else {
        wpilibRepositories.addAllDevelopmentRepositories(it)
    }
    tasks.withType(AbstractTestTask).configureEach {
        failOnNoDiscoveredTests = false
    }
}

develocity {
    buildScan {
        termsOfUseUrl = "https://gradle.com/help/legal-terms-of-use"
        termsOfUseAgree = "yes"
    }
}

import com.github.spotbugs.snom.Effort
ext.spotbugsEffort = Effort.MAX

ext.licenseFile = files("$rootDir/LICENSE.md", "$rootDir/ThirdPartyNotices.txt")

if (project.hasProperty("publishVersion")) {
    wpilibVersioning.version.set(project.publishVersion)
}

wpilibVersioning.version.finalizeValue()

def outputsFolder = file("$buildDir/allOutputs")

def versionFile = file("$outputsFolder/version.txt")

task outputVersions() {
    description = 'Prints the versions of wpilib to a file for use by the downstream packaging project'
    group = 'Build'
    outputs.files(versionFile)

    doFirst {
        buildDir.mkdir()
        outputsFolder.mkdir()
    }

    doLast {
        versionFile.write wpilibVersioning.version.get()
    }
}

task libraryBuild() {}

build.dependsOn outputVersions

task copyAllOutputs(type: Copy) {
    destinationDir = outputsFolder
}

build.dependsOn copyAllOutputs
copyAllOutputs.dependsOn outputVersions

def copyReleaseOnly = project.hasProperty('ciReleaseOnly')

ext.addTaskToCopyAllOutputs = { task ->
    if (copyReleaseOnly && task.name.contains('debug')) {
        return
    }
    copyAllOutputs.dependsOn task
    copyAllOutputs.inputs.file task.archiveFile
    copyAllOutputs.from task.archiveFile
}

subprojects {
    apply plugin: 'eclipse'
    apply plugin: 'idea'

    def subproj = it

    plugins.withType(NativeComponentPlugin) {
        subproj.apply plugin: MultiBuilds
    }

    plugins.withType(JavaPlugin) {
        java {
            sourceCompatibility = 21
            targetCompatibility = 21
        }
    }

    apply from: "${rootDir}/shared/java/javastyle.gradle"

    // Disables doclint in java 8.
    if (JavaVersion.current().isJava8Compatible()) {
        tasks.withType(Javadoc) {
            if (project.name != "docs") {
                options.addStringOption('Xdoclint:none', '-quiet')
            }
        }
    }

    tasks.withType(JavaCompile) {
        options.compilerArgs.add '-XDstringConcat=inline'
        options.encoding = 'UTF-8'
    }

    // Enables UTF-8 support in Javadoc
    tasks.withType(Javadoc) {
        options.addStringOption("charset", "utf-8")
        options.addStringOption("docencoding", "utf-8")
        options.addStringOption("encoding", "utf-8")
    }

    // Sign outputs with Developer ID
    tasks.withType(AbstractLinkTask) { task ->
        task.inputs.property "HasDeveloperId", project.hasProperty("developerID")

        if (project.hasProperty("developerID")) {
            // Don't sign any executables because codesign complains
            // about relative rpath.
            if (!(task instanceof LinkExecutable)) {
                doLast {
                    // Get path to binary.
                    String path = task.getLinkedFile().getAsFile().get().getAbsolutePath()
                    providers.exec {
                        setWorkingDir(rootDir)
                        def args = [
                            "sh",
                            "-c",
                            "codesign --force --strict --timestamp --options=runtime " +
                            "--verbose -s ${project.findProperty("developerID")} ${path}"
                        ]
                        commandLine(args)
                    }.result.get()
                }
            }
        }
    }

    tasks.withType(AbstractArchiveTask).configureEach {
        // Use file timestamps from the file system
        preserveFileTimestamps = true
        // Use permissions from the file system
        useFileSystemPermissions()
    }
}

ext.getCurrentArch = {
    return NativePlatforms.desktop
}

wrapper {
    gradleVersion = '9.2.0'
}
