apply plugin: 'cpp'

def jniDir = 'src/athena/cpp'
def generatedJNIHeaderLoc = "$buildDir/include"
def ntSourceDir = "$buildDir/ntSources"

debugStripSetup(project)

sourceSets {
    athena
}

dependencies {
    athenaCompile sourceSets.shared.output
    athenaCompile 'edu.wpi.first.wpilib.networktables.java:NetworkTables:+:arm'
    athenaRuntime 'edu.wpi.first.wpilib.networktables.java:NetworkTables:+:arm'
}

defineWpiUtilProperties()

// Configuration for the HAL bindings
model {
    components {
        wpilibJavaJNI(NativeLibrarySpec) {
            targetPlatform 'arm'
            binaries.all {
                tasks.withType(CppCompile) {
                    dependsOn jniHeaders
                    addNiLibraryLinks(linker, targetPlatform)
                    addWpiUtilLibraryLinks(it, linker, targetPlatform)
                }
            }
            sources {
                cpp {
                    source {
                        srcDirs = ["$jniDir/lib"]
                        includes = ['**/*.cpp']
                    }
                    exportedHeaders {
                        // JDK is included for jni.h. We also need the arm-linux specific headers. This does not need to change
                        // when compiling on Windows
                        // The JNI headers are put into the build/include directory by the jniHeaders task on wpilibJavaDevices
                        srcDirs = ["$jniDir/include", "$jniDir/include/linux", wpiUtilInclude]
                        jniHeaders.outputs.files.each { file ->
                            srcDirs file.getPath()
                        }
                    }
                    lib project: ':hal', library: 'HALAthena', linkage: 'shared'
                }
            }
        }
    }
}

// Maven publishing configuration
publishing {
    publications {
        wpilibj(MavenPublication) {
            artifact jar
            artifact wpilibjNativeLibraries
            artifact(wpilibjSources) {
                classifier "sources"
            }
            artifact(wpilibjJavadoc) {
                classifier "javadoc"
            }

            groupId 'edu.wpi.first.wpilibj'
            artifactId 'wpilibJavaFinal'
            version WPILibVersion.version
        }
    }

    setupWpilibRepo(it)
}

jar {
    dependsOn { classes }

    doFirst {
        def addClasspath = { classpath ->
            classpath.files.findAll { it.exists() }.each {
                if (file(it).directory) {
                    from it
                } else {
                    from zipTree(it.path)
                }
            }
        }
        addClasspath sourceSets.athena.runtimeClasspath
    }
}

tasks.whenTaskAdded { task ->
    if (task.name == 'wpilibJavaJNISharedLibrary') {
        jar.dependsOn task
        wpilibjNativeLibraries.dependsOn task
    }
}

task wpilibjSources(type: Jar, dependsOn: classes) {
    description = 'Creates the sources jar for the maven publishing routine'
    group = 'WPILib'
    classifier = 'sources'
    duplicatesStrategy = 'exclude'

    from sourceSets.athena.allJava
    from sourceSets.shared.allJava
}

task wpilibjNativeLibraries(type: Jar) {
    description = 'Creates the native library jar for the maven publishing routine'
    group = 'WPILib'
    classifier = 'nativelibraries'
    duplicatesStrategy = 'exclude'

    // Include the JNI library
    model {
        binaries {
            withType(SharedLibraryBinarySpec) { spec ->
                from(spec.sharedLibraryFile) {
                    into '/'
                }
                from(new File(spec.sharedLibraryFile.absolutePath + ".debug")) {
                    into '/'
                }
            }
        }
    }

    // Include the shared library object from hal project
    def hal = project(':hal')
    hal.model{
        binaries{
            withType(SharedLibraryBinarySpec) { spec ->
                from(spec.sharedLibraryFile) {
                    into '/'
                }
                from(new File(spec.sharedLibraryFile.absolutePath + ".debug")) {
                    into '/'
                }
            }
        }
    }
}

build.dependsOn wpilibjNativeLibraries

task unzipJavaNtSources(type: Copy) {
    description = 'Unzips the java networktables sources for doc creation'
    group = 'WPILib'
    doFirst {
        def ntSourcesDependency =
        project.dependencies.create('edu.wpi.first.wpilib.networktables.java:NetworkTables:+:sources@jar')
        def ntSourcesConfig = project.configurations.detachedConfiguration(ntSourcesDependency)
        ntSourcesDependency.setTransitive(false)
        def ntSources = ntSourcesConfig.singleFile
    }
    doLast {
        from zipTree(ntSources)
        exclude 'META-INF/*'
        into ntSourceDir
    }
}

task javadoc(type: Javadoc, overwrite: true) {
    dependsOn unzipJavaNtSources
    source sourceSets.athena.allJava, sourceSets.shared.allJava, unzipJavaNtSources.outputs.files
    classpath = files([sourceSets.athena.compileClasspath, sourceSets.shared.compileClasspath])
    javadoc.options.links("http://docs.oracle.com/javase/8/docs/api/")
    options.addStringOption "tag", "pre:a:Pre-Condition"
//    options.addStringOption('Xdoclint:accessibility,syntax,reference,html', '-quiet')
}

task wpilibjJavadoc(type: Jar, dependsOn: javadoc) {
    description = 'Creates the javadoc jar for the maven publishing routine'
    group = 'WPILib'
    classifier = 'javadoc'
    duplicatesStrategy = 'exclude'

    from javadoc.destinationDir
}

task jniHeaders {
    description = 'Generates JNI headers from edu.wpi.first.wpilibj.hal.*'
    group = 'WPILib'
    def outputFolder = file(generatedJNIHeaderLoc)
    inputs.files sourceSets.athena.output
    outputs.file outputFolder
    doLast {
        outputFolder.mkdirs()
        exec {
            executable org.gradle.internal.jvm.Jvm.current().getExecutable('javah')
            args '-d', outputFolder
            args '-classpath', sourceSets.athena.output.classesDir
            args 'edu.wpi.first.wpilibj.can.CANJNI'
            args 'edu.wpi.first.wpilibj.hal.FRCNetComm'
            args 'edu.wpi.first.wpilibj.hal.HAL'
            args 'edu.wpi.first.wpilibj.hal.HALUtil'
            args 'edu.wpi.first.wpilibj.hal.JNIWrapper'
            args 'edu.wpi.first.wpilibj.hal.AccelerometerJNI'
            args 'edu.wpi.first.wpilibj.hal.AnalogJNI'
            args 'edu.wpi.first.wpilibj.hal.AnalogGyroJNI'
            args 'edu.wpi.first.wpilibj.hal.ConstantsJNI'
            args 'edu.wpi.first.wpilibj.hal.CounterJNI'
            args 'edu.wpi.first.wpilibj.hal.DigitalGlitchFilterJNI'
            args 'edu.wpi.first.wpilibj.hal.DIOJNI'
            args 'edu.wpi.first.wpilibj.hal.EncoderJNI'
            args 'edu.wpi.first.wpilibj.hal.I2CJNI'
            args 'edu.wpi.first.wpilibj.hal.InterruptJNI'
            args 'edu.wpi.first.wpilibj.hal.NotifierJNI'
            args 'edu.wpi.first.wpilibj.hal.PortsJNI'
            args 'edu.wpi.first.wpilibj.hal.PWMJNI'
            args 'edu.wpi.first.wpilibj.hal.RelayJNI'
            args 'edu.wpi.first.wpilibj.hal.SPIJNI'
            args 'edu.wpi.first.wpilibj.hal.SolenoidJNI'
            args 'edu.wpi.first.wpilibj.hal.CompressorJNI'
            args 'edu.wpi.first.wpilibj.hal.PDPJNI'
            args 'edu.wpi.first.wpilibj.hal.PowerJNI'
            args 'edu.wpi.first.wpilibj.hal.SerialPortJNI'
        }
    }
}

clean {
    delete generatedJNIHeaderLoc
    delete ntSourceDir
}
