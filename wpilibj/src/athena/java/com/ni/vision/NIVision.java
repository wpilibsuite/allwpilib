//
// This file is auto-generated by wpilibj/wpilibJavaJNI/nivision/gen_java.py
// Please do not edit!
//

package com.ni.vision;

import java.lang.reflect.*;
import java.io.UnsupportedEncodingException;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class NIVision {
  private NIVision() {}

  private static native void imaqDispose(long addr);

  private static Constructor<?> constructDirectByteBuffer;
  private static Field bufferAddressField;

  static {
    try {
      Class<?>[] cArg = new Class[2];
      cArg[0] = long.class;
      cArg[1] = int.class;
      constructDirectByteBuffer =
          Class.forName("java.nio.DirectByteBuffer").getDeclaredConstructor(cArg);
      constructDirectByteBuffer.setAccessible(true);

      bufferAddressField = Buffer.class.getDeclaredField("address");
      bufferAddressField.setAccessible(true);
    } catch (ReflectiveOperationException e) {
      throw new ExceptionInInitializerError(e);
    }
  }

  private static ByteBuffer newDirectByteBuffer(long addr, int cap) {
    try {
      return ((ByteBuffer) (constructDirectByteBuffer.newInstance(addr, cap))).order(ByteOrder
          .nativeOrder());
    } catch (ReflectiveOperationException e) {
      throw new ExceptionInInitializerError(e);
    }
  }

  private static long getByteBufferAddress(ByteBuffer bb) {
    try {
      return bufferAddressField.getLong(bb);
    } catch (IllegalAccessException e) {
      return 0;
    }
  }

  public static ByteBuffer sliceByteBuffer(ByteBuffer bb, int offset, int size) {
    int pos = bb.position();
    int lim = bb.limit();
    bb.position(offset);
    bb.limit(offset + size);
    ByteBuffer new_bb = bb.slice().order(ByteOrder.nativeOrder());
    bb.position(pos);
    bb.limit(lim);
    return new_bb;
  }

  public static ByteBuffer getBytes(ByteBuffer bb, byte[] dst, int offset, int size) {
    int pos = bb.position();
    bb.position(offset);
    bb.get(dst, 0, size);
    bb.position(pos);
    return bb;
  }

  public static ByteBuffer putBytes(ByteBuffer bb, byte[] src, int offset, int size) {
    int pos = bb.position();
    bb.position(offset);
    bb.put(src, 0, size);
    bb.position(pos);
    return bb;
  }

  private static abstract class DisposedStruct {
    protected ByteBuffer backing;
    private boolean owned;

    protected DisposedStruct(int size) {
      backing = ByteBuffer.allocateDirect(size);
      backing.order(ByteOrder.nativeOrder());
      owned = false;
    }

    protected DisposedStruct(ByteBuffer backing, int offset, int size) {
      this.backing = sliceByteBuffer(backing, offset, size);
      owned = false;
    }

    private DisposedStruct(long nativeObj, boolean owned, int size) {
      backing = newDirectByteBuffer(nativeObj, size);
      this.owned = owned;
    }

    public void free() {
      if (owned) {
        imaqDispose(getByteBufferAddress(backing));
        owned = false;
        backing = null;
      }
    }

    @Override
    protected void finalize() throws Throwable {
      if (owned)
        imaqDispose(getByteBufferAddress(backing));
      super.finalize();
    }

    public long getAddress() {
      if (backing == null)
        return 0;
      write();
      return getByteBufferAddress(backing);
    }

    protected void setBuffer(ByteBuffer backing, int offset, int size) {
      this.backing = sliceByteBuffer(backing, offset, size);
    }

    abstract public void read();

    abstract public void write();

    abstract public int size();
  }

  private static abstract class OpaqueStruct {
    private long nativeObj;
    private boolean owned;

    protected OpaqueStruct() {
      nativeObj = 0;
      owned = false;
    }

    protected OpaqueStruct(long nativeObj, boolean owned) {
      this.nativeObj = nativeObj;
      this.owned = owned;
    }

    public void free() {
      if (owned && nativeObj != 0) {
        imaqDispose(nativeObj);
        owned = false;
        nativeObj = 0;
      }
    }

    @Override
    protected void finalize() throws Throwable {
      if (owned && nativeObj != 0)
        imaqDispose(nativeObj);
      super.finalize();
    }

    public long getAddress() {
      return nativeObj;
    }
  }

  public static class RawData {
    private ByteBuffer buf;
    private boolean owned;

    public RawData() {
      owned = false;
    }

    public RawData(ByteBuffer buf) {
      this.buf = buf;
      owned = false;
    }

    private RawData(long nativeObj, boolean owned, int size) {
      buf = newDirectByteBuffer(nativeObj, size);
      this.owned = owned;
    }

    public void free() {
      if (owned) {
        imaqDispose(getByteBufferAddress(buf));
        owned = false;
        buf = null;
      }
    }

    @Override
    protected void finalize() throws Throwable {
      if (owned)
        imaqDispose(getByteBufferAddress(buf));
      super.finalize();
    }

    public long getAddress() {
      if (buf == null)
        return 0;
      return getByteBufferAddress(buf);
    }

    public ByteBuffer getBuffer() {
      return buf;
    }

    public void setBuffer(ByteBuffer buf) {
      if (owned)
        free();
      this.buf = buf;
    }
  }

  private static long getPointer(ByteBuffer bb, int offset) {
    return (long) bb.getInt(offset);
  }

  private static void putPointer(ByteBuffer bb, int offset, long address) {
    bb.putInt(offset, (int) address);
  }

  private static void putPointer(ByteBuffer bb, int offset, ByteBuffer buf) {
    if (buf == null)
      bb.putInt(offset, 0);
    else
      bb.putInt(offset, (int) getByteBufferAddress(buf));
  }

  private static void putPointer(ByteBuffer bb, int offset, DisposedStruct struct) {
    if (struct == null)
      bb.putInt(offset, 0);
    else
      bb.putInt(offset, (int) struct.getAddress());
  }

  private static void putPointer(ByteBuffer bb, int offset, OpaqueStruct struct) {
    if (struct == null)
      bb.putInt(offset, 0);
    else
      bb.putInt(offset, (int) struct.getAddress());
  }

  /**
   * Opaque Structures
   */

  public static class CharSet extends OpaqueStruct {
    private CharSet() {}

    private CharSet(long nativeObj, boolean owned) {
      super(nativeObj, owned);
    }
  }

  public static class ClassifierSession extends OpaqueStruct {
    private ClassifierSession() {}

    private ClassifierSession(long nativeObj, boolean owned) {
      super(nativeObj, owned);
    }
  }

  public static class Image extends OpaqueStruct {
    private Image() {}

    private Image(long nativeObj, boolean owned) {
      super(nativeObj, owned);
    }
  }

  public static class MultipleGeometricPattern extends OpaqueStruct {
    private MultipleGeometricPattern() {}

    private MultipleGeometricPattern(long nativeObj, boolean owned) {
      super(nativeObj, owned);
    }
  }

  public static class Overlay extends OpaqueStruct {
    private Overlay() {}

    private Overlay(long nativeObj, boolean owned) {
      super(nativeObj, owned);
    }
  }

  public static class ROI extends OpaqueStruct {
    private ROI() {}

    private ROI(long nativeObj, boolean owned) {
      super(nativeObj, owned);
    }
  }

  /**
   * Manifest Constants
   */
  public static final boolean DEFAULT_SHOW_COORDINATES = true;
  public static final int DEFAULT_MAX_ICONS_PER_LINE = 4;
  public static final boolean DEFAULT_BMP_COMPRESS = false;
  public static final int DEFAULT_PNG_QUALITY = 750;
  public static final int DEFAULT_JPEG_QUALITY = 750;
  public static final int ALL_CONTOURS = -1;
  public static final int ALL_WINDOWS = -1;
  public static final int SHIFT = 1;
  public static final int ALT = 2;
  public static final int CTRL = 4;
  public static final int CAPS_LOCK = 8;
  public static final int MODAL_DIALOG = -1;
  public static final int USE_DEFAULT_QUALITY = -1;
  public static final int ALL_SAMPLES = -1;
  public static final int ALL_OBJECTS = -1;
  public static final int ALL_CHARACTERS = -1;

  /**
   * Predefined Valid Characters
   */
  public static final byte[] ANY_CHARACTER = {0};
  public static final byte[] ALPHABETIC = {0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
      0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
      0x59, 0x5a, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
      0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0};
  public static final byte[] ALPHANUMERIC = {0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
      0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
      0x59, 0x5a, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
      0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x30, 0x31,
      0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0};
  public static final byte[] UPPERCASE_LETTERS = {0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
      0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
      0x58, 0x59, 0x5a, 0};
  public static final byte[] LOWERCASE_LETTERS = {0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
      0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
      0x78, 0x79, 0x7a, 0};
  public static final byte[] DECIMAL_DIGITS = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
      0x38, 0x39, 0};
  public static final byte[] HEXADECIMAL_DIGITS = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
      0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0};
  public static final byte[] PATTERN = {0x5c, 0x78, 0x46, 0x46, 0};
  public static final byte[] FORCE_SPACE = {0x20, 0};

  /**
   * Enumerated Types
   */

  public static enum PointSymbol {
    POINT_AS_PIXEL(0), // A single pixel represents a point in the overlay.
    POINT_AS_CROSS(1), // A cross represents a point in the overlay.
    POINT_USER_DEFINED(2), // The pattern supplied by the user represents a
                           // point in the overlay.
    ;
    private final int value;

    private PointSymbol(int value) {
      this.value = value;
    }

    public static PointSymbol fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum MeasurementValue {
    AREA(0), // Surface area of the particle in pixels.
    AREA_CALIBRATED(1), // Surface area of the particle in calibrated units.
    NUM_HOLES(2), // Number of holes in the particle.
    AREA_OF_HOLES(3), // Surface area of the holes in calibrated units.
    TOTAL_AREA(4), // Total surface area (holes and particle) in calibrated
                   // units.
    IMAGE_AREA(5), // Surface area of the entire image in calibrated units.
    PARTICLE_TO_IMAGE(6), // Ratio, expressed as a percentage, of the surface
                          // area of a particle in relation to the total area of
                          // the particle.
    PARTICLE_TO_TOTAL(7), // Ratio, expressed as a percentage, of the surface
                          // area of a particle in relation to the total area of
                          // the particle.
    CENTER_MASS_X(8), // X-coordinate of the center of mass.
    CENTER_MASS_Y(9), // Y-coordinate of the center of mass.
    LEFT_COLUMN(10), // Left edge of the bounding rectangle.
    TOP_ROW(11), // Top edge of the bounding rectangle.
    RIGHT_COLUMN(12), // Right edge of the bounding rectangle.
    BOTTOM_ROW(13), // Bottom edge of bounding rectangle.
    WIDTH(14), // Width of bounding rectangle in calibrated units.
    HEIGHT(15), // Height of bounding rectangle in calibrated units.
    MAX_SEGMENT_LENGTH(16), // Length of longest horizontal line segment.
    MAX_SEGMENT_LEFT_COLUMN(17), // Leftmost x-coordinate of longest horizontal
                                 // line segment.
    MAX_SEGMENT_TOP_ROW(18), // Y-coordinate of longest horizontal line segment.
    PERIMETER(19), // Outer perimeter of the particle.
    PERIMETER_OF_HOLES(20), // Perimeter of all holes within the particle.
    SIGMA_X(21), // Sum of the particle pixels on the x-axis.
    SIGMA_Y(22), // Sum of the particle pixels on the y-axis.
    SIGMA_XX(23), // Sum of the particle pixels on the x-axis squared.
    SIGMA_YY(24), // Sum of the particle pixels on the y-axis squared.
    SIGMA_XY(25), // Sum of the particle pixels on the x-axis and y-axis.
    PROJ_X(26), // Projection corrected in X.
    PROJ_Y(27), // Projection corrected in Y.
    INERTIA_XX(28), // Inertia matrix coefficient in XX.
    INERTIA_YY(29), // Inertia matrix coefficient in YY.
    INERTIA_XY(30), // Inertia matrix coefficient in XY.
    MEAN_H(31), // Mean length of horizontal segments.
    MEAN_V(32), // Mean length of vertical segments.
    MAX_INTERCEPT(33), // Length of longest segment of the convex hull.
    MEAN_INTERCEPT(34), // Mean length of the chords in an object perpendicular
                        // to its max intercept.
    ORIENTATION(35), // The orientation based on the inertia of the pixels in
                     // the particle.
    EQUIV_ELLIPSE_MINOR(36), // Total length of the axis of the ellipse having
                             // the same area as the particle and a major axis
                             // equal to half the max intercept.
    ELLIPSE_MAJOR(37), // Total length of major axis having the same area and
                       // perimeter as the particle in calibrated units.
    ELLIPSE_MINOR(38), // Total length of minor axis having the same area and
                       // perimeter as the particle in calibrated units.
    ELLIPSE_RATIO(39), // Fraction of major axis to minor axis.
    RECT_LONG_SIDE(40), // Length of the long side of a rectangle having the
                        // same area and perimeter as the particle in calibrated
                        // units.
    RECT_SHORT_SIDE(41), // Length of the short side of a rectangle having the
                         // same area and perimeter as the particle in
                         // calibrated units.
    RECT_RATIO(42), // Ratio of rectangle long side to rectangle short side.
    ELONGATION(43), // Max intercept/mean perpendicular intercept.
    COMPACTNESS(44), // Particle area/(height x width).
    HEYWOOD(45), // Particle perimeter/perimeter of the circle having the same
                 // area as the particle.
    TYPE_FACTOR(46), // A complex factor relating the surface area to the moment
                     // of inertia.
    HYDRAULIC(47), // Particle area/particle perimeter.
    WADDLE_DISK(48), // Diameter of the disk having the same area as the
                     // particle in user units.
    DIAGONAL(49), // Diagonal of an equivalent rectangle in user units.
    ;
    private final int value;

    private MeasurementValue(int value) {
      this.value = value;
    }

    public static MeasurementValue fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ScalingMode {
    SCALE_LARGER(0), // The function duplicates pixels to make the image larger.
    SCALE_SMALLER(1), // The function subsamples pixels to make the image
                      // smaller.
    ;
    private final int value;

    private ScalingMode(int value) {
      this.value = value;
    }

    public static ScalingMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ScalingMethod {
    SCALE_TO_PRESERVE_AREA(0), // Correction functions scale the image such that
                               // the features in the corrected image have the
                               // same area as the features in the input image.
    SCALE_TO_FIT(1), // Correction functions scale the image such that the
                     // corrected image is the same size as the input image.
    ;
    private final int value;

    private ScalingMethod(int value) {
      this.value = value;
    }

    public static ScalingMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ReferenceMode {
    COORD_X_Y(0), // This method requires three elements in the points array.
    COORD_ORIGIN_X(1), // This method requires two elements in the points array.
    ;
    private final int value;

    private ReferenceMode(int value) {
      this.value = value;
    }

    public static ReferenceMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum RectOrientation {
    BASE_INSIDE(0), // Specifies that the base of the rectangular image lies
                    // along the inside edge of the annulus.
    BASE_OUTSIDE(1), // Specifies that the base of the rectangular image lies
                     // along the outside edge of the annulus.
    ;
    private final int value;

    private RectOrientation(int value) {
      this.value = value;
    }

    public static RectOrientation fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ShapeMode {
    SHAPE_RECT(1), // The function draws a rectangle.
    SHAPE_OVAL(2), // The function draws an oval.
    ;
    private final int value;

    private ShapeMode(int value) {
      this.value = value;
    }

    public static ShapeMode fromValue(int val) {
      for (ShapeMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum PolarityType {
    EDGE_RISING(1), // The edge is a rising edge.
    EDGE_FALLING(-1), // The edge is a falling edge.
    ;
    private final int value;

    private PolarityType(int value) {
      this.value = value;
    }

    public static PolarityType fromValue(int val) {
      for (PolarityType v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum SizeType {
    KEEP_LARGE(0), // The function keeps large particles remaining after the
                   // erosion.
    KEEP_SMALL(1), // The function keeps small particles eliminated by the
                   // erosion.
    ;
    private final int value;

    private SizeType(int value) {
      this.value = value;
    }

    public static SizeType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum Plane3D {
    C3D_REAL(0), // The function shows the real part of complex images.
    C3D_IMAGINARY(1), // The function shows the imaginary part of complex
                      // images.
    C3D_MAGNITUDE(2), // The function shows the magnitude part of complex
                      // images.
    C3D_PHASE(3), // The function shows the phase part of complex images.
    ;
    private final int value;

    private Plane3D(int value) {
      this.value = value;
    }

    public static Plane3D fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum PhotometricMode {
    WHITE_IS_ZERO(0), // The function interprets zero-value pixels as white.
    BLACK_IS_ZERO(1), // The function interprets zero-value pixels as black.
    ;
    private final int value;

    private PhotometricMode(int value) {
      this.value = value;
    }

    public static PhotometricMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ParticleInfoMode {
    BASIC_INFO(0), // The function returns only the following elements of each
                   // report: area, calibratedArea, boundingRect.
    ALL_INFO(1), // The function returns all the information about each
                 // particle.
    ;
    private final int value;

    private ParticleInfoMode(int value) {
      this.value = value;
    }

    public static ParticleInfoMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum OutlineMethod {
    EDGE_DIFFERENCE(0), // The function uses a method that produces continuous
                        // contours by highlighting each pixel where an
                        // intensity variation occurs between itself and its
                        // three upper-left neighbors.
    EDGE_GRADIENT(1), // The function uses a method that outlines contours where
                      // an intensity variation occurs along the vertical axis.
    EDGE_PREWITT(2), // The function uses a method that extracts the outer
                     // contours of objects.
    EDGE_ROBERTS(3), // The function uses a method that outlines the contours
                     // that highlight pixels where an intensity variation
                     // occurs along the diagonal axes.
    EDGE_SIGMA(4), // The function uses a method that outlines contours and
                   // details by setting pixels to the mean value found in their
                   // neighborhood, if their deviation from this value is not
                   // significant.
    EDGE_SOBEL(5), // The function uses a method that extracts the outer
                   // contours of objects.
    ;
    private final int value;

    private OutlineMethod(int value) {
      this.value = value;
    }

    public static OutlineMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum MorphologyMethod {
    AUTOM(0), // The function uses a transformation that generates simpler
              // particles that contain fewer details.
    CLOSE(1), // The function uses a transformation that fills tiny holes and
              // smooths boundaries.
    DILATE(2), // The function uses a transformation that eliminates tiny holes
               // isolated in particles and expands the contour of the particles
               // according to the template defined by the structuring element.
    ERODE(3), // The function uses a transformation that eliminates pixels
              // isolated in the background and erodes the contour of particles
              // according to the template defined by the structuring element.
    GRADIENT(4), // The function uses a transformation that leaves only the
                 // pixels that would be added by the dilation process or
                 // eliminated by the erosion process.
    GRADIENTOUT(5), // The function uses a transformation that leaves only the
                    // pixels that would be added by the dilation process.
    GRADIENTIN(6), // The function uses a transformation that leaves only the
                   // pixels that would be eliminated by the erosion process.
    HITMISS(7), // The function uses a transformation that extracts each pixel
                // located in a neighborhood exactly matching the template
                // defined by the structuring element.
    OPEN(8), // The function uses a transformation that removes small particles
             // and smooths boundaries.
    PCLOSE(9), // The function uses a transformation that fills tiny holes and
               // smooths the inner contour of particles according to the
               // template defined by the structuring element.
    POPEN(10), // The function uses a transformation that removes small
               // particles and smooths the contour of particles according to
               // the template defined by the structuring element.
    THICK(11), // The function uses a transformation that adds to an image those
               // pixels located in a neighborhood that matches a template
               // specified by the structuring element.
    THIN(12), // The function uses a transformation that eliminates pixels that
              // are located in a neighborhood matching a template specified by
              // the structuring element.
    ;
    private final int value;

    private MorphologyMethod(int value) {
      this.value = value;
    }

    public static MorphologyMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum MeterArcMode {
    METER_ARC_ROI(0), // The function uses the roi parameter and ignores the
                      // base, start, and end parameters.
    METER_ARC_POINTS(1), // The function uses the base,start, and end parameters
                         // and ignores the roi parameter.
    ;
    private final int value;

    private MeterArcMode(int value) {
      this.value = value;
    }

    public static MeterArcMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum RakeDirection {
    LEFT_TO_RIGHT(0), // The function searches from the left side of the search
                      // area to the right side of the search area.
    RIGHT_TO_LEFT(1), // The function searches from the right side of the search
                      // area to the left side of the search area.
    TOP_TO_BOTTOM(2), // The function searches from the top side of the search
                      // area to the bottom side of the search area.
    BOTTOM_TO_TOP(3), // The function searches from the bottom side of the
                      // search area to the top side of the search area.
    ;
    private final int value;

    private RakeDirection(int value) {
      this.value = value;
    }

    public static RakeDirection fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum TruncateMode {
    TRUNCATE_LOW(0), // The function truncates low frequencies.
    TRUNCATE_HIGH(1), // The function truncates high frequencies.
    ;
    private final int value;

    private TruncateMode(int value) {
      this.value = value;
    }

    public static TruncateMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum AttenuateMode {
    ATTENUATE_LOW(0), // The function attenuates low frequencies.
    ATTENUATE_HIGH(1), // The function attenuates high frequencies.
    ;
    private final int value;

    private AttenuateMode(int value) {
      this.value = value;
    }

    public static AttenuateMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum WindowThreadPolicy {
    CALLING_THREAD(0), // Using this policy, NI Vision creates windows in the
                       // thread that makes the first display function call for
                       // a given window number.
    SEPARATE_THREAD(1), // Using this policy, NI Vision creates windows in a
                        // separate thread and processes messages for the
                        // windows automatically.
    ;
    private final int value;

    private WindowThreadPolicy(int value) {
      this.value = value;
    }

    public static WindowThreadPolicy fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum WindowOptions {
    WIND_RESIZABLE(1), // When present, the user may resize the window
                       // interactively.
    WIND_TITLEBAR(2), // When present, the title bar on the window is visible.
    WIND_CLOSEABLE(4), // When present, the close box is available.
    WIND_TOPMOST(8), // When present, the window is always on top.
    ;
    private final int value;

    private WindowOptions(int value) {
      this.value = value;
    }

    public static WindowOptions fromValue(int val) {
      for (WindowOptions v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum WindowEventType {
    NO_EVENT(0), // No event occurred since the last call to imaqGetLastEvent().
    CLICK_EVENT(1), // The user clicked on a window.
    DRAW_EVENT(2), // The user drew an ROI in a window.
    MOVE_EVENT(3), // The user moved a window.
    SIZE_EVENT(4), // The user sized a window.
    SCROLL_EVENT(5), // The user scrolled a window.
    ACTIVATE_EVENT(6), // The user activated a window.
    CLOSE_EVENT(7), // The user closed a window.
    DOUBLE_CLICK_EVENT(8), // The user double-clicked in a window.
    ;
    private final int value;

    private WindowEventType(int value) {
      this.value = value;
    }

    public static WindowEventType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum VisionInfoType {
    ANY_VISION_INFO(0), // The function checks if any extra vision information
                        // is associated with the image.
    PATTERN_MATCHING_INFO(1), // The function checks if any pattern matching
                              // template information is associated with the
                              // image.
    CALIBRATION_INFO(2), // The function checks if any calibration information
                         // is associated with the image.
    OVERLAY_INFO(3), // The function checks if any overlay information is
                     // associated with the image.
    ;
    private final int value;

    private VisionInfoType(int value) {
      this.value = value;
    }

    public static VisionInfoType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum SearchStrategy {
    CONSERVATIVE(1), // Instructs the pattern matching algorithm to use the
                     // largest possible amount of information from the image at
                     // the expense of slowing down the speed of the algorithm.
    BALANCED(2), // Instructs the pattern matching algorithm to balance the
                 // amount of information from the image it uses with the speed
                 // of the algorithm.
    AGGRESSIVE(3), // Instructs the pattern matching algorithm to use a lower
                   // amount of information from the image, which allows the
                   // algorithm to run quickly but at the expense of accuracy.
    VERY_AGGRESSIVE(4), // Instructs the pattern matching algorithm to use the
                        // smallest possible amount of information from the
                        // image, which allows the algorithm to run at the
                        // highest speed possible but at the expense of
                        // accuracy.
    ;
    private final int value;

    private SearchStrategy(int value) {
      this.value = value;
    }

    public static SearchStrategy fromValue(int val) {
      for (SearchStrategy v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum TwoEdgePolarityType {
    NONE(0), // The function ignores the polarity of the edges.
    RISING_FALLING(1), // The polarity of the first edge is rising (dark to
                       // light) and the polarity of the second edge is falling
                       // (light to dark).
    FALLING_RISING(2), // The polarity of the first edge is falling (light to
                       // dark) and the polarity of the second edge is rising
                       // (dark to light).
    RISING_RISING(3), // The polarity of the first edge is rising (dark to
                      // light) and the polarity of the second edge is rising
                      // (dark to light).
    FALLING_FALLING(4), // The polarity of the first edge is falling (light to
                        // dark) and the polarity of the second edge is falling
                        // (light to dark).
    ;
    private final int value;

    private TwoEdgePolarityType(int value) {
      this.value = value;
    }

    public static TwoEdgePolarityType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ObjectType {
    BRIGHT_OBJECTS(0), // The function detects bright objects.
    DARK_OBJECTS(1), // The function detects dark objects.
    ;
    private final int value;

    private ObjectType(int value) {
      this.value = value;
    }

    public static ObjectType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum Tool {
    NO_TOOL(-1), // No tool is in the selected state.
    SELECTION_TOOL(0), // The selection tool selects an existing ROI in an
                       // image.
    POINT_TOOL(1), // The point tool draws a point on the image.
    LINE_TOOL(2), // The line tool draws a line on the image.
    RECTANGLE_TOOL(3), // The rectangle tool draws a rectangle on the image.
    OVAL_TOOL(4), // The oval tool draws an oval on the image.
    POLYGON_TOOL(5), // The polygon tool draws a polygon on the image.
    CLOSED_FREEHAND_TOOL(6), // The closed freehand tool draws closed freehand
                             // shapes on the image.
    ANNULUS_TOOL(7), // The annulus tool draws annuluses on the image.
    ZOOM_TOOL(8), // The zoom tool controls the zoom of an image.
    PAN_TOOL(9), // The pan tool shifts the view of the image.
    POLYLINE_TOOL(10), // The polyline tool draws a series of connected straight
                       // lines on the image.
    FREEHAND_TOOL(11), // The freehand tool draws freehand lines on the image.
    ROTATED_RECT_TOOL(12), // The rotated rectangle tool draws rotated
                           // rectangles on the image.
    ZOOM_OUT_TOOL(13), // The zoom out tool controls the zoom of an image.
    ;
    private final int value;

    private Tool(int value) {
      this.value = value;
    }

    public static Tool fromValue(int val) {
      for (Tool v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum TIFFCompressionType {
    NO_COMPRESSION(0), // The function does not compress the TIFF file.
    JPEG(1), // The function uses the JPEG compression algorithm to compress the
             // TIFF file.
    RUN_LENGTH(2), // The function uses a run length compression algorithm to
                   // compress the TIFF file.
    ZIP(3), // The function uses the ZIP compression algorithm to compress the
            // TIFF file.
    ;
    private final int value;

    private TIFFCompressionType(int value) {
      this.value = value;
    }

    public static TIFFCompressionType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ThresholdMethod {
    THRESH_CLUSTERING(0), // The function uses a method that sorts the histogram
                          // of the image within a discrete number of classes
                          // corresponding to the number of phases perceived in
                          // an image.
    THRESH_ENTROPY(1), // The function uses a method that is best for detecting
                       // particles that are present in minuscule proportions on
                       // the image.
    THRESH_METRIC(2), // The function uses a method that is well-suited for
                      // images in which classes are not too disproportionate.
    THRESH_MOMENTS(3), // The function uses a method that is suited for images
                       // that have poor contrast.
    THRESH_INTERCLASS(4), // The function uses a method that is well-suited for
                          // images in which classes have well separated pixel
                          // value distributions.
    ;
    private final int value;

    private ThresholdMethod(int value) {
      this.value = value;
    }

    public static ThresholdMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum TextAlignment {
    LEFT(0), // Left aligns the text at the reference point.
    CENTER(1), // Centers the text around the reference point.
    RIGHT(2), // Right aligns the text at the reference point.
    ;
    private final int value;

    private TextAlignment(int value) {
      this.value = value;
    }

    public static TextAlignment fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum SpokeDirection {
    OUTSIDE_TO_INSIDE(0), // The function searches from the outside of the
                          // search area to the inside of the search area.
    INSIDE_TO_OUTSIDE(1), // The function searches from the inside of the search
                          // area to the outside of the search area.
    ;
    private final int value;

    private SpokeDirection(int value) {
      this.value = value;
    }

    public static SpokeDirection fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum SkeletonMethod {
    SKELETON_L(0), // Uses an L-shaped structuring element in the skeleton
                   // function.
    SKELETON_M(1), // Uses an M-shaped structuring element in the skeleton
                   // function.
    SKELETON_INVERSE(2), // Uses an L-shaped structuring element on an inverse
                         // of the image in the skeleton function.
    ;
    private final int value;

    private SkeletonMethod(int value) {
      this.value = value;
    }

    public static SkeletonMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum VerticalTextAlignment {
    BOTTOM(0), // Aligns the bottom of the text at the reference point.
    TOP(1), // Aligns the top of the text at the reference point.
    BASELINE(2), // Aligns the baseline of the text at the reference point.
    ;
    private final int value;

    private VerticalTextAlignment(int value) {
      this.value = value;
    }

    public static VerticalTextAlignment fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum CalibrationROI {
    FULL_IMAGE(0), // The correction function corrects the whole image,
                   // regardless of the user-defined or calibration-defined
                   // ROIs.
    CALIBRATION_ROI(1), // The correction function corrects the area defined by
                        // the calibration ROI.
    USER_ROI(2), // The correction function corrects the area defined by the
                 // user-defined ROI.
    CALIBRATION_AND_USER_ROI(3), // The correction function corrects the area
                                 // defined by the intersection of the
                                 // user-defined ROI and the calibration ROI.
    CALIBRATION_OR_USER_ROI(4), // The correction function corrects the area
                                // defined by the union of the user-defined ROI
                                // and the calibration ROI.
    ;
    private final int value;

    private CalibrationROI(int value) {
      this.value = value;
    }

    public static CalibrationROI fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ContourType {
    EMPTY_CONTOUR(0), // The contour is empty.
    POINT(1), // The contour represents a point.
    LINE(2), // The contour represents a line.
    RECT(3), // The contour represents a rectangle.
    OVAL(4), // The contour represents an oval.
    CLOSED_CONTOUR(5), // The contour represents a series of connected points
                       // where the last point connects to the first.
    OPEN_CONTOUR(6), // The contour represents a series of connected points
                     // where the last point does not connect to the first.
    ANNULUS(7), // The contour represents an annulus.
    ROTATED_RECT(8), // The contour represents a rotated rectangle.
    ;
    private final int value;

    private ContourType(int value) {
      this.value = value;
    }

    public static ContourType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum MathTransformMethod {
    TRANSFORM_LINEAR(0), // The function uses linear remapping.
    TRANSFORM_LOG(1), // The function uses logarithmic remapping.
    TRANSFORM_EXP(2), // The function uses exponential remapping.
    TRANSFORM_SQR(3), // The function uses square remapping.
    TRANSFORM_SQRT(4), // The function uses square root remapping.
    TRANSFORM_POWX(5), // The function uses power X remapping.
    TRANSFORM_POW1X(6), // The function uses power 1/X remapping.
    ;
    private final int value;

    private MathTransformMethod(int value) {
      this.value = value;
    }

    public static MathTransformMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ComplexPlane {
    REAL(0), // The function operates on the real plane of the complex image.
    IMAGINARY(1), // The function operates on the imaginary plane of the complex
                  // image.
    MAGNITUDE(2), // The function operates on the magnitude plane of the complex
                  // image.
    PHASE(3), // The function operates on the phase plane of the complex image.
    ;
    private final int value;

    private ComplexPlane(int value) {
      this.value = value;
    }

    public static ComplexPlane fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum PaletteType {
    PALETTE_GRAY(0), // The function uses a palette that has a gradual
                     // gray-level variation from black to white.
    PALETTE_BINARY(1), // The function uses a palette of 16 cycles of 16
                       // different colors that is useful with binary images.
    PALETTE_GRADIENT(2), // The function uses a palette that has a gradation
                         // from red to white with a prominent range of light
                         // blue in the upper value range.
    PALETTE_RAINBOW(3), // The function uses a palette that has a gradation from
                        // blue to red with a prominent range of greens in the
                        // middle value range.
    PALETTE_TEMPERATURE(4), // The function uses a palette that has a gradation
                            // from light brown to dark brown.
    PALETTE_USER(5), // The function uses a palette defined by the user.
    ;
    private final int value;

    private PaletteType(int value) {
      this.value = value;
    }

    public static PaletteType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ColorSensitivity {
    SENSITIVITY_LOW(0), // Instructs the algorithm to divide the hue plane into
                        // a low number of sectors, allowing for simple color
                        // analysis.
    SENSITIVITY_MED(1), // Instructs the algorithm to divide the hue plane into
                        // a medium number of sectors, allowing for color
                        // analysis that balances sensitivity and complexity.
    SENSITIVITY_HIGH(2), // Instructs the algorithm to divide the hue plane into
                         // a high number of sectors, allowing for complex,
                         // sensitive color analysis.
    ;
    private final int value;

    private ColorSensitivity(int value) {
      this.value = value;
    }

    public static ColorSensitivity fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ColorMode {
    RGB(0), // The function operates in the RGB (Red, Blue, Green) color space.
    HSL(1), // The function operates in the HSL (Hue, Saturation, Luminance)
            // color space.
    HSV(2), // The function operates in the HSV (Hue, Saturation, Value) color
            // space.
    HSI(3), // The function operates in the HSI (Hue, Saturation, Intensity)
            // color space.
    CIE(4), // The function operates in the CIE L*a*b* color space.
    CIEXYZ(5), // The function operates in the CIE XYZ color space.
    ;
    private final int value;

    private ColorMode(int value) {
      this.value = value;
    }

    public static ColorMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DetectionMode {
    DETECT_PEAKS(0), // The function detects peaks.
    DETECT_VALLEYS(1), // The function detects valleys.
    ;
    private final int value;

    private DetectionMode(int value) {
      this.value = value;
    }

    public static DetectionMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum CalibrationUnit {
    UNDEFINED(0), // The image does not have a defined unit of measurement.
    ANGSTROM(1), // The unit of measure for the image is angstroms.
    MICROMETER(2), // The unit of measure for the image is micrometers.
    MILLIMETER(3), // The unit of measure for the image is millimeters.
    CENTIMETER(4), // The unit of measure for the image is centimeters.
    METER(5), // The unit of measure for the image is meters.
    KILOMETER(6), // The unit of measure for the image is kilometers.
    MICROINCH(7), // The unit of measure for the image is microinches.
    INCH(8), // The unit of measure for the image is inches.
    FOOT(9), // The unit of measure for the image is feet.
    NAUTICMILE(10), // The unit of measure for the image is nautical miles.
    GROUNDMILE(11), // The unit of measure for the image is ground miles.
    STEP(12), // The unit of measure for the image is steps.
    ;
    private final int value;

    private CalibrationUnit(int value) {
      this.value = value;
    }

    public static CalibrationUnit fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ConcentricRakeDirection {
    COUNTER_CLOCKWISE(0), // The function searches the search area in a
                          // counter-clockwise direction.
    CLOCKWISE(1), // The function searches the search area in a clockwise
                  // direction.
    ;
    private final int value;

    private ConcentricRakeDirection(int value) {
      this.value = value;
    }

    public static ConcentricRakeDirection fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum CalibrationMode {
    PERSPECTIVE(0), // Functions correct for distortion caused by the camera's
                    // perspective.
    NONLINEAR(1), // Functions correct for distortion caused by the camera's
                  // lens.
    SIMPLE_CALIBRATION(2), // Functions do not correct for distortion.
    CORRECTED_IMAGE(3), // The image is already corrected.
    ;
    private final int value;

    private CalibrationMode(int value) {
      this.value = value;
    }

    public static CalibrationMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum BrowserLocation {
    INSERT_FIRST_FREE(0), // Inserts the thumbnail in the first available cell.
    INSERT_END(1), // Inserts the thumbnail after the last occupied cell.
    ;
    private final int value;

    private BrowserLocation(int value) {
      this.value = value;
    }

    public static BrowserLocation fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum BrowserFrameStyle {
    RAISED_FRAME(0), // Each thumbnail has a raised frame.
    BEVELLED_FRAME(1), // Each thumbnail has a beveled frame.
    OUTLINE_FRAME(2), // Each thumbnail has an outlined frame.
    HIDDEN_FRAME(3), // Each thumbnail has a hidden frame.
    STEP_FRAME(4), // Each thumbnail has a stepped frame.
    RAISED_OUTLINE_FRAME(5), // Each thumbnail has a raised, outlined frame.
    ;
    private final int value;

    private BrowserFrameStyle(int value) {
      this.value = value;
    }

    public static BrowserFrameStyle fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum BorderMethod {
    BORDER_MIRROR(0), // Symmetrically copies pixel values from the image into
                      // the border.
    BORDER_COPY(1), // Copies the value of the pixel closest to the edge of the
                    // image into the border.
    BORDER_CLEAR(2), // Sets all pixels in the border to 0.
    ;
    private final int value;

    private BorderMethod(int value) {
      this.value = value;
    }

    public static BorderMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum BarcodeType {
    INVALID(-1), // The barcode is not of a type known by NI Vision.
    CODABAR(1), // The barcode is of type Codabar.
    CODE39(2), // The barcode is of type Code 39.
    CODE93(4), // The barcode is of type Code 93.
    CODE128(8), // The barcode is of type Code 128.
    EAN8(16), // The barcode is of type EAN 8.
    EAN13(32), // The barcode is of type EAN 13.
    I2_OF_5(64), // The barcode is of type Code 25.
    MSI(128), // The barcode is of type MSI code.
    UPCA(256), // The barcode is of type UPC A.
    PHARMACODE(512), // The barcode is of type Pharmacode.
    RSS_LIMITED(1024), // The barcode is of type RSS Limited.
    ;
    private final int value;

    private BarcodeType(int value) {
      this.value = value;
    }

    public static BarcodeType fromValue(int val) {
      for (BarcodeType v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum AxisOrientation {
    DIRECT(0), // The y-axis direction corresponds to the y-axis direction of
               // the Cartesian coordinate system.
    INDIRECT(1), // The y-axis direction corresponds to the y-axis direction of
                 // an image.
    ;
    private final int value;

    private AxisOrientation(int value) {
      this.value = value;
    }

    public static AxisOrientation fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ColorIgnoreMode {
    IGNORE_NONE(0), // Specifies that the function does not ignore any pixels.
    IGNORE_BLACK(1), // Specifies that the function ignores black pixels.
    IGNORE_WHITE(2), // Specifies that the function ignores white pixels.
    IGNORE_BLACK_AND_WHITE(3), // Specifies that the function ignores black
                               // pixels and white pixels.
    ;
    private final int value;

    private ColorIgnoreMode(int value) {
      this.value = value;
    }

    public static ColorIgnoreMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum LevelType {
    ABSOLUTE(0), // The function evaluates the threshold and hysteresis values
                 // as absolute values.
    RELATIVE(1), // The function evaluates the threshold and hysteresis values
                 // relative to the dynamic range of the given path.
    ;
    private final int value;

    private LevelType(int value) {
      this.value = value;
    }

    public static LevelType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum MatchingMode {
    MATCH_SHIFT_INVARIANT(1), // Searches for occurrences of the template image
                              // anywhere in the searchRect, assuming that the
                              // pattern is not rotated more than plus or minus
                              // 4 degrees.
    MATCH_ROTATION_INVARIANT(2), // Searches for occurrences of the pattern in
                                 // the image with no restriction on the
                                 // rotation of the pattern.
    ;
    private final int value;

    private MatchingMode(int value) {
      this.value = value;
    }

    public static MatchingMode fromValue(int val) {
      for (MatchingMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum MappingMethod {
    FULL_DYNAMIC(0), // (Obsolete) When the image bit depth is 0, the function
                     // maps the full dynamic range of the 16-bit image to an
                     // 8-bit scale.
    DOWNSHIFT(1), // (Obsolete) When the image bit depth is 0, the function
                  // shifts the 16-bit image pixels to the right the number of
                  // times specified by the shiftCount element of the
                  // DisplayMapping structure.
    RANGE(2), // (Obsolete) When the image bit depth is 0, the function maps the
              // pixel values in the range specified by the minimumValue and
              // maximumValue elements of the DisplayMapping structure to an
              // 8-bit scale.
    C90_PCT_DYNAMIC(3), // (Obsolete) When the image bit depth to 0, the
                        // function maps the dynamic range containing the middle
                        // 90 percent of the cumulated histogram of the image to
                        // an 8-bit (256 grayscale values) scale.
    PERCENT_RANGE(4), // (Obsolete) When the image bit depth is 0, the function
                      // maps the pixel values in the relative percentage range
                      // (0 to 100) of the cumulated histogram specified by
                      // minimumValue and maximumValue to an 8-bit scale.
    DEFAULT_MAPPING(10), // If the bit depth is 0, the function maps the 16-bit
                         // image to 8 bits by following the
                         // IMAQ_FULL_DYNAMIC_ALWAYS behavior; otherwise, the
                         // function shifts the image data to the right
                         // according to the IMAQ_MOST_SIGNIFICANT behavior.
    MOST_SIGNIFICANT(11), // The function shifts the 16-bit image pixels to the
                          // right until the 8 most significant bits of the
                          // image data are remaining.
    FULL_DYNAMIC_ALWAYS(12), // The function maps the full dynamic range of the
                             // 16-bit image to an 8-bit scale.
    DOWNSHIFT_ALWAYS(13), // The function shifts the 16-bit image pixels to the
                          // right the number of times specified by the
                          // shiftCount element of the DisplayMapping structure.
    RANGE_ALWAYS(14), // The function maps the pixel values in the range
                      // specified by the minimumValue and maximumValue elements
                      // of the DisplayMapping structure to an 8-bit scale.
    C90_PCT_DYNAMIC_ALWAYS(15), // The function maps the dynamic range
                                // containing the middle 90 percent of the
                                // cumulated histogram of the image to an 8-bit
                                // (256 grayscale values) scale.
    PERCENT_RANGE_ALWAYS(16), // The function maps the pixel values in the
                              // relative percentage range (0 to 100) of the
                              // cumulated histogram specified by minimumValue
                              // and maximumValue to an 8-bit scale.
    ;
    private final int value;

    private MappingMethod(int value) {
      this.value = value;
    }

    public static MappingMethod fromValue(int val) {
      for (MappingMethod v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ComparisonFunction {
    CLEAR_LESS(0), // The comparison is true if the source pixel value is less
                   // than the comparison image pixel value.
    CLEAR_LESS_OR_EQUAL(1), // The comparison is true if the source pixel value
                            // is less than or equal to the comparison image
                            // pixel value.
    CLEAR_EQUAL(2), // The comparison is true if the source pixel value is equal
                    // to the comparison image pixel value.
    CLEAR_GREATER_OR_EQUAL(3), // The comparison is true if the source pixel
                               // value is greater than or equal to the
                               // comparison image pixel value.
    CLEAR_GREATER(4), // The comparison is true if the source pixel value is
                      // greater than the comparison image pixel value.
    ;
    private final int value;

    private ComparisonFunction(int value) {
      this.value = value;
    }

    public static ComparisonFunction fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum LineGaugeMethod {
    EDGE_TO_EDGE(0), // Measures from the first edge on the line to the last
                     // edge on the line.
    EDGE_TO_POINT(1), // Measures from the first edge on the line to the end
                      // point of the line.
    POINT_TO_EDGE(2), // Measures from the start point of the line to the first
                      // edge on the line.
    POINT_TO_POINT(3), // Measures from the start point of the line to the end
                       // point of the line.
    ;
    private final int value;

    private LineGaugeMethod(int value) {
      this.value = value;
    }

    public static LineGaugeMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum Direction3D {
    C3D_NW(0), // The viewing angle for the 3D image is from the northwest.
    C3D_SW(1), // The viewing angle for the 3D image is from the southwest.
    C3D_SE(2), // The viewing angle for the 3D image is from the southeast.
    C3D_NE(3), // The viewing angle for the 3D image is from the northeast.
    ;
    private final int value;

    private Direction3D(int value) {
      this.value = value;
    }

    public static Direction3D fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum LearningMode {
    LEARN_ALL(0), // The function extracts information for shift- and
                  // rotation-invariant matching.
    LEARN_SHIFT_INFORMATION(1), // The function extracts information for
                                // shift-invariant matching.
    LEARN_ROTATION_INFORMATION(2), // The function extracts information for
                                   // rotation-invariant matching.
    ;
    private final int value;

    private LearningMode(int value) {
      this.value = value;
    }

    public static LearningMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum KernelFamily {
    GRADIENT_FAMILY(0), // The kernel is in the gradient family.
    LAPLACIAN_FAMILY(1), // The kernel is in the Laplacian family.
    SMOOTHING_FAMILY(2), // The kernel is in the smoothing family.
    GAUSSIAN_FAMILY(3), // The kernel is in the Gaussian family.
    ;
    private final int value;

    private KernelFamily(int value) {
      this.value = value;
    }

    public static KernelFamily fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum InterpolationMethod {
    ZERO_ORDER(0), // The function uses an interpolation method that
                   // interpolates new pixel values using the nearest valid
                   // neighboring pixel.
    BILINEAR(1), // The function uses an interpolation method that interpolates
                 // new pixel values using a bidirectional average of the
                 // neighboring pixels.
    QUADRATIC(2), // The function uses an interpolation method that interpolates
                  // new pixel values using a quadratic approximating
                  // polynomial.
    CUBIC_SPLINE(3), // The function uses an interpolation method that
                     // interpolates new pixel values by fitting them to a cubic
                     // spline curve, where the curve is based on known pixel
                     // values from the image.
    BILINEAR_FIXED(4), // The function uses an interpolation method that
                       // interpolates new pixel values using a bidirectional
                       // average of the neighboring pixels.
    ;
    private final int value;

    private InterpolationMethod(int value) {
      this.value = value;
    }

    public static InterpolationMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ImageType {
    IMAGE_U8(0), // The image type is 8-bit unsigned integer grayscale.
    IMAGE_U16(7), // The image type is 16-bit unsigned integer grayscale.
    IMAGE_I16(1), // The image type is 16-bit signed integer grayscale.
    IMAGE_SGL(2), // The image type is 32-bit floating-point grayscale.
    IMAGE_COMPLEX(3), // The image type is complex.
    IMAGE_RGB(4), // The image type is RGB color.
    IMAGE_HSL(5), // The image type is HSL color.
    IMAGE_RGB_U64(6), // The image type is 64-bit unsigned RGB color.
    ;
    private final int value;

    private ImageType(int value) {
      this.value = value;
    }

    public static ImageType fromValue(int val) {
      for (ImageType v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ImageFeatureMode {
    COLOR_AND_SHAPE_FEATURES(0), // Instructs the function to use the color and
                                 // the shape features of the color pattern.
    COLOR_FEATURES(1), // Instructs the function to use the color features of
                       // the color pattern.
    SHAPE_FEATURES(2), // Instructs the function to use the shape features of
                       // the color pattern.
    ;
    private final int value;

    private ImageFeatureMode(int value) {
      this.value = value;
    }

    public static ImageFeatureMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum FontColor {
    WHITE(0), // Draws text in white.
    BLACK(1), // Draws text in black.
    INVERT(2), // Inverts the text pixels.
    BLACK_ON_WHITE(3), // Draws text in black with a white background.
    WHITE_ON_BLACK(4), // Draws text in white with a black background.
    ;
    private final int value;

    private FontColor(int value) {
      this.value = value;
    }

    public static FontColor fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum FlipAxis {
    HORIZONTAL_AXIS(0), // Flips the image over the central horizontal axis.
    VERTICAL_AXIS(1), // Flips the image over the central vertical axis.
    CENTER_AXIS(2), // Flips the image over both the central vertical and
                    // horizontal axes.
    DIAG_L_TO_R_AXIS(3), // Flips the image over an axis from the upper left
                         // corner to lower right corner.
    DIAG_R_TO_L_AXIS(4), // Flips the image over an axis from the upper right
                         // corner to lower left corner.
    ;
    private final int value;

    private FlipAxis(int value) {
      this.value = value;
    }

    public static FlipAxis fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum EdgeProcess {
    FIRST(0), // The function looks for the first edge.
    FIRST_AND_LAST(1), // The function looks for the first and last edge.
    ALL(2), // The function looks for all edges.
    BEST(3), // The function looks for the best edge.
    ;
    private final int value;

    private EdgeProcess(int value) {
      this.value = value;
    }

    public static EdgeProcess fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DrawMode {
    DRAW_VALUE(0), // Draws the boundary of the object with the specified pixel
                   // value.
    DRAW_INVERT(2), // Inverts the pixel values of the boundary of the object.
    PAINT_VALUE(1), // Fills the object with the given pixel value.
    PAINT_INVERT(3), // Inverts the pixel values of the object.
    HIGHLIGHT_VALUE(4), // The function fills the object by highlighting the
                        // enclosed pixels with the color of the object.
    ;
    private final int value;

    private DrawMode(int value) {
      this.value = value;
    }

    public static DrawMode fromValue(int val) {
      for (DrawMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum NearestNeighborMetric {
    METRIC_MAXIMUM(0), // The maximum metric.
    METRIC_SUM(1), // The sum metric.
    METRIC_EUCLIDEAN(2), // The Euclidean metric.
    ;
    private final int value;

    private NearestNeighborMetric(int value) {
      this.value = value;
    }

    public static NearestNeighborMetric fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ReadResolution {
    LOW_RESOLUTION(0), // Configures NI Vision to use low resolution during the
                       // read process.
    MEDIUM_RESOLUTION(1), // Configures NI Vision to use medium resolution
                          // during the read process.
    HIGH_RESOLUTION(2), // Configures NI Vision to use high resolution during
                        // the read process.
    ;
    private final int value;

    private ReadResolution(int value) {
      this.value = value;
    }

    public static ReadResolution fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ThresholdMode {
    FIXED_RANGE(0), // Performs thresholding using the values you provide in the
                    // lowThreshold and highThreshold elements of
                    // OCRProcessingOptions.
    COMPUTED_UNIFORM(1), // Calculates a single threshold value for the entire
                         // ROI.
    COMPUTED_LINEAR(2), // Calculates a value on the left side of the ROI,
                        // calculates a value on the right side of the ROI, and
                        // linearly fills the middle values from left to right.
    COMPUTED_NONLINEAR(3), // Divides the ROI into the number of blocks
                           // specified by the blockCount element of
                           // OCRProcessingOptions and calculates a threshold
                           // value for each block.
    ;
    private final int value;

    private ThresholdMode(int value) {
      this.value = value;
    }

    public static ThresholdMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ReadStrategy {
    READ_AGGRESSIVE(0), // Configures NI Vision to perform fewer checks when
                        // analyzing objects to determine if they match trained
                        // characters.
    READ_CONSERVATIVE(1), // Configures NI Vision to perform more checks to
                          // determine if an object matches a trained character.
    ;
    private final int value;

    private ReadStrategy(int value) {
      this.value = value;
    }

    public static ReadStrategy fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum MeasurementType {
    MT_CENTER_OF_MASS_X(0), // X-coordinate of the point representing the
                            // average position of the total particle mass,
                            // assuming every point in the particle has a
                            // constant density.
    MT_CENTER_OF_MASS_Y(1), // Y-coordinate of the point representing the
                            // average position of the total particle mass,
                            // assuming every point in the particle has a
                            // constant density.
    MT_FIRST_PIXEL_X(2), // X-coordinate of the highest, leftmost particle
                         // pixel.
    MT_FIRST_PIXEL_Y(3), // Y-coordinate of the highest, leftmost particle
                         // pixel.
    MT_BOUNDING_RECT_LEFT(4), // X-coordinate of the leftmost particle point.
    MT_BOUNDING_RECT_TOP(5), // Y-coordinate of highest particle point.
    MT_BOUNDING_RECT_RIGHT(6), // X-coordinate of the rightmost particle point.
    MT_BOUNDING_RECT_BOTTOM(7), // Y-coordinate of the lowest particle point.
    MT_MAX_FERET_DIAMETER_START_X(8), // X-coordinate of the start of the line
                                      // segment connecting the two perimeter
                                      // points that are the furthest apart.
    MT_MAX_FERET_DIAMETER_START_Y(9), // Y-coordinate of the start of the line
                                      // segment connecting the two perimeter
                                      // points that are the furthest apart.
    MT_MAX_FERET_DIAMETER_END_X(10), // X-coordinate of the end of the line
                                     // segment connecting the two perimeter
                                     // points that are the furthest apart.
    MT_MAX_FERET_DIAMETER_END_Y(11), // Y-coordinate of the end of the line
                                     // segment connecting the two perimeter
                                     // points that are the furthest apart.
    MT_MAX_HORIZ_SEGMENT_LENGTH_LEFT(12), // X-coordinate of the leftmost pixel
                                          // in the longest row of contiguous
                                          // pixels in the particle.
    MT_MAX_HORIZ_SEGMENT_LENGTH_RIGHT(13), // X-coordinate of the rightmost
                                           // pixel in the longest row of
                                           // contiguous pixels in the particle.
    MT_MAX_HORIZ_SEGMENT_LENGTH_ROW(14), // Y-coordinate of all of the pixels in
                                         // the longest row of contiguous pixels
                                         // in the particle.
    MT_BOUNDING_RECT_WIDTH(16), // Distance between the x-coordinate of the
                                // leftmost particle point and the x-coordinate
                                // of the rightmost particle point.
    MT_BOUNDING_RECT_HEIGHT(17), // Distance between the y-coordinate of highest
                                 // particle point and the y-coordinate of the
                                 // lowest particle point.
    MT_BOUNDING_RECT_DIAGONAL(18), // Distance between opposite corners of the
                                   // bounding rectangle.
    MT_PERIMETER(19), // Length of the outer boundary of the particle.
    MT_CONVEX_HULL_PERIMETER(20), // Perimeter of the smallest convex polygon
                                  // containing all points in the particle.
    MT_HOLES_PERIMETER(21), // Sum of the perimeters of each hole in the
                            // particle.
    MT_MAX_FERET_DIAMETER(22), // Distance between the start and end of the line
                               // segment connecting the two perimeter points
                               // that are the furthest apart.
    MT_EQUIVALENT_ELLIPSE_MAJOR_AXIS(23), // Length of the major axis of the
                                          // ellipse with the same perimeter and
                                          // area as the particle.
    MT_EQUIVALENT_ELLIPSE_MINOR_AXIS(24), // Length of the minor axis of the
                                          // ellipse with the same perimeter and
                                          // area as the particle.
    MT_EQUIVALENT_ELLIPSE_MINOR_AXIS_FERET(25), // Length of the minor axis of
                                                // the ellipse with the same
                                                // area as the particle, and
                                                // Major Axis equal in length to
                                                // the Max Feret Diameter.
    MT_EQUIVALENT_RECT_LONG_SIDE(26), // Longest side of the rectangle with the
                                      // same perimeter and area as the
                                      // particle.
    MT_EQUIVALENT_RECT_SHORT_SIDE(27), // Shortest side of the rectangle with
                                       // the same perimeter and area as the
                                       // particle.
    MT_EQUIVALENT_RECT_DIAGONAL(28), // Distance between opposite corners of the
                                     // rectangle with the same perimeter and
                                     // area as the particle.
    MT_EQUIVALENT_RECT_SHORT_SIDE_FERET(29), // Shortest side of the rectangle
                                             // with the same area as the
                                             // particle, and longest side equal
                                             // in length to the Max Feret
                                             // Diameter.
    MT_AVERAGE_HORIZ_SEGMENT_LENGTH(30), // Average length of a horizontal
                                         // segment in the particle.
    MT_AVERAGE_VERT_SEGMENT_LENGTH(31), // Average length of a vertical segment
                                        // in the particle.
    MT_HYDRAULIC_RADIUS(32), // The particle area divided by the particle
                             // perimeter.
    MT_WADDEL_DISK_DIAMETER(33), // Diameter of a disk with the same area as the
                                 // particle.
    MT_AREA(35), // Area of the particle.
    MT_HOLES_AREA(36), // Sum of the areas of each hole in the particle.
    MT_PARTICLE_AND_HOLES_AREA(37), // Area of a particle that completely covers
                                    // the image.
    MT_CONVEX_HULL_AREA(38), // Area of the smallest convex polygon containing
                             // all points in the particle.
    MT_IMAGE_AREA(39), // Area of the image.
    MT_NUMBER_OF_HOLES(41), // Number of holes in the particle.
    MT_NUMBER_OF_HORIZ_SEGMENTS(42), // Number of horizontal segments in the
                                     // particle.
    MT_NUMBER_OF_VERT_SEGMENTS(43), // Number of vertical segments in the
                                    // particle.
    MT_ORIENTATION(45), // The angle of the line that passes through the
                        // particle Center of Mass about which the particle has
                        // the lowest moment of inertia.
    MT_MAX_FERET_DIAMETER_ORIENTATION(46), // The angle of the line segment
                                           // connecting the two perimeter
                                           // points that are the furthest
                                           // apart.
    MT_AREA_BY_IMAGE_AREA(48), // Percentage of the particle Area covering the
                               // Image Area.
    MT_AREA_BY_PARTICLE_AND_HOLES_AREA(49), // Percentage of the particle Area
                                            // in relation to its Particle and
                                            // Holes Area.
    MT_RATIO_OF_EQUIVALENT_ELLIPSE_AXES(50), // Equivalent Ellipse Major Axis
                                             // divided by Equivalent Ellipse
                                             // Minor Axis.
    MT_RATIO_OF_EQUIVALENT_RECT_SIDES(51), // Equivalent Rect Long Side divided
                                           // by Equivalent Rect Short Side.
    MT_ELONGATION_FACTOR(53), // Max Feret Diameter divided by Equivalent Rect
                              // Short Side (Feret).
    MT_COMPACTNESS_FACTOR(54), // Area divided by the product of Bounding Rect
                               // Width and Bounding Rect Height.
    MT_HEYWOOD_CIRCULARITY_FACTOR(55), // Perimeter divided by the circumference
                                       // of a circle with the same area.
    MT_TYPE_FACTOR(56), // Factor relating area to moment of inertia.
    MT_SUM_X(58), // The sum of all x-coordinates in the particle.
    MT_SUM_Y(59), // The sum of all y-coordinates in the particle.
    MT_SUM_XX(60), // The sum of all x-coordinates squared in the particle.
    MT_SUM_XY(61), // The sum of all x-coordinates times y-coordinates in the
                   // particle.
    MT_SUM_YY(62), // The sum of all y-coordinates squared in the particle.
    MT_SUM_XXX(63), // The sum of all x-coordinates cubed in the particle.
    MT_SUM_XXY(64), // The sum of all x-coordinates squared times y-coordinates
                    // in the particle.
    MT_SUM_XYY(65), // The sum of all x-coordinates times y-coordinates squared
                    // in the particle.
    MT_SUM_YYY(66), // The sum of all y-coordinates cubed in the particle.
    MT_MOMENT_OF_INERTIA_XX(68), // The moment of inertia in the x-direction
                                 // twice.
    MT_MOMENT_OF_INERTIA_XY(69), // The moment of inertia in the x and y
                                 // directions.
    MT_MOMENT_OF_INERTIA_YY(70), // The moment of inertia in the y-direction
                                 // twice.
    MT_MOMENT_OF_INERTIA_XXX(71), // The moment of inertia in the x-direction
                                  // three times.
    MT_MOMENT_OF_INERTIA_XXY(72), // The moment of inertia in the x-direction
                                  // twice and the y-direction once.
    MT_MOMENT_OF_INERTIA_XYY(73), // The moment of inertia in the x-direction
                                  // once and the y-direction twice.
    MT_MOMENT_OF_INERTIA_YYY(74), // The moment of inertia in the y-direction
                                  // three times.
    MT_NORM_MOMENT_OF_INERTIA_XX(75), // The normalized moment of inertia in the
                                      // x-direction twice.
    MT_NORM_MOMENT_OF_INERTIA_XY(76), // The normalized moment of inertia in the
                                      // x- and y-directions.
    MT_NORM_MOMENT_OF_INERTIA_YY(77), // The normalized moment of inertia in the
                                      // y-direction twice.
    MT_NORM_MOMENT_OF_INERTIA_XXX(78), // The normalized moment of inertia in
                                       // the x-direction three times.
    MT_NORM_MOMENT_OF_INERTIA_XXY(79), // The normalized moment of inertia in
                                       // the x-direction twice and the
                                       // y-direction once.
    MT_NORM_MOMENT_OF_INERTIA_XYY(80), // The normalized moment of inertia in
                                       // the x-direction once and the
                                       // y-direction twice.
    MT_NORM_MOMENT_OF_INERTIA_YYY(81), // The normalized moment of inertia in
                                       // the y-direction three times.
    MT_HU_MOMENT_1(82), // The first Hu moment.
    MT_HU_MOMENT_2(83), // The second Hu moment.
    MT_HU_MOMENT_3(84), // The third Hu moment.
    MT_HU_MOMENT_4(85), // The fourth Hu moment.
    MT_HU_MOMENT_5(86), // The fifth Hu moment.
    MT_HU_MOMENT_6(87), // The sixth Hu moment.
    MT_HU_MOMENT_7(88), // The seventh Hu moment.
    ;
    private final int value;

    private MeasurementType(int value) {
      this.value = value;
    }

    public static MeasurementType fromValue(int val) {
      for (MeasurementType v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum GeometricMatchingMode {
    GEOMETRIC_MATCH_SHIFT_INVARIANT(0), // Searches for occurrences of the
                                        // pattern in the image, assuming that
                                        // the pattern is not rotated more than
                                        // plus or minus 5 degrees.
    GEOMETRIC_MATCH_ROTATION_INVARIANT(1), // Searches for occurrences of the
                                           // pattern in the image with reduced
                                           // restriction on the rotation of the
                                           // pattern.
    GEOMETRIC_MATCH_SCALE_INVARIANT(2), // Searches for occurrences of the
                                        // pattern in the image with reduced
                                        // restriction on the size of the
                                        // pattern.
    GEOMETRIC_MATCH_OCCLUSION_INVARIANT(4), // Searches for occurrences of the
                                            // pattern in the image, allowing
                                            // for a specified percentage of the
                                            // pattern to be occluded.
    ;
    private final int value;

    private GeometricMatchingMode(int value) {
      this.value = value;
    }

    public static GeometricMatchingMode fromValue(int val) {
      for (GeometricMatchingMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ButtonLabel {
    BUTTON_OK(0), // The label "OK".
    BUTTON_SAVE(1), // The label "Save".
    BUTTON_SELECT(2), // The label "Select".
    BUTTON_LOAD(3), // The label "Load".
    ;
    private final int value;

    private ButtonLabel(int value) {
      this.value = value;
    }

    public static ButtonLabel fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum NearestNeighborMethod {
    MINIMUM_MEAN_DISTANCE(0), // The minimum mean distance method.
    K_NEAREST_NEIGHBOR(1), // The k-nearest neighbor method.
    NEAREST_PROTOTYPE(2), // The nearest prototype method.
    ;
    private final int value;

    private NearestNeighborMethod(int value) {
      this.value = value;
    }

    public static NearestNeighborMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum QRMirrorMode {
    QR_MIRROR_MODE_AUTO_DETECT(-2), // The function should determine if the QR
                                    // code is mirrored.
    QR_MIRROR_MODE_MIRRORED(1), // The function should expect the QR code to
                                // appear mirrored.
    QR_MIRROR_MODE_NORMAL(0), // The function should expect the QR code to
                              // appear normal.
    ;
    private final int value;

    private QRMirrorMode(int value) {
      this.value = value;
    }

    public static QRMirrorMode fromValue(int val) {
      for (QRMirrorMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ColumnProcessingMode {
    AVERAGE_COLUMNS(0), // Averages the data extracted for edge detection.
    MEDIAN_COLUMNS(1), // Takes the median of the data extracted for edge
                       // detection.
    ;
    private final int value;

    private ColumnProcessingMode(int value) {
      this.value = value;
    }

    public static ColumnProcessingMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum FindReferenceDirection {
    LEFT_TO_RIGHT_DIRECT(0), // Searches from the left side of the search area
                             // to the right side of the search area for a
                             // direct axis.
    LEFT_TO_RIGHT_INDIRECT(1), // Searches from the left side of the search area
                               // to the right side of the search area for an
                               // indirect axis.
    TOP_TO_BOTTOM_DIRECT(2), // Searches from the top of the search area to the
                             // bottom of the search area for a direct axis.
    TOP_TO_BOTTOM_INDIRECT(3), // Searches from the top of the search area to
                               // the bottom of the search area for an indirect
                               // axis.
    RIGHT_TO_LEFT_DIRECT(4), // Searches from the right side of the search area
                             // to the left side of the search area for a direct
                             // axis.
    RIGHT_TO_LEFT_INDIRECT(5), // Searches from the right side of the search
                               // area to the left side of the search area for
                               // an indirect axis.
    BOTTOM_TO_TOP_DIRECT(6), // Searches from the bottom of the search area to
                             // the top of the search area for a direct axis.
    BOTTOM_TO_TOP_INDIRECT(7), // Searches from the bottom of the search area to
                               // the top of the search area for an indirect
                               // axis.
    ;
    private final int value;

    private FindReferenceDirection(int value) {
      this.value = value;
    }

    public static FindReferenceDirection fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum MulticoreOperation {
    GET_CORES(0), // The number of processor cores NI Vision is currently using.
    SET_CORES(1), // The number of processor cores for NI Vision to use.
    USE_MAX_AVAILABLE(2), // Use the maximum number of available processor
                          // cores.
    ;
    private final int value;

    private MulticoreOperation(int value) {
      this.value = value;
    }

    public static MulticoreOperation fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum GroupBehavior {
    GROUP_CLEAR(0), // Sets the behavior of the overlay group to clear the
                    // current settings when an image is transformed.
    GROUP_KEEP(1), // Sets the behavior of the overlay group to keep the current
                   // settings when an image is transformed.
    GROUP_TRANSFORM(2), // Sets the behavior of the overlay group to transform
                        // with the image.
    ;
    private final int value;

    private GroupBehavior(int value) {
      this.value = value;
    }

    public static GroupBehavior fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum QRDimensions {
    QR_DIMENSIONS_AUTO_DETECT(0), // The function will automatically determine
                                  // the dimensions of the QR code.
    QR_DIMENSIONS_11x11(11), // Specifies the dimensions of the QR code as 11 x
                             // 11.
    QR_DIMENSIONS_13x13(13), // Specifies the dimensions of the QR code as 13 x
                             // 13.
    QR_DIMENSIONS_15x15(15), // Specifies the dimensions of the QR code as 15 x
                             // 15.
    QR_DIMENSIONS_17x17(17), // Specifies the dimensions of the QR code as 17 x
                             // 17.
    QR_DIMENSIONS_21x21(21), // Specifies the dimensions of the QR code as 21 x
                             // 21.
    QR_DIMENSIONS_25x25(25), // Specifies the dimensions of the QR code as 25 x
                             // 25.
    QR_DIMENSIONS_29x29(29), // Specifies the dimensions of the QR code as 29 x
                             // 29.
    QR_DIMENSIONS_33x33(33), // Specifies the dimensions of the QR code as 33 x
                             // 33.
    QR_DIMENSIONS_37x37(37), // Specifies the dimensions of the QR code as 37 x
                             // 37.
    QR_DIMENSIONS_41x41(41), // Specifies the dimensions of the QR code as 41 x
                             // 41.
    QR_DIMENSIONS_45x45(45), // Specifies the dimensions of the QR code as 45 x
                             // 45.
    QR_DIMENSIONS_49x49(49), // Specifies the dimensions of the QR code as 49 x
                             // 49.
    QR_DIMENSIONS_53x53(53), // Specifies the dimensions of the QR code as 53 x
                             // 53.
    QR_DIMENSIONS_57x57(57), // Specifies the dimensions of the QR code as 57 x
                             // 57.
    QR_DIMENSIONS_61x61(61), // Specifies the dimensions of the QR code as 61 x
                             // 61.
    QR_DIMENSIONS_65x65(65), // Specifies the dimensions of the QR code as 65 x
                             // 65.
    QR_DIMENSIONS_69x69(69), // Specifies the dimensions of the QR code as 69 x
                             // 69.
    QR_DIMENSIONS_73x73(73), // Specifies the dimensions of the QR code as 73 x
                             // 73.
    QR_DIMENSIONS_77x77(77), // Specifies the dimensions of the QR code as 77 x
                             // 77.
    QR_DIMENSIONS_81x81(81), // Specifies the dimensions of the QR code as 81 x
                             // 81.
    QR_DIMENSIONS_85x85(85), // Specifies the dimensions of the QR code as 85 x
                             // 85.
    QR_DIMENSIONS_89x89(89), // Specifies the dimensions of the QR code as 89 x
                             // 89.
    QR_DIMENSIONS_93x93(93), // Specifies the dimensions of the QR code as 93 x
                             // 93.
    QR_DIMENSIONS_97x97(97), // Specifies the dimensions of the QR code as 97 x
                             // 97.
    QR_DIMENSIONS_101x101(101), // Specifies the dimensions of the QR code as
                                // 101 x 101.
    QR_DIMENSIONS_105x105(105), // Specifies the dimensions of the QR code as
                                // 105 x 105.
    QR_DIMENSIONS_109x109(109), // Specifies the dimensions of the QR code as
                                // 109 x 109.
    QR_DIMENSIONS_113x113(113), // Specifies the dimensions of the QR code as
                                // 113 x 113.
    QR_DIMENSIONS_117x117(117), // Specifies the dimensions of the QR code as
                                // 117 x 117.
    QR_DIMENSIONS_121x121(121), // Specifies the dimensions of the QR code as
                                // 121 x 121.
    QR_DIMENSIONS_125x125(125), // Specifies the dimensions of the QR code as
                                // 125 x 125.
    QR_DIMENSIONS_129x129(129), // Specifies the dimensions of the QR code as
                                // 129 x 129.
    QR_DIMENSIONS_133x133(133), // Specifies the dimensions of the QR code as
                                // 133 x 133.
    QR_DIMENSIONS_137x137(137), // Specifies the dimensions of the QR code as
                                // 137 x 137.
    QR_DIMENSIONS_141x141(141), // Specifies the dimensions of the QR code as
                                // 141 x 141.
    QR_DIMENSIONS_145x145(145), // Specifies the dimensions of the QR code as
                                // 145 x 145.
    QR_DIMENSIONS_149x149(149), // Specifies the dimensions of the QR code as
                                // 149 x 149.
    QR_DIMENSIONS_153x153(153), // Specifies the dimensions of the QR code as
                                // 153 x 153.
    QR_DIMENSIONS_157x157(157), // Specifies the dimensions of the QR code as
                                // 157 x 1537.
    QR_DIMENSIONS_161x161(161), // Specifies the dimensions of the QR code as
                                // 161 x 161.
    QR_DIMENSIONS_165x165(165), // Specifies the dimensions of the QR code as
                                // 165 x 165.
    QR_DIMENSIONS_169x169(169), // Specifies the dimensions of the QR code as
                                // 169 x 169.
    QR_DIMENSIONS_173x173(173), // Specifies the dimensions of the QR code as
                                // 173 x 173.
    QR_DIMENSIONS_177x177(177), // Specifies the dimensions of the QR code as
                                // 177 x 177.
    ;
    private final int value;

    private QRDimensions(int value) {
      this.value = value;
    }

    public static QRDimensions fromValue(int val) {
      for (QRDimensions v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum QRCellFilterMode {
    QR_CELL_FILTER_MODE_AUTO_DETECT(-2), // The function will try all filter
                                         // modes and uses the one that decodes
                                         // the QR code within the fewest
                                         // iterations and utilizing the least
                                         // amount of error correction.
    QR_CELL_FILTER_MODE_AVERAGE(0), // The function sets the pixel value for the
                                    // cell to the average of the sampled
                                    // pixels.
    QR_CELL_FILTER_MODE_MEDIAN(1), // The function sets the pixel value for the
                                   // cell to the median of the sampled pixels.
    QR_CELL_FILTER_MODE_CENTRAL_AVERAGE(2), // The function sets the pixel value
                                            // for the cell to the average of
                                            // the pixels in the center of the
                                            // cell sample.
    QR_CELL_FILTER_MODE_HIGH_AVERAGE(3), // The function sets the pixel value
                                         // for the cell to the average value of
                                         // the half of the sampled pixels with
                                         // the highest pixel values.
    QR_CELL_FILTER_MODE_LOW_AVERAGE(4), // The function sets the pixel value for
                                        // the cell to the average value of the
                                        // half of the sampled pixels with the
                                        // lowest pixel values.
    QR_CELL_FILTER_MODE_VERY_HIGH_AVERAGE(5), // The function sets the pixel
                                              // value for the cell to the
                                              // average value of the ninth of
                                              // the sampled pixels with the
                                              // highest pixel values.
    QR_CELL_FILTER_MODE_VERY_LOW_AVERAGE(6), // The function sets the pixel
                                             // value for the cell to the
                                             // average value of the ninth of
                                             // the sampled pixels with the
                                             // lowest pixel values.
    QR_CELL_FILTER_MODE_ALL(8), // The function tries each filter mode, starting
                                // with IMAQ_QR_CELL_FILTER_MODE_AVERAGE and
                                // ending with
                                // IMAQ_QR_CELL_FILTER_MODE_VERY_LOW_AVERAGE,
                                // stopping once a filter mode decodes
                                // correctly.
    ;
    private final int value;

    private QRCellFilterMode(int value) {
      this.value = value;
    }

    public static QRCellFilterMode fromValue(int val) {
      for (QRCellFilterMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum RoundingMode {
    ROUNDING_MODE_OPTIMIZE(0), // Rounds the result of a division using the best
                               // available method.
    ROUNDING_MODE_TRUNCATE(1), // Truncates the result of a division.
    ;
    private final int value;

    private RoundingMode(int value) {
      this.value = value;
    }

    public static RoundingMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum QRDemodulationMode {
    QR_DEMODULATION_MODE_AUTO_DETECT(-2), // The function will try each
                                          // demodulation mode and use the one
                                          // which decodes the QR code within
                                          // the fewest iterations and utilizing
                                          // the least amount of error
                                          // correction.
    QR_DEMODULATION_MODE_HISTOGRAM(0), // The function uses a histogram of all
                                       // of the QR cells to calculate a
                                       // threshold.
    QR_DEMODULATION_MODE_LOCAL_CONTRAST(1), // The function examines each of the
                                            // cell's neighbors to determine if
                                            // the cell is on or off.
    QR_DEMODULATION_MODE_COMBINED(2), // The function uses the histogram of the
                                      // QR code to calculate a threshold.
    QR_DEMODULATION_MODE_ALL(3), // The function tries
                                 // IMAQ_QR_DEMODULATION_MODE_HISTOGRAM, then
                                 // IMAQ_QR_DEMODULATION_MODE_LOCAL_CONTRAST and
                                 // then IMAQ_QR_DEMODULATION_MODE_COMBINED,
                                 // stopping once one mode is successful.
    ;
    private final int value;

    private QRDemodulationMode(int value) {
      this.value = value;
    }

    public static QRDemodulationMode fromValue(int val) {
      for (QRDemodulationMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ContrastMode {
    ORIGINAL_CONTRAST(0), // Instructs the geometric matching algorithm to find
                          // matches with the same contrast as the template.
    REVERSED_CONTRAST(1), // Instructs the geometric matching algorithm to find
                          // matches with the inverted contrast of the template.
    BOTH_CONTRASTS(2), // Instructs the geometric matching algorithm to find
                       // matches with the same and inverted contrast of the
                       // template.
    ;
    private final int value;

    private ContrastMode(int value) {
      this.value = value;
    }

    public static ContrastMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum QRPolarities {
    QR_POLARITY_AUTO_DETECT(-2), // The function should determine the polarity
                                 // of the QR code.
    QR_POLARITY_BLACK_ON_WHITE(0), // The function should search for a QR code
                                   // with dark data on a bright background.
    QR_POLARITY_WHITE_ON_BLACK(1), // The function should search for a QR code
                                   // with bright data on a dark background.
    ;
    private final int value;

    private QRPolarities(int value) {
      this.value = value;
    }

    public static QRPolarities fromValue(int val) {
      for (QRPolarities v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum QRRotationMode {
    QR_ROTATION_MODE_UNLIMITED(0), // The function allows for unlimited
                                   // rotation.
    QR_ROTATION_MODE_0_DEGREES(1), // The function allows for ??? 5 degrees of
                                   // rotation.
    QR_ROTATION_MODE_90_DEGREES(2), // The function allows for between 85 and 95
                                    // degrees of rotation.
    QR_ROTATION_MODE_180_DEGREES(3), // The function allows for between 175 and
                                     // 185 degrees of rotation.
    QR_ROTATION_MODE_270_DEGREES(4), // The function allows for between 265 and
                                     // 275 degrees of rotation.
    ;
    private final int value;

    private QRRotationMode(int value) {
      this.value = value;
    }

    public static QRRotationMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum QRGradingMode {
    QR_NO_GRADING(0), // The function does not make any preparatory
                      // calculations.
    ;
    private final int value;

    private QRGradingMode(int value) {
      this.value = value;
    }

    public static QRGradingMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum StraightEdgeSearchMode {
    USE_FIRST_RAKE_EDGES(0), // Fits a straight edge on the first points
                             // detected using a rake.
    USE_BEST_RAKE_EDGES(1), // Fits a straight edge on the best points detected
                            // using a rake.
    USE_BEST_HOUGH_LINE(2), // Finds the strongest straight edge using all
                            // points detected on a rake.
    USE_FIRST_PROJECTION_EDGE(3), // Uses the location of the first projected
                                  // edge as the straight edge.
    USE_BEST_PROJECTION_EDGE(4), // Finds the strongest projected edge location
                                 // to determine the straight edge.
    ;
    private final int value;

    private StraightEdgeSearchMode(int value) {
      this.value = value;
    }

    public static StraightEdgeSearchMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum SearchDirection {
    SEARCH_DIRECTION_LEFT_TO_RIGHT(0), // Searches from the left side of the
                                       // search area to the right side of the
                                       // search area.
    SEARCH_DIRECTION_RIGHT_TO_LEFT(1), // Searches from the right side of the
                                       // search area to the left side of the
                                       // search area.
    SEARCH_DIRECTION_TOP_TO_BOTTOM(2), // Searches from the top side of the
                                       // search area to the bottom side of the
                                       // search area.
    SEARCH_DIRECTION_BOTTOM_TO_TOP(3), // Searches from the bottom side of the
                                       // search area to the top side of the
                                       // search area.
    ;
    private final int value;

    private SearchDirection(int value) {
      this.value = value;
    }

    public static SearchDirection fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum QRStreamMode {
    QR_MODE_NUMERIC(0), // Specifies that the data was encoded using numeric
                        // mode.
    QR_MODE_ALPHANUMERIC(1), // Specifies that the data was encoded using
                             // alpha-numeric mode.
    QR_MODE_RAW_BYTE(2), // Specifies that the data was not encoded but is only
                         // raw binary bytes, or encoded in JIS-8.
    QR_MODE_EAN128_TOKEN(3), // Specifies that the data has a special meaning
                             // represented by the application ID.
    QR_MODE_EAN128_DATA(4), // Specifies that the data has a special meaning
                            // represented by the application ID.
    QR_MODE_ECI(5), // Specifies that the data was meant to be read using the
                    // language represented in the language ID.
    QR_MODE_KANJI(6), // Specifies that the data was encoded in Shift-JIS16
                      // Japanese.
    ;
    private final int value;

    private QRStreamMode(int value) {
      this.value = value;
    }

    public static QRStreamMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ParticleClassifierType {
    PARTICLE_LARGEST(0), // Use only the largest particle in the image.
    PARTICLE_ALL(1), // Use all particles in the image.
    ;
    private final int value;

    private ParticleClassifierType(int value) {
      this.value = value;
    }

    public static ParticleClassifierType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum QRCellSampleSize {
    QR_CELL_SAMPLE_SIZE_AUTO_DETECT(-2), // The function will try each sample
                                         // size and use the one which decodes
                                         // the QR code within the fewest
                                         // iterations and utilizing the least
                                         // amount of error correction.
    QR_CELL_SAMPLE_SIZE1X1(1), // The function will use a 1x1 sized sample from
                               // each cell.
    QR_CELL_SAMPLE_SIZE2X2(2), // The function will use a 2x2 sized sample from
                               // each cell.
    QR_CELL_SAMPLE_SIZE3X3(3), // The function will use a 3x3 sized sample from
                               // each cell.
    QR_CELL_SAMPLE_SIZE4X4(4), // The function will use a 4x4 sized sample from
                               // each cell.
    QR_CELL_SAMPLE_SIZE5X5(5), // The function will use a 5x5 sized sample from
                               // each cell.
    QR_CELL_SAMPLE_SIZE6X6(6), // The function will use a 6x6 sized sample from
                               // each cell.
    QR_CELL_SAMPLE_SIZE7X7(7), // The function will use a 7x7 sized sample from
                               // each cell.
    ;
    private final int value;

    private QRCellSampleSize(int value) {
      this.value = value;
    }

    public static QRCellSampleSize fromValue(int val) {
      for (QRCellSampleSize v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum RakeProcessType {
    GET_FIRST_EDGES(0), GET_FIRST_AND_LAST_EDGES(1), GET_ALL_EDGES(2), GET_BEST_EDGES(3), ;
    private final int value;

    private RakeProcessType(int value) {
      this.value = value;
    }

    public static RakeProcessType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum GeometricSetupDataItem {
    CURVE_EXTRACTION_MODE(0), // Specifies how the function identifies curves in
                              // the image.
    CURVE_EDGE_THRSHOLD(1), // Specifies the minimum contrast an edge pixel must
                            // have for it to be considered part of a curve.
    CURVE_EDGE_FILTER(2), // Specifies the width of the edge filter that the
                          // function uses to identify curves in the image.
    MINIMUM_CURVE_LENGTH(3), // Specifies the length, in pixels, of the smallest
                             // curve that you want the function to identify.
    CURVE_ROW_SEARCH_STEP_SIZE(4), // Specifies the distance, in the y
                                   // direction, between the image rows that the
                                   // algorithm inspects for curve seed points.
    CURVE_COL_SEARCH_STEP_SIZE(5), // Specifies the distance, in the x
                                   // direction, between the image columns that
                                   // the algorithm inspects for curve seed
                                   // points.
    CURVE_MAX_END_POINT_GAP(6), // Specifies the maximum gap, in pixels, between
                                // the endpoints of a curve that the function
                                // identifies as a closed curve.
    EXTRACT_CLOSED_CURVES(7), // Specifies whether to identify only closed
                              // curves in the image.
    ENABLE_SUBPIXEL_CURVE_EXTRACTION(8), // The function ignores this option.
    ENABLE_CORRELATION_SCORE(9), // Specifies that the function should calculate
                                 // the Correlation Score and return it for each
                                 // match result.
    ENABLE_SUBPIXEL_ACCURACY(10), // Determines whether to return the match
                                  // results with subpixel accuracy.
    SUBPIXEL_ITERATIONS(11), // Specifies the maximum number of incremental
                             // improvements used to refine matches using
                             // subpixel information.
    SUBPIXEL_TOLERANCE(12), // Specifies the maximum amount of change, in
                            // pixels, between consecutive incremental
                            // improvements in the match position before the
                            // function stops refining the match position.
    INITIAL_MATCH_LIST_LENGTH(13), // Specifies the maximum size of the match
                                   // list.
    ENABLE_TARGET_TEMPLATE_CURVESCORE(14), // Specifies whether the function
                                           // should calculate the match curve
                                           // to template curve score and return
                                           // it for each match result.
    MINIMUM_MATCH_SEPARATION_DISTANCE(15), // Specifies the minimum separation
                                           // distance, in pixels, between the
                                           // origins of two matches that have
                                           // unique positions.
    MINIMUM_MATCH_SEPARATION_ANGLE(16), // Specifies the minimum angular
                                        // difference, in degrees, between two
                                        // matches that have unique angles.
    MINIMUM_MATCH_SEPARATION_SCALE(17), // Specifies the minimum difference in
                                        // scale, expressed as a percentage,
                                        // between two matches that have unique
                                        // scales.
    MAXIMUM_MATCH_OVERLAP(18), // Specifies whether you want the algorithm to
                               // spend less time accurately estimating the
                               // location of a match.
    ENABLE_COARSE_RESULT(19), // Specifies whether you want the algorithm to
                              // spend less time accurately estimating the
                              // location of a match.
    ENABLE_CALIBRATION_SUPPORT(20), // Specifies whether or not the algorithm
                                    // treat the inspection image as a
                                    // calibrated image.
    ENABLE_CONTRAST_REVERSAL(21), // Specifies the contrast of the matches to
                                  // search for.
    SEARCH_STRATEGY(22), // Specifies the aggressiveness of the strategy used to
                         // find matches in the image.
    REFINEMENT_MATCH_FACTOR(23), // Specifies the factor applied to the number
                                 // of matches requested to determine how many
                                 // matches are refined in the pyramid stage.
    SUBPIXEL_MATCH_FACTOR(24), // Specifies the factor applied to the number for
                               // matches requested to determine how many
                               // matches are used for the final (subpixel)
                               // stage.
    MAX_REFINEMENT_ITERATIONS(25), // Specifies maximum refinement iteration.
    ;
    private final int value;

    private GeometricSetupDataItem(int value) {
      this.value = value;
    }

    public static GeometricSetupDataItem fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DistortionModel {
    POLYNOMIAL_MODEL(0), // Polynomial model.
    DIVISION_MODEL(1), // Division Model.
    NO_DISTORTION_MODEL(-1), // Not a distortion model.
    ;
    private final int value;

    private DistortionModel(int value) {
      this.value = value;
    }

    public static DistortionModel fromValue(int val) {
      for (DistortionModel v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum CalibrationThumbnailType {
    CAMARA_MODEL_TYPE(0), // Camara model thumbnail type.
    PERSPECTIVE_TYPE(1), // Perspective thumbnail type.
    MICRO_PLANE_TYPE(2), // Micro Plane thumbnail type.
    ;
    private final int value;

    private CalibrationThumbnailType(int value) {
      this.value = value;
    }

    public static CalibrationThumbnailType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum SettingType {
    ROTATION_ANGLE_RANGE(0), // Set a range for this option to specify the
                             // angles at which you expect the Function to find
                             // template matches in the inspection image.
    SCALE_RANGE(1), // Set a range for this option to specify the sizes at which
                    // you expect the Function to find template matches in the
                    // inspection image.
    OCCLUSION_RANGE(2), // Set a range for this option to specify the amount of
                        // occlusion you expect for a match in the inspection
                        // image.
    ;
    private final int value;

    private SettingType(int value) {
      this.value = value;
    }

    public static SettingType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum SegmentationDistanceLevel {
    SEGMENTATION_LEVEL_CONSERVATIVE(0), // Uses extensive criteria to determine
                                        // the Maximum Distance.
    SEGMENTATION_LEVEL_AGGRESSIVE(1), // Uses few criteria to determine the
                                      // Maximum Distance.
    ;
    private final int value;

    private SegmentationDistanceLevel(int value) {
      this.value = value;
    }

    public static SegmentationDistanceLevel fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ExtractContourSelection {
    CLOSEST(0), // Selects the curve closest to the ROI.
    LONGEST(1), // Selects the longest curve.
    STRONGEST(2), // Selects the curve with the highest edge strength averaged
                  // from each point on the curve.
    ;
    private final int value;

    private ExtractContourSelection(int value) {
      this.value = value;
    }

    public static ExtractContourSelection fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum FindTransformMode {
    FIND_REFERENCE(0), // Update both parts of the coordinate system.
    UPDATE_TRANSFORM(1), // Update only the new reference system.
    ;
    private final int value;

    private FindTransformMode(int value) {
      this.value = value;
    }

    public static FindTransformMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ExtractContourDirection {
    RECT_LEFT_RIGHT(0), // Searches the ROI from left to right.
    RECT_RIGHT_LEFT(1), // Searches the ROI from right to left.
    RECT_TOP_BOTTOM(2), // Searches the ROI from top to bottom.
    RECT_BOTTOM_TOP(3), // Searches the ROI from bottom to top.
    ANNULUS_INNER_OUTER(4), // Searches the ROI from the inner radius to the
                            // outer radius.
    ANNULUS_OUTER_INNER(5), // Searches the ROI from the outer radius to the
                            // inner radius.
    ANNULUS_START_STOP(6), // Searches the ROI from start angle to end angle.
    ANNULUS_STOP_START(7), // Searches the ROI from end angle to start angle.
    ;
    private final int value;

    private ExtractContourDirection(int value) {
      this.value = value;
    }

    public static ExtractContourDirection fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum EdgePolaritySearchMode {
    SEARCH_FOR_ALL_EDGES(0), // Searches for all edges.
    SEARCH_FOR_RISING_EDGES(1), // Searches for rising edges only.
    SEARCH_FOR_FALLING_EDGES(2), // Searches for falling edges only.
    ;
    private final int value;

    private EdgePolaritySearchMode(int value) {
      this.value = value;
    }

    public static EdgePolaritySearchMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum Connectivity {
    FOUR_CONNECTED(0), // Morphological reconstruction is performed in
                       // connectivity mode 4.
    EIGHT_CONNECTED(1), // Morphological reconstruction is performed in
                        // connectivity mode 8.
    ;
    private final int value;

    private Connectivity(int value) {
      this.value = value;
    }

    public static Connectivity fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum MorphologyReconstructOperation {
    DILATE_RECONSTRUCT(0), // Performs Reconstruction by dilation.
    ERODE_RECONSTRUCT(1), // Performs Reconstruction by erosion.
    ;
    private final int value;

    private MorphologyReconstructOperation(int value) {
      this.value = value;
    }

    public static MorphologyReconstructOperation fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum WaveletType {
    DB02(0), DB03(1), DB04(2), // Specifies the Wavelet Type as DB02.
    DB05(3), DB06(4), DB07(5), DB08(6), DB09(7), DB10(8), DB11(9), DB12(10), DB13(11), DB14(12), HAAR(
        13), BIOR1_3(14), BIOR1_5(15), BIOR2_2(16), BIOR2_4(17), BIOR2_6(18), BIOR2_8(19), BIOR3_1(
        20), BIOR3_3(21), BIOR3_5(22), BIOR3_7(23), BIOR3_9(24), BIOR4_4(25), COIF1(26), COIF2(27), COIF3(
        28), COIF4(29), COIF5(30), SYM2(31), SYM3(32), SYM4(33), SYM5(34), SYM6(35), SYM7(36), SYM8(
        37), BIOR5_5(38), BIOR6_8(39), ;
    private final int value;

    private WaveletType(int value) {
      this.value = value;
    }

    public static WaveletType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ParticleClassifierThresholdType {
    THRESHOLD_MANUAL(0), // The classifier performs a manual threshold on the
                         // image during preprocessing.
    THRESHOLD_AUTO(1), // The classifier performs an auto threshold on the image
                       // during preprocessing.
    THRESHOLD_LOCAL(2), // The classifier performs a local threshold on the
                        // image during preprocessing.
    ;
    private final int value;

    private ParticleClassifierThresholdType(int value) {
      this.value = value;
    }

    public static ParticleClassifierThresholdType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum MeasureParticlesCalibrationMode {
    CALIBRATION_MODE_PIXEL(0), // The function takes only pixel measurements on
                               // the particles in the image.
    CALIBRATION_MODE_CALIBRATED(1), // The function takes only calibrated
                                    // measurements on the particles in the
                                    // image.
    CALIBRATION_MODE_BOTH(2), // The function takes both pixel and calibrated
                              // measurements on the particles in the image.
    ;
    private final int value;

    private MeasureParticlesCalibrationMode(int value) {
      this.value = value;
    }

    public static MeasureParticlesCalibrationMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum GeometricMatchingSearchStrategy {
    GEOMETRIC_MATCHING_CONSERVATIVE(0), // Instructs the pattern matching
                                        // algorithm to use the largest possible
                                        // amount of information from the image
                                        // at the expense of slowing down the
                                        // speed of the algorithm.
    GEOMETRIC_MATCHING_BALANCED(1), // Instructs the pattern matching algorithm
                                    // to balance the amount of information from
                                    // the image it uses with the speed of the
                                    // algorithm.
    GEOMETRIC_MATCHING_AGGRESSIVE(2), // Instructs the pattern matching
                                      // algorithm to use a lower amount of
                                      // information from the image, which
                                      // allows the algorithm to run quickly but
                                      // at the expense of accuracy.
    ;
    private final int value;

    private GeometricMatchingSearchStrategy(int value) {
      this.value = value;
    }

    public static GeometricMatchingSearchStrategy fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ColorClassificationResolution {
    CLASSIFIER_LOW_RESOLUTION(0), // Low resolution version of the color
                                  // classifier.
    CLASSIFIER_MEDIUM_RESOLUTION(1), // Medium resolution version of the color
                                     // classifier.
    CLASSIFIER_HIGH_RESOLUTION(2), // High resolution version of the color
                                   // classifier.
    ;
    private final int value;

    private ColorClassificationResolution(int value) {
      this.value = value;
    }

    public static ColorClassificationResolution fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ConnectionConstraintType {
    DISTANCE_CONSTRAINT(0), // Specifies the distance, in pixels, within which
                            // the end points of two curves must lie in order to
                            // be considered part of a contour.
    ANGLE_CONSTRAINT(1), // Specifies the range, in degrees, within which the
                         // difference between the angle of two curves, measured
                         // at the end points, must lie in order for the two
                         // curves to be considered part of a contour.
    CONNECTIVITY_CONSTRAINT(2), // Specifies the distance, in pixels, within
                                // which a line extended from the end point of a
                                // curve must pass the end point of another
                                // curve in order for the two curves to be
                                // considered part of a contour.
    GRADIENT_CONSTRAINT(3), // Specifies the range, in degrees, within which the
                            // gradient angles of two curves, measured at the
                            // end points, must lie in order for the two curves
                            // to be considered part of a contour.
    NUM_CONNECTION_CONSTRAINT_TYPES(4), // .
    ;
    private final int value;

    private ConnectionConstraintType(int value) {
      this.value = value;
    }

    public static ConnectionConstraintType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum Barcode2DContrast {
    ALL_BARCODE_2D_CONTRASTS(0), // The function searches for barcodes of each
                                 // contrast type.
    BLACK_ON_WHITE_BARCODE_2D(1), // The function searches for 2D barcodes
                                  // containing black data on a white
                                  // background.
    WHITE_ON_BLACK_BARCODE_2D(2), // The function searches for 2D barcodes
                                  // containing white data on a black
                                  // background.
    ;
    private final int value;

    private Barcode2DContrast(int value) {
      this.value = value;
    }

    public static Barcode2DContrast fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum QRModelType {
    QR_MODELTYPE_AUTO_DETECT(0), // Specifies that the function will auto-detect
                                 // the type of QR code.
    QR_MODELTYPE_MICRO(1), // Specifies the QR code is of a micro type.
    QR_MODELTYPE_MODEL1(2), // Specifies the QR code is of a model1 type.
    QR_MODELTYPE_MODEL2(3), // Specifies the QR code is of a model2 type.
    ;
    private final int value;

    private QRModelType(int value) {
      this.value = value;
    }

    public static QRModelType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum WindowBackgroundFillStyle {
    FILL_STYLE_SOLID(0), // Fill the display window with a solid color.
    FILL_STYLE_HATCH(2), // Fill the display window with a pattern defined by
                         // WindowBackgroundHatchStyle.
    FILL_STYLE_DEFAULT(3), // Fill the display window with the NI Vision default
                           // pattern.
    ;
    private final int value;

    private WindowBackgroundFillStyle(int value) {
      this.value = value;
    }

    public static WindowBackgroundFillStyle fromValue(int val) {
      for (WindowBackgroundFillStyle v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ExtractionMode {
    NORMAL_IMAGE(0), // Specifies that the function makes no assumptions about
                     // the uniformity of objects in the image or the image
                     // background.
    UNIFORM_REGIONS(1), // Specifies that the function assumes that either the
                        // objects in the image or the image background consists
                        // of uniform pixel values.
    ;
    private final int value;

    private ExtractionMode(int value) {
      this.value = value;
    }

    public static ExtractionMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum EdgeFilterSize {
    FINE(0), // Specifies that the function uses a fine (narrow) edge filter.
    NORMAL(1), // Specifies that the function uses a normal edge filter.
    CONTOUR_TRACING(2), // Sets the Edge Filter Size to contour tracing, which
                        // provides the best results for contour extraction but
                        // increases the time required to process the image.
    ;
    private final int value;

    private EdgeFilterSize(int value) {
      this.value = value;
    }

    public static EdgeFilterSize fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum Barcode2DSearchMode {
    SEARCH_MULTIPLE(0), // The function searches for multiple 2D barcodes.
    SEARCH_SINGLE_CONSERVATIVE(1), // The function searches for 2D barcodes
                                   // using the same searching algorithm as
                                   // IMAQ_SEARCH_MULTIPLE but stops searching
                                   // after locating one valid barcode.
    SEARCH_SINGLE_AGGRESSIVE(2), // The function searches for a single 2D
                                 // barcode using a method that assumes the
                                 // barcode occupies a majority of the search
                                 // region.
    ;
    private final int value;

    private Barcode2DSearchMode(int value) {
      this.value = value;
    }

    public static Barcode2DSearchMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DataMatrixSubtype {
    ALL_DATA_MATRIX_SUBTYPES(0), // The function searches for Data Matrix
                                 // barcodes of all subtypes.
    DATA_MATRIX_SUBTYPES_ECC_000_ECC_140(1), // The function searches for Data
                                             // Matrix barcodes of subtypes ECC
                                             // 000, ECC 050, ECC 080, ECC 100
                                             // and ECC 140.
    DATA_MATRIX_SUBTYPE_ECC_200(2), // The function searches for Data Matrix ECC
                                    // 200 barcodes.
    ;
    private final int value;

    private DataMatrixSubtype(int value) {
      this.value = value;
    }

    public static DataMatrixSubtype fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum FeatureType {
    NOT_FOUND_FEATURE(0), // Specifies the feature is not found.
    CIRCLE_FEATURE(1), // Specifies the feature is a circle.
    ELLIPSE_FEATURE(2), // Specifies the feature is an ellipse.
    CONST_CURVE_FEATURE(3), // Specifies the features is a constant curve.
    RECTANGLE_FEATURE(4), // Specifies the feature is a rectangle.
    LEG_FEATURE(5), // Specifies the feature is a leg.
    CORNER_FEATURE(6), // Specifies the feature is a corner.
    PARALLEL_LINE_PAIR_FEATURE(7), // Specifies the feature is a parallel line
                                   // pair.
    PAIR_OF_PARALLEL_LINE_PAIRS_FEATURE(8), // Specifies the feature is a pair
                                            // of parallel line pairs.
    LINE_FEATURE(9), // Specifies the feature is a line.
    CLOSED_CURVE_FEATURE(10), // Specifies the feature is a closed curve.
    ;
    private final int value;

    private FeatureType(int value) {
      this.value = value;
    }

    public static FeatureType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum Barcode2DCellShape {
    SQUARE_CELLS(0), // The function uses an algorithm for decoding the 2D
                     // barcode that works with square data cells.
    ROUND_CELLS(1), // The function uses an algorithm for decoding the 2D
                    // barcode that works with round data cells.
    ;
    private final int value;

    private Barcode2DCellShape(int value) {
      this.value = value;
    }

    public static Barcode2DCellShape fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum LocalThresholdMethod {
    NIBLACK(0), // The function computes thresholds for each pixel based on its
                // local statistics using the Niblack local thresholding
                // algorithm.
    BACKGROUND_CORRECTION(1), // The function performs background correction
                              // first to eliminate non-uniform lighting
                              // effects, then performs thresholding using the
                              // Otsu thresholding algorithm.
    ;
    private final int value;

    private LocalThresholdMethod(int value) {
      this.value = value;
    }

    public static LocalThresholdMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum Barcode2DType {
    PDF417(0), // The 2D barcode is of type PDF417.
    DATA_MATRIX_ECC_000(1), // The 2D barcode is of type Data Matrix ECC 000.
    DATA_MATRIX_ECC_050(2), // The 2D barcode is of type Data Matrix ECC 050.
    DATA_MATRIX_ECC_080(3), // The 2D barcode is of type Data Matrix ECC 080.
    DATA_MATRIX_ECC_100(4), // The 2D barcode is of type Data Matrix ECC 100.
    DATA_MATRIX_ECC_140(5), // The 2D barcode is of type Data Matrix ECC 140.
    DATA_MATRIX_ECC_200(6), // The 2D barcode is of type Data Matrix ECC 200.
    ;
    private final int value;

    private Barcode2DType(int value) {
      this.value = value;
    }

    public static Barcode2DType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ClassifierEngineType {
    ENGINE_NONE(0), // No engine has been set on this classifier session.
    ENGINE_NEAREST_NEIGHBOR(1), // Nearest neighbor engine.
    ENGINE_SUPPORT_VECTOR_MACHINE(2), ;
    private final int value;

    private ClassifierEngineType(int value) {
      this.value = value;
    }

    public static ClassifierEngineType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ClassifierType {
    CLASSIFIER_CUSTOM(0), // The classifier session classifies vectors of
                          // doubles.
    CLASSIFIER_PARTICLE(1), // The classifier session classifies particles in
                            // binary images.
    CLASSIFIER_COLOR(2), // The classifier session classifies an image based on
                         // its color.
    CLASSIFIER_TEXTURE(3), // The classifier session classifies an image based
                           // on its texture.
    ;
    private final int value;

    private ClassifierType(int value) {
      this.value = value;
    }

    public static ClassifierType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ParticleType {
    PARTICLE_BRIGHT(0), // Bright particles.
    PARTICLE_DARK(1), // Dark particles.
    ;
    private final int value;

    private ParticleType(int value) {
      this.value = value;
    }

    public static ParticleType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum VisionInfoType2 {
    VISIONINFO_CALIBRATION(0x01), // Used to indicate interaction with the
                                  // Calibration information in an image.
    VISIONINFO_OVERLAY(0x02), // Used to indicate interaction with the Overlay
                              // information in an image.
    VISIONINFO_GRAYTEMPLATE(0x04), // Used to indicate interaction with the
                                   // grayscale template information in an
                                   // image.
    VISIONINFO_COLORTEMPLATE(0x08), // Used to indicate interaction with the
                                    // color template information in an image.
    VISIONINFO_GEOMETRICTEMPLATE(0x10), // Used to indicate interaction with the
                                        // geometric template information in an
                                        // image.
    VISIONINFO_CUSTOMDATA(0x20), // Used to indicate interaction with the binary
                                 // or text Custom Data in an image.
    VISIONINFO_GOLDENTEMPLATE(0x40), // Used to indicate interaction with the
                                     // golden template information in an image.
    VISIONINFO_GEOMETRICTEMPLATE2(0x80), // Used to indicate interaction with
                                         // the geometric template 2 information
                                         // in an image.
    VISIONINFO_ALL(0xFFFFFFFF), // Removes, checks for, or indicates the
                                // presence of all types of extra information in
                                // an image.
    ;
    private final int value;

    private VisionInfoType2(int value) {
      this.value = value;
    }

    public static VisionInfoType2 fromValue(int val) {
      for (VisionInfoType2 v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum ReadClassifierFileMode {
    CLASSIFIER_READ_ALL(0), // Read all information from the classifier file.
    CLASSIFIER_READ_SAMPLES(1), // Read only the samples from the classifier
                                // file.
    CLASSIFIER_READ_PROPERTIES(2), // Read only the properties from the
                                   // classifier file.
    ;
    private final int value;

    private ReadClassifierFileMode(int value) {
      this.value = value;
    }

    public static ReadClassifierFileMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum WriteClassifierFileMode {
    CLASSIFIER_WRITE_ALL(0), // Writes all information to the classifier file.
    CLASSIFIER_WRITE_CLASSIFY_ONLY(1), // Write only the information needed to
                                       // classify to the classifier file.
    ;
    private final int value;

    private WriteClassifierFileMode(int value) {
      this.value = value;
    }

    public static WriteClassifierFileMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum Barcode2DShape {
    SQUARE_BARCODE_2D(0), // The function searches for square 2D barcodes.
    RECTANGULAR_BARCODE_2D(1), // The function searches for rectangular 2D
                               // barcodes.
    ;
    private final int value;

    private Barcode2DShape(int value) {
      this.value = value;
    }

    public static Barcode2DShape fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DataMatrixRotationMode {
    UNLIMITED_ROTATION(0), // The function allows for unlimited rotation.
    C0_DEGREES(1), // The function allows for between -5 and 5 degrees of
                   // rotation.
    C90_DEGREES(2), // The function allows for between 85 and 95 degrees of
                    // rotation.
    C180_DEGREES(3), // The function allows for between 175 and 185 degrees of
                     // rotation.
    C270_DEGREES(4), // The function allows for between 265 and 275 degrees of
                     // rotation.
    ;
    private final int value;

    private DataMatrixRotationMode(int value) {
      this.value = value;
    }

    public static DataMatrixRotationMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum AIMGrade {
    AIM_GRADE_F(0), // The Data Matrix barcode received a grade of F.
    AIM_GRADE_D(1), // The Data Matrix barcode received a grade of D.
    AIM_GRADE_C(2), // The Data Matrix barcode received a grade of C.
    AIM_GRADE_B(3), // The Data Matrix barcode received a grade of B.
    AIM_GRADE_A(4), // The Data Matrix barcode received a grade of A.
    ;
    private final int value;

    private AIMGrade(int value) {
      this.value = value;
    }

    public static AIMGrade fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DataMatrixCellFillMode {
    AUTO_DETECT_CELL_FILL_MODE(-2), // Sets the function to determine the Data
                                    // Matrix barcode cell fill percentage
                                    // automatically.
    LOW_FILL(0), // Sets the function to read Data Matrix barcodes with a cell
                 // fill percentage of less than 30 percent.
    NORMAL_FILL(1), // Sets the function to read Data Matrix barcodes with a
                    // cell fill percentage greater than or equal to 30 percent.
    ;
    private final int value;

    private DataMatrixCellFillMode(int value) {
      this.value = value;
    }

    public static DataMatrixCellFillMode fromValue(int val) {
      for (DataMatrixCellFillMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DataMatrixDemodulationMode {
    AUTO_DETECT_DEMODULATION_MODE(-2), // The function will try each
                                       // demodulation mode and use the one
                                       // which decodes the Data Matrix barcode
                                       // within the fewest iterations and
                                       // utilizing the least amount of error
                                       // correction.
    HISTOGRAM(0), // The function uses a histogram of all of the Data Matrix
                  // cells to calculate a threshold.
    LOCAL_CONTRAST(1), // The function examines each of the cell's neighbors to
                       // determine if the cell is on or off.
    COMBINED(2), // The function uses the histogram of the Data Matrix barcode
                 // to calculate a threshold.
    ALL_DEMODULATION_MODES(3), // The function tries IMAQ_HISTOGRAM, then
                               // IMAQ_LOCAL_CONTRAST and then IMAQ_COMBINATION,
                               // stopping once one mode is successful.
    ;
    private final int value;

    private DataMatrixDemodulationMode(int value) {
      this.value = value;
    }

    public static DataMatrixDemodulationMode fromValue(int val) {
      for (DataMatrixDemodulationMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DataMatrixECC {
    AUTO_DETECT_ECC(-2), // Sets the function to determine the Data Matrix
                         // barcode ECC automatically.
    ECC_000(0), // Sets the function to read Data Matrix barcodes of ECC 000
                // only.
    ECC_050(50), // Sets the function to read Data Matrix barcodes of ECC 050
                 // only.
    ECC_080(80), // Sets the function to read Data Matrix barcodes of ECC 080
                 // only.
    ECC_100(100), // Sets the function to read Data Matrix barcodes of ECC 100
                  // only.
    ECC_140(140), // Sets the function to read Data Matrix barcodes of ECC 140
                  // only.
    ECC_000_140(190), // Sets the function to read Data Matrix barcodes of ECC
                      // 000, ECC 050, ECC 080, ECC 100, and ECC 140 only.
    ECC_200(200), // Sets the function to read Data Matrix barcodes of ECC 200
                  // only.
    ;
    private final int value;

    private DataMatrixECC(int value) {
      this.value = value;
    }

    public static DataMatrixECC fromValue(int val) {
      for (DataMatrixECC v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DataMatrixPolarity {
    AUTO_DETECT_POLARITY(-2), // Sets the function to determine the Data Matrix
                              // barcode polarity automatically.
    BLACK_DATA_ON_WHITE_BACKGROUND(0), // Sets the function to read Data Matrix
                                       // barcodes with dark data on a bright
                                       // background.
    WHITE_DATA_ON_BLACK_BACKGROUND(1), // Sets the function to read Data Matrix
                                       // barcodes with bright data on a dark
                                       // background.
    ;
    private final int value;

    private DataMatrixPolarity(int value) {
      this.value = value;
    }

    public static DataMatrixPolarity fromValue(int val) {
      for (DataMatrixPolarity v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DataMatrixCellFilterMode {
    AUTO_DETECT_CELL_FILTER_MODE(-2), // The function will try all filter modes
                                      // and uses the one that decodes the Data
                                      // Matrix barcode within the fewest
                                      // iterations and utilizing the least
                                      // amount of error correction.
    AVERAGE_FILTER(0), // The function sets the pixel value for the cell to the
                       // average of the sampled pixels.
    MEDIAN_FILTER(1), // The function sets the pixel value for the cell to the
                      // median of the sampled pixels.
    CENTRAL_AVERAGE_FILTER(2), // The function sets the pixel value for the cell
                               // to the average of the pixels in the center of
                               // the cell sample.
    HIGH_AVERAGE_FILTER(3), // The function sets the pixel value for the cell to
                            // the average value of the half of the sampled
                            // pixels with the highest pixel values.
    LOW_AVERAGE_FILTER(4), // The function sets the pixel value for the cell to
                           // the average value of the half of the sampled
                           // pixels with the lowest pixel values.
    VERY_HIGH_AVERAGE_FILTER(5), // The function sets the pixel value for the
                                 // cell to the average value of the ninth of
                                 // the sampled pixels with the highest pixel
                                 // values.
    VERY_LOW_AVERAGE_FILTER(6), // The function sets the pixel value for the
                                // cell to the average value of the ninth of the
                                // sampled pixels with the lowest pixel values.
    ALL_CELL_FILTERS(8), // The function tries each filter mode, starting with
                         // IMAQ_AVERAGE_FILTER and ending with
                         // IMAQ_VERY_LOW_AVERAGE_FILTER, stopping once a filter
                         // mode decodes correctly.
    ;
    private final int value;

    private DataMatrixCellFilterMode(int value) {
      this.value = value;
    }

    public static DataMatrixCellFilterMode fromValue(int val) {
      for (DataMatrixCellFilterMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum WindowBackgroundHatchStyle {
    HATCH_STYLE_HORIZONTAL(0), // The background of the display window will be
                               // horizontal bars.
    HATCH_STYLE_VERTICAL(1), // The background of the display window will be
                             // vertical bars.
    HATCH_STYLE_FORWARD_DIAGONAL(2), // The background of the display window
                                     // will be diagonal bars.
    HATCH_STYLE_BACKWARD_DIAGONAL(3), // The background of the display window
                                      // will be diagonal bars.
    HATCH_STYLE_CROSS(4), // The background of the display window will be
                          // intersecting horizontal and vertical bars.
    HATCH_STYLE_CROSS_HATCH(5), // The background of the display window will be
                                // intersecting forward and backward diagonal
                                // bars.
    ;
    private final int value;

    private WindowBackgroundHatchStyle(int value) {
      this.value = value;
    }

    public static WindowBackgroundHatchStyle fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DataMatrixMirrorMode {
    AUTO_DETECT_MIRROR(-2), // Specifies that the function should determine if
                            // the Data Matrix barcode is mirrored.
    APPEARS_NORMAL(0), // Specifies that the function should expect the Data
                       // Matrix barcode to appear normal.
    APPEARS_MIRRORED(1), // Specifies that the function should expect the Data
                         // Matrix barcode to appear mirrored.
    ;
    private final int value;

    private DataMatrixMirrorMode(int value) {
      this.value = value;
    }

    public static DataMatrixMirrorMode fromValue(int val) {
      for (DataMatrixMirrorMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum CalibrationMode2 {
    PERSPECTIVE_MODE(0), // Functions correct for distortion caused by the
                         // camera's perspective.
    MICROPLANE_MODE(1), // Functions correct for distortion caused by the
                        // camera's lens.
    SIMPLE_CALIBRATION_MODE(2), // Functions do not correct for distortion.
    CORRECTED_IMAGE_MODE(3), // The image is already corrected.
    NO_CALIBRATION_MODE(4), // Image with No calibration.
    ;
    private final int value;

    private CalibrationMode2(int value) {
      this.value = value;
    }

    public static CalibrationMode2 fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DataMatrixGradingMode {
    NO_GRADING(0), // The function does not make any preparatory calculations.
    PREPARE_FOR_AIM(1), // The function prepares the image for grading using the
                        // AIM Print Quality metrics.
    ;
    private final int value;

    private DataMatrixGradingMode(int value) {
      this.value = value;
    }

    public static DataMatrixGradingMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum WaveletTransformMode {
    WAVELET_TRANSFORM_INTEGER(0), // Uses a 5-3 reversible integer transform.
    WAVELET_TRANSFORM_FLOATING_POINT(1), // Performs a 9-7 irreversible
                                         // floating-point transform.
    ;
    private final int value;

    private WaveletTransformMode(int value) {
      this.value = value;
    }

    public static WaveletTransformMode fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum NormalizationMethod {
    NORMALIZATION_NONE(0), // No normalization.
    NORMALIZATION_HISTOGRAM_MATCHING(1), // Adjust image so its histogram is
                                         // similar to the golden template's
                                         // histogram.
    NORMALIZATION_AVERAGE_MATCHING(2), // Adjust image so its mean pixel value
                                       // equals the golden template's mean
                                       // pixel value.
    ;
    private final int value;

    private NormalizationMethod(int value) {
      this.value = value;
    }

    public static NormalizationMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum RegistrationMethod {
    REGISTRATION_NONE(0), // No registration.
    REGISTRATION_PERSPECTIVE(1), // Adjust image to correct for minor variations
                                 // in alignment or perspective.
    ;
    private final int value;

    private RegistrationMethod(int value) {
      this.value = value;
    }

    public static RegistrationMethod fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum LinearAveragesMode {
    COLUMN_AVERAGES(1), // Specifies that the function calculates the mean pixel
                        // value of each column.
    ROW_AVERAGES(2), // Specifies that the function calculates the mean pixel
                     // value of each row.
    RISING_DIAGONAL_AVERAGES(4), // Specifies that the function calculates the
                                 // mean pixel value of each diagonal running
                                 // from the lower left to the upper right of
                                 // the inspected area of the image.
    FALLING_DIAGONAL_AVERAGES(8), // Specifies that the function calculates the
                                  // mean pixel value of each diagonal running
                                  // from the upper left to the lower right of
                                  // the inspected area of the image.
    ALL_LINEAR_AVERAGES(15), // Specifies that the function calculates all four
                             // linear mean pixel values.
    ;
    private final int value;

    private LinearAveragesMode(int value) {
      this.value = value;
    }

    public static LinearAveragesMode fromValue(int val) {
      for (LinearAveragesMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  public static enum CompressionType {
    COMPRESSION_NONE(0), // Specifies that the function should not compress the
                         // image.
    COMPRESSION_JPEG(1), // Specifies that the function should use lossy JPEG
                         // compression on the image.
    COMPRESSION_PACKED_BINARY(2), // Specifies that the function should use
                                  // lossless binary packing on the image.
    ;
    private final int value;

    private CompressionType(int value) {
      this.value = value;
    }

    public static CompressionType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum FlattenType {
    FLATTEN_IMAGE(0), // Flattens just the image data.
    FLATTEN_IMAGE_AND_VISION_INFO(1), // Flattens the image data and any Vision
                                      // information associated with the image.
    ;
    private final int value;

    private FlattenType(int value) {
      this.value = value;
    }

    public static FlattenType fromValue(int val) {
      try {
        return values()[val];
      } catch (ArrayIndexOutOfBoundsException e) {
        return null;
      }
    }

    public int getValue() {
      return value;
    }
  }

  public static enum DataMatrixCellSampleSize {
    AUTO_DETECT_CELL_SAMPLE_SIZE(-2), // The function will try each sample size
                                      // and use the one which decodes the Data
                                      // Matrix barcode within the fewest
                                      // iterations and utilizing the least
                                      // amount of error correction.
    C1x1(1), // The function will use a 1x1 sized sample from each cell.
    C2x2(2), // The function will use a 2x2 sized sample from each cell.
    C3x3(3), // The function will use a 3x3 sized sample from each cell.
    C4x4(4), // The function will use a 4x4 sized sample from each cell.
    C5x5(5), // The function will use a 5x5 sized sample from each cell.
    C6x6(6), // The function will use a 6x6 sized sample from each cell.
    C7x7(7), // The function will use a 7x7 sized sample from each cell.
    ;
    private final int value;

    private DataMatrixCellSampleSize(int value) {
      this.value = value;
    }

    public static DataMatrixCellSampleSize fromValue(int val) {
      for (DataMatrixCellSampleSize v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Forward Declare Data Structures
   */

  /**
   * Data Structures
   */

  public static class DivisionModel extends DisposedStruct {
    public float kappa; // The learned kappa coefficient of division model.

    private void init() {

    }

    public DivisionModel() {
      super(4);
      init();
    }

    public DivisionModel(double kappa) {
      super(4);
      this.kappa = (float) kappa;
    }

    protected DivisionModel(ByteBuffer backing, int offset) {
      super(backing, offset, 4);
      init();
    }

    protected DivisionModel(long nativeObj, boolean owned) {
      super(nativeObj, owned, 4);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 4);
    }

    public void read() {
      kappa = backing.getFloat(0);
    }

    public void write() {
      backing.putFloat(0, kappa);
    }

    public int size() {
      return 4;
    }
  }

  public static class FocalLength extends DisposedStruct {
    public float fx; // Focal length in X direction.
    public float fy; // Focal length in Y direction.

    private void init() {

    }

    public FocalLength() {
      super(8);
      init();
    }

    public FocalLength(double fx, double fy) {
      super(8);
      this.fx = (float) fx;
      this.fy = (float) fy;
    }

    protected FocalLength(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected FocalLength(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      fx = backing.getFloat(0);
      fy = backing.getFloat(4);
    }

    public void write() {
      backing.putFloat(0, fx);
      backing.putFloat(4, fy);
    }

    public int size() {
      return 8;
    }
  }

  public static class PolyModel extends DisposedStruct {
    public float[] kCoeffs; // The learned radial coefficients of polynomial
                            // model.
    public float p1; // The P1(learned tangential coefficients of polynomial
                     // model).
    public float p2; // The P2(learned tangential coefficients of polynomial
                     // model).
    private ByteBuffer kCoeffs_buf;

    private void init() {
      kCoeffs = new float[0];
    }

    public PolyModel() {
      super(16);
      init();
    }

    public PolyModel(float[] kCoeffs, double p1, double p2) {
      super(16);
      this.kCoeffs = kCoeffs;
      this.p1 = (float) p1;
      this.p2 = (float) p2;
    }

    protected PolyModel(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected PolyModel(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      int kCoeffs_numKCoeffs = backing.getInt(4);
      long kCoeffs_addr = getPointer(backing, 0);
      kCoeffs = new float[kCoeffs_numKCoeffs];
      if (kCoeffs_numKCoeffs > 0 && kCoeffs_addr != 0) {
        newDirectByteBuffer(kCoeffs_addr, kCoeffs_numKCoeffs * 4).asFloatBuffer().get(kCoeffs);
      }
      p1 = backing.getFloat(8);
      p2 = backing.getFloat(12);
    }

    public void write() {
      kCoeffs_buf = ByteBuffer.allocateDirect(kCoeffs.length * 4).order(ByteOrder.nativeOrder());
      kCoeffs_buf.asFloatBuffer().put(kCoeffs).rewind();
      backing.putInt(4, kCoeffs.length);
      putPointer(backing, 0, kCoeffs_buf);
      backing.putFloat(8, p1);
      backing.putFloat(12, p2);
    }

    public int size() {
      return 16;
    }
  }

  public static class DistortionModelParams extends DisposedStruct {
    public DistortionModel distortionModel; // Type of learned distortion model.
    public PolyModel polyModel; // The learned coefficients of polynomial model.
    public DivisionModel divisionModel; // The learned coefficient of division
                                        // model.

    private void init() {
      polyModel = new PolyModel(backing, 4);
      divisionModel = new DivisionModel(backing, 20);
    }

    public DistortionModelParams() {
      super(24);
      init();
    }

    public DistortionModelParams(DistortionModel distortionModel, PolyModel polyModel,
        DivisionModel divisionModel) {
      super(24);
      this.distortionModel = distortionModel;
      this.polyModel = polyModel;
      this.divisionModel = divisionModel;
    }

    protected DistortionModelParams(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected DistortionModelParams(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      distortionModel = DistortionModel.fromValue(backing.getInt(0));
      polyModel.read();
      divisionModel.read();
    }

    public void write() {
      if (distortionModel != null)
        backing.putInt(0, distortionModel.getValue());
      polyModel.write();
      divisionModel.write();
    }

    public int size() {
      return 24;
    }
  }

  public static class PointFloat extends DisposedStruct {
    public float x; // The x-coordinate of the point.
    public float y; // The y-coordinate of the point.

    private void init() {

    }

    public PointFloat() {
      super(8);
      init();
    }

    public PointFloat(double x, double y) {
      super(8);
      this.x = (float) x;
      this.y = (float) y;
    }

    protected PointFloat(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected PointFloat(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      x = backing.getFloat(0);
      y = backing.getFloat(4);
    }

    public void write() {
      backing.putFloat(0, x);
      backing.putFloat(4, y);
    }

    public int size() {
      return 8;
    }
  }

  public static class InternalParameters extends DisposedStruct {
    public byte isInsufficientData;
    public FocalLength focalLength;
    public PointFloat opticalCenter;

    private void init() {
      focalLength = new FocalLength(backing, 4);
      opticalCenter = new PointFloat(backing, 12);
    }

    public InternalParameters() {
      super(20);
      init();
    }

    public InternalParameters(byte isInsufficientData, FocalLength focalLength,
        PointFloat opticalCenter) {
      super(20);
      this.isInsufficientData = isInsufficientData;
      this.focalLength = focalLength;
      this.opticalCenter = opticalCenter;
    }

    protected InternalParameters(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected InternalParameters(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      isInsufficientData = backing.get(0);
      focalLength.read();
      opticalCenter.read();
    }

    public void write() {
      backing.put(0, isInsufficientData);
      focalLength.write();
      opticalCenter.write();
    }

    public int size() {
      return 20;
    }
  }

  public static class MaxGridSize extends DisposedStruct {
    public int xMax; // Maximum x limit for the grid size.
    public int yMax; // Maximum y limit for the grid size.

    private void init() {

    }

    public MaxGridSize() {
      super(8);
      init();
    }

    public MaxGridSize(int xMax, int yMax) {
      super(8);
      this.xMax = xMax;
      this.yMax = yMax;
    }

    protected MaxGridSize(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected MaxGridSize(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      xMax = backing.getInt(0);
      yMax = backing.getInt(4);
    }

    public void write() {
      backing.putInt(0, xMax);
      backing.putInt(4, yMax);
    }

    public int size() {
      return 8;
    }
  }

  public static class ImageSize extends DisposedStruct {
    public int xRes; // X resolution of the image.
    public int yRes; // Y resolution of the image.

    private void init() {

    }

    public ImageSize() {
      super(8);
      init();
    }

    public ImageSize(int xRes, int yRes) {
      super(8);
      this.xRes = xRes;
      this.yRes = yRes;
    }

    protected ImageSize(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected ImageSize(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      xRes = backing.getInt(0);
      yRes = backing.getInt(4);
    }

    public void write() {
      backing.putInt(0, xRes);
      backing.putInt(4, yRes);
    }

    public int size() {
      return 8;
    }
  }

  public static class CalibrationReferencePoints extends DisposedStruct {
    public PointDouble[] pixelCoords; // Specifies the coordinates of the pixel
                                      // reference points.
    public PointDouble[] realCoords; // Specifies the measuring unit associated
                                     // with the image.
    public CalibrationUnit units; // Specifies the units of X Step and Y Step.
    public ImageSize imageSize; // Specifies the size of calibration template
                                // image.
    private ByteBuffer pixelCoords_buf;
    private ByteBuffer realCoords_buf;

    private void init() {
      pixelCoords = new PointDouble[0];
      realCoords = new PointDouble[0];
      imageSize = new ImageSize(backing, 20);
    }

    public CalibrationReferencePoints() {
      super(28);
      init();
    }

    public CalibrationReferencePoints(PointDouble[] pixelCoords, PointDouble[] realCoords,
        CalibrationUnit units, ImageSize imageSize) {
      super(28);
      this.pixelCoords = pixelCoords;
      this.realCoords = realCoords;
      this.units = units;
      this.imageSize = imageSize;
    }

    protected CalibrationReferencePoints(ByteBuffer backing, int offset) {
      super(backing, offset, 28);
      init();
    }

    protected CalibrationReferencePoints(long nativeObj, boolean owned) {
      super(nativeObj, owned, 28);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 28);
    }

    public void read() {
      int pixelCoords_numPixelCoords = backing.getInt(4);
      long pixelCoords_addr = getPointer(backing, 0);
      pixelCoords = new PointDouble[pixelCoords_numPixelCoords];
      if (pixelCoords_numPixelCoords > 0 && pixelCoords_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(pixelCoords_addr, pixelCoords_numPixelCoords * 16);
        for (int i = 0, off = 0; i < pixelCoords_numPixelCoords; i++, off += 16) {
          pixelCoords[i] = new PointDouble(bb, off);
          pixelCoords[i].read();
        }
      }
      int realCoords_numRealCoords = backing.getInt(12);
      long realCoords_addr = getPointer(backing, 8);
      realCoords = new PointDouble[realCoords_numRealCoords];
      if (realCoords_numRealCoords > 0 && realCoords_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(realCoords_addr, realCoords_numRealCoords * 16);
        for (int i = 0, off = 0; i < realCoords_numRealCoords; i++, off += 16) {
          realCoords[i] = new PointDouble(bb, off);
          realCoords[i].read();
        }
      }
      units = CalibrationUnit.fromValue(backing.getInt(16));
      imageSize.read();
    }

    public void write() {
      pixelCoords_buf =
          ByteBuffer.allocateDirect(pixelCoords.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < pixelCoords.length; i++, off += 16) {
        pixelCoords[i].setBuffer(pixelCoords_buf, off);
        pixelCoords[i].write();
      }
      backing.putInt(4, pixelCoords.length);
      putPointer(backing, 0, pixelCoords_buf);
      realCoords_buf =
          ByteBuffer.allocateDirect(realCoords.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < realCoords.length; i++, off += 16) {
        realCoords[i].setBuffer(realCoords_buf, off);
        realCoords[i].write();
      }
      backing.putInt(12, realCoords.length);
      putPointer(backing, 8, realCoords_buf);
      if (units != null)
        backing.putInt(16, units.getValue());
      imageSize.write();
    }

    public int size() {
      return 28;
    }
  }

  public static class GetCameraParametersReport extends DisposedStruct {
    public int projectionMatrixRows; // Number of rows in projection matrix.
    public int projectionMatrixCols; // Number of columns in projection matrix.
    public DistortionModelParams distortion; // Distortion model Coefficients.
    public InternalParameters internalParams; // The learned internal paramters
                                              // of camera model such as focal
                                              // length and optical center.

    private void init() {
      distortion = new DistortionModelParams(backing, 12);
      internalParams = new InternalParameters(backing, 36);
    }

    public GetCameraParametersReport() {
      super(56);
      init();
    }

    public GetCameraParametersReport(int projectionMatrixRows, int projectionMatrixCols,
        DistortionModelParams distortion, InternalParameters internalParams) {
      super(56);
      this.projectionMatrixRows = projectionMatrixRows;
      this.projectionMatrixCols = projectionMatrixCols;
      this.distortion = distortion;
      this.internalParams = internalParams;
    }

    protected GetCameraParametersReport(ByteBuffer backing, int offset) {
      super(backing, offset, 56);
      init();
    }

    protected GetCameraParametersReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 56);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 56);
    }

    public void read() {
      projectionMatrixRows = backing.getInt(4);
      projectionMatrixCols = backing.getInt(8);
      distortion.read();
      internalParams.read();
    }

    public void write() {
      backing.putInt(4, projectionMatrixRows);
      backing.putInt(8, projectionMatrixCols);
      distortion.write();
      internalParams.write();
    }

    public int size() {
      return 56;
    }
  }

  public static class CalibrationAxisInfo extends DisposedStruct {
    public PointFloat center; // The origin of the reference coordinate system,
                              // expressed in pixel units.
    public float rotationAngle; // The angle of the x-axis of the real-world
                                // coordinate system, in relation to the
                                // horizontal.
    public AxisOrientation axisDirection; // Specifies the direction of the
                                          // calibraiton axis which is either
                                          // Direct or Indirect.

    private void init() {
      center = new PointFloat(backing, 0);
    }

    public CalibrationAxisInfo() {
      super(16);
      init();
    }

    public CalibrationAxisInfo(PointFloat center, double rotationAngle,
        AxisOrientation axisDirection) {
      super(16);
      this.center = center;
      this.rotationAngle = (float) rotationAngle;
      this.axisDirection = axisDirection;
    }

    protected CalibrationAxisInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected CalibrationAxisInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      center.read();
      rotationAngle = backing.getFloat(8);
      axisDirection = AxisOrientation.fromValue(backing.getInt(12));
    }

    public void write() {
      center.write();
      backing.putFloat(8, rotationAngle);
      if (axisDirection != null)
        backing.putInt(12, axisDirection.getValue());
    }

    public int size() {
      return 16;
    }
  }

  public static class CalibrationLearnSetupInfo extends DisposedStruct {
    public CalibrationMode2 calibrationMethod; // Type of calibration method
                                               // used.
    public DistortionModel distortionModel; // Type of learned distortion model.
    public ScalingMethod scaleMode; // The aspect scaling to use when correcting
                                    // an image.
    public CalibrationROI roiMode; // The ROI to use when correcting an image.
    public byte learnCorrectionTable; // Set this input to true value if you
                                      // want the correction table to be
                                      // determined and stored.

    private void init() {

    }

    public CalibrationLearnSetupInfo() {
      super(20);
      init();
    }

    public CalibrationLearnSetupInfo(CalibrationMode2 calibrationMethod,
        DistortionModel distortionModel, ScalingMethod scaleMode, CalibrationROI roiMode,
        byte learnCorrectionTable) {
      super(20);
      this.calibrationMethod = calibrationMethod;
      this.distortionModel = distortionModel;
      this.scaleMode = scaleMode;
      this.roiMode = roiMode;
      this.learnCorrectionTable = learnCorrectionTable;
    }

    protected CalibrationLearnSetupInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected CalibrationLearnSetupInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      calibrationMethod = CalibrationMode2.fromValue(backing.getInt(0));
      distortionModel = DistortionModel.fromValue(backing.getInt(4));
      scaleMode = ScalingMethod.fromValue(backing.getInt(8));
      roiMode = CalibrationROI.fromValue(backing.getInt(12));
      learnCorrectionTable = backing.get(16);
    }

    public void write() {
      if (calibrationMethod != null)
        backing.putInt(0, calibrationMethod.getValue());
      if (distortionModel != null)
        backing.putInt(4, distortionModel.getValue());
      if (scaleMode != null)
        backing.putInt(8, scaleMode.getValue());
      if (roiMode != null)
        backing.putInt(12, roiMode.getValue());
      backing.put(16, learnCorrectionTable);
    }

    public int size() {
      return 20;
    }
  }

  public static class GridDescriptor extends DisposedStruct {
    public float xStep; // The distance in the x direction between two adjacent
                        // pixels in units specified by unit.
    public float yStep; // The distance in the y direction between two adjacent
                        // pixels in units specified by unit.
    public CalibrationUnit unit; // The unit of measure for the image.

    private void init() {

    }

    public GridDescriptor() {
      super(12);
      init();
    }

    public GridDescriptor(double xStep, double yStep, CalibrationUnit unit) {
      super(12);
      this.xStep = (float) xStep;
      this.yStep = (float) yStep;
      this.unit = unit;
    }

    protected GridDescriptor(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected GridDescriptor(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      xStep = backing.getFloat(0);
      yStep = backing.getFloat(4);
      unit = CalibrationUnit.fromValue(backing.getInt(8));
    }

    public void write() {
      backing.putFloat(0, xStep);
      backing.putFloat(4, yStep);
      if (unit != null)
        backing.putInt(8, unit.getValue());
    }

    public int size() {
      return 12;
    }
  }

  public static class ErrorStatistics extends DisposedStruct {
    public double mean; // Mean error statistics value.
    public double maximum; // Maximum value of error.
    public double standardDeviation; // The standard deviation error statistiscs
                                     // value.
    public double distortion; // The distortion error statistics value.

    private void init() {

    }

    public ErrorStatistics() {
      super(32);
      init();
    }

    public ErrorStatistics(double mean, double maximum, double standardDeviation, double distortion) {
      super(32);
      this.mean = mean;
      this.maximum = maximum;
      this.standardDeviation = standardDeviation;
      this.distortion = distortion;
    }

    protected ErrorStatistics(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected ErrorStatistics(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      mean = backing.getDouble(0);
      maximum = backing.getDouble(8);
      standardDeviation = backing.getDouble(16);
      distortion = backing.getDouble(24);
    }

    public void write() {
      backing.putDouble(0, mean);
      backing.putDouble(8, maximum);
      backing.putDouble(16, standardDeviation);
      backing.putDouble(24, distortion);
    }

    public int size() {
      return 32;
    }
  }

  public static class GetCalibrationInfoReport extends DisposedStruct {
    public ROI userRoi; // Specifies the ROI the user provided when learning the
                        // calibration.
    public ROI calibrationRoi; // Specifies the ROI that corresponds to the
                               // region of the image where the calibration
                               // information is accurate.
    public CalibrationAxisInfo axisInfo; // Reference Coordinate System for the
                                         // real-world coordinates.
    public CalibrationLearnSetupInfo learnSetupInfo; // Calibration learn setup
                                                     // information.
    public GridDescriptor gridDescriptor; // Specifies scaling constants used to
                                          // calibrate the image.
    public int errorMapRows; // Number of rows in error map.
    public int errorMapCols; // Number of Columns in error map.
    public ErrorStatistics errorStatistics; // Error statistics of the
                                            // calibration.

    private void init() {
      axisInfo = new CalibrationAxisInfo(backing, 8);
      learnSetupInfo = new CalibrationLearnSetupInfo(backing, 24);
      gridDescriptor = new GridDescriptor(backing, 44);
      errorStatistics = new ErrorStatistics(backing, 72);
    }

    public GetCalibrationInfoReport() {
      super(104);
      init();
    }

    public GetCalibrationInfoReport(ROI userRoi, ROI calibrationRoi, CalibrationAxisInfo axisInfo,
        CalibrationLearnSetupInfo learnSetupInfo, GridDescriptor gridDescriptor, int errorMapRows,
        int errorMapCols, ErrorStatistics errorStatistics) {
      super(104);
      this.userRoi = userRoi;
      this.calibrationRoi = calibrationRoi;
      this.axisInfo = axisInfo;
      this.learnSetupInfo = learnSetupInfo;
      this.gridDescriptor = gridDescriptor;
      this.errorMapRows = errorMapRows;
      this.errorMapCols = errorMapCols;
      this.errorStatistics = errorStatistics;
    }

    protected GetCalibrationInfoReport(ByteBuffer backing, int offset) {
      super(backing, offset, 104);
      init();
    }

    protected GetCalibrationInfoReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 104);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 104);
    }

    public void read() {
      long userRoi_addr = getPointer(backing, 0);
      if (userRoi_addr == 0)
        userRoi = null;
      else
        userRoi = new ROI(userRoi_addr, false);
      long calibrationRoi_addr = getPointer(backing, 4);
      if (calibrationRoi_addr == 0)
        calibrationRoi = null;
      else
        calibrationRoi = new ROI(calibrationRoi_addr, false);
      axisInfo.read();
      learnSetupInfo.read();
      gridDescriptor.read();
      errorMapRows = backing.getInt(60);
      errorMapCols = backing.getInt(64);
      errorStatistics.read();
    }

    public void write() {
      putPointer(backing, 0, userRoi);
      putPointer(backing, 4, calibrationRoi);
      axisInfo.write();
      learnSetupInfo.write();
      gridDescriptor.write();
      backing.putInt(60, errorMapRows);
      backing.putInt(64, errorMapCols);
      errorStatistics.write();
    }

    public int size() {
      return 104;
    }
  }

  public static class EdgePolarity extends DisposedStruct {
    public EdgePolaritySearchMode start;
    public EdgePolaritySearchMode end;

    private void init() {

    }

    public EdgePolarity() {
      super(8);
      init();
    }

    public EdgePolarity(EdgePolaritySearchMode start, EdgePolaritySearchMode end) {
      super(8);
      this.start = start;
      this.end = end;
    }

    protected EdgePolarity(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected EdgePolarity(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      start = EdgePolaritySearchMode.fromValue(backing.getInt(0));
      end = EdgePolaritySearchMode.fromValue(backing.getInt(4));
    }

    public void write() {
      if (start != null)
        backing.putInt(0, start.getValue());
      if (end != null)
        backing.putInt(4, end.getValue());
    }

    public int size() {
      return 8;
    }
  }

  public static class ClampSettings extends DisposedStruct {
    public double angleRange; // Specifies the angle range.
    public EdgePolarity edgePolarity; // Specifies the edge polarity.

    private void init() {
      edgePolarity = new EdgePolarity(backing, 8);
    }

    public ClampSettings() {
      super(16);
      init();
    }

    public ClampSettings(double angleRange, EdgePolarity edgePolarity) {
      super(16);
      this.angleRange = angleRange;
      this.edgePolarity = edgePolarity;
    }

    protected ClampSettings(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ClampSettings(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      angleRange = backing.getDouble(0);
      edgePolarity.read();
    }

    public void write() {
      backing.putDouble(0, angleRange);
      edgePolarity.write();
    }

    public int size() {
      return 16;
    }
  }

  public static class PointDouble extends DisposedStruct {
    public double x; // The x-coordinate of the point.
    public double y; // The y-coordinate of the point.

    private void init() {

    }

    public PointDouble() {
      super(16);
      init();
    }

    public PointDouble(double x, double y) {
      super(16);
      this.x = x;
      this.y = y;
    }

    protected PointDouble(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected PointDouble(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      x = backing.getDouble(0);
      y = backing.getDouble(8);
    }

    public void write() {
      backing.putDouble(0, x);
      backing.putDouble(8, y);
    }

    public int size() {
      return 16;
    }
  }

  public static class PointDoublePair extends DisposedStruct {
    public PointDouble start; // The Start co-ordinate of the pair.
    public PointDouble end; // The End co-ordinate of the pair.

    private void init() {
      start = new PointDouble(backing, 0);
      end = new PointDouble(backing, 16);
    }

    public PointDoublePair() {
      super(32);
      init();
    }

    public PointDoublePair(PointDouble start, PointDouble end) {
      super(32);
      this.start = start;
      this.end = end;
    }

    protected PointDoublePair(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected PointDoublePair(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      start.read();
      end.read();
    }

    public void write() {
      start.write();
      end.write();
    }

    public int size() {
      return 32;
    }
  }

  public static class ClampResults extends DisposedStruct {
    public double distancePix; // Defines the Pixel world distance.
    public double distanceRealWorld; // Defines the real world distance.
    public double angleAbs; // Defines the absolute angle.
    public double angleRelative; // Defines the relative angle.

    private void init() {

    }

    public ClampResults() {
      super(32);
      init();
    }

    public ClampResults(double distancePix, double distanceRealWorld, double angleAbs,
        double angleRelative) {
      super(32);
      this.distancePix = distancePix;
      this.distanceRealWorld = distanceRealWorld;
      this.angleAbs = angleAbs;
      this.angleRelative = angleRelative;
    }

    protected ClampResults(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected ClampResults(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      distancePix = backing.getDouble(0);
      distanceRealWorld = backing.getDouble(8);
      angleAbs = backing.getDouble(16);
      angleRelative = backing.getDouble(24);
    }

    public void write() {
      backing.putDouble(0, distancePix);
      backing.putDouble(8, distanceRealWorld);
      backing.putDouble(16, angleAbs);
      backing.putDouble(24, angleRelative);
    }

    public int size() {
      return 32;
    }
  }

  public static class ClampPoints extends DisposedStruct {
    public PointDoublePair pixel; // Specifies the pixel world point pair for
                                  // clamp.
    public PointDoublePair realWorld; // Specifies the real world point pair for
                                      // clamp.

    private void init() {
      pixel = new PointDoublePair(backing, 0);
      realWorld = new PointDoublePair(backing, 32);
    }

    public ClampPoints() {
      super(64);
      init();
    }

    public ClampPoints(PointDoublePair pixel, PointDoublePair realWorld) {
      super(64);
      this.pixel = pixel;
      this.realWorld = realWorld;
    }

    protected ClampPoints(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected ClampPoints(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      pixel.read();
      realWorld.read();
    }

    public void write() {
      pixel.write();
      realWorld.write();
    }

    public int size() {
      return 64;
    }
  }

  public static class RGBValue extends DisposedStruct {
    public short B; // The blue value of the color.
    public short G; // The green value of the color.
    public short R; // The red value of the color.
    public short alpha; // The alpha value of the color, which represents extra
                        // information about a color image, such as gamma
                        // correction.

    private void init() {

    }

    public RGBValue() {
      super(4);
      init();
    }

    public RGBValue(int B, int G, int R, int alpha) {
      super(4);
      this.B = (short) B;
      this.G = (short) G;
      this.R = (short) R;
      this.alpha = (short) alpha;
    }

    protected RGBValue(ByteBuffer backing, int offset) {
      super(backing, offset, 4);
      init();
    }

    protected RGBValue(long nativeObj, boolean owned) {
      super(nativeObj, owned, 4);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 4);
    }

    public void read() {
      B = (short) (backing.get(0) & 0xff);
      G = (short) (backing.get(1) & 0xff);
      R = (short) (backing.get(2) & 0xff);
      alpha = (short) (backing.get(3) & 0xff);
    }

    public void write() {
      backing.put(0, (byte) (B & 0xff));
      backing.put(1, (byte) (G & 0xff));
      backing.put(2, (byte) (R & 0xff));
      backing.put(3, (byte) (alpha & 0xff));
    }

    public int size() {
      return 4;
    }
  }

  public static class ClampOverlaySettings extends DisposedStruct {
    public int showSearchArea; // If TRUE, the function overlays the search area
                               // on the image.
    public int showCurves; // If TRUE, the function overlays the curves on the
                           // image.
    public int showClampLocation; // If TRUE, the function overlays the clamp
                                  // location on the image.
    public int showResult; // If TRUE, the function overlays the hit lines to
                           // the object and the edge used to generate the hit
                           // line on the result image.
    public RGBValue searchAreaColor; // Specifies the RGB color value to use to
                                     // overlay the search area.
    public RGBValue curvesColor; // Specifies the RGB color value to use to
                                 // overlay the curves.
    public RGBValue clampLocationsColor; // Specifies the RGB color value to use
                                         // to overlay the clamp locations.
    public RGBValue resultColor; // Specifies the RGB color value to use to
                                 // overlay the results.
    public String overlayGroupName; // Specifies the group overlay name for the
                                    // step overlays.
    private ByteBuffer overlayGroupName_buf;

    private void init() {
      searchAreaColor = new RGBValue(backing, 16);
      curvesColor = new RGBValue(backing, 20);
      clampLocationsColor = new RGBValue(backing, 24);
      resultColor = new RGBValue(backing, 28);
    }

    public ClampOverlaySettings() {
      super(36);
      init();
    }

    public ClampOverlaySettings(int showSearchArea, int showCurves, int showClampLocation,
        int showResult, RGBValue searchAreaColor, RGBValue curvesColor,
        RGBValue clampLocationsColor, RGBValue resultColor, String overlayGroupName) {
      super(36);
      this.showSearchArea = showSearchArea;
      this.showCurves = showCurves;
      this.showClampLocation = showClampLocation;
      this.showResult = showResult;
      this.searchAreaColor = searchAreaColor;
      this.curvesColor = curvesColor;
      this.clampLocationsColor = clampLocationsColor;
      this.resultColor = resultColor;
      this.overlayGroupName = overlayGroupName;
    }

    protected ClampOverlaySettings(ByteBuffer backing, int offset) {
      super(backing, offset, 36);
      init();
    }

    protected ClampOverlaySettings(long nativeObj, boolean owned) {
      super(nativeObj, owned, 36);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 36);
    }

    public void read() {
      showSearchArea = backing.getInt(0);
      showCurves = backing.getInt(4);
      showClampLocation = backing.getInt(8);
      showResult = backing.getInt(12);
      searchAreaColor.read();
      curvesColor.read();
      clampLocationsColor.read();
      resultColor.read();
      long overlayGroupName_addr = getPointer(backing, 32);
      if (overlayGroupName_addr == 0)
        overlayGroupName = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          overlayGroupName = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName = "";
        }
      }

    }

    public void write() {
      backing.putInt(0, showSearchArea);
      backing.putInt(4, showCurves);
      backing.putInt(8, showClampLocation);
      backing.putInt(12, showResult);
      searchAreaColor.write();
      curvesColor.write();
      clampLocationsColor.write();
      resultColor.write();
      if (overlayGroupName != null) {
        byte[] overlayGroupName_bytes;
        try {
          overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName_bytes = new byte[0];
        }
        overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length + 1);
        putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length)
            .put(overlayGroupName_bytes.length, (byte) 0);
      }
      putPointer(backing, 32, overlayGroupName == null ? 0
          : getByteBufferAddress(overlayGroupName_buf));
    }

    public int size() {
      return 36;
    }
  }

  public static class ClampMax2Report extends DisposedStruct {
    public ClampResults clampResults; // Specifies the Clamp results information
                                      // returned by the function.
    public ClampPoints clampPoints; // Specifies the clamp points information
                                    // returned by the function.
    public int calibrationValid; // Specifies if the calibration information is
                                 // valid or not.

    private void init() {
      clampResults = new ClampResults(backing, 0);
      clampPoints = new ClampPoints(backing, 32);
    }

    public ClampMax2Report() {
      super(104);
      init();
    }

    public ClampMax2Report(ClampResults clampResults, ClampPoints clampPoints, int calibrationValid) {
      super(104);
      this.clampResults = clampResults;
      this.clampPoints = clampPoints;
      this.calibrationValid = calibrationValid;
    }

    protected ClampMax2Report(ByteBuffer backing, int offset) {
      super(backing, offset, 104);
      init();
    }

    protected ClampMax2Report(long nativeObj, boolean owned) {
      super(nativeObj, owned, 104);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 104);
    }

    public void read() {
      clampResults.read();
      clampPoints.read();
      calibrationValid = backing.getInt(96);
    }

    public void write() {
      clampResults.write();
      clampPoints.write();
      backing.putInt(96, calibrationValid);
    }

    public int size() {
      return 104;
    }
  }

  public static class ContourFitSplineReport extends DisposedStruct {
    public PointDouble[] points; // It returns the points of the best-fit
                                 // B-spline curve.
    private ByteBuffer points_buf;

    private void init() {
      points = new PointDouble[0];
    }

    public ContourFitSplineReport() {
      super(8);
      init();
    }

    public ContourFitSplineReport(PointDouble[] points) {
      super(8);
      this.points = points;
    }

    protected ContourFitSplineReport(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected ContourFitSplineReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      int points_numberOfPoints = backing.getInt(4);
      long points_addr = getPointer(backing, 0);
      points = new PointDouble[points_numberOfPoints];
      if (points_numberOfPoints > 0 && points_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(points_addr, points_numberOfPoints * 16);
        for (int i = 0, off = 0; i < points_numberOfPoints; i++, off += 16) {
          points[i] = new PointDouble(bb, off);
          points[i].read();
        }
      }
    }

    public void write() {
      points_buf = ByteBuffer.allocateDirect(points.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < points.length; i++, off += 16) {
        points[i].setBuffer(points_buf, off);
        points[i].write();
      }
      backing.putInt(4, points.length);
      putPointer(backing, 0, points_buf);
    }

    public int size() {
      return 8;
    }
  }

  public static class LineFloat extends DisposedStruct {
    public PointFloat start; // The coordinate location of the start of the
                             // line.
    public PointFloat end; // The coordinate location of the end of the line.

    private void init() {
      start = new PointFloat(backing, 0);
      end = new PointFloat(backing, 8);
    }

    public LineFloat() {
      super(16);
      init();
    }

    public LineFloat(PointFloat start, PointFloat end) {
      super(16);
      this.start = start;
      this.end = end;
    }

    protected LineFloat(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected LineFloat(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      start.read();
      end.read();
    }

    public void write() {
      start.write();
      end.write();
    }

    public int size() {
      return 16;
    }
  }

  public static class LineEquation extends DisposedStruct {
    public double a; // The a coefficient of the line equation.
    public double b; // The b coefficient of the line equation.
    public double c; // The c coefficient of the line equation.

    private void init() {

    }

    public LineEquation() {
      super(24);
      init();
    }

    public LineEquation(double a, double b, double c) {
      super(24);
      this.a = a;
      this.b = b;
      this.c = c;
    }

    protected LineEquation(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected LineEquation(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      a = backing.getDouble(0);
      b = backing.getDouble(8);
      c = backing.getDouble(16);
    }

    public void write() {
      backing.putDouble(0, a);
      backing.putDouble(8, b);
      backing.putDouble(16, c);
    }

    public int size() {
      return 24;
    }
  }

  public static class ContourFitLineReport extends DisposedStruct {
    public LineFloat lineSegment; // Line Segment represents the intersection of
                                  // the line equation and the contour.
    public LineEquation lineEquation; // Line Equation is a structure of three
                                      // coefficients A, B, and C of the
                                      // equation in the normal form (Ax + By +
                                      // C=0) of the best fit line.

    private void init() {
      lineSegment = new LineFloat(backing, 0);
      lineEquation = new LineEquation(backing, 16);
    }

    public ContourFitLineReport() {
      super(40);
      init();
    }

    public ContourFitLineReport(LineFloat lineSegment, LineEquation lineEquation) {
      super(40);
      this.lineSegment = lineSegment;
      this.lineEquation = lineEquation;
    }

    protected ContourFitLineReport(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected ContourFitLineReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      lineSegment.read();
      lineEquation.read();
    }

    public void write() {
      lineSegment.write();
      lineEquation.write();
    }

    public int size() {
      return 40;
    }
  }

  public static class ContourFitPolynomialReport extends DisposedStruct {
    public PointDouble[] bestFit; // It returns the points of the best-fit
                                  // polynomial.
    public double[] polynomialCoefficients; // Polynomial Coefficients returns
                                            // the coefficients of the
                                            // polynomial equation.
    private ByteBuffer bestFit_buf;
    private ByteBuffer polynomialCoefficients_buf;

    private void init() {
      bestFit = new PointDouble[0];
      polynomialCoefficients = new double[0];
    }

    public ContourFitPolynomialReport() {
      super(16);
      init();
    }

    public ContourFitPolynomialReport(PointDouble[] bestFit, double[] polynomialCoefficients) {
      super(16);
      this.bestFit = bestFit;
      this.polynomialCoefficients = polynomialCoefficients;
    }

    protected ContourFitPolynomialReport(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ContourFitPolynomialReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      int bestFit_numberOfPoints = backing.getInt(4);
      long bestFit_addr = getPointer(backing, 0);
      bestFit = new PointDouble[bestFit_numberOfPoints];
      if (bestFit_numberOfPoints > 0 && bestFit_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(bestFit_addr, bestFit_numberOfPoints * 16);
        for (int i = 0, off = 0; i < bestFit_numberOfPoints; i++, off += 16) {
          bestFit[i] = new PointDouble(bb, off);
          bestFit[i].read();
        }
      }
      int polynomialCoefficients_numberOfCoefficients = backing.getInt(12);
      long polynomialCoefficients_addr = getPointer(backing, 8);
      polynomialCoefficients = new double[polynomialCoefficients_numberOfCoefficients];
      if (polynomialCoefficients_numberOfCoefficients > 0 && polynomialCoefficients_addr != 0) {
        newDirectByteBuffer(polynomialCoefficients_addr,
            polynomialCoefficients_numberOfCoefficients * 8).asDoubleBuffer().get(
            polynomialCoefficients);
      }
    }

    public void write() {
      bestFit_buf = ByteBuffer.allocateDirect(bestFit.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < bestFit.length; i++, off += 16) {
        bestFit[i].setBuffer(bestFit_buf, off);
        bestFit[i].write();
      }
      backing.putInt(4, bestFit.length);
      putPointer(backing, 0, bestFit_buf);
      polynomialCoefficients_buf =
          ByteBuffer.allocateDirect(polynomialCoefficients.length * 8).order(
              ByteOrder.nativeOrder());
      polynomialCoefficients_buf.asDoubleBuffer().put(polynomialCoefficients).rewind();
      backing.putInt(12, polynomialCoefficients.length);
      putPointer(backing, 8, polynomialCoefficients_buf);
    }

    public int size() {
      return 16;
    }
  }

  public static class PartialCircle extends DisposedStruct {
    public PointFloat center; // Center of the circle.
    public double radius; // Radius of the circle.
    public double startAngle; // Start angle of the fitted structure.
    public double endAngle; // End angle of the fitted structure.

    private void init() {
      center = new PointFloat(backing, 0);
    }

    public PartialCircle() {
      super(32);
      init();
    }

    public PartialCircle(PointFloat center, double radius, double startAngle, double endAngle) {
      super(32);
      this.center = center;
      this.radius = radius;
      this.startAngle = startAngle;
      this.endAngle = endAngle;
    }

    protected PartialCircle(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected PartialCircle(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      center.read();
      radius = backing.getDouble(8);
      startAngle = backing.getDouble(16);
      endAngle = backing.getDouble(24);
    }

    public void write() {
      center.write();
      backing.putDouble(8, radius);
      backing.putDouble(16, startAngle);
      backing.putDouble(24, endAngle);
    }

    public int size() {
      return 32;
    }
  }

  public static class PartialEllipse extends DisposedStruct {
    public PointFloat center; // Center of the Ellipse.
    public double angle; // Angle of the ellipse.
    public double majorRadius; // The length of the semi-major axis of the
                               // ellipse.
    public double minorRadius; // The length of the semi-minor axis of the
                               // ellipse.
    public double startAngle; // Start angle of the fitted structure.
    public double endAngle; // End angle of the fitted structure.

    private void init() {
      center = new PointFloat(backing, 0);
    }

    public PartialEllipse() {
      super(48);
      init();
    }

    public PartialEllipse(PointFloat center, double angle, double majorRadius, double minorRadius,
        double startAngle, double endAngle) {
      super(48);
      this.center = center;
      this.angle = angle;
      this.majorRadius = majorRadius;
      this.minorRadius = minorRadius;
      this.startAngle = startAngle;
      this.endAngle = endAngle;
    }

    protected PartialEllipse(ByteBuffer backing, int offset) {
      super(backing, offset, 48);
      init();
    }

    protected PartialEllipse(long nativeObj, boolean owned) {
      super(nativeObj, owned, 48);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 48);
    }

    public void read() {
      center.read();
      angle = backing.getDouble(8);
      majorRadius = backing.getDouble(16);
      minorRadius = backing.getDouble(24);
      startAngle = backing.getDouble(32);
      endAngle = backing.getDouble(40);
    }

    public void write() {
      center.write();
      backing.putDouble(8, angle);
      backing.putDouble(16, majorRadius);
      backing.putDouble(24, minorRadius);
      backing.putDouble(32, startAngle);
      backing.putDouble(40, endAngle);
    }

    public int size() {
      return 48;
    }
  }

  public static class SetupMatchPatternData extends DisposedStruct {
    public byte[] matchSetupData; // String containing the match setup data.
    private ByteBuffer matchSetupData_buf;

    private void init() {
      matchSetupData = new byte[0];
    }

    public SetupMatchPatternData() {
      super(8);
      init();
    }

    public SetupMatchPatternData(byte[] matchSetupData) {
      super(8);
      this.matchSetupData = matchSetupData;
    }

    protected SetupMatchPatternData(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected SetupMatchPatternData(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      int matchSetupData_numMatchSetupData = backing.getInt(4);
      long matchSetupData_addr = getPointer(backing, 0);
      matchSetupData = new byte[matchSetupData_numMatchSetupData];
      if (matchSetupData_numMatchSetupData > 0 && matchSetupData_addr != 0) {
        getBytes(newDirectByteBuffer(matchSetupData_addr, matchSetupData_numMatchSetupData),
            matchSetupData, 0, matchSetupData_numMatchSetupData);
      }
    }

    public void write() {
      matchSetupData_buf = ByteBuffer.allocateDirect(matchSetupData.length);
      putBytes(matchSetupData_buf, matchSetupData, 0, matchSetupData.length);
      backing.putInt(4, matchSetupData.length);
      putPointer(backing, 0, matchSetupData_buf);
    }

    public int size() {
      return 8;
    }
  }

  public static class RangeSettingDouble extends DisposedStruct {
    public SettingType settingType; // Match Constraints specifies the match
                                    // option whose values you want to constrain
                                    // by the given range.
    public double min; // Min is the minimum value of the range for a given
                       // Match Constraint.
    public double max; // Max is the maximum value of the range for a given
                       // Match Constraint.

    private void init() {

    }

    public RangeSettingDouble() {
      super(24);
      init();
    }

    public RangeSettingDouble(SettingType settingType, double min, double max) {
      super(24);
      this.settingType = settingType;
      this.min = min;
      this.max = max;
    }

    protected RangeSettingDouble(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected RangeSettingDouble(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      settingType = SettingType.fromValue(backing.getInt(0));
      min = backing.getDouble(8);
      max = backing.getDouble(16);
    }

    public void write() {
      if (settingType != null)
        backing.putInt(0, settingType.getValue());
      backing.putDouble(8, min);
      backing.putDouble(16, max);
    }

    public int size() {
      return 24;
    }
  }

  public static class GeometricAdvancedSetupDataOption extends DisposedStruct {
    public GeometricSetupDataItem type; // It determines the option you want to
                                        // use during the matching phase.
    public double value; // Value is the value for the option you want to use
                         // during the matching phase.

    private void init() {

    }

    public GeometricAdvancedSetupDataOption() {
      super(16);
      init();
    }

    public GeometricAdvancedSetupDataOption(GeometricSetupDataItem type, double value) {
      super(16);
      this.type = type;
      this.value = value;
    }

    protected GeometricAdvancedSetupDataOption(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected GeometricAdvancedSetupDataOption(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      type = GeometricSetupDataItem.fromValue(backing.getInt(0));
      value = backing.getDouble(8);
    }

    public void write() {
      if (type != null)
        backing.putInt(0, type.getValue());
      backing.putDouble(8, value);
    }

    public int size() {
      return 16;
    }
  }

  public static class ContourInfoReport extends DisposedStruct {
    public PointDouble[] pointsPixel; // Points (pixel) specifies the location
                                      // of every point detected on the curve,
                                      // in pixels.
    public PointDouble[] pointsReal; // Points (real) specifies the location of
                                     // every point detected on the curve, in
                                     // calibrated units.
    public double[] curvaturePixel; // Curvature Pixel displays the curvature
                                    // profile for the selected contour, in
                                    // pixels.
    public double[] curvatureReal; // Curvature Real displays the curvature
                                   // profile for the selected contour, in
                                   // calibrated units.
    public double length; // Length (pixel) specifies the length, in pixels, of
                          // the curves in the image.
    public double lengthReal; // Length (real) specifies the length, in
                              // calibrated units, of the curves within the
                              // curvature range.
    public int hasEquation; // Has Equation specifies whether the contour has a
                            // fitted equation.
    private ByteBuffer pointsPixel_buf;
    private ByteBuffer pointsReal_buf;
    private ByteBuffer curvaturePixel_buf;
    private ByteBuffer curvatureReal_buf;

    private void init() {
      pointsPixel = new PointDouble[0];
      pointsReal = new PointDouble[0];
      curvaturePixel = new double[0];
      curvatureReal = new double[0];
    }

    public ContourInfoReport() {
      super(56);
      init();
    }

    public ContourInfoReport(PointDouble[] pointsPixel, PointDouble[] pointsReal,
        double[] curvaturePixel, double[] curvatureReal, double length, double lengthReal,
        int hasEquation) {
      super(56);
      this.pointsPixel = pointsPixel;
      this.pointsReal = pointsReal;
      this.curvaturePixel = curvaturePixel;
      this.curvatureReal = curvatureReal;
      this.length = length;
      this.lengthReal = lengthReal;
      this.hasEquation = hasEquation;
    }

    protected ContourInfoReport(ByteBuffer backing, int offset) {
      super(backing, offset, 56);
      init();
    }

    protected ContourInfoReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 56);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 56);
    }

    public void read() {
      int pointsPixel_numPointsPixel = backing.getInt(4);
      long pointsPixel_addr = getPointer(backing, 0);
      pointsPixel = new PointDouble[pointsPixel_numPointsPixel];
      if (pointsPixel_numPointsPixel > 0 && pointsPixel_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(pointsPixel_addr, pointsPixel_numPointsPixel * 16);
        for (int i = 0, off = 0; i < pointsPixel_numPointsPixel; i++, off += 16) {
          pointsPixel[i] = new PointDouble(bb, off);
          pointsPixel[i].read();
        }
      }
      int pointsReal_numPointsReal = backing.getInt(12);
      long pointsReal_addr = getPointer(backing, 8);
      pointsReal = new PointDouble[pointsReal_numPointsReal];
      if (pointsReal_numPointsReal > 0 && pointsReal_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(pointsReal_addr, pointsReal_numPointsReal * 16);
        for (int i = 0, off = 0; i < pointsReal_numPointsReal; i++, off += 16) {
          pointsReal[i] = new PointDouble(bb, off);
          pointsReal[i].read();
        }
      }
      int curvaturePixel_numCurvaturePixel = backing.getInt(20);
      long curvaturePixel_addr = getPointer(backing, 16);
      curvaturePixel = new double[curvaturePixel_numCurvaturePixel];
      if (curvaturePixel_numCurvaturePixel > 0 && curvaturePixel_addr != 0) {
        newDirectByteBuffer(curvaturePixel_addr, curvaturePixel_numCurvaturePixel * 8)
            .asDoubleBuffer().get(curvaturePixel);
      }
      int curvatureReal_numCurvatureReal = backing.getInt(28);
      long curvatureReal_addr = getPointer(backing, 24);
      curvatureReal = new double[curvatureReal_numCurvatureReal];
      if (curvatureReal_numCurvatureReal > 0 && curvatureReal_addr != 0) {
        newDirectByteBuffer(curvatureReal_addr, curvatureReal_numCurvatureReal * 8)
            .asDoubleBuffer().get(curvatureReal);
      }
      length = backing.getDouble(32);
      lengthReal = backing.getDouble(40);
      hasEquation = backing.getInt(48);
    }

    public void write() {
      pointsPixel_buf =
          ByteBuffer.allocateDirect(pointsPixel.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < pointsPixel.length; i++, off += 16) {
        pointsPixel[i].setBuffer(pointsPixel_buf, off);
        pointsPixel[i].write();
      }
      backing.putInt(4, pointsPixel.length);
      putPointer(backing, 0, pointsPixel_buf);
      pointsReal_buf =
          ByteBuffer.allocateDirect(pointsReal.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < pointsReal.length; i++, off += 16) {
        pointsReal[i].setBuffer(pointsReal_buf, off);
        pointsReal[i].write();
      }
      backing.putInt(12, pointsReal.length);
      putPointer(backing, 8, pointsReal_buf);
      curvaturePixel_buf =
          ByteBuffer.allocateDirect(curvaturePixel.length * 8).order(ByteOrder.nativeOrder());
      curvaturePixel_buf.asDoubleBuffer().put(curvaturePixel).rewind();
      backing.putInt(20, curvaturePixel.length);
      putPointer(backing, 16, curvaturePixel_buf);
      curvatureReal_buf =
          ByteBuffer.allocateDirect(curvatureReal.length * 8).order(ByteOrder.nativeOrder());
      curvatureReal_buf.asDoubleBuffer().put(curvatureReal).rewind();
      backing.putInt(28, curvatureReal.length);
      putPointer(backing, 24, curvatureReal_buf);
      backing.putDouble(32, length);
      backing.putDouble(40, lengthReal);
      backing.putInt(48, hasEquation);
    }

    public int size() {
      return 56;
    }
  }

  public static class ROILabel extends DisposedStruct {
    public String className; // Specifies the classname you want to segment.
    public int label; // Label is the label number associated with the Class
                      // Name.
    private ByteBuffer className_buf;

    private void init() {

    }

    public ROILabel() {
      super(8);
      init();
    }

    public ROILabel(String className, int label) {
      super(8);
      this.className = className;
      this.label = label;
    }

    protected ROILabel(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected ROILabel(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      long className_addr = getPointer(backing, 0);
      if (className_addr == 0)
        className = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(className_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          className = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          className = "";
        }
      }

      label = backing.getInt(4);
    }

    public void write() {
      if (className != null) {
        byte[] className_bytes;
        try {
          className_bytes = className.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          className_bytes = new byte[0];
        }
        className_buf = ByteBuffer.allocateDirect(className_bytes.length + 1);
        putBytes(className_buf, className_bytes, 0, className_bytes.length).put(
            className_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, className == null ? 0 : getByteBufferAddress(className_buf));
      backing.putInt(4, label);
    }

    public int size() {
      return 8;
    }
  }

  public static class SupervisedColorSegmentationReport extends DisposedStruct {
    public ROILabel[] labelOut; // The Roi labels array.
    private ByteBuffer labelOut_buf;

    private void init() {
      labelOut = new ROILabel[0];
    }

    public SupervisedColorSegmentationReport() {
      super(8);
      init();
    }

    public SupervisedColorSegmentationReport(ROILabel[] labelOut) {
      super(8);
      this.labelOut = labelOut;
    }

    protected SupervisedColorSegmentationReport(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected SupervisedColorSegmentationReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      int labelOut_numLabelOut = backing.getInt(4);
      long labelOut_addr = getPointer(backing, 0);
      labelOut = new ROILabel[labelOut_numLabelOut];
      if (labelOut_numLabelOut > 0 && labelOut_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(labelOut_addr, labelOut_numLabelOut * 8);
        for (int i = 0, off = 0; i < labelOut_numLabelOut; i++, off += 8) {
          labelOut[i] = new ROILabel(bb, off);
          labelOut[i].read();
        }
      }
    }

    public void write() {
      labelOut_buf = ByteBuffer.allocateDirect(labelOut.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < labelOut.length; i++, off += 8) {
        labelOut[i].setBuffer(labelOut_buf, off);
        labelOut[i].write();
      }
      backing.putInt(4, labelOut.length);
      putPointer(backing, 0, labelOut_buf);
    }

    public int size() {
      return 8;
    }
  }

  public static class LabelToROIReport extends DisposedStruct {
    public ROI[] roiArray; // Array of ROIs.
    public int[] labelsOutArray; // Array of labels.
    public int[] isTooManyVectorsArray; // isTooManyVectorsArray array.
    private ByteBuffer roiArray_buf;
    private ByteBuffer labelsOutArray_buf;
    private ByteBuffer isTooManyVectorsArray_buf;

    private void init() {
      roiArray = new ROI[0];
      labelsOutArray = new int[0];
      isTooManyVectorsArray = new int[0];
    }

    public LabelToROIReport() {
      super(24);
      init();
    }

    public LabelToROIReport(ROI[] roiArray, int[] labelsOutArray, int[] isTooManyVectorsArray) {
      super(24);
      this.roiArray = roiArray;
      this.labelsOutArray = labelsOutArray;
      this.isTooManyVectorsArray = isTooManyVectorsArray;
    }

    protected LabelToROIReport(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected LabelToROIReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      int roiArray_numOfROIs = backing.getInt(4);
      long roiArray_addr = getPointer(backing, 0);
      roiArray = new ROI[roiArray_numOfROIs];
      if (roiArray_numOfROIs > 0 && roiArray_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(roiArray_addr, roiArray_numOfROIs * 4);
        for (int i = 0, off = 0; i < roiArray_numOfROIs; i++, off += 4) {
          roiArray[i] = new ROI(getPointer(bb, off), false);
        }
      }
      int labelsOutArray_numOfLabels = backing.getInt(12);
      long labelsOutArray_addr = getPointer(backing, 8);
      labelsOutArray = new int[labelsOutArray_numOfLabels];
      if (labelsOutArray_numOfLabels > 0 && labelsOutArray_addr != 0) {
        newDirectByteBuffer(labelsOutArray_addr, labelsOutArray_numOfLabels * 4).asIntBuffer().get(
            labelsOutArray);
      }
      int isTooManyVectorsArray_isTooManyVectorsArraySize = backing.getInt(20);
      long isTooManyVectorsArray_addr = getPointer(backing, 16);
      isTooManyVectorsArray = new int[isTooManyVectorsArray_isTooManyVectorsArraySize];
      if (isTooManyVectorsArray_isTooManyVectorsArraySize > 0 && isTooManyVectorsArray_addr != 0) {
        newDirectByteBuffer(isTooManyVectorsArray_addr,
            isTooManyVectorsArray_isTooManyVectorsArraySize * 4).asIntBuffer().get(
            isTooManyVectorsArray);
      }
    }

    public void write() {
      roiArray_buf = ByteBuffer.allocateDirect(roiArray.length * 4).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < roiArray.length; i++, off += 4) {
        putPointer(roiArray_buf, off, roiArray[i]);
      }
      backing.putInt(4, roiArray.length);
      putPointer(backing, 0, roiArray_buf);
      labelsOutArray_buf =
          ByteBuffer.allocateDirect(labelsOutArray.length * 4).order(ByteOrder.nativeOrder());
      labelsOutArray_buf.asIntBuffer().put(labelsOutArray).rewind();
      backing.putInt(12, labelsOutArray.length);
      putPointer(backing, 8, labelsOutArray_buf);
      isTooManyVectorsArray_buf =
          ByteBuffer.allocateDirect(isTooManyVectorsArray.length * 4)
              .order(ByteOrder.nativeOrder());
      isTooManyVectorsArray_buf.asIntBuffer().put(isTooManyVectorsArray).rewind();
      backing.putInt(20, isTooManyVectorsArray.length);
      putPointer(backing, 16, isTooManyVectorsArray_buf);
    }

    public int size() {
      return 24;
    }
  }

  public static class ColorSegmenationOptions extends DisposedStruct {
    public int windowX; // X is the window size in x direction.
    public int windowY; // Y is the window size in y direction.
    public int stepSize; // Step Size is the distance between two windows.
    public int minParticleArea; // Min Particle Area is the minimum number of
                                // allowed pixels.
    public int maxParticleArea; // Max Particle Area is the maximum number of
                                // allowed pixels.
    public short isFineSegment; // When enabled, the step processes the boundary
                                // pixels of each segmentation cluster using a
                                // step size of 1.

    private void init() {

    }

    public ColorSegmenationOptions() {
      super(24);
      init();
    }

    public ColorSegmenationOptions(int windowX, int windowY, int stepSize, int minParticleArea,
        int maxParticleArea, int isFineSegment) {
      super(24);
      this.windowX = windowX;
      this.windowY = windowY;
      this.stepSize = stepSize;
      this.minParticleArea = minParticleArea;
      this.maxParticleArea = maxParticleArea;
      this.isFineSegment = (short) isFineSegment;
    }

    protected ColorSegmenationOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected ColorSegmenationOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      windowX = backing.getInt(0);
      windowY = backing.getInt(4);
      stepSize = backing.getInt(8);
      minParticleArea = backing.getInt(12);
      maxParticleArea = backing.getInt(16);
      isFineSegment = backing.getShort(20);
    }

    public void write() {
      backing.putInt(0, windowX);
      backing.putInt(4, windowY);
      backing.putInt(8, stepSize);
      backing.putInt(12, minParticleArea);
      backing.putInt(16, maxParticleArea);
      backing.putShort(20, isFineSegment);
    }

    public int size() {
      return 24;
    }
  }

  public static class ClassifiedCurve extends DisposedStruct {
    public double length; // Specifies the length, in pixels, of the curves
                          // within the curvature range.
    public double lengthReal; // specifies the length, in calibrated units, of
                              // the curves within the curvature range.
    public double maxCurvature; // specifies the maximum curvature, in pixels,
                                // for the selected curvature range.
    public double maxCurvatureReal; // specifies the maximum curvature, in
                                    // calibrated units, for the selected
                                    // curvature range.
    public int label; // specifies the class to which the the sample belongs.
    public PointDouble[] curvePoints; // Curve Points is a point-coordinate
                                      // cluster that defines the points of the
                                      // curve.
    private ByteBuffer curvePoints_buf;

    private void init() {
      curvePoints = new PointDouble[0];
    }

    public ClassifiedCurve() {
      super(48);
      init();
    }

    public ClassifiedCurve(double length, double lengthReal, double maxCurvature,
        double maxCurvatureReal, int label, PointDouble[] curvePoints) {
      super(48);
      this.length = length;
      this.lengthReal = lengthReal;
      this.maxCurvature = maxCurvature;
      this.maxCurvatureReal = maxCurvatureReal;
      this.label = label;
      this.curvePoints = curvePoints;
    }

    protected ClassifiedCurve(ByteBuffer backing, int offset) {
      super(backing, offset, 48);
      init();
    }

    protected ClassifiedCurve(long nativeObj, boolean owned) {
      super(nativeObj, owned, 48);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 48);
    }

    public void read() {
      length = backing.getDouble(0);
      lengthReal = backing.getDouble(8);
      maxCurvature = backing.getDouble(16);
      maxCurvatureReal = backing.getDouble(24);
      label = backing.getInt(32);
      int curvePoints_numCurvePoints = backing.getInt(40);
      long curvePoints_addr = getPointer(backing, 36);
      curvePoints = new PointDouble[curvePoints_numCurvePoints];
      if (curvePoints_numCurvePoints > 0 && curvePoints_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(curvePoints_addr, curvePoints_numCurvePoints * 16);
        for (int i = 0, off = 0; i < curvePoints_numCurvePoints; i++, off += 16) {
          curvePoints[i] = new PointDouble(bb, off);
          curvePoints[i].read();
        }
      }
    }

    public void write() {
      backing.putDouble(0, length);
      backing.putDouble(8, lengthReal);
      backing.putDouble(16, maxCurvature);
      backing.putDouble(24, maxCurvatureReal);
      backing.putInt(32, label);
      curvePoints_buf =
          ByteBuffer.allocateDirect(curvePoints.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < curvePoints.length; i++, off += 16) {
        curvePoints[i].setBuffer(curvePoints_buf, off);
        curvePoints[i].write();
      }
      backing.putInt(40, curvePoints.length);
      putPointer(backing, 36, curvePoints_buf);
    }

    public int size() {
      return 48;
    }
  }

  public static class RangeDouble extends DisposedStruct {
    public double minValue; // The minimum value of the range.
    public double maxValue; // The maximum value of the range.

    private void init() {

    }

    public RangeDouble() {
      super(16);
      init();
    }

    public RangeDouble(double minValue, double maxValue) {
      super(16);
      this.minValue = minValue;
      this.maxValue = maxValue;
    }

    protected RangeDouble(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected RangeDouble(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      minValue = backing.getDouble(0);
      maxValue = backing.getDouble(8);
    }

    public void write() {
      backing.putDouble(0, minValue);
      backing.putDouble(8, maxValue);
    }

    public int size() {
      return 16;
    }
  }

  public static class RangeLabel extends DisposedStruct {
    public RangeDouble range; // Specifies the range of curvature values.
    public int label; // Class Label specifies the class to which the the sample
                      // belongs.

    private void init() {
      range = new RangeDouble(backing, 0);
    }

    public RangeLabel() {
      super(24);
      init();
    }

    public RangeLabel(RangeDouble range, int label) {
      super(24);
      this.range = range;
      this.label = label;
    }

    protected RangeLabel(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected RangeLabel(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      range.read();
      label = backing.getInt(16);
    }

    public void write() {
      range.write();
      backing.putInt(16, label);
    }

    public int size() {
      return 24;
    }
  }

  public static class CurvatureAnalysisReport extends DisposedStruct {
    public ClassifiedCurve[] curves;
    private ByteBuffer curves_buf;

    private void init() {
      curves = new ClassifiedCurve[0];
    }

    public CurvatureAnalysisReport() {
      super(8);
      init();
    }

    public CurvatureAnalysisReport(ClassifiedCurve[] curves) {
      super(8);
      this.curves = curves;
    }

    protected CurvatureAnalysisReport(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected CurvatureAnalysisReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      int curves_numCurves = backing.getInt(4);
      long curves_addr = getPointer(backing, 0);
      curves = new ClassifiedCurve[curves_numCurves];
      if (curves_numCurves > 0 && curves_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(curves_addr, curves_numCurves * 48);
        for (int i = 0, off = 0; i < curves_numCurves; i++, off += 48) {
          curves[i] = new ClassifiedCurve(bb, off);
          curves[i].read();
        }
      }
    }

    public void write() {
      curves_buf = ByteBuffer.allocateDirect(curves.length * 48).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < curves.length; i++, off += 48) {
        curves[i].setBuffer(curves_buf, off);
        curves[i].write();
      }
      backing.putInt(4, curves.length);
      putPointer(backing, 0, curves_buf);
    }

    public int size() {
      return 8;
    }
  }

  public static class Disparity extends DisposedStruct {
    public PointDouble current; // Current is a array of points that defines the
                                // target contour.
    public PointDouble reference; // reference is a array of points that defines
                                  // the template contour.
    public double distance; // Specifies the distance, in pixels, between the
                            // template contour point and the target contour
                            // point.

    private void init() {
      current = new PointDouble(backing, 0);
      reference = new PointDouble(backing, 16);
    }

    public Disparity() {
      super(40);
      init();
    }

    public Disparity(PointDouble current, PointDouble reference, double distance) {
      super(40);
      this.current = current;
      this.reference = reference;
      this.distance = distance;
    }

    protected Disparity(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected Disparity(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      current.read();
      reference.read();
      distance = backing.getDouble(32);
    }

    public void write() {
      current.write();
      reference.write();
      backing.putDouble(32, distance);
    }

    public int size() {
      return 40;
    }
  }

  public static class ComputeDistancesReport extends DisposedStruct {
    public Disparity[] distances; // Distances is an array containing the
                                  // computed distances.
    public Disparity[] distancesReal; // Distances Real is an array containing
                                      // the computed distances in calibrated
                                      // units.
    private ByteBuffer distances_buf;
    private ByteBuffer distancesReal_buf;

    private void init() {
      distances = new Disparity[0];
      distancesReal = new Disparity[0];
    }

    public ComputeDistancesReport() {
      super(16);
      init();
    }

    public ComputeDistancesReport(Disparity[] distances, Disparity[] distancesReal) {
      super(16);
      this.distances = distances;
      this.distancesReal = distancesReal;
    }

    protected ComputeDistancesReport(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ComputeDistancesReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      int distances_numDistances = backing.getInt(4);
      long distances_addr = getPointer(backing, 0);
      distances = new Disparity[distances_numDistances];
      if (distances_numDistances > 0 && distances_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(distances_addr, distances_numDistances * 40);
        for (int i = 0, off = 0; i < distances_numDistances; i++, off += 40) {
          distances[i] = new Disparity(bb, off);
          distances[i].read();
        }
      }
      int distancesReal_numDistancesReal = backing.getInt(12);
      long distancesReal_addr = getPointer(backing, 8);
      distancesReal = new Disparity[distancesReal_numDistancesReal];
      if (distancesReal_numDistancesReal > 0 && distancesReal_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(distancesReal_addr, distancesReal_numDistancesReal * 40);
        for (int i = 0, off = 0; i < distancesReal_numDistancesReal; i++, off += 40) {
          distancesReal[i] = new Disparity(bb, off);
          distancesReal[i].read();
        }
      }
    }

    public void write() {
      distances_buf =
          ByteBuffer.allocateDirect(distances.length * 40).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < distances.length; i++, off += 40) {
        distances[i].setBuffer(distances_buf, off);
        distances[i].write();
      }
      backing.putInt(4, distances.length);
      putPointer(backing, 0, distances_buf);
      distancesReal_buf =
          ByteBuffer.allocateDirect(distancesReal.length * 40).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < distancesReal.length; i++, off += 40) {
        distancesReal[i].setBuffer(distancesReal_buf, off);
        distancesReal[i].write();
      }
      backing.putInt(12, distancesReal.length);
      putPointer(backing, 8, distancesReal_buf);
    }

    public int size() {
      return 16;
    }
  }

  public static class MatchMode extends DisposedStruct {
    public int rotation; // Rotation When enabled, the Function searches for
                         // occurrences of the template in the inspection image,
                         // allowing for template matches to be rotated.
    public int scale; // Rotation When enabled, the Function searches for
                      // occurrences of the template in the inspection image,
                      // allowing for template matches to be rotated.
    public int occlusion; // Occlusion specifies whether or not to search for
                          // occluded versions of the shape.

    private void init() {

    }

    public MatchMode() {
      super(12);
      init();
    }

    public MatchMode(int rotation, int scale, int occlusion) {
      super(12);
      this.rotation = rotation;
      this.scale = scale;
      this.occlusion = occlusion;
    }

    protected MatchMode(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected MatchMode(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      rotation = backing.getInt(0);
      scale = backing.getInt(4);
      occlusion = backing.getInt(8);
    }

    public void write() {
      backing.putInt(0, rotation);
      backing.putInt(4, scale);
      backing.putInt(8, occlusion);
    }

    public int size() {
      return 12;
    }
  }

  public static class ClassifiedDisparity extends DisposedStruct {
    public double length; // Length (pixel) specifies the length, in pixels, of
                          // the curves within the curvature range.
    public double lengthReal; // Length (real) specifies the length, in
                              // calibrated units, of the curves within the
                              // curvature range.
    public double maxDistance; // Maximum Distance (pixel) specifies the maximum
                               // distance, in pixels, between points along the
                               // selected contour and the template contour.
    public double maxDistanceReal; // Maximum Distance (real) specifies the
                                   // maximum distance, in calibrated units,
                                   // between points along the selected contour
                                   // and the template contour.
    public int label; // Class Label specifies the class to which the the sample
                      // belongs.
    public PointDouble[] templateSubsection; // Template subsection points is an
                                             // array of points that defines the
                                             // boundary of the template.
    public PointDouble[] targetSubsection; // Current Points(Target subsection
                                           // points) is an array of points that
                                           // defines the boundary of the
                                           // target.
    private ByteBuffer templateSubsection_buf;
    private ByteBuffer targetSubsection_buf;

    private void init() {
      templateSubsection = new PointDouble[0];
      targetSubsection = new PointDouble[0];
    }

    public ClassifiedDisparity() {
      super(56);
      init();
    }

    public ClassifiedDisparity(double length, double lengthReal, double maxDistance,
        double maxDistanceReal, int label, PointDouble[] templateSubsection,
        PointDouble[] targetSubsection) {
      super(56);
      this.length = length;
      this.lengthReal = lengthReal;
      this.maxDistance = maxDistance;
      this.maxDistanceReal = maxDistanceReal;
      this.label = label;
      this.templateSubsection = templateSubsection;
      this.targetSubsection = targetSubsection;
    }

    protected ClassifiedDisparity(ByteBuffer backing, int offset) {
      super(backing, offset, 56);
      init();
    }

    protected ClassifiedDisparity(long nativeObj, boolean owned) {
      super(nativeObj, owned, 56);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 56);
    }

    public void read() {
      length = backing.getDouble(0);
      lengthReal = backing.getDouble(8);
      maxDistance = backing.getDouble(16);
      maxDistanceReal = backing.getDouble(24);
      label = backing.getInt(32);
      int templateSubsection_numTemplateSubsection = backing.getInt(40);
      long templateSubsection_addr = getPointer(backing, 36);
      templateSubsection = new PointDouble[templateSubsection_numTemplateSubsection];
      if (templateSubsection_numTemplateSubsection > 0 && templateSubsection_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(templateSubsection_addr,
                templateSubsection_numTemplateSubsection * 16);
        for (int i = 0, off = 0; i < templateSubsection_numTemplateSubsection; i++, off += 16) {
          templateSubsection[i] = new PointDouble(bb, off);
          templateSubsection[i].read();
        }
      }
      int targetSubsection_numTargetSubsection = backing.getInt(48);
      long targetSubsection_addr = getPointer(backing, 44);
      targetSubsection = new PointDouble[targetSubsection_numTargetSubsection];
      if (targetSubsection_numTargetSubsection > 0 && targetSubsection_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(targetSubsection_addr, targetSubsection_numTargetSubsection * 16);
        for (int i = 0, off = 0; i < targetSubsection_numTargetSubsection; i++, off += 16) {
          targetSubsection[i] = new PointDouble(bb, off);
          targetSubsection[i].read();
        }
      }
    }

    public void write() {
      backing.putDouble(0, length);
      backing.putDouble(8, lengthReal);
      backing.putDouble(16, maxDistance);
      backing.putDouble(24, maxDistanceReal);
      backing.putInt(32, label);
      templateSubsection_buf =
          ByteBuffer.allocateDirect(templateSubsection.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < templateSubsection.length; i++, off += 16) {
        templateSubsection[i].setBuffer(templateSubsection_buf, off);
        templateSubsection[i].write();
      }
      backing.putInt(40, templateSubsection.length);
      putPointer(backing, 36, templateSubsection_buf);
      targetSubsection_buf =
          ByteBuffer.allocateDirect(targetSubsection.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < targetSubsection.length; i++, off += 16) {
        targetSubsection[i].setBuffer(targetSubsection_buf, off);
        targetSubsection[i].write();
      }
      backing.putInt(48, targetSubsection.length);
      putPointer(backing, 44, targetSubsection_buf);
    }

    public int size() {
      return 56;
    }
  }

  public static class ClassifyDistancesReport extends DisposedStruct {
    public ClassifiedDisparity[] classifiedDistances; // Disparity array
                                                      // containing the
                                                      // classified distances.
    private ByteBuffer classifiedDistances_buf;

    private void init() {
      classifiedDistances = new ClassifiedDisparity[0];
    }

    public ClassifyDistancesReport() {
      super(8);
      init();
    }

    public ClassifyDistancesReport(ClassifiedDisparity[] classifiedDistances) {
      super(8);
      this.classifiedDistances = classifiedDistances;
    }

    protected ClassifyDistancesReport(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected ClassifyDistancesReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      int classifiedDistances_numClassifiedDistances = backing.getInt(4);
      long classifiedDistances_addr = getPointer(backing, 0);
      classifiedDistances = new ClassifiedDisparity[classifiedDistances_numClassifiedDistances];
      if (classifiedDistances_numClassifiedDistances > 0 && classifiedDistances_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(classifiedDistances_addr,
                classifiedDistances_numClassifiedDistances * 56);
        for (int i = 0, off = 0; i < classifiedDistances_numClassifiedDistances; i++, off += 56) {
          classifiedDistances[i] = new ClassifiedDisparity(bb, off);
          classifiedDistances[i].read();
        }
      }
    }

    public void write() {
      classifiedDistances_buf =
          ByteBuffer.allocateDirect(classifiedDistances.length * 56).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < classifiedDistances.length; i++, off += 56) {
        classifiedDistances[i].setBuffer(classifiedDistances_buf, off);
        classifiedDistances[i].write();
      }
      backing.putInt(4, classifiedDistances.length);
      putPointer(backing, 0, classifiedDistances_buf);
    }

    public int size() {
      return 8;
    }
  }

  public static class ContourComputeCurvatureReport extends DisposedStruct {
    public double[] curvaturePixel; // Curvature Pixel displays the curvature
                                    // profile for the selected contour, in
                                    // pixels.
    public double[] curvatureReal; // Curvature Real displays the curvature
                                   // profile for the selected contour, in
                                   // calibrated units.
    private ByteBuffer curvaturePixel_buf;
    private ByteBuffer curvatureReal_buf;

    private void init() {
      curvaturePixel = new double[0];
      curvatureReal = new double[0];
    }

    public ContourComputeCurvatureReport() {
      super(16);
      init();
    }

    public ContourComputeCurvatureReport(double[] curvaturePixel, double[] curvatureReal) {
      super(16);
      this.curvaturePixel = curvaturePixel;
      this.curvatureReal = curvatureReal;
    }

    protected ContourComputeCurvatureReport(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ContourComputeCurvatureReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      int curvaturePixel_numCurvaturePixel = backing.getInt(4);
      long curvaturePixel_addr = getPointer(backing, 0);
      curvaturePixel = new double[curvaturePixel_numCurvaturePixel];
      if (curvaturePixel_numCurvaturePixel > 0 && curvaturePixel_addr != 0) {
        newDirectByteBuffer(curvaturePixel_addr, curvaturePixel_numCurvaturePixel * 8)
            .asDoubleBuffer().get(curvaturePixel);
      }
      int curvatureReal_numCurvatureReal = backing.getInt(12);
      long curvatureReal_addr = getPointer(backing, 8);
      curvatureReal = new double[curvatureReal_numCurvatureReal];
      if (curvatureReal_numCurvatureReal > 0 && curvatureReal_addr != 0) {
        newDirectByteBuffer(curvatureReal_addr, curvatureReal_numCurvatureReal * 8)
            .asDoubleBuffer().get(curvatureReal);
      }
    }

    public void write() {
      curvaturePixel_buf =
          ByteBuffer.allocateDirect(curvaturePixel.length * 8).order(ByteOrder.nativeOrder());
      curvaturePixel_buf.asDoubleBuffer().put(curvaturePixel).rewind();
      backing.putInt(4, curvaturePixel.length);
      putPointer(backing, 0, curvaturePixel_buf);
      curvatureReal_buf =
          ByteBuffer.allocateDirect(curvatureReal.length * 8).order(ByteOrder.nativeOrder());
      curvatureReal_buf.asDoubleBuffer().put(curvatureReal).rewind();
      backing.putInt(12, curvatureReal.length);
      putPointer(backing, 8, curvatureReal_buf);
    }

    public int size() {
      return 16;
    }
  }

  public static class ContourOverlaySettings extends DisposedStruct {
    public int overlay; // Overlay specifies whether to display the overlay on
                        // the image.
    public RGBValue color; // Color is the color of the overlay.
    public int width; // Width specifies the width of the overlay in pixels.
    public int maintainWidth; // Maintain Width? specifies whether you want the
                              // overlay measured in screen pixels or image
                              // pixels.

    private void init() {
      color = new RGBValue(backing, 4);
    }

    public ContourOverlaySettings() {
      super(16);
      init();
    }

    public ContourOverlaySettings(int overlay, RGBValue color, int width, int maintainWidth) {
      super(16);
      this.overlay = overlay;
      this.color = color;
      this.width = width;
      this.maintainWidth = maintainWidth;
    }

    protected ContourOverlaySettings(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ContourOverlaySettings(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      overlay = backing.getInt(0);
      color.read();
      width = backing.getInt(8);
      maintainWidth = backing.getInt(12);
    }

    public void write() {
      backing.putInt(0, overlay);
      color.write();
      backing.putInt(8, width);
      backing.putInt(12, maintainWidth);
    }

    public int size() {
      return 16;
    }
  }

  public static class CurveParameters extends DisposedStruct {
    public ExtractionMode extractionMode; // Specifies the method the function
                                          // uses to identify curves in the
                                          // image.
    public int threshold; // Specifies the minimum contrast a seed point must
                          // have in order to begin a curve.
    public EdgeFilterSize filterSize; // Specifies the width of the edge filter
                                      // the function uses to identify curves in
                                      // the image.
    public int minLength; // Specifies the length, in pixels, of the smallest
                          // curve the function will extract.
    public int searchStep; // Search Step Size specifies the distance, in the y
                           // direction, between the image rows that the
                           // algorithm inspects for curve seed points.
    public int maxEndPointGap; // Specifies the maximum gap, in pixels, between
                               // the endpoints of a curve that the function
                               // identifies as a closed curve.
    public int subpixel; // Subpixel specifies whether to detect curve points
                         // with subpixel accuracy.

    private void init() {

    }

    public CurveParameters() {
      super(28);
      init();
    }

    public CurveParameters(ExtractionMode extractionMode, int threshold, EdgeFilterSize filterSize,
        int minLength, int searchStep, int maxEndPointGap, int subpixel) {
      super(28);
      this.extractionMode = extractionMode;
      this.threshold = threshold;
      this.filterSize = filterSize;
      this.minLength = minLength;
      this.searchStep = searchStep;
      this.maxEndPointGap = maxEndPointGap;
      this.subpixel = subpixel;
    }

    protected CurveParameters(ByteBuffer backing, int offset) {
      super(backing, offset, 28);
      init();
    }

    protected CurveParameters(long nativeObj, boolean owned) {
      super(nativeObj, owned, 28);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 28);
    }

    public void read() {
      extractionMode = ExtractionMode.fromValue(backing.getInt(0));
      threshold = backing.getInt(4);
      filterSize = EdgeFilterSize.fromValue(backing.getInt(8));
      minLength = backing.getInt(12);
      searchStep = backing.getInt(16);
      maxEndPointGap = backing.getInt(20);
      subpixel = backing.getInt(24);
    }

    public void write() {
      if (extractionMode != null)
        backing.putInt(0, extractionMode.getValue());
      backing.putInt(4, threshold);
      if (filterSize != null)
        backing.putInt(8, filterSize.getValue());
      backing.putInt(12, minLength);
      backing.putInt(16, searchStep);
      backing.putInt(20, maxEndPointGap);
      backing.putInt(24, subpixel);
    }

    public int size() {
      return 28;
    }
  }

  public static class ExtractContourReport extends DisposedStruct {
    public PointDouble[] contourPoints; // Contour Points specifies every point
                                        // found on the contour.
    public PointDouble[] sourcePoints; // Source Image Points specifies every
                                       // point found on the contour in the
                                       // source image.
    private ByteBuffer contourPoints_buf;
    private ByteBuffer sourcePoints_buf;

    private void init() {
      contourPoints = new PointDouble[0];
      sourcePoints = new PointDouble[0];
    }

    public ExtractContourReport() {
      super(16);
      init();
    }

    public ExtractContourReport(PointDouble[] contourPoints, PointDouble[] sourcePoints) {
      super(16);
      this.contourPoints = contourPoints;
      this.sourcePoints = sourcePoints;
    }

    protected ExtractContourReport(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ExtractContourReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      int contourPoints_numContourPoints = backing.getInt(4);
      long contourPoints_addr = getPointer(backing, 0);
      contourPoints = new PointDouble[contourPoints_numContourPoints];
      if (contourPoints_numContourPoints > 0 && contourPoints_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(contourPoints_addr, contourPoints_numContourPoints * 16);
        for (int i = 0, off = 0; i < contourPoints_numContourPoints; i++, off += 16) {
          contourPoints[i] = new PointDouble(bb, off);
          contourPoints[i].read();
        }
      }
      int sourcePoints_numSourcePoints = backing.getInt(12);
      long sourcePoints_addr = getPointer(backing, 8);
      sourcePoints = new PointDouble[sourcePoints_numSourcePoints];
      if (sourcePoints_numSourcePoints > 0 && sourcePoints_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(sourcePoints_addr, sourcePoints_numSourcePoints * 16);
        for (int i = 0, off = 0; i < sourcePoints_numSourcePoints; i++, off += 16) {
          sourcePoints[i] = new PointDouble(bb, off);
          sourcePoints[i].read();
        }
      }
    }

    public void write() {
      contourPoints_buf =
          ByteBuffer.allocateDirect(contourPoints.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < contourPoints.length; i++, off += 16) {
        contourPoints[i].setBuffer(contourPoints_buf, off);
        contourPoints[i].write();
      }
      backing.putInt(4, contourPoints.length);
      putPointer(backing, 0, contourPoints_buf);
      sourcePoints_buf =
          ByteBuffer.allocateDirect(sourcePoints.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < sourcePoints.length; i++, off += 16) {
        sourcePoints[i].setBuffer(sourcePoints_buf, off);
        sourcePoints[i].write();
      }
      backing.putInt(12, sourcePoints.length);
      putPointer(backing, 8, sourcePoints_buf);
    }

    public int size() {
      return 16;
    }
  }

  public static class ConnectionConstraint extends DisposedStruct {
    public ConnectionConstraintType constraintType; // Constraint Type specifies
                                                    // what criteria to use to
                                                    // consider two curves part
                                                    // of a contour.
    public RangeDouble range; // Specifies range for a given Match Constraint.

    private void init() {
      range = new RangeDouble(backing, 8);
    }

    public ConnectionConstraint() {
      super(24);
      init();
    }

    public ConnectionConstraint(ConnectionConstraintType constraintType, RangeDouble range) {
      super(24);
      this.constraintType = constraintType;
      this.range = range;
    }

    protected ConnectionConstraint(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected ConnectionConstraint(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      constraintType = ConnectionConstraintType.fromValue(backing.getInt(0));
      range.read();
    }

    public void write() {
      if (constraintType != null)
        backing.putInt(0, constraintType.getValue());
      range.write();
    }

    public int size() {
      return 24;
    }
  }

  public static class ExtractTextureFeaturesReport extends DisposedStruct {
    public int[] waveletBands; // The array having all the Wavelet Banks used
                               // for extraction.
    public int textureFeaturesRows; // Number of Rows in the Texture Features
                                    // array.
    public int textureFeaturesCols; // Number of Cols in Texture Features array.
    private ByteBuffer waveletBands_buf;

    private void init() {
      waveletBands = new int[0];
    }

    public ExtractTextureFeaturesReport() {
      super(20);
      init();
    }

    public ExtractTextureFeaturesReport(int[] waveletBands, int textureFeaturesRows,
        int textureFeaturesCols) {
      super(20);
      this.waveletBands = waveletBands;
      this.textureFeaturesRows = textureFeaturesRows;
      this.textureFeaturesCols = textureFeaturesCols;
    }

    protected ExtractTextureFeaturesReport(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected ExtractTextureFeaturesReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      int waveletBands_numWaveletBands = backing.getInt(4);
      long waveletBands_addr = getPointer(backing, 0);
      waveletBands = new int[waveletBands_numWaveletBands];
      if (waveletBands_numWaveletBands > 0 && waveletBands_addr != 0) {
        newDirectByteBuffer(waveletBands_addr, waveletBands_numWaveletBands * 4).asIntBuffer().get(
            waveletBands);
      }
      textureFeaturesRows = backing.getInt(12);
      textureFeaturesCols = backing.getInt(16);
    }

    public void write() {
      waveletBands_buf =
          ByteBuffer.allocateDirect(waveletBands.length * 4).order(ByteOrder.nativeOrder());
      waveletBands_buf.asIntBuffer().put(waveletBands).rewind();
      backing.putInt(4, waveletBands.length);
      putPointer(backing, 0, waveletBands_buf);
      backing.putInt(12, textureFeaturesRows);
      backing.putInt(16, textureFeaturesCols);
    }

    public int size() {
      return 20;
    }
  }

  public static class WaveletBandsReport extends DisposedStruct {
    public float LHLBand; // 2-D array for LHL Band.
    public int rows; // Number of Rows for each of the 2-D arrays.
    public int cols; // Number of Columns for each of the 2-D arrays.

    private void init() {

    }

    public WaveletBandsReport() {
      super(40);
      init();
    }

    public WaveletBandsReport(double LHLBand, int rows, int cols) {
      super(40);
      this.LHLBand = (float) LHLBand;
      this.rows = rows;
      this.cols = cols;
    }

    protected WaveletBandsReport(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected WaveletBandsReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      LHLBand = backing.getFloat(24);
      rows = backing.getInt(32);
      cols = backing.getInt(36);
    }

    public void write() {
      backing.putFloat(24, LHLBand);
      backing.putInt(32, rows);
      backing.putInt(36, cols);
    }

    public int size() {
      return 40;
    }
  }

  public static class CircleFitOptions extends DisposedStruct {
    public int maxRadius; // Specifies the acceptable distance, in pixels, that
                          // a point determined to belong to the circle can be
                          // from the perimeter of the circle.
    public double stepSize; // Step Size is the angle, in degrees, between each
                            // radial line in the annular region.
    public RakeProcessType processType; // Method used to process the data
                                        // extracted for edge detection.

    private void init() {

    }

    public CircleFitOptions() {
      super(24);
      init();
    }

    public CircleFitOptions(int maxRadius, double stepSize, RakeProcessType processType) {
      super(24);
      this.maxRadius = maxRadius;
      this.stepSize = stepSize;
      this.processType = processType;
    }

    protected CircleFitOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected CircleFitOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      maxRadius = backing.getInt(0);
      stepSize = backing.getDouble(8);
      processType = RakeProcessType.fromValue(backing.getInt(16));
    }

    public void write() {
      backing.putInt(0, maxRadius);
      backing.putDouble(8, stepSize);
      if (processType != null)
        backing.putInt(16, processType.getValue());
    }

    public int size() {
      return 24;
    }
  }

  public static class EdgeOptions2 extends DisposedStruct {
    public EdgePolaritySearchMode polarity; // Specifies the polarity of the
                                            // edges to be found.
    public int kernelSize; // Specifies the size of the edge detection kernel.
    public int width; // Specifies the number of pixels averaged perpendicular
                      // to the search direction to compute the edge profile
                      // strength at each point along the search ROI.
    public float minThreshold; // Specifies the minimum edge strength (gradient
                               // magnitude) required for a detected edge.
    public InterpolationMethod interpolationType; // Specifies the interpolation
                                                  // method used to locate the
                                                  // edge position.
    public ColumnProcessingMode columnProcessingMode; // Specifies the method
                                                      // used to find the
                                                      // straight edge.

    private void init() {

    }

    public EdgeOptions2() {
      super(24);
      init();
    }

    public EdgeOptions2(EdgePolaritySearchMode polarity, int kernelSize, int width,
        double minThreshold, InterpolationMethod interpolationType,
        ColumnProcessingMode columnProcessingMode) {
      super(24);
      this.polarity = polarity;
      this.kernelSize = kernelSize;
      this.width = width;
      this.minThreshold = (float) minThreshold;
      this.interpolationType = interpolationType;
      this.columnProcessingMode = columnProcessingMode;
    }

    protected EdgeOptions2(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected EdgeOptions2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      polarity = EdgePolaritySearchMode.fromValue(backing.getInt(0));
      kernelSize = backing.getInt(4);
      width = backing.getInt(8);
      minThreshold = backing.getFloat(12);
      interpolationType = InterpolationMethod.fromValue(backing.getInt(16));
      columnProcessingMode = ColumnProcessingMode.fromValue(backing.getInt(20));
    }

    public void write() {
      if (polarity != null)
        backing.putInt(0, polarity.getValue());
      backing.putInt(4, kernelSize);
      backing.putInt(8, width);
      backing.putFloat(12, minThreshold);
      if (interpolationType != null)
        backing.putInt(16, interpolationType.getValue());
      if (columnProcessingMode != null)
        backing.putInt(20, columnProcessingMode.getValue());
    }

    public int size() {
      return 24;
    }
  }

  public static class FindCircularEdgeOptions extends DisposedStruct {
    public SpokeDirection direction; // Specifies the Spoke direction to search
                                     // in the ROI.
    public int showSearchArea; // If TRUE, the function overlays the search area
                               // on the image.
    public int showSearchLines; // If TRUE, the function overlays the search
                                // lines used to locate the edges on the image.
    public int showEdgesFound; // If TRUE, the function overlays the locations
                               // of the edges found on the image.
    public int showResult; // If TRUE, the function overlays the hit lines to
                           // the object and the edge used to generate the hit
                           // line on the result image.
    public RGBValue searchAreaColor; // Specifies the RGB color value to use to
                                     // overlay the search area.
    public RGBValue searchLinesColor; // Specifies the RGB color value to use to
                                      // overlay the search lines.
    public RGBValue searchEdgesColor; // Specifies the RGB color value to use to
                                      // overlay the search edges.
    public RGBValue resultColor; // Specifies the RGB color value to use to
                                 // overlay the results.
    public String overlayGroupName; // Specifies the overlay group name to
                                    // assign to the overlays.
    public EdgeOptions2 edgeOptions; // Specifies the edge detection options
                                     // along a single search line.
    private ByteBuffer overlayGroupName_buf;

    private void init() {
      searchAreaColor = new RGBValue(backing, 20);
      searchLinesColor = new RGBValue(backing, 24);
      searchEdgesColor = new RGBValue(backing, 28);
      resultColor = new RGBValue(backing, 32);
      edgeOptions = new EdgeOptions2(backing, 40);
    }

    public FindCircularEdgeOptions() {
      super(64);
      init();
    }

    public FindCircularEdgeOptions(SpokeDirection direction, int showSearchArea,
        int showSearchLines, int showEdgesFound, int showResult, RGBValue searchAreaColor,
        RGBValue searchLinesColor, RGBValue searchEdgesColor, RGBValue resultColor,
        String overlayGroupName, EdgeOptions2 edgeOptions) {
      super(64);
      this.direction = direction;
      this.showSearchArea = showSearchArea;
      this.showSearchLines = showSearchLines;
      this.showEdgesFound = showEdgesFound;
      this.showResult = showResult;
      this.searchAreaColor = searchAreaColor;
      this.searchLinesColor = searchLinesColor;
      this.searchEdgesColor = searchEdgesColor;
      this.resultColor = resultColor;
      this.overlayGroupName = overlayGroupName;
      this.edgeOptions = edgeOptions;
    }

    protected FindCircularEdgeOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected FindCircularEdgeOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      direction = SpokeDirection.fromValue(backing.getInt(0));
      showSearchArea = backing.getInt(4);
      showSearchLines = backing.getInt(8);
      showEdgesFound = backing.getInt(12);
      showResult = backing.getInt(16);
      searchAreaColor.read();
      searchLinesColor.read();
      searchEdgesColor.read();
      resultColor.read();
      long overlayGroupName_addr = getPointer(backing, 36);
      if (overlayGroupName_addr == 0)
        overlayGroupName = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          overlayGroupName = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName = "";
        }
      }

      edgeOptions.read();
    }

    public void write() {
      if (direction != null)
        backing.putInt(0, direction.getValue());
      backing.putInt(4, showSearchArea);
      backing.putInt(8, showSearchLines);
      backing.putInt(12, showEdgesFound);
      backing.putInt(16, showResult);
      searchAreaColor.write();
      searchLinesColor.write();
      searchEdgesColor.write();
      resultColor.write();
      if (overlayGroupName != null) {
        byte[] overlayGroupName_bytes;
        try {
          overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName_bytes = new byte[0];
        }
        overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length + 1);
        putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length)
            .put(overlayGroupName_bytes.length, (byte) 0);
      }
      putPointer(backing, 36, overlayGroupName == null ? 0
          : getByteBufferAddress(overlayGroupName_buf));
      edgeOptions.write();
    }

    public int size() {
      return 64;
    }
  }

  public static class FindConcentricEdgeOptions extends DisposedStruct {
    public ConcentricRakeDirection direction; // Specifies the Concentric Rake
                                              // direction.
    public int showSearchArea; // If TRUE, the function overlays the search area
                               // on the image.
    public int showSearchLines; // If TRUE, the function overlays the search
                                // lines used to locate the edges on the image.
    public int showEdgesFound; // If TRUE, the function overlays the locations
                               // of the edges found on the image.
    public int showResult; // If TRUE, the function overlays the hit lines to
                           // the object and the edge used to generate the hit
                           // line on the result image.
    public RGBValue searchAreaColor; // Specifies the RGB color value to use to
                                     // overlay the search area.
    public RGBValue searchLinesColor; // Specifies the RGB color value to use to
                                      // overlay the search lines.
    public RGBValue searchEdgesColor; // Specifies the RGB color value to use to
                                      // overlay the search edges.
    public RGBValue resultColor; // Specifies the RGB color value to use to
                                 // overlay the results.
    public String overlayGroupName; // Specifies the overlay group name to
                                    // assign to the overlays.
    public EdgeOptions2 edgeOptions; // Specifies the edge detection options
                                     // along a single search line.
    private ByteBuffer overlayGroupName_buf;

    private void init() {
      searchAreaColor = new RGBValue(backing, 20);
      searchLinesColor = new RGBValue(backing, 24);
      searchEdgesColor = new RGBValue(backing, 28);
      resultColor = new RGBValue(backing, 32);
      edgeOptions = new EdgeOptions2(backing, 40);
    }

    public FindConcentricEdgeOptions() {
      super(64);
      init();
    }

    public FindConcentricEdgeOptions(ConcentricRakeDirection direction, int showSearchArea,
        int showSearchLines, int showEdgesFound, int showResult, RGBValue searchAreaColor,
        RGBValue searchLinesColor, RGBValue searchEdgesColor, RGBValue resultColor,
        String overlayGroupName, EdgeOptions2 edgeOptions) {
      super(64);
      this.direction = direction;
      this.showSearchArea = showSearchArea;
      this.showSearchLines = showSearchLines;
      this.showEdgesFound = showEdgesFound;
      this.showResult = showResult;
      this.searchAreaColor = searchAreaColor;
      this.searchLinesColor = searchLinesColor;
      this.searchEdgesColor = searchEdgesColor;
      this.resultColor = resultColor;
      this.overlayGroupName = overlayGroupName;
      this.edgeOptions = edgeOptions;
    }

    protected FindConcentricEdgeOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected FindConcentricEdgeOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      direction = ConcentricRakeDirection.fromValue(backing.getInt(0));
      showSearchArea = backing.getInt(4);
      showSearchLines = backing.getInt(8);
      showEdgesFound = backing.getInt(12);
      showResult = backing.getInt(16);
      searchAreaColor.read();
      searchLinesColor.read();
      searchEdgesColor.read();
      resultColor.read();
      long overlayGroupName_addr = getPointer(backing, 36);
      if (overlayGroupName_addr == 0)
        overlayGroupName = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          overlayGroupName = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName = "";
        }
      }

      edgeOptions.read();
    }

    public void write() {
      if (direction != null)
        backing.putInt(0, direction.getValue());
      backing.putInt(4, showSearchArea);
      backing.putInt(8, showSearchLines);
      backing.putInt(12, showEdgesFound);
      backing.putInt(16, showResult);
      searchAreaColor.write();
      searchLinesColor.write();
      searchEdgesColor.write();
      resultColor.write();
      if (overlayGroupName != null) {
        byte[] overlayGroupName_bytes;
        try {
          overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName_bytes = new byte[0];
        }
        overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length + 1);
        putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length)
            .put(overlayGroupName_bytes.length, (byte) 0);
      }
      putPointer(backing, 36, overlayGroupName == null ? 0
          : getByteBufferAddress(overlayGroupName_buf));
      edgeOptions.write();
    }

    public int size() {
      return 64;
    }
  }

  public static class ConcentricEdgeFitOptions extends DisposedStruct {
    public int maxRadius; // Specifies the acceptable distance, in pixels, that
                          // a point determined to belong to the circle can be
                          // from the perimeter of the circle.
    public double stepSize; // The sampling factor that determines the gap
                            // between the rake lines.
    public RakeProcessType processType; // Method used to process the data
                                        // extracted for edge detection.

    private void init() {

    }

    public ConcentricEdgeFitOptions() {
      super(24);
      init();
    }

    public ConcentricEdgeFitOptions(int maxRadius, double stepSize, RakeProcessType processType) {
      super(24);
      this.maxRadius = maxRadius;
      this.stepSize = stepSize;
      this.processType = processType;
    }

    protected ConcentricEdgeFitOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected ConcentricEdgeFitOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      maxRadius = backing.getInt(0);
      stepSize = backing.getDouble(8);
      processType = RakeProcessType.fromValue(backing.getInt(16));
    }

    public void write() {
      backing.putInt(0, maxRadius);
      backing.putDouble(8, stepSize);
      if (processType != null)
        backing.putInt(16, processType.getValue());
    }

    public int size() {
      return 24;
    }
  }

  public static class FindConcentricEdgeReport extends DisposedStruct {
    public PointFloat startPt; // Pixel Coordinates for starting point of the
                               // edge.
    public PointFloat endPt; // Pixel Coordinates for end point of the edge.
    public PointFloat startPtCalibrated; // Real world Coordinates for starting
                                         // point of the edge.
    public PointFloat endPtCalibrated; // Real world Coordinates for end point
                                       // of the edge.
    public double angle; // Angle of the edge found.
    public double angleCalibrated; // Calibrated angle of the edge found.
    public double straightness; // The straightness value of the detected
                                // straight edge.
    public double avgStrength; // Average strength of the egde found.
    public double avgSNR; // Average SNR(Signal to Noise Ratio) for the edge
                          // found.
    public int lineFound; // If the edge is found or not.

    private void init() {
      startPt = new PointFloat(backing, 0);
      endPt = new PointFloat(backing, 8);
      startPtCalibrated = new PointFloat(backing, 16);
      endPtCalibrated = new PointFloat(backing, 24);
    }

    public FindConcentricEdgeReport() {
      super(80);
      init();
    }

    public FindConcentricEdgeReport(PointFloat startPt, PointFloat endPt,
        PointFloat startPtCalibrated, PointFloat endPtCalibrated, double angle,
        double angleCalibrated, double straightness, double avgStrength, double avgSNR,
        int lineFound) {
      super(80);
      this.startPt = startPt;
      this.endPt = endPt;
      this.startPtCalibrated = startPtCalibrated;
      this.endPtCalibrated = endPtCalibrated;
      this.angle = angle;
      this.angleCalibrated = angleCalibrated;
      this.straightness = straightness;
      this.avgStrength = avgStrength;
      this.avgSNR = avgSNR;
      this.lineFound = lineFound;
    }

    protected FindConcentricEdgeReport(ByteBuffer backing, int offset) {
      super(backing, offset, 80);
      init();
    }

    protected FindConcentricEdgeReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 80);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 80);
    }

    public void read() {
      startPt.read();
      endPt.read();
      startPtCalibrated.read();
      endPtCalibrated.read();
      angle = backing.getDouble(32);
      angleCalibrated = backing.getDouble(40);
      straightness = backing.getDouble(48);
      avgStrength = backing.getDouble(56);
      avgSNR = backing.getDouble(64);
      lineFound = backing.getInt(72);
    }

    public void write() {
      startPt.write();
      endPt.write();
      startPtCalibrated.write();
      endPtCalibrated.write();
      backing.putDouble(32, angle);
      backing.putDouble(40, angleCalibrated);
      backing.putDouble(48, straightness);
      backing.putDouble(56, avgStrength);
      backing.putDouble(64, avgSNR);
      backing.putInt(72, lineFound);
    }

    public int size() {
      return 80;
    }
  }

  public static class FindCircularEdgeReport extends DisposedStruct {
    public PointFloat centerCalibrated; // Real world Coordinates of the Center.
    public double radiusCalibrated; // Real world radius of the Circular Edge
                                    // found.
    public PointFloat center; // Pixel Coordinates of the Center.
    public double radius; // Radius in pixels of the Circular Edge found.
    public double roundness; // The roundness of the calculated circular edge.
    public double avgStrength; // Average strength of the egde found.
    public double avgSNR; // Average SNR(Signal to Noise Ratio) for the edge
                          // found.
    public int circleFound; // If the circlular edge is found or not.

    private void init() {
      centerCalibrated = new PointFloat(backing, 0);
      center = new PointFloat(backing, 16);
    }

    public FindCircularEdgeReport() {
      super(64);
      init();
    }

    public FindCircularEdgeReport(PointFloat centerCalibrated, double radiusCalibrated,
        PointFloat center, double radius, double roundness, double avgStrength, double avgSNR,
        int circleFound) {
      super(64);
      this.centerCalibrated = centerCalibrated;
      this.radiusCalibrated = radiusCalibrated;
      this.center = center;
      this.radius = radius;
      this.roundness = roundness;
      this.avgStrength = avgStrength;
      this.avgSNR = avgSNR;
      this.circleFound = circleFound;
    }

    protected FindCircularEdgeReport(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected FindCircularEdgeReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      centerCalibrated.read();
      radiusCalibrated = backing.getDouble(8);
      center.read();
      radius = backing.getDouble(24);
      roundness = backing.getDouble(32);
      avgStrength = backing.getDouble(40);
      avgSNR = backing.getDouble(48);
      circleFound = backing.getInt(56);
    }

    public void write() {
      centerCalibrated.write();
      backing.putDouble(8, radiusCalibrated);
      center.write();
      backing.putDouble(24, radius);
      backing.putDouble(32, roundness);
      backing.putDouble(40, avgStrength);
      backing.putDouble(48, avgSNR);
      backing.putInt(56, circleFound);
    }

    public int size() {
      return 64;
    }
  }

  public static class WindowSize extends DisposedStruct {
    public int x; // Window lenght on X direction.
    public int y; // Window lenght on Y direction.
    public int stepSize; // Distance between windows.

    private void init() {

    }

    public WindowSize() {
      super(12);
      init();
    }

    public WindowSize(int x, int y, int stepSize) {
      super(12);
      this.x = x;
      this.y = y;
      this.stepSize = stepSize;
    }

    protected WindowSize(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected WindowSize(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      x = backing.getInt(0);
      y = backing.getInt(4);
      stepSize = backing.getInt(8);
    }

    public void write() {
      backing.putInt(0, x);
      backing.putInt(4, y);
      backing.putInt(8, stepSize);
    }

    public int size() {
      return 12;
    }
  }

  public static class DisplacementVector extends DisposedStruct {
    public int x; // length on X direction.
    public int y; // length on Y direction.

    private void init() {

    }

    public DisplacementVector() {
      super(8);
      init();
    }

    public DisplacementVector(int x, int y) {
      super(8);
      this.x = x;
      this.y = y;
    }

    protected DisplacementVector(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected DisplacementVector(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      x = backing.getInt(0);
      y = backing.getInt(4);
    }

    public void write() {
      backing.putInt(0, x);
      backing.putInt(4, y);
    }

    public int size() {
      return 8;
    }
  }

  public static class WaveletOptions extends DisposedStruct {
    public WaveletType typeOfWavelet; // Type of wavelet(db, bior.
    public float minEnergy; // Minimum Energy in the bands to consider for
                            // texture defect detection.

    private void init() {

    }

    public WaveletOptions() {
      super(8);
      init();
    }

    public WaveletOptions(WaveletType typeOfWavelet, double minEnergy) {
      super(8);
      this.typeOfWavelet = typeOfWavelet;
      this.minEnergy = (float) minEnergy;
    }

    protected WaveletOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected WaveletOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      typeOfWavelet = WaveletType.fromValue(backing.getInt(0));
      minEnergy = backing.getFloat(4);
    }

    public void write() {
      if (typeOfWavelet != null)
        backing.putInt(0, typeOfWavelet.getValue());
      backing.putFloat(4, minEnergy);
    }

    public int size() {
      return 8;
    }
  }

  public static class CooccurrenceOptions extends DisposedStruct {
    public int level; // Level/size of matrix.
    public DisplacementVector displacement; // Displacemnet between pixels to
                                            // accumulate the matrix.

    private void init() {
      displacement = new DisplacementVector(backing, 4);
    }

    public CooccurrenceOptions() {
      super(12);
      init();
    }

    public CooccurrenceOptions(int level, DisplacementVector displacement) {
      super(12);
      this.level = level;
      this.displacement = displacement;
    }

    protected CooccurrenceOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected CooccurrenceOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      level = backing.getInt(0);
      displacement.read();
    }

    public void write() {
      backing.putInt(0, level);
      displacement.write();
    }

    public int size() {
      return 12;
    }
  }

  public static class ParticleClassifierLocalThresholdOptions extends DisposedStruct {
    public LocalThresholdMethod method; // Specifies the local thresholding
                                        // method the function uses.
    public ParticleType particleType; // Specifies what kind of particles to
                                      // look for.
    public int windowWidth; // The width of the rectangular window around the
                            // pixel on which the function performs the local
                            // threshold.
    public int windowHeight; // The height of the rectangular window around the
                             // pixel on which the function performs the local
                             // threshold.
    public double deviationWeight; // Specifies the k constant used in the
                                   // Niblack local thresholding algorithm,
                                   // which determines the weight applied to the
                                   // variance calculation.

    private void init() {

    }

    public ParticleClassifierLocalThresholdOptions() {
      super(24);
      init();
    }

    public ParticleClassifierLocalThresholdOptions(LocalThresholdMethod method,
        ParticleType particleType, int windowWidth, int windowHeight, double deviationWeight) {
      super(24);
      this.method = method;
      this.particleType = particleType;
      this.windowWidth = windowWidth;
      this.windowHeight = windowHeight;
      this.deviationWeight = deviationWeight;
    }

    protected ParticleClassifierLocalThresholdOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected ParticleClassifierLocalThresholdOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      method = LocalThresholdMethod.fromValue(backing.getInt(0));
      particleType = ParticleType.fromValue(backing.getInt(4));
      windowWidth = backing.getInt(8);
      windowHeight = backing.getInt(12);
      deviationWeight = backing.getDouble(16);
    }

    public void write() {
      if (method != null)
        backing.putInt(0, method.getValue());
      if (particleType != null)
        backing.putInt(4, particleType.getValue());
      backing.putInt(8, windowWidth);
      backing.putInt(12, windowHeight);
      backing.putDouble(16, deviationWeight);
    }

    public int size() {
      return 24;
    }
  }

  public static class RangeFloat extends DisposedStruct {
    public float minValue; // The minimum value of the range.
    public float maxValue; // The maximum value of the range.

    private void init() {

    }

    public RangeFloat() {
      super(8);
      init();
    }

    public RangeFloat(double minValue, double maxValue) {
      super(8);
      this.minValue = (float) minValue;
      this.maxValue = (float) maxValue;
    }

    protected RangeFloat(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected RangeFloat(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      minValue = backing.getFloat(0);
      maxValue = backing.getFloat(4);
    }

    public void write() {
      backing.putFloat(0, minValue);
      backing.putFloat(4, maxValue);
    }

    public int size() {
      return 8;
    }
  }

  public static class ParticleClassifierAutoThresholdOptions extends DisposedStruct {
    public ThresholdMethod method; // The method for binary thresholding, which
                                   // specifies how to calculate the classes.
    public ParticleType particleType; // Specifies what kind of particles to
                                      // look for.
    public RangeFloat limits; // The limits on the automatic threshold range.

    private void init() {
      limits = new RangeFloat(backing, 8);
    }

    public ParticleClassifierAutoThresholdOptions() {
      super(16);
      init();
    }

    public ParticleClassifierAutoThresholdOptions(ThresholdMethod method,
        ParticleType particleType, RangeFloat limits) {
      super(16);
      this.method = method;
      this.particleType = particleType;
      this.limits = limits;
    }

    protected ParticleClassifierAutoThresholdOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ParticleClassifierAutoThresholdOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      method = ThresholdMethod.fromValue(backing.getInt(0));
      particleType = ParticleType.fromValue(backing.getInt(4));
      limits.read();
    }

    public void write() {
      if (method != null)
        backing.putInt(0, method.getValue());
      if (particleType != null)
        backing.putInt(4, particleType.getValue());
      limits.write();
    }

    public int size() {
      return 16;
    }
  }

  public static class ParticleClassifierPreprocessingOptions2 extends DisposedStruct {
    public ParticleClassifierThresholdType thresholdType; // The type of
                                                          // threshold to
                                                          // perform on the
                                                          // image.
    public RangeFloat manualThresholdRange; // The range of pixels to keep if
                                            // manually thresholding the image.
    public ParticleClassifierAutoThresholdOptions autoThresholdOptions; // The
                                                                        // options
                                                                        // used
                                                                        // to
                                                                        // auto
                                                                        // threshold
                                                                        // the
                                                                        // image.
    public ParticleClassifierLocalThresholdOptions localThresholdOptions; // The
                                                                          // options
                                                                          // used
                                                                          // to
                                                                          // local
                                                                          // threshold
                                                                          // the
                                                                          // image.
    public int rejectBorder; // Set this element to TRUE to reject border
                             // particles.
    public int numErosions; // The number of erosions to perform.

    private void init() {
      manualThresholdRange = new RangeFloat(backing, 4);
      autoThresholdOptions = new ParticleClassifierAutoThresholdOptions(backing, 12);
      localThresholdOptions = new ParticleClassifierLocalThresholdOptions(backing, 32);
    }

    public ParticleClassifierPreprocessingOptions2() {
      super(64);
      init();
    }

    public ParticleClassifierPreprocessingOptions2(ParticleClassifierThresholdType thresholdType,
        RangeFloat manualThresholdRange,
        ParticleClassifierAutoThresholdOptions autoThresholdOptions,
        ParticleClassifierLocalThresholdOptions localThresholdOptions, int rejectBorder,
        int numErosions) {
      super(64);
      this.thresholdType = thresholdType;
      this.manualThresholdRange = manualThresholdRange;
      this.autoThresholdOptions = autoThresholdOptions;
      this.localThresholdOptions = localThresholdOptions;
      this.rejectBorder = rejectBorder;
      this.numErosions = numErosions;
    }

    protected ParticleClassifierPreprocessingOptions2(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected ParticleClassifierPreprocessingOptions2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      thresholdType = ParticleClassifierThresholdType.fromValue(backing.getInt(0));
      manualThresholdRange.read();
      autoThresholdOptions.read();
      localThresholdOptions.read();
      rejectBorder = backing.getInt(56);
      numErosions = backing.getInt(60);
    }

    public void write() {
      if (thresholdType != null)
        backing.putInt(0, thresholdType.getValue());
      manualThresholdRange.write();
      autoThresholdOptions.write();
      localThresholdOptions.write();
      backing.putInt(56, rejectBorder);
      backing.putInt(60, numErosions);
    }

    public int size() {
      return 64;
    }
  }

  public static class MeasureParticlesReport extends DisposedStruct {
    public int numParticles; // The number of particles on which measurements
                             // were taken.
    public int numMeasurements; // The number of measurements taken.

    private void init() {

    }

    public MeasureParticlesReport() {
      super(16);
      init();
    }

    public MeasureParticlesReport(int numParticles, int numMeasurements) {
      super(16);
      this.numParticles = numParticles;
      this.numMeasurements = numMeasurements;
    }

    protected MeasureParticlesReport(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected MeasureParticlesReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      numParticles = backing.getInt(8);
      numMeasurements = backing.getInt(12);
    }

    public void write() {
      backing.putInt(8, numParticles);
      backing.putInt(12, numMeasurements);
    }

    public int size() {
      return 16;
    }
  }

  public static class GeometricPatternMatch3 extends DisposedStruct {
    public PointFloat position; // The location of the origin of the template in
                                // the match.
    public float rotation; // The rotation of the match relative to the template
                           // image, in degrees.
    public float scale; // The size of the match relative to the size of the
                        // template image, expressed as a percentage.
    public float score; // The accuracy of the match.
    public PointFloat[] corner; // An array of four points describing the
                                // rectangle surrounding the template image.
    public int inverse; // This element is TRUE if the match is an inverse of
                        // the template image.
    public float occlusion; // The percentage of the match that is occluded.
    public float templateMatchCurveScore; // The accuracy of the match obtained
                                          // by comparing the template curves to
                                          // the curves in the match region.
    public float matchTemplateCurveScore; // The accuracy of the match obtained
                                          // by comparing the curves in the
                                          // match region to the template
                                          // curves.
    public float correlationScore; // The accuracy of the match obtained by
                                   // comparing the template image to the match
                                   // region using a correlation metric that
                                   // compares the two regions as a function of
                                   // their pixel values.
    public PointFloat calibratedPosition; // The location of the origin of the
                                          // template in the match.
    public float calibratedRotation; // The rotation of the match relative to
                                     // the template image, in degrees.
    public PointFloat[] calibratedCorner; // An array of four points describing
                                          // the rectangle surrounding the
                                          // template image.

    private void init() {
      position = new PointFloat(backing, 0);
      corner = new PointFloat[4];

      for (int i = 0, off = 20; i < 4; i++, off += 8)
        corner[i] = new PointFloat(backing, off);
      calibratedPosition = new PointFloat(backing, 72);
      calibratedCorner = new PointFloat[4];

      for (int i = 0, off = 84; i < 4; i++, off += 8)
        calibratedCorner[i] = new PointFloat(backing, off);
    }

    public GeometricPatternMatch3() {
      super(116);
      init();
    }

    public GeometricPatternMatch3(PointFloat position, double rotation, double scale, double score,
        PointFloat[] corner, int inverse, double occlusion, double templateMatchCurveScore,
        double matchTemplateCurveScore, double correlationScore, PointFloat calibratedPosition,
        double calibratedRotation, PointFloat[] calibratedCorner) {
      super(116);
      this.position = position;
      this.rotation = (float) rotation;
      this.scale = (float) scale;
      this.score = (float) score;
      this.corner = corner;
      this.inverse = inverse;
      this.occlusion = (float) occlusion;
      this.templateMatchCurveScore = (float) templateMatchCurveScore;
      this.matchTemplateCurveScore = (float) matchTemplateCurveScore;
      this.correlationScore = (float) correlationScore;
      this.calibratedPosition = calibratedPosition;
      this.calibratedRotation = (float) calibratedRotation;
      this.calibratedCorner = calibratedCorner;
    }

    protected GeometricPatternMatch3(ByteBuffer backing, int offset) {
      super(backing, offset, 116);
      init();
    }

    protected GeometricPatternMatch3(long nativeObj, boolean owned) {
      super(nativeObj, owned, 116);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 116);
    }

    public void read() {
      position.read();
      rotation = backing.getFloat(8);
      scale = backing.getFloat(12);
      score = backing.getFloat(16);
      for (PointFloat it : corner) {
        it.read();
      }
      inverse = backing.getInt(52);
      occlusion = backing.getFloat(56);
      templateMatchCurveScore = backing.getFloat(60);
      matchTemplateCurveScore = backing.getFloat(64);
      correlationScore = backing.getFloat(68);
      calibratedPosition.read();
      calibratedRotation = backing.getFloat(80);
      for (PointFloat it : calibratedCorner) {
        it.read();
      }
    }

    public void write() {
      position.write();
      backing.putFloat(8, rotation);
      backing.putFloat(12, scale);
      backing.putFloat(16, score);
      for (PointFloat it : corner) {
        it.write();
      }
      backing.putInt(52, inverse);
      backing.putFloat(56, occlusion);
      backing.putFloat(60, templateMatchCurveScore);
      backing.putFloat(64, matchTemplateCurveScore);
      backing.putFloat(68, correlationScore);
      calibratedPosition.write();
      backing.putFloat(80, calibratedRotation);
      for (PointFloat it : calibratedCorner) {
        it.write();
      }
    }

    public int size() {
      return 116;
    }
  }

  public static class MatchGeometricPatternAdvancedOptions3 extends DisposedStruct {
    public int subpixelIterations; // Specifies the maximum number of
                                   // incremental improvements used to refine
                                   // matches with subpixel information.
    public double subpixelTolerance; // Specifies the maximum amount of change,
                                     // in pixels, between consecutive
                                     // incremental improvements in the match
                                     // position before the function stops
                                     // refining the match position.
    public int initialMatchListLength; // Specifies the maximum size of the
                                       // match list.
    public int targetTemplateCurveScore; // Set this element to TRUE to specify
                                         // that the function should calculate
                                         // the match curve to template curve
                                         // score and return it for each match
                                         // result.
    public int correlationScore; // Set this element to TRUE to specify that the
                                 // function should calculate the correlation
                                 // score and return it for each match result.
    public double minMatchSeparationDistance; // Specifies the minimum
                                              // separation distance, in pixels,
                                              // between the origins of two
                                              // matches that have unique
                                              // positions.
    public double minMatchSeparationAngle; // Specifies the minimum angular
                                           // difference, in degrees, between
                                           // two matches that have unique
                                           // angles.
    public double minMatchSeparationScale; // Specifies the minimum difference
                                           // in scale, expressed as a
                                           // percentage, between two matches
                                           // that have unique scales.
    public double maxMatchOverlap; // Specifies the maximum amount of overlap,
                                   // expressed as a percentage, allowed between
                                   // the bounding rectangles of two unique
                                   // matches.
    public int coarseResult; // Specifies whether you want the function to spend
                             // less time accurately estimating the location of
                             // a match.
    public int enableCalibrationSupport; // Set this element to TRUE to specify
                                         // the algorithm treat the inspection
                                         // image as a calibrated image.
    public ContrastMode enableContrastReversal; // Use this element to specify
                                                // the contrast of the matches
                                                // to search for in the image.
    public GeometricMatchingSearchStrategy matchStrategy; // Specifies the
                                                          // aggressiveness of
                                                          // the search
                                                          // strategy.
    public int refineMatchFactor; // Specifies the factor that is applied to the
                                  // number of matches requested by the user to
                                  // determine the number of matches that are
                                  // refined at the initial matching stage.
    public int subpixelMatchFactor; // Specifies the factor that is applied to
                                    // the number of matches requested by the
                                    // user to determine the number of matches
                                    // that are evaluated at the final subpixel
                                    // matching stage.

    private void init() {

    }

    public MatchGeometricPatternAdvancedOptions3() {
      super(88);
      init();
    }

    public MatchGeometricPatternAdvancedOptions3(int subpixelIterations, double subpixelTolerance,
        int initialMatchListLength, int targetTemplateCurveScore, int correlationScore,
        double minMatchSeparationDistance, double minMatchSeparationAngle,
        double minMatchSeparationScale, double maxMatchOverlap, int coarseResult,
        int enableCalibrationSupport, ContrastMode enableContrastReversal,
        GeometricMatchingSearchStrategy matchStrategy, int refineMatchFactor,
        int subpixelMatchFactor) {
      super(88);
      this.subpixelIterations = subpixelIterations;
      this.subpixelTolerance = subpixelTolerance;
      this.initialMatchListLength = initialMatchListLength;
      this.targetTemplateCurveScore = targetTemplateCurveScore;
      this.correlationScore = correlationScore;
      this.minMatchSeparationDistance = minMatchSeparationDistance;
      this.minMatchSeparationAngle = minMatchSeparationAngle;
      this.minMatchSeparationScale = minMatchSeparationScale;
      this.maxMatchOverlap = maxMatchOverlap;
      this.coarseResult = coarseResult;
      this.enableCalibrationSupport = enableCalibrationSupport;
      this.enableContrastReversal = enableContrastReversal;
      this.matchStrategy = matchStrategy;
      this.refineMatchFactor = refineMatchFactor;
      this.subpixelMatchFactor = subpixelMatchFactor;
    }

    protected MatchGeometricPatternAdvancedOptions3(ByteBuffer backing, int offset) {
      super(backing, offset, 88);
      init();
    }

    protected MatchGeometricPatternAdvancedOptions3(long nativeObj, boolean owned) {
      super(nativeObj, owned, 88);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 88);
    }

    public void read() {
      subpixelIterations = backing.getInt(0);
      subpixelTolerance = backing.getDouble(8);
      initialMatchListLength = backing.getInt(16);
      targetTemplateCurveScore = backing.getInt(20);
      correlationScore = backing.getInt(24);
      minMatchSeparationDistance = backing.getDouble(32);
      minMatchSeparationAngle = backing.getDouble(40);
      minMatchSeparationScale = backing.getDouble(48);
      maxMatchOverlap = backing.getDouble(56);
      coarseResult = backing.getInt(64);
      enableCalibrationSupport = backing.getInt(68);
      enableContrastReversal = ContrastMode.fromValue(backing.getInt(72));
      matchStrategy = GeometricMatchingSearchStrategy.fromValue(backing.getInt(76));
      refineMatchFactor = backing.getInt(80);
      subpixelMatchFactor = backing.getInt(84);
    }

    public void write() {
      backing.putInt(0, subpixelIterations);
      backing.putDouble(8, subpixelTolerance);
      backing.putInt(16, initialMatchListLength);
      backing.putInt(20, targetTemplateCurveScore);
      backing.putInt(24, correlationScore);
      backing.putDouble(32, minMatchSeparationDistance);
      backing.putDouble(40, minMatchSeparationAngle);
      backing.putDouble(48, minMatchSeparationScale);
      backing.putDouble(56, maxMatchOverlap);
      backing.putInt(64, coarseResult);
      backing.putInt(68, enableCalibrationSupport);
      if (enableContrastReversal != null)
        backing.putInt(72, enableContrastReversal.getValue());
      if (matchStrategy != null)
        backing.putInt(76, matchStrategy.getValue());
      backing.putInt(80, refineMatchFactor);
      backing.putInt(84, subpixelMatchFactor);
    }

    public int size() {
      return 88;
    }
  }

  public static class ColorOptions extends DisposedStruct {
    public ColorClassificationResolution colorClassificationResolution; // Specifies
                                                                        // the
                                                                        // color
                                                                        // resolution
                                                                        // of
                                                                        // the
                                                                        // classifier.
    public int useLuminance; // Specifies if the luminance band is going to be
                             // used in the feature vector.
    public ColorMode colorMode; // Specifies the color mode of the classifier.

    private void init() {

    }

    public ColorOptions() {
      super(12);
      init();
    }

    public ColorOptions(ColorClassificationResolution colorClassificationResolution,
        int useLuminance, ColorMode colorMode) {
      super(12);
      this.colorClassificationResolution = colorClassificationResolution;
      this.useLuminance = useLuminance;
      this.colorMode = colorMode;
    }

    protected ColorOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected ColorOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      colorClassificationResolution = ColorClassificationResolution.fromValue(backing.getInt(0));
      useLuminance = backing.getInt(4);
      colorMode = ColorMode.fromValue(backing.getInt(8));
    }

    public void write() {
      if (colorClassificationResolution != null)
        backing.putInt(0, colorClassificationResolution.getValue());
      backing.putInt(4, useLuminance);
      if (colorMode != null)
        backing.putInt(8, colorMode.getValue());
    }

    public int size() {
      return 12;
    }
  }

  public static class SampleScore extends DisposedStruct {
    public String className; // The name of the class.
    public float distance; // The distance from the item to this class.
    public int index; // index of this sample.
    private ByteBuffer className_buf;

    private void init() {

    }

    public SampleScore() {
      super(12);
      init();
    }

    public SampleScore(String className, double distance, int index) {
      super(12);
      this.className = className;
      this.distance = (float) distance;
      this.index = index;
    }

    protected SampleScore(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected SampleScore(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      long className_addr = getPointer(backing, 0);
      if (className_addr == 0)
        className = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(className_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          className = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          className = "";
        }
      }

      distance = backing.getFloat(4);
      index = backing.getInt(8);
    }

    public void write() {
      if (className != null) {
        byte[] className_bytes;
        try {
          className_bytes = className.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          className_bytes = new byte[0];
        }
        className_buf = ByteBuffer.allocateDirect(className_bytes.length + 1);
        putBytes(className_buf, className_bytes, 0, className_bytes.length).put(
            className_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, className == null ? 0 : getByteBufferAddress(className_buf));
      backing.putFloat(4, distance);
      backing.putInt(8, index);
    }

    public int size() {
      return 12;
    }
  }

  public static class ClassifierReportAdvanced extends DisposedStruct {
    public String bestClassName; // The name of the best class for the sample.
    public float classificationScore; // The similarity of the sample and the
                                      // two closest classes in the classifier.
    public float identificationScore; // The similarity of the sample and the
                                      // assigned class.
    public ClassScore[] allScores; // All classes and their scores.
    public SampleScore[] sampleScores; // All samples and their scores.
    private ByteBuffer bestClassName_buf;
    private ByteBuffer allScores_buf;
    private ByteBuffer sampleScores_buf;

    private void init() {
      allScores = new ClassScore[0];
      sampleScores = new SampleScore[0];
    }

    public ClassifierReportAdvanced() {
      super(28);
      init();
    }

    public ClassifierReportAdvanced(String bestClassName, double classificationScore,
        double identificationScore, ClassScore[] allScores, SampleScore[] sampleScores) {
      super(28);
      this.bestClassName = bestClassName;
      this.classificationScore = (float) classificationScore;
      this.identificationScore = (float) identificationScore;
      this.allScores = allScores;
      this.sampleScores = sampleScores;
    }

    protected ClassifierReportAdvanced(ByteBuffer backing, int offset) {
      super(backing, offset, 28);
      init();
    }

    protected ClassifierReportAdvanced(long nativeObj, boolean owned) {
      super(nativeObj, owned, 28);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 28);
    }

    public void read() {
      long bestClassName_addr = getPointer(backing, 0);
      if (bestClassName_addr == 0)
        bestClassName = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(bestClassName_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          bestClassName = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          bestClassName = "";
        }
      }

      classificationScore = backing.getFloat(4);
      identificationScore = backing.getFloat(8);
      int allScores_allScoresSize = backing.getInt(16);
      long allScores_addr = getPointer(backing, 12);
      allScores = new ClassScore[allScores_allScoresSize];
      if (allScores_allScoresSize > 0 && allScores_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(allScores_addr, allScores_allScoresSize * 8);
        for (int i = 0, off = 0; i < allScores_allScoresSize; i++, off += 8) {
          allScores[i] = new ClassScore(bb, off);
          allScores[i].read();
        }
      }
      int sampleScores_sampleScoresSize = backing.getInt(24);
      long sampleScores_addr = getPointer(backing, 20);
      sampleScores = new SampleScore[sampleScores_sampleScoresSize];
      if (sampleScores_sampleScoresSize > 0 && sampleScores_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(sampleScores_addr, sampleScores_sampleScoresSize * 12);
        for (int i = 0, off = 0; i < sampleScores_sampleScoresSize; i++, off += 12) {
          sampleScores[i] = new SampleScore(bb, off);
          sampleScores[i].read();
        }
      }
    }

    public void write() {
      if (bestClassName != null) {
        byte[] bestClassName_bytes;
        try {
          bestClassName_bytes = bestClassName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bestClassName_bytes = new byte[0];
        }
        bestClassName_buf = ByteBuffer.allocateDirect(bestClassName_bytes.length + 1);
        putBytes(bestClassName_buf, bestClassName_bytes, 0, bestClassName_bytes.length).put(
            bestClassName_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, bestClassName == null ? 0 : getByteBufferAddress(bestClassName_buf));
      backing.putFloat(4, classificationScore);
      backing.putFloat(8, identificationScore);
      allScores_buf =
          ByteBuffer.allocateDirect(allScores.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < allScores.length; i++, off += 8) {
        allScores[i].setBuffer(allScores_buf, off);
        allScores[i].write();
      }
      backing.putInt(16, allScores.length);
      putPointer(backing, 12, allScores_buf);
      sampleScores_buf =
          ByteBuffer.allocateDirect(sampleScores.length * 12).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < sampleScores.length; i++, off += 12) {
        sampleScores[i].setBuffer(sampleScores_buf, off);
        sampleScores[i].write();
      }
      backing.putInt(24, sampleScores.length);
      putPointer(backing, 20, sampleScores_buf);
    }

    public int size() {
      return 28;
    }
  }

  public static class LearnGeometricPatternAdvancedOptions2 extends DisposedStruct {
    public double minScaleFactor; // Specifies the minimum scale factor that the
                                  // template is learned for.
    public double maxScaleFactor; // Specifies the maximum scale factor the
                                  // template is learned for.
    public double minRotationAngleValue; // Specifies the minimum rotation angle
                                         // the template is learned for.
    public double maxRotationAngleValue; // Specifies the maximum rotation angle
                                         // the template is learned for.
    public int imageSamplingFactor; // Specifies the factor that is used to
                                    // subsample the template and the image for
                                    // the initial matching phase.

    private void init() {

    }

    public LearnGeometricPatternAdvancedOptions2() {
      super(40);
      init();
    }

    public LearnGeometricPatternAdvancedOptions2(double minScaleFactor, double maxScaleFactor,
        double minRotationAngleValue, double maxRotationAngleValue, int imageSamplingFactor) {
      super(40);
      this.minScaleFactor = minScaleFactor;
      this.maxScaleFactor = maxScaleFactor;
      this.minRotationAngleValue = minRotationAngleValue;
      this.maxRotationAngleValue = maxRotationAngleValue;
      this.imageSamplingFactor = imageSamplingFactor;
    }

    protected LearnGeometricPatternAdvancedOptions2(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected LearnGeometricPatternAdvancedOptions2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      minScaleFactor = backing.getDouble(0);
      maxScaleFactor = backing.getDouble(8);
      minRotationAngleValue = backing.getDouble(16);
      maxRotationAngleValue = backing.getDouble(24);
      imageSamplingFactor = backing.getInt(32);
    }

    public void write() {
      backing.putDouble(0, minScaleFactor);
      backing.putDouble(8, maxScaleFactor);
      backing.putDouble(16, minRotationAngleValue);
      backing.putDouble(24, maxRotationAngleValue);
      backing.putInt(32, imageSamplingFactor);
    }

    public int size() {
      return 40;
    }
  }

  public static class ParticleFilterOptions2 extends DisposedStruct {
    public int rejectMatches; // Set this parameter to TRUE to transfer only
                              // those particles that do not meet all the
                              // criteria.
    public int rejectBorder; // Set this element to TRUE to reject border
                             // particles.
    public int fillHoles; // Set this element to TRUE to fill holes in
                          // particles.
    public int connectivity8; // Set this parameter to TRUE to use
                              // connectivity-8 to determine whether particles
                              // are touching.

    private void init() {

    }

    public ParticleFilterOptions2() {
      super(16);
      init();
    }

    public ParticleFilterOptions2(int rejectMatches, int rejectBorder, int fillHoles,
        int connectivity8) {
      super(16);
      this.rejectMatches = rejectMatches;
      this.rejectBorder = rejectBorder;
      this.fillHoles = fillHoles;
      this.connectivity8 = connectivity8;
    }

    protected ParticleFilterOptions2(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ParticleFilterOptions2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      rejectMatches = backing.getInt(0);
      rejectBorder = backing.getInt(4);
      fillHoles = backing.getInt(8);
      connectivity8 = backing.getInt(12);
    }

    public void write() {
      backing.putInt(0, rejectMatches);
      backing.putInt(4, rejectBorder);
      backing.putInt(8, fillHoles);
      backing.putInt(12, connectivity8);
    }

    public int size() {
      return 16;
    }
  }

  public static class FindEdgeOptions2 extends DisposedStruct {
    public RakeDirection direction; // The direction to search in the ROI.
    public int showSearchArea; // If TRUE, the function overlays the search area
                               // on the image.
    public int showSearchLines; // If TRUE, the function overlays the search
                                // lines used to locate the edges on the image.
    public int showEdgesFound; // If TRUE, the function overlays the locations
                               // of the edges found on the image.
    public int showResult; // If TRUE, the function overlays the hit lines to
                           // the object and the edge used to generate the hit
                           // line on the result image.
    public RGBValue searchAreaColor; // Specifies the RGB color value to use to
                                     // overlay the search area.
    public RGBValue searchLinesColor; // Specifies the RGB color value to use to
                                      // overlay the search lines.
    public RGBValue searchEdgesColor; // Specifies the RGB color value to use to
                                      // overlay the search edges.
    public RGBValue resultColor; // Specifies the RGB color value to use to
                                 // overlay the results.
    public String overlayGroupName; // Specifies the overlay group name to
                                    // assign to the overlays.
    public EdgeOptions2 edgeOptions; // Specifies the edge detection options
                                     // along a single search line.
    private ByteBuffer overlayGroupName_buf;

    private void init() {
      searchAreaColor = new RGBValue(backing, 20);
      searchLinesColor = new RGBValue(backing, 24);
      searchEdgesColor = new RGBValue(backing, 28);
      resultColor = new RGBValue(backing, 32);
      edgeOptions = new EdgeOptions2(backing, 40);
    }

    public FindEdgeOptions2() {
      super(64);
      init();
    }

    public FindEdgeOptions2(RakeDirection direction, int showSearchArea, int showSearchLines,
        int showEdgesFound, int showResult, RGBValue searchAreaColor, RGBValue searchLinesColor,
        RGBValue searchEdgesColor, RGBValue resultColor, String overlayGroupName,
        EdgeOptions2 edgeOptions) {
      super(64);
      this.direction = direction;
      this.showSearchArea = showSearchArea;
      this.showSearchLines = showSearchLines;
      this.showEdgesFound = showEdgesFound;
      this.showResult = showResult;
      this.searchAreaColor = searchAreaColor;
      this.searchLinesColor = searchLinesColor;
      this.searchEdgesColor = searchEdgesColor;
      this.resultColor = resultColor;
      this.overlayGroupName = overlayGroupName;
      this.edgeOptions = edgeOptions;
    }

    protected FindEdgeOptions2(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected FindEdgeOptions2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      direction = RakeDirection.fromValue(backing.getInt(0));
      showSearchArea = backing.getInt(4);
      showSearchLines = backing.getInt(8);
      showEdgesFound = backing.getInt(12);
      showResult = backing.getInt(16);
      searchAreaColor.read();
      searchLinesColor.read();
      searchEdgesColor.read();
      resultColor.read();
      long overlayGroupName_addr = getPointer(backing, 36);
      if (overlayGroupName_addr == 0)
        overlayGroupName = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          overlayGroupName = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName = "";
        }
      }

      edgeOptions.read();
    }

    public void write() {
      if (direction != null)
        backing.putInt(0, direction.getValue());
      backing.putInt(4, showSearchArea);
      backing.putInt(8, showSearchLines);
      backing.putInt(12, showEdgesFound);
      backing.putInt(16, showResult);
      searchAreaColor.write();
      searchLinesColor.write();
      searchEdgesColor.write();
      resultColor.write();
      if (overlayGroupName != null) {
        byte[] overlayGroupName_bytes;
        try {
          overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName_bytes = new byte[0];
        }
        overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length + 1);
        putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length)
            .put(overlayGroupName_bytes.length, (byte) 0);
      }
      putPointer(backing, 36, overlayGroupName == null ? 0
          : getByteBufferAddress(overlayGroupName_buf));
      edgeOptions.write();
    }

    public int size() {
      return 64;
    }
  }

  public static class FindEdgeReport extends DisposedStruct {
    public StraightEdge[] straightEdges; // An array of straight edges detected.
    private ByteBuffer straightEdges_buf;

    private void init() {
      straightEdges = new StraightEdge[0];
    }

    public FindEdgeReport() {
      super(8);
      init();
    }

    public FindEdgeReport(StraightEdge[] straightEdges) {
      super(8);
      this.straightEdges = straightEdges;
    }

    protected FindEdgeReport(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected FindEdgeReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      int straightEdges_numStraightEdges = backing.getInt(4);
      long straightEdges_addr = getPointer(backing, 0);
      straightEdges = new StraightEdge[straightEdges_numStraightEdges];
      if (straightEdges_numStraightEdges > 0 && straightEdges_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(straightEdges_addr, straightEdges_numStraightEdges * 88);
        for (int i = 0, off = 0; i < straightEdges_numStraightEdges; i++, off += 88) {
          straightEdges[i] = new StraightEdge(bb, off);
          straightEdges[i].read();
        }
      }
    }

    public void write() {
      straightEdges_buf =
          ByteBuffer.allocateDirect(straightEdges.length * 88).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < straightEdges.length; i++, off += 88) {
        straightEdges[i].setBuffer(straightEdges_buf, off);
        straightEdges[i].write();
      }
      backing.putInt(4, straightEdges.length);
      putPointer(backing, 0, straightEdges_buf);
    }

    public int size() {
      return 8;
    }
  }

  public static class FindTransformRectOptions2 extends DisposedStruct {
    public FindReferenceDirection direction; // Specifies the direction and
                                             // orientation in which the
                                             // function searches for the
                                             // primary axis.
    public int showSearchArea; // If TRUE, the function overlays the search area
                               // on the image.
    public int showSearchLines; // If TRUE, the function overlays the search
                                // lines used to locate the edges on the image.
    public int showEdgesFound; // If TRUE, the function overlays the locations
                               // of the edges found on the image.
    public int showResult; // If TRUE, the function overlays the hit lines to
                           // the object and the edge used to generate the hit
                           // line on the result image.
    public RGBValue searchAreaColor; // Specifies the RGB color value to use to
                                     // overlay the search area.
    public RGBValue searchLinesColor; // Specifies the RGB color value to use to
                                      // overlay the search lines.
    public RGBValue searchEdgesColor; // Specifies the RGB color value to use to
                                      // overlay the search edges.
    public RGBValue resultColor; // Specifies the RGB color value to use to
                                 // overlay the results.
    public String overlayGroupName; // Specifies the overlay group name to
                                    // assign to the overlays.
    public EdgeOptions2 edgeOptions; // Specifies the edge detection options
                                     // along a single search line.
    private ByteBuffer overlayGroupName_buf;

    private void init() {
      searchAreaColor = new RGBValue(backing, 20);
      searchLinesColor = new RGBValue(backing, 24);
      searchEdgesColor = new RGBValue(backing, 28);
      resultColor = new RGBValue(backing, 32);
      edgeOptions = new EdgeOptions2(backing, 40);
    }

    public FindTransformRectOptions2() {
      super(64);
      init();
    }

    public FindTransformRectOptions2(FindReferenceDirection direction, int showSearchArea,
        int showSearchLines, int showEdgesFound, int showResult, RGBValue searchAreaColor,
        RGBValue searchLinesColor, RGBValue searchEdgesColor, RGBValue resultColor,
        String overlayGroupName, EdgeOptions2 edgeOptions) {
      super(64);
      this.direction = direction;
      this.showSearchArea = showSearchArea;
      this.showSearchLines = showSearchLines;
      this.showEdgesFound = showEdgesFound;
      this.showResult = showResult;
      this.searchAreaColor = searchAreaColor;
      this.searchLinesColor = searchLinesColor;
      this.searchEdgesColor = searchEdgesColor;
      this.resultColor = resultColor;
      this.overlayGroupName = overlayGroupName;
      this.edgeOptions = edgeOptions;
    }

    protected FindTransformRectOptions2(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected FindTransformRectOptions2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      direction = FindReferenceDirection.fromValue(backing.getInt(0));
      showSearchArea = backing.getInt(4);
      showSearchLines = backing.getInt(8);
      showEdgesFound = backing.getInt(12);
      showResult = backing.getInt(16);
      searchAreaColor.read();
      searchLinesColor.read();
      searchEdgesColor.read();
      resultColor.read();
      long overlayGroupName_addr = getPointer(backing, 36);
      if (overlayGroupName_addr == 0)
        overlayGroupName = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          overlayGroupName = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName = "";
        }
      }

      edgeOptions.read();
    }

    public void write() {
      if (direction != null)
        backing.putInt(0, direction.getValue());
      backing.putInt(4, showSearchArea);
      backing.putInt(8, showSearchLines);
      backing.putInt(12, showEdgesFound);
      backing.putInt(16, showResult);
      searchAreaColor.write();
      searchLinesColor.write();
      searchEdgesColor.write();
      resultColor.write();
      if (overlayGroupName != null) {
        byte[] overlayGroupName_bytes;
        try {
          overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName_bytes = new byte[0];
        }
        overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length + 1);
        putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length)
            .put(overlayGroupName_bytes.length, (byte) 0);
      }
      putPointer(backing, 36, overlayGroupName == null ? 0
          : getByteBufferAddress(overlayGroupName_buf));
      edgeOptions.write();
    }

    public int size() {
      return 64;
    }
  }

  public static class FindTransformRectsOptions2 extends DisposedStruct {
    public FindReferenceDirection direction; // Specifies the direction and
                                             // orientation in which the
                                             // function searches for the
                                             // primary axis.
    public int showSearchArea; // If TRUE, the function overlays the search area
                               // on the image.
    public int showSearchLines; // If TRUE, the function overlays the search
                                // lines used to locate the edges on the image.
    public int showEdgesFound; // If TRUE, the function overlays the locations
                               // of the edges found on the image.
    public int showResult; // If TRUE, the function overlays the hit lines to
                           // the object and the edge used to generate the hit
                           // line on the result image.
    public RGBValue searchAreaColor; // Specifies the RGB color value to use to
                                     // overlay the search area.
    public RGBValue searchLinesColor; // Specifies the RGB color value to use to
                                      // overlay the search lines.
    public RGBValue searchEdgesColor; // Specifies the RGB color value to use to
                                      // overlay the search edges.
    public RGBValue resultColor; // Specifies the RGB color value to use to
                                 // overlay the results.
    public String overlayGroupName; // Specifies the overlay group name to
                                    // assign to the overlays.
    public EdgeOptions2 primaryEdgeOptions; // Specifies the parameters used to
                                            // compute the edge gradient
                                            // information and detect the edges
                                            // for the primary ROI.
    public EdgeOptions2 secondaryEdgeOptions; // Specifies the parameters used
                                              // to compute the edge gradient
                                              // information and detect the
                                              // edges for the secondary ROI.
    private ByteBuffer overlayGroupName_buf;

    private void init() {
      searchAreaColor = new RGBValue(backing, 20);
      searchLinesColor = new RGBValue(backing, 24);
      searchEdgesColor = new RGBValue(backing, 28);
      resultColor = new RGBValue(backing, 32);
      primaryEdgeOptions = new EdgeOptions2(backing, 40);
      secondaryEdgeOptions = new EdgeOptions2(backing, 64);
    }

    public FindTransformRectsOptions2() {
      super(88);
      init();
    }

    public FindTransformRectsOptions2(FindReferenceDirection direction, int showSearchArea,
        int showSearchLines, int showEdgesFound, int showResult, RGBValue searchAreaColor,
        RGBValue searchLinesColor, RGBValue searchEdgesColor, RGBValue resultColor,
        String overlayGroupName, EdgeOptions2 primaryEdgeOptions, EdgeOptions2 secondaryEdgeOptions) {
      super(88);
      this.direction = direction;
      this.showSearchArea = showSearchArea;
      this.showSearchLines = showSearchLines;
      this.showEdgesFound = showEdgesFound;
      this.showResult = showResult;
      this.searchAreaColor = searchAreaColor;
      this.searchLinesColor = searchLinesColor;
      this.searchEdgesColor = searchEdgesColor;
      this.resultColor = resultColor;
      this.overlayGroupName = overlayGroupName;
      this.primaryEdgeOptions = primaryEdgeOptions;
      this.secondaryEdgeOptions = secondaryEdgeOptions;
    }

    protected FindTransformRectsOptions2(ByteBuffer backing, int offset) {
      super(backing, offset, 88);
      init();
    }

    protected FindTransformRectsOptions2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 88);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 88);
    }

    public void read() {
      direction = FindReferenceDirection.fromValue(backing.getInt(0));
      showSearchArea = backing.getInt(4);
      showSearchLines = backing.getInt(8);
      showEdgesFound = backing.getInt(12);
      showResult = backing.getInt(16);
      searchAreaColor.read();
      searchLinesColor.read();
      searchEdgesColor.read();
      resultColor.read();
      long overlayGroupName_addr = getPointer(backing, 36);
      if (overlayGroupName_addr == 0)
        overlayGroupName = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          overlayGroupName = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName = "";
        }
      }

      primaryEdgeOptions.read();
      secondaryEdgeOptions.read();
    }

    public void write() {
      if (direction != null)
        backing.putInt(0, direction.getValue());
      backing.putInt(4, showSearchArea);
      backing.putInt(8, showSearchLines);
      backing.putInt(12, showEdgesFound);
      backing.putInt(16, showResult);
      searchAreaColor.write();
      searchLinesColor.write();
      searchEdgesColor.write();
      resultColor.write();
      if (overlayGroupName != null) {
        byte[] overlayGroupName_bytes;
        try {
          overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          overlayGroupName_bytes = new byte[0];
        }
        overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length + 1);
        putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length)
            .put(overlayGroupName_bytes.length, (byte) 0);
      }
      putPointer(backing, 36, overlayGroupName == null ? 0
          : getByteBufferAddress(overlayGroupName_buf));
      primaryEdgeOptions.write();
      secondaryEdgeOptions.write();
    }

    public int size() {
      return 88;
    }
  }

  public static class ReadTextReport3 extends DisposedStruct {
    public String readString; // The read string.
    public CharReport3[] characterReport; // An array of reports describing the
                                          // properties of each identified
                                          // character.
    public ROI roiBoundingCharacters; // An array specifying the coordinates of
                                      // the character bounding ROI.
    private ByteBuffer readString_buf;
    private ByteBuffer characterReport_buf;

    private void init() {
      characterReport = new CharReport3[0];
    }

    public ReadTextReport3() {
      super(16);
      init();
    }

    public ReadTextReport3(String readString, CharReport3[] characterReport,
        ROI roiBoundingCharacters) {
      super(16);
      this.readString = readString;
      this.characterReport = characterReport;
      this.roiBoundingCharacters = roiBoundingCharacters;
    }

    protected ReadTextReport3(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ReadTextReport3(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      long readString_addr = getPointer(backing, 0);
      if (readString_addr == 0)
        readString = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(readString_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          readString = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          readString = "";
        }
      }

      int characterReport_numCharacterReports = backing.getInt(8);
      long characterReport_addr = getPointer(backing, 4);
      characterReport = new CharReport3[characterReport_numCharacterReports];
      if (characterReport_numCharacterReports > 0 && characterReport_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(characterReport_addr, characterReport_numCharacterReports * 44);
        for (int i = 0, off = 0; i < characterReport_numCharacterReports; i++, off += 44) {
          characterReport[i] = new CharReport3(bb, off);
          characterReport[i].read();
        }
      }
      long roiBoundingCharacters_addr = getPointer(backing, 12);
      if (roiBoundingCharacters_addr == 0)
        roiBoundingCharacters = null;
      else
        roiBoundingCharacters = new ROI(roiBoundingCharacters_addr, false);
    }

    public void write() {
      if (readString != null) {
        byte[] readString_bytes;
        try {
          readString_bytes = readString.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          readString_bytes = new byte[0];
        }
        readString_buf = ByteBuffer.allocateDirect(readString_bytes.length + 1);
        putBytes(readString_buf, readString_bytes, 0, readString_bytes.length).put(
            readString_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, readString == null ? 0 : getByteBufferAddress(readString_buf));
      characterReport_buf =
          ByteBuffer.allocateDirect(characterReport.length * 44).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < characterReport.length; i++, off += 44) {
        characterReport[i].setBuffer(characterReport_buf, off);
        characterReport[i].write();
      }
      backing.putInt(8, characterReport.length);
      putPointer(backing, 4, characterReport_buf);
      putPointer(backing, 12, roiBoundingCharacters);
    }

    public int size() {
      return 16;
    }
  }

  public static class CharacterStatistics extends DisposedStruct {
    public int left; // The left offset of the character bounding rectangles in
                     // the current ROI.
    public int top; // The top offset of the character bounding rectangles in
                    // the current ROI.
    public int width; // The width of each of the characters you trained in the
                      // current ROI.
    public int height; // The height of each trained character in the current
                       // ROI.
    public int characterSize; // The size of the character in pixels.

    private void init() {

    }

    public CharacterStatistics() {
      super(20);
      init();
    }

    public CharacterStatistics(int left, int top, int width, int height, int characterSize) {
      super(20);
      this.left = left;
      this.top = top;
      this.width = width;
      this.height = height;
      this.characterSize = characterSize;
    }

    protected CharacterStatistics(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected CharacterStatistics(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      left = backing.getInt(0);
      top = backing.getInt(4);
      width = backing.getInt(8);
      height = backing.getInt(12);
      characterSize = backing.getInt(16);
    }

    public void write() {
      backing.putInt(0, left);
      backing.putInt(4, top);
      backing.putInt(8, width);
      backing.putInt(12, height);
      backing.putInt(16, characterSize);
    }

    public int size() {
      return 20;
    }
  }

  public static class CharReport3 extends DisposedStruct {
    public String character; // The character value.
    public int classificationScore; // The degree to which the assigned
                                    // character class represents the object
                                    // better than the other character classes
                                    // in the character set.
    public int verificationScore; // The similarity of the character and the
                                  // reference character for the character
                                  // class.
    public int verified; // This element is TRUE if a reference character was
                         // found for the character class and FALSE if a
                         // reference character was not found.
    public int lowThreshold; // The minimum value of the threshold range used
                             // for this character.
    public int highThreshold; // The maximum value of the threshold range used
                              // for this character.
    public CharacterStatistics characterStats; // Describes the characters
                                               // segmented in the ROI.
    private ByteBuffer character_buf;

    private void init() {
      characterStats = new CharacterStatistics(backing, 24);
    }

    public CharReport3() {
      super(44);
      init();
    }

    public CharReport3(String character, int classificationScore, int verificationScore,
        int verified, int lowThreshold, int highThreshold, CharacterStatistics characterStats) {
      super(44);
      this.character = character;
      this.classificationScore = classificationScore;
      this.verificationScore = verificationScore;
      this.verified = verified;
      this.lowThreshold = lowThreshold;
      this.highThreshold = highThreshold;
      this.characterStats = characterStats;
    }

    protected CharReport3(ByteBuffer backing, int offset) {
      super(backing, offset, 44);
      init();
    }

    protected CharReport3(long nativeObj, boolean owned) {
      super(nativeObj, owned, 44);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 44);
    }

    public void read() {
      long character_addr = getPointer(backing, 0);
      if (character_addr == 0)
        character = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(character_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          character = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          character = "";
        }
      }

      classificationScore = backing.getInt(4);
      verificationScore = backing.getInt(8);
      verified = backing.getInt(12);
      lowThreshold = backing.getInt(16);
      highThreshold = backing.getInt(20);
      characterStats.read();
    }

    public void write() {
      if (character != null) {
        byte[] character_bytes;
        try {
          character_bytes = character.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          character_bytes = new byte[0];
        }
        character_buf = ByteBuffer.allocateDirect(character_bytes.length + 1);
        putBytes(character_buf, character_bytes, 0, character_bytes.length).put(
            character_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, character == null ? 0 : getByteBufferAddress(character_buf));
      backing.putInt(4, classificationScore);
      backing.putInt(8, verificationScore);
      backing.putInt(12, verified);
      backing.putInt(16, lowThreshold);
      backing.putInt(20, highThreshold);
      characterStats.write();
    }

    public int size() {
      return 44;
    }
  }

  public static class ArcInfo2 extends DisposedStruct {
    public PointFloat center; // The center point of the arc.
    public double radius; // The radius of the arc.
    public double startAngle; // The starting angle of the arc, specified
                              // counter-clockwise from the x-axis.
    public double endAngle; // The ending angle of the arc, specified
                            // counter-clockwise from the x-axis.

    private void init() {
      center = new PointFloat(backing, 0);
    }

    public ArcInfo2() {
      super(32);
      init();
    }

    public ArcInfo2(PointFloat center, double radius, double startAngle, double endAngle) {
      super(32);
      this.center = center;
      this.radius = radius;
      this.startAngle = startAngle;
      this.endAngle = endAngle;
    }

    protected ArcInfo2(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected ArcInfo2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      center.read();
      radius = backing.getDouble(8);
      startAngle = backing.getDouble(16);
      endAngle = backing.getDouble(24);
    }

    public void write() {
      center.write();
      backing.putDouble(8, radius);
      backing.putDouble(16, startAngle);
      backing.putDouble(24, endAngle);
    }

    public int size() {
      return 32;
    }
  }

  public static class EdgeReport2 extends DisposedStruct {
    public EdgeInfo[] edges; // An array of edges detected.
    public double[] gradientInfo; // An array that contains the calculated edge
                                  // strengths along the user-defined search
                                  // area.
    public int calibrationValid; // Indicates if the calibration data
                                 // corresponding to the location of the edges
                                 // is correct.
    private ByteBuffer edges_buf;
    private ByteBuffer gradientInfo_buf;

    private void init() {
      edges = new EdgeInfo[0];
      gradientInfo = new double[0];
    }

    public EdgeReport2() {
      super(20);
      init();
    }

    public EdgeReport2(EdgeInfo[] edges, double[] gradientInfo, int calibrationValid) {
      super(20);
      this.edges = edges;
      this.gradientInfo = gradientInfo;
      this.calibrationValid = calibrationValid;
    }

    protected EdgeReport2(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected EdgeReport2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      int edges_numEdges = backing.getInt(4);
      long edges_addr = getPointer(backing, 0);
      edges = new EdgeInfo[edges_numEdges];
      if (edges_numEdges > 0 && edges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(edges_addr, edges_numEdges * 56);
        for (int i = 0, off = 0; i < edges_numEdges; i++, off += 56) {
          edges[i] = new EdgeInfo(bb, off);
          edges[i].read();
        }
      }
      int gradientInfo_numGradientInfo = backing.getInt(12);
      long gradientInfo_addr = getPointer(backing, 8);
      gradientInfo = new double[gradientInfo_numGradientInfo];
      if (gradientInfo_numGradientInfo > 0 && gradientInfo_addr != 0) {
        newDirectByteBuffer(gradientInfo_addr, gradientInfo_numGradientInfo * 8).asDoubleBuffer()
            .get(gradientInfo);
      }
      calibrationValid = backing.getInt(16);
    }

    public void write() {
      edges_buf = ByteBuffer.allocateDirect(edges.length * 56).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < edges.length; i++, off += 56) {
        edges[i].setBuffer(edges_buf, off);
        edges[i].write();
      }
      backing.putInt(4, edges.length);
      putPointer(backing, 0, edges_buf);
      gradientInfo_buf =
          ByteBuffer.allocateDirect(gradientInfo.length * 8).order(ByteOrder.nativeOrder());
      gradientInfo_buf.asDoubleBuffer().put(gradientInfo).rewind();
      backing.putInt(12, gradientInfo.length);
      putPointer(backing, 8, gradientInfo_buf);
      backing.putInt(16, calibrationValid);
    }

    public int size() {
      return 20;
    }
  }

  public static class SearchArcInfo extends DisposedStruct {
    public ArcInfo2 arcCoordinates; // Describes the arc used for edge
                                    // detection.
    public EdgeReport2 edgeReport; // Describes the edges found in this search
                                   // line.

    private void init() {
      arcCoordinates = new ArcInfo2(backing, 0);
      edgeReport = new EdgeReport2(backing, 32);
    }

    public SearchArcInfo() {
      super(56);
      init();
    }

    public SearchArcInfo(ArcInfo2 arcCoordinates, EdgeReport2 edgeReport) {
      super(56);
      this.arcCoordinates = arcCoordinates;
      this.edgeReport = edgeReport;
    }

    protected SearchArcInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 56);
      init();
    }

    protected SearchArcInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 56);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 56);
    }

    public void read() {
      arcCoordinates.read();
      edgeReport.read();
    }

    public void write() {
      arcCoordinates.write();
      edgeReport.write();
    }

    public int size() {
      return 56;
    }
  }

  public static class ConcentricRakeReport2 extends DisposedStruct {
    public EdgeInfo[] firstEdges; // The first edge point detected along each
                                  // search line in the ROI.
    public EdgeInfo[] lastEdges; // The last edge point detected along each
                                 // search line in the ROI.
    public SearchArcInfo[] searchArcs; // Contains the arcs used for edge
                                       // detection and the edge information for
                                       // each arc.
    private ByteBuffer firstEdges_buf;
    private ByteBuffer lastEdges_buf;
    private ByteBuffer searchArcs_buf;

    private void init() {
      firstEdges = new EdgeInfo[0];
      lastEdges = new EdgeInfo[0];
      searchArcs = new SearchArcInfo[0];
    }

    public ConcentricRakeReport2() {
      super(24);
      init();
    }

    public ConcentricRakeReport2(EdgeInfo[] firstEdges, EdgeInfo[] lastEdges,
        SearchArcInfo[] searchArcs) {
      super(24);
      this.firstEdges = firstEdges;
      this.lastEdges = lastEdges;
      this.searchArcs = searchArcs;
    }

    protected ConcentricRakeReport2(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected ConcentricRakeReport2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      int firstEdges_numFirstEdges = backing.getInt(4);
      long firstEdges_addr = getPointer(backing, 0);
      firstEdges = new EdgeInfo[firstEdges_numFirstEdges];
      if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges * 56);
        for (int i = 0, off = 0; i < firstEdges_numFirstEdges; i++, off += 56) {
          firstEdges[i] = new EdgeInfo(bb, off);
          firstEdges[i].read();
        }
      }
      int lastEdges_numLastEdges = backing.getInt(12);
      long lastEdges_addr = getPointer(backing, 8);
      lastEdges = new EdgeInfo[lastEdges_numLastEdges];
      if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges * 56);
        for (int i = 0, off = 0; i < lastEdges_numLastEdges; i++, off += 56) {
          lastEdges[i] = new EdgeInfo(bb, off);
          lastEdges[i].read();
        }
      }
      int searchArcs_numSearchArcs = backing.getInt(20);
      long searchArcs_addr = getPointer(backing, 16);
      searchArcs = new SearchArcInfo[searchArcs_numSearchArcs];
      if (searchArcs_numSearchArcs > 0 && searchArcs_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(searchArcs_addr, searchArcs_numSearchArcs * 56);
        for (int i = 0, off = 0; i < searchArcs_numSearchArcs; i++, off += 56) {
          searchArcs[i] = new SearchArcInfo(bb, off);
          searchArcs[i].read();
        }
      }
    }

    public void write() {
      firstEdges_buf =
          ByteBuffer.allocateDirect(firstEdges.length * 56).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < firstEdges.length; i++, off += 56) {
        firstEdges[i].setBuffer(firstEdges_buf, off);
        firstEdges[i].write();
      }
      backing.putInt(4, firstEdges.length);
      putPointer(backing, 0, firstEdges_buf);
      lastEdges_buf =
          ByteBuffer.allocateDirect(lastEdges.length * 56).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < lastEdges.length; i++, off += 56) {
        lastEdges[i].setBuffer(lastEdges_buf, off);
        lastEdges[i].write();
      }
      backing.putInt(12, lastEdges.length);
      putPointer(backing, 8, lastEdges_buf);
      searchArcs_buf =
          ByteBuffer.allocateDirect(searchArcs.length * 56).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < searchArcs.length; i++, off += 56) {
        searchArcs[i].setBuffer(searchArcs_buf, off);
        searchArcs[i].write();
      }
      backing.putInt(20, searchArcs.length);
      putPointer(backing, 16, searchArcs_buf);
    }

    public int size() {
      return 24;
    }
  }

  public static class SpokeReport2 extends DisposedStruct {
    public EdgeInfo[] firstEdges; // The first edge point detected along each
                                  // search line in the ROI.
    public EdgeInfo[] lastEdges; // The last edge point detected along each
                                 // search line in the ROI.
    public SearchLineInfo[] searchLines; // The search lines used for edge
                                         // detection.
    private ByteBuffer firstEdges_buf;
    private ByteBuffer lastEdges_buf;
    private ByteBuffer searchLines_buf;

    private void init() {
      firstEdges = new EdgeInfo[0];
      lastEdges = new EdgeInfo[0];
      searchLines = new SearchLineInfo[0];
    }

    public SpokeReport2() {
      super(24);
      init();
    }

    public SpokeReport2(EdgeInfo[] firstEdges, EdgeInfo[] lastEdges, SearchLineInfo[] searchLines) {
      super(24);
      this.firstEdges = firstEdges;
      this.lastEdges = lastEdges;
      this.searchLines = searchLines;
    }

    protected SpokeReport2(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected SpokeReport2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      int firstEdges_numFirstEdges = backing.getInt(4);
      long firstEdges_addr = getPointer(backing, 0);
      firstEdges = new EdgeInfo[firstEdges_numFirstEdges];
      if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges * 56);
        for (int i = 0, off = 0; i < firstEdges_numFirstEdges; i++, off += 56) {
          firstEdges[i] = new EdgeInfo(bb, off);
          firstEdges[i].read();
        }
      }
      int lastEdges_numLastEdges = backing.getInt(12);
      long lastEdges_addr = getPointer(backing, 8);
      lastEdges = new EdgeInfo[lastEdges_numLastEdges];
      if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges * 56);
        for (int i = 0, off = 0; i < lastEdges_numLastEdges; i++, off += 56) {
          lastEdges[i] = new EdgeInfo(bb, off);
          lastEdges[i].read();
        }
      }
      int searchLines_numSearchLines = backing.getInt(20);
      long searchLines_addr = getPointer(backing, 16);
      searchLines = new SearchLineInfo[searchLines_numSearchLines];
      if (searchLines_numSearchLines > 0 && searchLines_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(searchLines_addr, searchLines_numSearchLines * 36);
        for (int i = 0, off = 0; i < searchLines_numSearchLines; i++, off += 36) {
          searchLines[i] = new SearchLineInfo(bb, off);
          searchLines[i].read();
        }
      }
    }

    public void write() {
      firstEdges_buf =
          ByteBuffer.allocateDirect(firstEdges.length * 56).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < firstEdges.length; i++, off += 56) {
        firstEdges[i].setBuffer(firstEdges_buf, off);
        firstEdges[i].write();
      }
      backing.putInt(4, firstEdges.length);
      putPointer(backing, 0, firstEdges_buf);
      lastEdges_buf =
          ByteBuffer.allocateDirect(lastEdges.length * 56).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < lastEdges.length; i++, off += 56) {
        lastEdges[i].setBuffer(lastEdges_buf, off);
        lastEdges[i].write();
      }
      backing.putInt(12, lastEdges.length);
      putPointer(backing, 8, lastEdges_buf);
      searchLines_buf =
          ByteBuffer.allocateDirect(searchLines.length * 36).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < searchLines.length; i++, off += 36) {
        searchLines[i].setBuffer(searchLines_buf, off);
        searchLines[i].write();
      }
      backing.putInt(20, searchLines.length);
      putPointer(backing, 16, searchLines_buf);
    }

    public int size() {
      return 24;
    }
  }

  public static class EdgeInfo extends DisposedStruct {
    public PointFloat position; // The location of the edge in the image.
    public PointFloat calibratedPosition; // The position of the edge in the
                                          // image in real-world coordinates.
    public double distance; // The location of the edge from the first point
                            // along the boundary of the input ROI.
    public double calibratedDistance; // The location of the edge from the first
                                      // point along the boundary of the input
                                      // ROI in real-world coordinates.
    public double magnitude; // The intensity contrast at the edge.
    public double noisePeak; // The strength of the noise associated with the
                             // current edge.
    public int rising; // Indicates the polarity of the edge.

    private void init() {
      position = new PointFloat(backing, 0);
      calibratedPosition = new PointFloat(backing, 8);
    }

    public EdgeInfo() {
      super(56);
      init();
    }

    public EdgeInfo(PointFloat position, PointFloat calibratedPosition, double distance,
        double calibratedDistance, double magnitude, double noisePeak, int rising) {
      super(56);
      this.position = position;
      this.calibratedPosition = calibratedPosition;
      this.distance = distance;
      this.calibratedDistance = calibratedDistance;
      this.magnitude = magnitude;
      this.noisePeak = noisePeak;
      this.rising = rising;
    }

    protected EdgeInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 56);
      init();
    }

    protected EdgeInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 56);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 56);
    }

    public void read() {
      position.read();
      calibratedPosition.read();
      distance = backing.getDouble(16);
      calibratedDistance = backing.getDouble(24);
      magnitude = backing.getDouble(32);
      noisePeak = backing.getDouble(40);
      rising = backing.getInt(48);
    }

    public void write() {
      position.write();
      calibratedPosition.write();
      backing.putDouble(16, distance);
      backing.putDouble(24, calibratedDistance);
      backing.putDouble(32, magnitude);
      backing.putDouble(40, noisePeak);
      backing.putInt(48, rising);
    }

    public int size() {
      return 56;
    }
  }

  public static class SearchLineInfo extends DisposedStruct {
    public LineFloat lineCoordinates; // The endpoints of the search line.
    public EdgeReport2 edgeReport; // Describes the edges found in this search
                                   // line.

    private void init() {
      lineCoordinates = new LineFloat(backing, 0);
      edgeReport = new EdgeReport2(backing, 16);
    }

    public SearchLineInfo() {
      super(36);
      init();
    }

    public SearchLineInfo(LineFloat lineCoordinates, EdgeReport2 edgeReport) {
      super(36);
      this.lineCoordinates = lineCoordinates;
      this.edgeReport = edgeReport;
    }

    protected SearchLineInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 36);
      init();
    }

    protected SearchLineInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 36);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 36);
    }

    public void read() {
      lineCoordinates.read();
      edgeReport.read();
    }

    public void write() {
      lineCoordinates.write();
      edgeReport.write();
    }

    public int size() {
      return 36;
    }
  }

  public static class RakeReport2 extends DisposedStruct {
    public EdgeInfo[] firstEdges; // The first edge point detected along each
                                  // search line in the ROI.
    public EdgeInfo[] lastEdges; // The last edge point detected along each
                                 // search line in the ROI.
    public SearchLineInfo[] searchLines; // The search lines used for edge
                                         // detection.
    private ByteBuffer firstEdges_buf;
    private ByteBuffer lastEdges_buf;
    private ByteBuffer searchLines_buf;

    private void init() {
      firstEdges = new EdgeInfo[0];
      lastEdges = new EdgeInfo[0];
      searchLines = new SearchLineInfo[0];
    }

    public RakeReport2() {
      super(24);
      init();
    }

    public RakeReport2(EdgeInfo[] firstEdges, EdgeInfo[] lastEdges, SearchLineInfo[] searchLines) {
      super(24);
      this.firstEdges = firstEdges;
      this.lastEdges = lastEdges;
      this.searchLines = searchLines;
    }

    protected RakeReport2(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected RakeReport2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      int firstEdges_numFirstEdges = backing.getInt(4);
      long firstEdges_addr = getPointer(backing, 0);
      firstEdges = new EdgeInfo[firstEdges_numFirstEdges];
      if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges * 56);
        for (int i = 0, off = 0; i < firstEdges_numFirstEdges; i++, off += 56) {
          firstEdges[i] = new EdgeInfo(bb, off);
          firstEdges[i].read();
        }
      }
      int lastEdges_numLastEdges = backing.getInt(12);
      long lastEdges_addr = getPointer(backing, 8);
      lastEdges = new EdgeInfo[lastEdges_numLastEdges];
      if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges * 56);
        for (int i = 0, off = 0; i < lastEdges_numLastEdges; i++, off += 56) {
          lastEdges[i] = new EdgeInfo(bb, off);
          lastEdges[i].read();
        }
      }
      int searchLines_numSearchLines = backing.getInt(20);
      long searchLines_addr = getPointer(backing, 16);
      searchLines = new SearchLineInfo[searchLines_numSearchLines];
      if (searchLines_numSearchLines > 0 && searchLines_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(searchLines_addr, searchLines_numSearchLines * 36);
        for (int i = 0, off = 0; i < searchLines_numSearchLines; i++, off += 36) {
          searchLines[i] = new SearchLineInfo(bb, off);
          searchLines[i].read();
        }
      }
    }

    public void write() {
      firstEdges_buf =
          ByteBuffer.allocateDirect(firstEdges.length * 56).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < firstEdges.length; i++, off += 56) {
        firstEdges[i].setBuffer(firstEdges_buf, off);
        firstEdges[i].write();
      }
      backing.putInt(4, firstEdges.length);
      putPointer(backing, 0, firstEdges_buf);
      lastEdges_buf =
          ByteBuffer.allocateDirect(lastEdges.length * 56).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < lastEdges.length; i++, off += 56) {
        lastEdges[i].setBuffer(lastEdges_buf, off);
        lastEdges[i].write();
      }
      backing.putInt(12, lastEdges.length);
      putPointer(backing, 8, lastEdges_buf);
      searchLines_buf =
          ByteBuffer.allocateDirect(searchLines.length * 36).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < searchLines.length; i++, off += 36) {
        searchLines[i].setBuffer(searchLines_buf, off);
        searchLines[i].write();
      }
      backing.putInt(20, searchLines.length);
      putPointer(backing, 16, searchLines_buf);
    }

    public int size() {
      return 24;
    }
  }

  public static class TransformBehaviors extends DisposedStruct {
    public GroupBehavior ShiftBehavior; // Specifies the behavior of an overlay
                                        // group when a shift operation is
                                        // applied to an image.
    public GroupBehavior ScaleBehavior; // Specifies the behavior of an overlay
                                        // group when a scale operation is
                                        // applied to an image.
    public GroupBehavior RotateBehavior; // Specifies the behavior of an overlay
                                         // group when a rotate operation is
                                         // applied to an image.
    public GroupBehavior SymmetryBehavior; // Specifies the behavior of an
                                           // overlay group when a symmetry
                                           // operation is applied to an image.

    private void init() {

    }

    public TransformBehaviors() {
      super(16);
      init();
    }

    public TransformBehaviors(GroupBehavior ShiftBehavior, GroupBehavior ScaleBehavior,
        GroupBehavior RotateBehavior, GroupBehavior SymmetryBehavior) {
      super(16);
      this.ShiftBehavior = ShiftBehavior;
      this.ScaleBehavior = ScaleBehavior;
      this.RotateBehavior = RotateBehavior;
      this.SymmetryBehavior = SymmetryBehavior;
    }

    protected TransformBehaviors(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected TransformBehaviors(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      ShiftBehavior = GroupBehavior.fromValue(backing.getInt(0));
      ScaleBehavior = GroupBehavior.fromValue(backing.getInt(4));
      RotateBehavior = GroupBehavior.fromValue(backing.getInt(8));
      SymmetryBehavior = GroupBehavior.fromValue(backing.getInt(12));
    }

    public void write() {
      if (ShiftBehavior != null)
        backing.putInt(0, ShiftBehavior.getValue());
      if (ScaleBehavior != null)
        backing.putInt(4, ScaleBehavior.getValue());
      if (RotateBehavior != null)
        backing.putInt(8, RotateBehavior.getValue());
      if (SymmetryBehavior != null)
        backing.putInt(12, SymmetryBehavior.getValue());
    }

    public int size() {
      return 16;
    }
  }

  public static class QRCodeDataToken extends DisposedStruct {
    public QRStreamMode mode; // Specifies the stream mode or the format of the
                              // data that is encoded in the QR code.
    public int modeData; // Indicates specifiers used by the user to postprocess
                         // the data if it requires it.
    public byte[] data; // Shows the encoded data in the QR code.
    private ByteBuffer data_buf;

    private void init() {
      data = new byte[0];
    }

    public QRCodeDataToken() {
      super(16);
      init();
    }

    public QRCodeDataToken(QRStreamMode mode, int modeData, byte[] data) {
      super(16);
      this.mode = mode;
      this.modeData = modeData;
      this.data = data;
    }

    protected QRCodeDataToken(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected QRCodeDataToken(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      mode = QRStreamMode.fromValue(backing.getInt(0));
      modeData = backing.getInt(4);
      int data_dataLength = backing.getInt(12);
      long data_addr = getPointer(backing, 8);
      data = new byte[data_dataLength];
      if (data_dataLength > 0 && data_addr != 0) {
        getBytes(newDirectByteBuffer(data_addr, data_dataLength), data, 0, data_dataLength);
      }
    }

    public void write() {
      if (mode != null)
        backing.putInt(0, mode.getValue());
      backing.putInt(4, modeData);
      data_buf = ByteBuffer.allocateDirect(data.length);
      putBytes(data_buf, data, 0, data.length);
      backing.putInt(12, data.length);
      putPointer(backing, 8, data_buf);
    }

    public int size() {
      return 16;
    }
  }

  public static class ParticleFilterOptions extends DisposedStruct {
    public int rejectMatches; // Set this parameter to TRUE to transfer only
                              // those particles that do not meet all the
                              // criteria.
    public int rejectBorder; // Set this element to TRUE to reject border
                             // particles.
    public int connectivity8; // Set this parameter to TRUE to use
                              // connectivity-8 to determine whether particles
                              // are touching.

    private void init() {

    }

    public ParticleFilterOptions() {
      super(12);
      init();
    }

    public ParticleFilterOptions(int rejectMatches, int rejectBorder, int connectivity8) {
      super(12);
      this.rejectMatches = rejectMatches;
      this.rejectBorder = rejectBorder;
      this.connectivity8 = connectivity8;
    }

    protected ParticleFilterOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected ParticleFilterOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      rejectMatches = backing.getInt(0);
      rejectBorder = backing.getInt(4);
      connectivity8 = backing.getInt(8);
    }

    public void write() {
      backing.putInt(0, rejectMatches);
      backing.putInt(4, rejectBorder);
      backing.putInt(8, connectivity8);
    }

    public int size() {
      return 12;
    }
  }

  public static class StraightEdgeReport2 extends DisposedStruct {
    public StraightEdge[] straightEdges; // Contains an array of found straight
                                         // edges.
    public SearchLineInfo[] searchLines; // Contains an array of all search
                                         // lines used in the detection.
    private ByteBuffer straightEdges_buf;
    private ByteBuffer searchLines_buf;

    private void init() {
      straightEdges = new StraightEdge[0];
      searchLines = new SearchLineInfo[0];
    }

    public StraightEdgeReport2() {
      super(16);
      init();
    }

    public StraightEdgeReport2(StraightEdge[] straightEdges, SearchLineInfo[] searchLines) {
      super(16);
      this.straightEdges = straightEdges;
      this.searchLines = searchLines;
    }

    protected StraightEdgeReport2(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected StraightEdgeReport2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      int straightEdges_numStraightEdges = backing.getInt(4);
      long straightEdges_addr = getPointer(backing, 0);
      straightEdges = new StraightEdge[straightEdges_numStraightEdges];
      if (straightEdges_numStraightEdges > 0 && straightEdges_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(straightEdges_addr, straightEdges_numStraightEdges * 88);
        for (int i = 0, off = 0; i < straightEdges_numStraightEdges; i++, off += 88) {
          straightEdges[i] = new StraightEdge(bb, off);
          straightEdges[i].read();
        }
      }
      int searchLines_numSearchLines = backing.getInt(12);
      long searchLines_addr = getPointer(backing, 8);
      searchLines = new SearchLineInfo[searchLines_numSearchLines];
      if (searchLines_numSearchLines > 0 && searchLines_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(searchLines_addr, searchLines_numSearchLines * 36);
        for (int i = 0, off = 0; i < searchLines_numSearchLines; i++, off += 36) {
          searchLines[i] = new SearchLineInfo(bb, off);
          searchLines[i].read();
        }
      }
    }

    public void write() {
      straightEdges_buf =
          ByteBuffer.allocateDirect(straightEdges.length * 88).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < straightEdges.length; i++, off += 88) {
        straightEdges[i].setBuffer(straightEdges_buf, off);
        straightEdges[i].write();
      }
      backing.putInt(4, straightEdges.length);
      putPointer(backing, 0, straightEdges_buf);
      searchLines_buf =
          ByteBuffer.allocateDirect(searchLines.length * 36).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < searchLines.length; i++, off += 36) {
        searchLines[i].setBuffer(searchLines_buf, off);
        searchLines[i].write();
      }
      backing.putInt(12, searchLines.length);
      putPointer(backing, 8, searchLines_buf);
    }

    public int size() {
      return 16;
    }
  }

  public static class StraightEdgeOptions extends DisposedStruct {
    public int numLines; // Specifies the number of straight edges to find.
    public StraightEdgeSearchMode searchMode; // Specifies the method used to
                                              // find the straight edge.
    public double minScore; // Specifies the minimum score of a detected
                            // straight edge.
    public double maxScore; // Specifies the maximum score of a detected edge.
    public double orientation; // Specifies the angle at which the straight edge
                               // is expected to be found.
    public double angleRange; // Specifies the +/- range around the orientation
                              // within which the straight edge is expected to
                              // be found.
    public double angleTolerance; // Specifies the expected angular accuracy of
                                  // the straight edge.
    public int stepSize; // Specifies the gap in pixels between the search lines
                         // used with the rake-based methods.
    public double minSignalToNoiseRatio; // Specifies the minimum signal to
                                         // noise ratio (SNR) of the edge points
                                         // used to fit the straight edge.
    public double minCoverage; // Specifies the minimum number of points as a
                               // percentage of the number of search lines that
                               // need to be included in the detected straight
                               // edge.
    public int houghIterations; // Specifies the number of iterations used in
                                // the Hough-based method.

    private void init() {

    }

    public StraightEdgeOptions() {
      super(80);
      init();
    }

    public StraightEdgeOptions(int numLines, StraightEdgeSearchMode searchMode, double minScore,
        double maxScore, double orientation, double angleRange, double angleTolerance,
        int stepSize, double minSignalToNoiseRatio, double minCoverage, int houghIterations) {
      super(80);
      this.numLines = numLines;
      this.searchMode = searchMode;
      this.minScore = minScore;
      this.maxScore = maxScore;
      this.orientation = orientation;
      this.angleRange = angleRange;
      this.angleTolerance = angleTolerance;
      this.stepSize = stepSize;
      this.minSignalToNoiseRatio = minSignalToNoiseRatio;
      this.minCoverage = minCoverage;
      this.houghIterations = houghIterations;
    }

    protected StraightEdgeOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 80);
      init();
    }

    protected StraightEdgeOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 80);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 80);
    }

    public void read() {
      numLines = backing.getInt(0);
      searchMode = StraightEdgeSearchMode.fromValue(backing.getInt(4));
      minScore = backing.getDouble(8);
      maxScore = backing.getDouble(16);
      orientation = backing.getDouble(24);
      angleRange = backing.getDouble(32);
      angleTolerance = backing.getDouble(40);
      stepSize = backing.getInt(48);
      minSignalToNoiseRatio = backing.getDouble(56);
      minCoverage = backing.getDouble(64);
      houghIterations = backing.getInt(72);
    }

    public void write() {
      backing.putInt(0, numLines);
      if (searchMode != null)
        backing.putInt(4, searchMode.getValue());
      backing.putDouble(8, minScore);
      backing.putDouble(16, maxScore);
      backing.putDouble(24, orientation);
      backing.putDouble(32, angleRange);
      backing.putDouble(40, angleTolerance);
      backing.putInt(48, stepSize);
      backing.putDouble(56, minSignalToNoiseRatio);
      backing.putDouble(64, minCoverage);
      backing.putInt(72, houghIterations);
    }

    public int size() {
      return 80;
    }
  }

  public static class StraightEdge extends DisposedStruct {
    public LineFloat straightEdgeCoordinates; // End points of the detected
                                              // straight edge in pixel
                                              // coordinates.
    public LineFloat calibratedStraightEdgeCoordinates; // End points of the
                                                        // detected straight
                                                        // edge in real-world
                                                        // coordinates.
    public double angle; // Angle of the found edge using the pixel coordinates.
    public double calibratedAngle; // Angle of the found edge using the
                                   // real-world coordinates.
    public double score; // Describes the score of the detected edge.
    public double straightness; // The straightness value of the detected
                                // straight edge.
    public double averageSignalToNoiseRatio; // Describes the average signal to
                                             // noise ratio (SNR) of the
                                             // detected edge.
    public int calibrationValid; // Indicates if the calibration data for the
                                 // straight edge is valid.
    public EdgeInfo[] usedEdges; // An array of edges that were used to
                                 // determine this straight line.
    private ByteBuffer usedEdges_buf;

    private void init() {
      straightEdgeCoordinates = new LineFloat(backing, 0);
      calibratedStraightEdgeCoordinates = new LineFloat(backing, 16);
      usedEdges = new EdgeInfo[0];
    }

    public StraightEdge() {
      super(88);
      init();
    }

    public StraightEdge(LineFloat straightEdgeCoordinates,
        LineFloat calibratedStraightEdgeCoordinates, double angle, double calibratedAngle,
        double score, double straightness, double averageSignalToNoiseRatio, int calibrationValid,
        EdgeInfo[] usedEdges) {
      super(88);
      this.straightEdgeCoordinates = straightEdgeCoordinates;
      this.calibratedStraightEdgeCoordinates = calibratedStraightEdgeCoordinates;
      this.angle = angle;
      this.calibratedAngle = calibratedAngle;
      this.score = score;
      this.straightness = straightness;
      this.averageSignalToNoiseRatio = averageSignalToNoiseRatio;
      this.calibrationValid = calibrationValid;
      this.usedEdges = usedEdges;
    }

    protected StraightEdge(ByteBuffer backing, int offset) {
      super(backing, offset, 88);
      init();
    }

    protected StraightEdge(long nativeObj, boolean owned) {
      super(nativeObj, owned, 88);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 88);
    }

    public void read() {
      straightEdgeCoordinates.read();
      calibratedStraightEdgeCoordinates.read();
      angle = backing.getDouble(32);
      calibratedAngle = backing.getDouble(40);
      score = backing.getDouble(48);
      straightness = backing.getDouble(56);
      averageSignalToNoiseRatio = backing.getDouble(64);
      calibrationValid = backing.getInt(72);
      int usedEdges_numUsedEdges = backing.getInt(80);
      long usedEdges_addr = getPointer(backing, 76);
      usedEdges = new EdgeInfo[usedEdges_numUsedEdges];
      if (usedEdges_numUsedEdges > 0 && usedEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(usedEdges_addr, usedEdges_numUsedEdges * 56);
        for (int i = 0, off = 0; i < usedEdges_numUsedEdges; i++, off += 56) {
          usedEdges[i] = new EdgeInfo(bb, off);
          usedEdges[i].read();
        }
      }
    }

    public void write() {
      straightEdgeCoordinates.write();
      calibratedStraightEdgeCoordinates.write();
      backing.putDouble(32, angle);
      backing.putDouble(40, calibratedAngle);
      backing.putDouble(48, score);
      backing.putDouble(56, straightness);
      backing.putDouble(64, averageSignalToNoiseRatio);
      backing.putInt(72, calibrationValid);
      usedEdges_buf =
          ByteBuffer.allocateDirect(usedEdges.length * 56).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < usedEdges.length; i++, off += 56) {
        usedEdges[i].setBuffer(usedEdges_buf, off);
        usedEdges[i].write();
      }
      backing.putInt(80, usedEdges.length);
      putPointer(backing, 76, usedEdges_buf);
    }

    public int size() {
      return 88;
    }
  }

  public static class QRCodeSearchOptions extends DisposedStruct {
    public QRRotationMode rotationMode; // Specifies the amount of QR code
                                        // rotation the function should allow
                                        // for.
    public int skipLocation; // If set to TRUE, specifies that the function
                             // should assume that the QR code occupies the
                             // entire image (or the entire search region).
    public int edgeThreshold; // The strength of the weakest edge the function
                              // uses to find the coarse location of the QR code
                              // in the image.
    public QRDemodulationMode demodulationMode; // The demodulation mode the
                                                // function uses to locate the
                                                // QR code.
    public QRCellSampleSize cellSampleSize; // The cell sample size the function
                                            // uses to locate the QR code.
    public QRCellFilterMode cellFilterMode; // The cell filter mode the function
                                            // uses to locate the QR code.
    public int skewDegreesAllowed; // Specifies the amount of skew in the QR
                                   // code the function should allow for.

    private void init() {

    }

    public QRCodeSearchOptions() {
      super(48);
      init();
    }

    public QRCodeSearchOptions(QRRotationMode rotationMode, int skipLocation, int edgeThreshold,
        QRDemodulationMode demodulationMode, QRCellSampleSize cellSampleSize,
        QRCellFilterMode cellFilterMode, int skewDegreesAllowed) {
      super(48);
      this.rotationMode = rotationMode;
      this.skipLocation = skipLocation;
      this.edgeThreshold = edgeThreshold;
      this.demodulationMode = demodulationMode;
      this.cellSampleSize = cellSampleSize;
      this.cellFilterMode = cellFilterMode;
      this.skewDegreesAllowed = skewDegreesAllowed;
    }

    protected QRCodeSearchOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 48);
      init();
    }

    protected QRCodeSearchOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 48);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 48);
    }

    public void read() {
      rotationMode = QRRotationMode.fromValue(backing.getInt(0));
      skipLocation = backing.getInt(4);
      edgeThreshold = backing.getInt(8);
      demodulationMode = QRDemodulationMode.fromValue(backing.getInt(16));
      cellSampleSize = QRCellSampleSize.fromValue(backing.getInt(24));
      cellFilterMode = QRCellFilterMode.fromValue(backing.getInt(32));
      skewDegreesAllowed = backing.getInt(40);
    }

    public void write() {
      if (rotationMode != null)
        backing.putInt(0, rotationMode.getValue());
      backing.putInt(4, skipLocation);
      backing.putInt(8, edgeThreshold);
      if (demodulationMode != null)
        backing.putInt(16, demodulationMode.getValue());
      if (cellSampleSize != null)
        backing.putInt(24, cellSampleSize.getValue());
      if (cellFilterMode != null)
        backing.putInt(32, cellFilterMode.getValue());
      backing.putInt(40, skewDegreesAllowed);
    }

    public int size() {
      return 48;
    }
  }

  public static class QRCodeSizeOptions extends DisposedStruct {
    public int minSize; // Specifies the minimum size (in pixels) of the QR code
                        // in the image.
    public int maxSize; // Specifies the maximum size (in pixels) of the QR code
                        // in the image.

    private void init() {

    }

    public QRCodeSizeOptions() {
      super(8);
      init();
    }

    public QRCodeSizeOptions(int minSize, int maxSize) {
      super(8);
      this.minSize = minSize;
      this.maxSize = maxSize;
    }

    protected QRCodeSizeOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected QRCodeSizeOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      minSize = backing.getInt(0);
      maxSize = backing.getInt(4);
    }

    public void write() {
      backing.putInt(0, minSize);
      backing.putInt(4, maxSize);
    }

    public int size() {
      return 8;
    }
  }

  public static class QRCodeDescriptionOptions extends DisposedStruct {
    public QRDimensions dimensions; // The number of rows and columns that are
                                    // populated for the QR code, measured in
                                    // cells.
    public QRPolarities polarity; // The polarity of the QR code.
    public QRMirrorMode mirror; // This element is TRUE if the QR code appears
                                // mirrored in the image and FALSE if the QR
                                // code appears normally in the image.
    public QRModelType modelType; // This option allows you to specify the type
                                  // of QR code.

    private void init() {

    }

    public QRCodeDescriptionOptions() {
      super(32);
      init();
    }

    public QRCodeDescriptionOptions(QRDimensions dimensions, QRPolarities polarity,
        QRMirrorMode mirror, QRModelType modelType) {
      super(32);
      this.dimensions = dimensions;
      this.polarity = polarity;
      this.mirror = mirror;
      this.modelType = modelType;
    }

    protected QRCodeDescriptionOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected QRCodeDescriptionOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      dimensions = QRDimensions.fromValue(backing.getInt(0));
      polarity = QRPolarities.fromValue(backing.getInt(8));
      mirror = QRMirrorMode.fromValue(backing.getInt(16));
      modelType = QRModelType.fromValue(backing.getInt(24));
    }

    public void write() {
      if (dimensions != null)
        backing.putInt(0, dimensions.getValue());
      if (polarity != null)
        backing.putInt(8, polarity.getValue());
      if (mirror != null)
        backing.putInt(16, mirror.getValue());
      if (modelType != null)
        backing.putInt(24, modelType.getValue());
    }

    public int size() {
      return 32;
    }
  }

  public static class QRCodeReport extends DisposedStruct {
    public int found; // This element is TRUE if the function located and
                      // decoded a QR code and FALSE if the function failed to
                      // locate and decode a QR code.
    public byte[] data; // The data encoded in the QR code.
    public PointFloat[] boundingBox; // An array of four points describing the
                                     // rectangle surrounding the QR code.
    public QRCodeDataToken[] tokenizedData; // Contains the data tokenized in
                                            // exactly the way it was encoded in
                                            // the code.
    public int numErrorsCorrected; // The number of errors the function
                                   // corrected when decoding the QR code.
    public int dimensions; // The number of rows and columns that are populated
                           // for the QR code, measured in cells.
    public int version; // The version of the QR code.
    public QRModelType modelType; // This option allows you to specify what type
                                  // of QR code this is.
    public QRStreamMode streamMode; // The format of the data encoded in the
                                    // stream.
    public QRPolarities matrixPolarity; // The polarity of the QR code.
    public int mirrored; // This element is TRUE if the QR code appears mirrored
                         // in the image and FALSE if the QR code appears
                         // normally in the image.
    public int positionInAppendStream; // Indicates what position the QR code is
                                       // in with respect to the stream of data
                                       // in all codes.
    public int sizeOfAppendStream; // Specifies how many QR codes are part of a
                                   // larger array of codes.
    public int firstEAN128ApplicationID; // The first EAN-128 Application ID
                                         // encountered in the stream.
    public int firstECIDesignator; // The first Regional Language Designator
                                   // encountered in the stream.
    public int appendStreamIdentifier; // Specifies what stream the QR code is
                                       // in relation to when the code is part
                                       // of a larger array of codes.
    public int minimumEdgeStrength; // The strength of the weakest edge the
                                    // function used to find the coarse location
                                    // of the QR code in the image.
    public QRDemodulationMode demodulationMode; // The demodulation mode the
                                                // function used to locate the
                                                // QR code.
    public QRCellSampleSize cellSampleSize; // The cell sample size the function
                                            // used to locate the QR code.
    public QRCellFilterMode cellFilterMode; // The cell filter mode the function
                                            // used to locate the QR code.
    private ByteBuffer data_buf;
    private ByteBuffer tokenizedData_buf;

    private void init() {
      data = new byte[0];
      boundingBox = new PointFloat[4];

      for (int i = 0, off = 12; i < 4; i++, off += 8)
        boundingBox[i] = new PointFloat(backing, off);
      tokenizedData = new QRCodeDataToken[0];
    }

    public QRCodeReport() {
      super(136);
      init();
    }

    public QRCodeReport(int found, byte[] data, PointFloat[] boundingBox,
        QRCodeDataToken[] tokenizedData, int numErrorsCorrected, int dimensions, int version,
        QRModelType modelType, QRStreamMode streamMode, QRPolarities matrixPolarity, int mirrored,
        int positionInAppendStream, int sizeOfAppendStream, int firstEAN128ApplicationID,
        int firstECIDesignator, int appendStreamIdentifier, int minimumEdgeStrength,
        QRDemodulationMode demodulationMode, QRCellSampleSize cellSampleSize,
        QRCellFilterMode cellFilterMode) {
      super(136);
      this.found = found;
      this.data = data;
      this.boundingBox = boundingBox;
      this.tokenizedData = tokenizedData;
      this.numErrorsCorrected = numErrorsCorrected;
      this.dimensions = dimensions;
      this.version = version;
      this.modelType = modelType;
      this.streamMode = streamMode;
      this.matrixPolarity = matrixPolarity;
      this.mirrored = mirrored;
      this.positionInAppendStream = positionInAppendStream;
      this.sizeOfAppendStream = sizeOfAppendStream;
      this.firstEAN128ApplicationID = firstEAN128ApplicationID;
      this.firstECIDesignator = firstECIDesignator;
      this.appendStreamIdentifier = appendStreamIdentifier;
      this.minimumEdgeStrength = minimumEdgeStrength;
      this.demodulationMode = demodulationMode;
      this.cellSampleSize = cellSampleSize;
      this.cellFilterMode = cellFilterMode;
    }

    protected QRCodeReport(ByteBuffer backing, int offset) {
      super(backing, offset, 136);
      init();
    }

    protected QRCodeReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 136);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 136);
    }

    public void read() {
      found = backing.getInt(0);
      int data_dataLength = backing.getInt(8);
      long data_addr = getPointer(backing, 4);
      data = new byte[data_dataLength];
      if (data_dataLength > 0 && data_addr != 0) {
        getBytes(newDirectByteBuffer(data_addr, data_dataLength), data, 0, data_dataLength);
      }
      for (PointFloat it : boundingBox) {
        it.read();
      }
      int tokenizedData_sizeOfTokenizedData = backing.getInt(48);
      long tokenizedData_addr = getPointer(backing, 44);
      tokenizedData = new QRCodeDataToken[tokenizedData_sizeOfTokenizedData];
      if (tokenizedData_sizeOfTokenizedData > 0 && tokenizedData_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(tokenizedData_addr, tokenizedData_sizeOfTokenizedData * 16);
        for (int i = 0, off = 0; i < tokenizedData_sizeOfTokenizedData; i++, off += 16) {
          tokenizedData[i] = new QRCodeDataToken(bb, off);
          tokenizedData[i].read();
        }
      }
      numErrorsCorrected = backing.getInt(52);
      dimensions = backing.getInt(56);
      version = backing.getInt(60);
      modelType = QRModelType.fromValue(backing.getInt(64));
      streamMode = QRStreamMode.fromValue(backing.getInt(68));
      matrixPolarity = QRPolarities.fromValue(backing.getInt(72));
      mirrored = backing.getInt(80);
      positionInAppendStream = backing.getInt(84);
      sizeOfAppendStream = backing.getInt(88);
      firstEAN128ApplicationID = backing.getInt(92);
      firstECIDesignator = backing.getInt(96);
      appendStreamIdentifier = backing.getInt(100);
      minimumEdgeStrength = backing.getInt(104);
      demodulationMode = QRDemodulationMode.fromValue(backing.getInt(112));
      cellSampleSize = QRCellSampleSize.fromValue(backing.getInt(120));
      cellFilterMode = QRCellFilterMode.fromValue(backing.getInt(128));
    }

    public void write() {
      backing.putInt(0, found);
      data_buf = ByteBuffer.allocateDirect(data.length);
      putBytes(data_buf, data, 0, data.length);
      backing.putInt(8, data.length);
      putPointer(backing, 4, data_buf);
      for (PointFloat it : boundingBox) {
        it.write();
      }
      tokenizedData_buf =
          ByteBuffer.allocateDirect(tokenizedData.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < tokenizedData.length; i++, off += 16) {
        tokenizedData[i].setBuffer(tokenizedData_buf, off);
        tokenizedData[i].write();
      }
      backing.putInt(48, tokenizedData.length);
      putPointer(backing, 44, tokenizedData_buf);
      backing.putInt(52, numErrorsCorrected);
      backing.putInt(56, dimensions);
      backing.putInt(60, version);
      if (modelType != null)
        backing.putInt(64, modelType.getValue());
      if (streamMode != null)
        backing.putInt(68, streamMode.getValue());
      if (matrixPolarity != null)
        backing.putInt(72, matrixPolarity.getValue());
      backing.putInt(80, mirrored);
      backing.putInt(84, positionInAppendStream);
      backing.putInt(88, sizeOfAppendStream);
      backing.putInt(92, firstEAN128ApplicationID);
      backing.putInt(96, firstECIDesignator);
      backing.putInt(100, appendStreamIdentifier);
      backing.putInt(104, minimumEdgeStrength);
      if (demodulationMode != null)
        backing.putInt(112, demodulationMode.getValue());
      if (cellSampleSize != null)
        backing.putInt(120, cellSampleSize.getValue());
      if (cellFilterMode != null)
        backing.putInt(128, cellFilterMode.getValue());
    }

    public int size() {
      return 136;
    }
  }

  public static class AIMGradeReport extends DisposedStruct {
    public AIMGrade overallGrade; // The overall letter grade, which is equal to
                                  // the lowest of the other five letter grades.
    public AIMGrade decodingGrade; // The letter grade assigned to a Data Matrix
                                   // barcode based on the success of the
                                   // function in decoding the Data Matrix
                                   // barcode.
    public AIMGrade symbolContrastGrade; // The letter grade assigned to a Data
                                         // Matrix barcode based on the symbol
                                         // contrast raw score.
    public float symbolContrast; // The symbol contrast raw score representing
                                 // the percentage difference between the mean
                                 // of the reflectance of the darkest 10 percent
                                 // and lightest 10 percent of the Data Matrix
                                 // barcode.
    public AIMGrade printGrowthGrade; // The print growth letter grade for the
                                      // Data Matrix barcode.
    public float printGrowth; // The print growth raw score for the barcode,
                              // which is based on the extent to which dark or
                              // light markings appropriately fill their module
                              // boundaries.
    public AIMGrade axialNonuniformityGrade; // The axial nonuniformity grade
                                             // for the Data Matrix barcode.
    public float axialNonuniformity; // The axial nonuniformity raw score for
                                     // the barcode, which is based on how much
                                     // the sampling point spacing differs from
                                     // one axis to another.
    public AIMGrade unusedErrorCorrectionGrade; // The unused error correction
                                                // letter grade for the Data
                                                // Matrix barcode.
    public float unusedErrorCorrection; // The unused error correction raw score
                                        // for the Data Matrix barcode, which is
                                        // based on the extent to which regional
                                        // or spot damage in the Data Matrix
                                        // barcode has eroded the reading safety
                                        // margin provided by the error
                                        // correction.

    private void init() {

    }

    public AIMGradeReport() {
      super(40);
      init();
    }

    public AIMGradeReport(AIMGrade overallGrade, AIMGrade decodingGrade,
        AIMGrade symbolContrastGrade, double symbolContrast, AIMGrade printGrowthGrade,
        double printGrowth, AIMGrade axialNonuniformityGrade, double axialNonuniformity,
        AIMGrade unusedErrorCorrectionGrade, double unusedErrorCorrection) {
      super(40);
      this.overallGrade = overallGrade;
      this.decodingGrade = decodingGrade;
      this.symbolContrastGrade = symbolContrastGrade;
      this.symbolContrast = (float) symbolContrast;
      this.printGrowthGrade = printGrowthGrade;
      this.printGrowth = (float) printGrowth;
      this.axialNonuniformityGrade = axialNonuniformityGrade;
      this.axialNonuniformity = (float) axialNonuniformity;
      this.unusedErrorCorrectionGrade = unusedErrorCorrectionGrade;
      this.unusedErrorCorrection = (float) unusedErrorCorrection;
    }

    protected AIMGradeReport(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected AIMGradeReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      overallGrade = AIMGrade.fromValue(backing.getInt(0));
      decodingGrade = AIMGrade.fromValue(backing.getInt(4));
      symbolContrastGrade = AIMGrade.fromValue(backing.getInt(8));
      symbolContrast = backing.getFloat(12);
      printGrowthGrade = AIMGrade.fromValue(backing.getInt(16));
      printGrowth = backing.getFloat(20);
      axialNonuniformityGrade = AIMGrade.fromValue(backing.getInt(24));
      axialNonuniformity = backing.getFloat(28);
      unusedErrorCorrectionGrade = AIMGrade.fromValue(backing.getInt(32));
      unusedErrorCorrection = backing.getFloat(36);
    }

    public void write() {
      if (overallGrade != null)
        backing.putInt(0, overallGrade.getValue());
      if (decodingGrade != null)
        backing.putInt(4, decodingGrade.getValue());
      if (symbolContrastGrade != null)
        backing.putInt(8, symbolContrastGrade.getValue());
      backing.putFloat(12, symbolContrast);
      if (printGrowthGrade != null)
        backing.putInt(16, printGrowthGrade.getValue());
      backing.putFloat(20, printGrowth);
      if (axialNonuniformityGrade != null)
        backing.putInt(24, axialNonuniformityGrade.getValue());
      backing.putFloat(28, axialNonuniformity);
      if (unusedErrorCorrectionGrade != null)
        backing.putInt(32, unusedErrorCorrectionGrade.getValue());
      backing.putFloat(36, unusedErrorCorrection);
    }

    public int size() {
      return 40;
    }
  }

  public static class DataMatrixSizeOptions extends DisposedStruct {
    public int minSize; // Specifies the minimum size (in pixels) of the Data
                        // Matrix barcode in the image.
    public int maxSize; // Specifies the maximum size (in pixels) of the Data
                        // Matrix barcode in the image.
    public int quietZoneWidth; // Specifies the expected minimum size of the
                               // quiet zone, in pixels.

    private void init() {

    }

    public DataMatrixSizeOptions() {
      super(12);
      init();
    }

    public DataMatrixSizeOptions(int minSize, int maxSize, int quietZoneWidth) {
      super(12);
      this.minSize = minSize;
      this.maxSize = maxSize;
      this.quietZoneWidth = quietZoneWidth;
    }

    protected DataMatrixSizeOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected DataMatrixSizeOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      minSize = backing.getInt(0);
      maxSize = backing.getInt(4);
      quietZoneWidth = backing.getInt(8);
    }

    public void write() {
      backing.putInt(0, minSize);
      backing.putInt(4, maxSize);
      backing.putInt(8, quietZoneWidth);
    }

    public int size() {
      return 12;
    }
  }

  public static class DataMatrixDescriptionOptions extends DisposedStruct {
    public float aspectRatio; // Specifies the ratio of the width of each Data
                              // Matrix barcode cell (in pixels) to the height
                              // of the Data Matrix barcode (in pixels).
    public int rows; // Specifies the number of rows in the Data Matrix barcode.
    public int columns; // Specifies the number of columns in the Data Matrix
                        // barcode.
    public int rectangle; // Set this element to TRUE to specify that the Data
                          // Matrix barcode is rectangular.
    public DataMatrixECC ecc; // Specifies the ECC used for this Data Matrix
                              // barcode.
    public DataMatrixPolarity polarity; // Specifies the data-to-background
                                        // contrast for the Data Matrix barcode.
    public DataMatrixCellFillMode cellFill; // Specifies the fill percentage for
                                            // a cell of the Data Matrix barcode
                                            // that is in the "ON" state.
    public float minBorderIntegrity; // Specifies the minimum percentage of the
                                     // border (locator pattern and timing
                                     // pattern) the function should expect in
                                     // the Data Matrix barcode.
    public DataMatrixMirrorMode mirrorMode; // Specifies if the Data Matrix
                                            // barcode appears normally in the
                                            // image or if the barcode appears
                                            // mirrored in the image.

    private void init() {

    }

    public DataMatrixDescriptionOptions() {
      super(56);
      init();
    }

    public DataMatrixDescriptionOptions(double aspectRatio, int rows, int columns, int rectangle,
        DataMatrixECC ecc, DataMatrixPolarity polarity, DataMatrixCellFillMode cellFill,
        double minBorderIntegrity, DataMatrixMirrorMode mirrorMode) {
      super(56);
      this.aspectRatio = (float) aspectRatio;
      this.rows = rows;
      this.columns = columns;
      this.rectangle = rectangle;
      this.ecc = ecc;
      this.polarity = polarity;
      this.cellFill = cellFill;
      this.minBorderIntegrity = (float) minBorderIntegrity;
      this.mirrorMode = mirrorMode;
    }

    protected DataMatrixDescriptionOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 56);
      init();
    }

    protected DataMatrixDescriptionOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 56);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 56);
    }

    public void read() {
      aspectRatio = backing.getFloat(0);
      rows = backing.getInt(4);
      columns = backing.getInt(8);
      rectangle = backing.getInt(12);
      ecc = DataMatrixECC.fromValue(backing.getInt(16));
      polarity = DataMatrixPolarity.fromValue(backing.getInt(24));
      cellFill = DataMatrixCellFillMode.fromValue(backing.getInt(32));
      minBorderIntegrity = backing.getFloat(40);
      mirrorMode = DataMatrixMirrorMode.fromValue(backing.getInt(48));
    }

    public void write() {
      backing.putFloat(0, aspectRatio);
      backing.putInt(4, rows);
      backing.putInt(8, columns);
      backing.putInt(12, rectangle);
      if (ecc != null)
        backing.putInt(16, ecc.getValue());
      if (polarity != null)
        backing.putInt(24, polarity.getValue());
      if (cellFill != null)
        backing.putInt(32, cellFill.getValue());
      backing.putFloat(40, minBorderIntegrity);
      if (mirrorMode != null)
        backing.putInt(48, mirrorMode.getValue());
    }

    public int size() {
      return 56;
    }
  }

  public static class DataMatrixSearchOptions extends DisposedStruct {
    public DataMatrixRotationMode rotationMode; // Specifies the amount of Data
                                                // Matrix barcode rotation the
                                                // function should allow for.
    public int skipLocation; // If set to TRUE, specifies that the function
                             // should assume that the Data Matrix barcode
                             // occupies the entire image (or the entire search
                             // region).
    public int edgeThreshold; // Specifies the minimum contrast a pixel must
                              // have in order to be considered part of a matrix
                              // cell edge.
    public DataMatrixDemodulationMode demodulationMode; // Specifies the mode
                                                        // the function should
                                                        // use to demodulate
                                                        // (determine which
                                                        // cells are on and
                                                        // which cells are off)
                                                        // the Data Matrix
                                                        // barcode.
    public DataMatrixCellSampleSize cellSampleSize; // Specifies the sample
                                                    // size, in pixels, the
                                                    // function should take to
                                                    // determine if each cell is
                                                    // on or off.
    public DataMatrixCellFilterMode cellFilterMode; // Specifies the mode the
                                                    // function uses to
                                                    // determine the pixel value
                                                    // for each cell.
    public int skewDegreesAllowed; // Specifies the amount of skew in the Data
                                   // Matrix barcode the function should allow
                                   // for.
    public int maxIterations; // Specifies the maximum number of iterations
                              // before the function stops looking for the Data
                              // Matrix barcode.
    public int initialSearchVectorWidth; // Specifies the number of pixels the
                                         // function should average together to
                                         // determine the location of an edge.

    private void init() {

    }

    public DataMatrixSearchOptions() {
      super(56);
      init();
    }

    public DataMatrixSearchOptions(DataMatrixRotationMode rotationMode, int skipLocation,
        int edgeThreshold, DataMatrixDemodulationMode demodulationMode,
        DataMatrixCellSampleSize cellSampleSize, DataMatrixCellFilterMode cellFilterMode,
        int skewDegreesAllowed, int maxIterations, int initialSearchVectorWidth) {
      super(56);
      this.rotationMode = rotationMode;
      this.skipLocation = skipLocation;
      this.edgeThreshold = edgeThreshold;
      this.demodulationMode = demodulationMode;
      this.cellSampleSize = cellSampleSize;
      this.cellFilterMode = cellFilterMode;
      this.skewDegreesAllowed = skewDegreesAllowed;
      this.maxIterations = maxIterations;
      this.initialSearchVectorWidth = initialSearchVectorWidth;
    }

    protected DataMatrixSearchOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 56);
      init();
    }

    protected DataMatrixSearchOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 56);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 56);
    }

    public void read() {
      rotationMode = DataMatrixRotationMode.fromValue(backing.getInt(0));
      skipLocation = backing.getInt(4);
      edgeThreshold = backing.getInt(8);
      demodulationMode = DataMatrixDemodulationMode.fromValue(backing.getInt(16));
      cellSampleSize = DataMatrixCellSampleSize.fromValue(backing.getInt(24));
      cellFilterMode = DataMatrixCellFilterMode.fromValue(backing.getInt(32));
      skewDegreesAllowed = backing.getInt(40);
      maxIterations = backing.getInt(44);
      initialSearchVectorWidth = backing.getInt(48);
    }

    public void write() {
      if (rotationMode != null)
        backing.putInt(0, rotationMode.getValue());
      backing.putInt(4, skipLocation);
      backing.putInt(8, edgeThreshold);
      if (demodulationMode != null)
        backing.putInt(16, demodulationMode.getValue());
      if (cellSampleSize != null)
        backing.putInt(24, cellSampleSize.getValue());
      if (cellFilterMode != null)
        backing.putInt(32, cellFilterMode.getValue());
      backing.putInt(40, skewDegreesAllowed);
      backing.putInt(44, maxIterations);
      backing.putInt(48, initialSearchVectorWidth);
    }

    public int size() {
      return 56;
    }
  }

  public static class DataMatrixReport extends DisposedStruct {
    public int found; // This element is TRUE if the function located and
                      // decoded a Data Matrix barcode and FALSE if the function
                      // failed to locate and decode a Data Matrix barcode.
    public int binary; // This element is TRUE if the Data Matrix barcode
                       // contains binary data and FALSE if the Data Matrix
                       // barcode contains text data.
    public byte[] data; // The data encoded in the Data Matrix barcode.
    public PointFloat[] boundingBox; // An array of four points describing the
                                     // rectangle surrounding the Data Matrix
                                     // barcode.
    public int numErrorsCorrected; // The number of errors the function
                                   // corrected when decoding the Data Matrix
                                   // barcode.
    public int numErasuresCorrected; // The number of erasures the function
                                     // corrected when decoding the Data Matrix
                                     // barcode.
    public float aspectRatio; // Specifies the aspect ratio of the Data Matrix
                              // barcode in the image, which equals the ratio of
                              // the width of a Data Matrix barcode cell (in
                              // pixels) to the height of a Data Matrix barcode
                              // cell (in pixels).
    public int rows; // The number of rows in the Data Matrix barcode.
    public int columns; // The number of columns in the Data Matrix barcode.
    public DataMatrixECC ecc; // The Error Correction Code (ECC) used by the
                              // Data Matrix barcode.
    public DataMatrixPolarity polarity; // The polarity of the Data Matrix
                                        // barcode.
    public DataMatrixCellFillMode cellFill; // The cell fill percentage of the
                                            // Data Matrix barcode.
    public float borderIntegrity; // The percentage of the Data Matrix barcode
                                  // border that appears correctly in the image.
    public int mirrored; // This element is TRUE if the Data Matrix barcode
                         // appears mirrored in the image and FALSE if the Data
                         // Matrix barcode appears normally in the image.
    public int minimumEdgeStrength; // The strength of the weakest edge the
                                    // function used to find the coarse location
                                    // of the Data Matrix barcode in the image.
    public DataMatrixDemodulationMode demodulationMode; // The demodulation mode
                                                        // the function used to
                                                        // locate the Data
                                                        // Matrix barcode.
    public DataMatrixCellSampleSize cellSampleSize; // The cell sample size the
                                                    // function used to locate
                                                    // the Data Matrix barcode.
    public DataMatrixCellFilterMode cellFilterMode; // The cell filter mode the
                                                    // function used to locate
                                                    // the Data Matrix barcode.
    public int iterations; // The number of iterations the function took in
                           // attempting to locate the Data Matrix barcode.
    private ByteBuffer data_buf;

    private void init() {
      data = new byte[0];
      boundingBox = new PointFloat[4];

      for (int i = 0, off = 16; i < 4; i++, off += 8)
        boundingBox[i] = new PointFloat(backing, off);
    }

    public DataMatrixReport() {
      super(144);
      init();
    }

    public DataMatrixReport(int found, int binary, byte[] data, PointFloat[] boundingBox,
        int numErrorsCorrected, int numErasuresCorrected, double aspectRatio, int rows,
        int columns, DataMatrixECC ecc, DataMatrixPolarity polarity,
        DataMatrixCellFillMode cellFill, double borderIntegrity, int mirrored,
        int minimumEdgeStrength, DataMatrixDemodulationMode demodulationMode,
        DataMatrixCellSampleSize cellSampleSize, DataMatrixCellFilterMode cellFilterMode,
        int iterations) {
      super(144);
      this.found = found;
      this.binary = binary;
      this.data = data;
      this.boundingBox = boundingBox;
      this.numErrorsCorrected = numErrorsCorrected;
      this.numErasuresCorrected = numErasuresCorrected;
      this.aspectRatio = (float) aspectRatio;
      this.rows = rows;
      this.columns = columns;
      this.ecc = ecc;
      this.polarity = polarity;
      this.cellFill = cellFill;
      this.borderIntegrity = (float) borderIntegrity;
      this.mirrored = mirrored;
      this.minimumEdgeStrength = minimumEdgeStrength;
      this.demodulationMode = demodulationMode;
      this.cellSampleSize = cellSampleSize;
      this.cellFilterMode = cellFilterMode;
      this.iterations = iterations;
    }

    protected DataMatrixReport(ByteBuffer backing, int offset) {
      super(backing, offset, 144);
      init();
    }

    protected DataMatrixReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 144);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 144);
    }

    public void read() {
      found = backing.getInt(0);
      binary = backing.getInt(4);
      int data_dataLength = backing.getInt(12);
      long data_addr = getPointer(backing, 8);
      data = new byte[data_dataLength];
      if (data_dataLength > 0 && data_addr != 0) {
        getBytes(newDirectByteBuffer(data_addr, data_dataLength), data, 0, data_dataLength);
      }
      for (PointFloat it : boundingBox) {
        it.read();
      }
      numErrorsCorrected = backing.getInt(48);
      numErasuresCorrected = backing.getInt(52);
      aspectRatio = backing.getFloat(56);
      rows = backing.getInt(60);
      columns = backing.getInt(64);
      ecc = DataMatrixECC.fromValue(backing.getInt(72));
      polarity = DataMatrixPolarity.fromValue(backing.getInt(80));
      cellFill = DataMatrixCellFillMode.fromValue(backing.getInt(88));
      borderIntegrity = backing.getFloat(96);
      mirrored = backing.getInt(100);
      minimumEdgeStrength = backing.getInt(104);
      demodulationMode = DataMatrixDemodulationMode.fromValue(backing.getInt(112));
      cellSampleSize = DataMatrixCellSampleSize.fromValue(backing.getInt(120));
      cellFilterMode = DataMatrixCellFilterMode.fromValue(backing.getInt(128));
      iterations = backing.getInt(136);
    }

    public void write() {
      backing.putInt(0, found);
      backing.putInt(4, binary);
      data_buf = ByteBuffer.allocateDirect(data.length);
      putBytes(data_buf, data, 0, data.length);
      backing.putInt(12, data.length);
      putPointer(backing, 8, data_buf);
      for (PointFloat it : boundingBox) {
        it.write();
      }
      backing.putInt(48, numErrorsCorrected);
      backing.putInt(52, numErasuresCorrected);
      backing.putFloat(56, aspectRatio);
      backing.putInt(60, rows);
      backing.putInt(64, columns);
      if (ecc != null)
        backing.putInt(72, ecc.getValue());
      if (polarity != null)
        backing.putInt(80, polarity.getValue());
      if (cellFill != null)
        backing.putInt(88, cellFill.getValue());
      backing.putFloat(96, borderIntegrity);
      backing.putInt(100, mirrored);
      backing.putInt(104, minimumEdgeStrength);
      if (demodulationMode != null)
        backing.putInt(112, demodulationMode.getValue());
      if (cellSampleSize != null)
        backing.putInt(120, cellSampleSize.getValue());
      if (cellFilterMode != null)
        backing.putInt(128, cellFilterMode.getValue());
      backing.putInt(136, iterations);
    }

    public int size() {
      return 144;
    }
  }

  public static class JPEG2000FileAdvancedOptions extends DisposedStruct {
    public WaveletTransformMode waveletMode; // Determines which wavelet
                                             // transform to use when writing
                                             // the file.
    public int useMultiComponentTransform; // Set this parameter to TRUE to use
                                           // an additional transform on RGB
                                           // images.
    public int maxWaveletTransformLevel; // Specifies the maximum allowed level
                                         // of wavelet transform.
    public float quantizationStepSize; // Specifies the absolute base
                                       // quantization step size for derived
                                       // quantization mode.

    private void init() {

    }

    public JPEG2000FileAdvancedOptions() {
      super(16);
      init();
    }

    public JPEG2000FileAdvancedOptions(WaveletTransformMode waveletMode,
        int useMultiComponentTransform, int maxWaveletTransformLevel, double quantizationStepSize) {
      super(16);
      this.waveletMode = waveletMode;
      this.useMultiComponentTransform = useMultiComponentTransform;
      this.maxWaveletTransformLevel = maxWaveletTransformLevel;
      this.quantizationStepSize = (float) quantizationStepSize;
    }

    protected JPEG2000FileAdvancedOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected JPEG2000FileAdvancedOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      waveletMode = WaveletTransformMode.fromValue(backing.getInt(0));
      useMultiComponentTransform = backing.getInt(4);
      maxWaveletTransformLevel = backing.getInt(8);
      quantizationStepSize = backing.getFloat(12);
    }

    public void write() {
      if (waveletMode != null)
        backing.putInt(0, waveletMode.getValue());
      backing.putInt(4, useMultiComponentTransform);
      backing.putInt(8, maxWaveletTransformLevel);
      backing.putFloat(12, quantizationStepSize);
    }

    public int size() {
      return 16;
    }
  }

  public static class MatchGeometricPatternAdvancedOptions2 extends DisposedStruct {
    public int minFeaturesUsed; // Specifies the minimum number of features the
                                // function uses when matching.
    public int maxFeaturesUsed; // Specifies the maximum number of features the
                                // function uses when matching.
    public int subpixelIterations; // Specifies the maximum number of
                                   // incremental improvements used to refine
                                   // matches with subpixel information.
    public double subpixelTolerance; // Specifies the maximum amount of change,
                                     // in pixels, between consecutive
                                     // incremental improvements in the match
                                     // position before the function stops
                                     // refining the match position.
    public int initialMatchListLength; // Specifies the maximum size of the
                                       // match list.
    public float matchTemplateCurveScore; // Set this element to TRUE to specify
                                          // that the function should calculate
                                          // the match curve to template curve
                                          // score and return it for each match
                                          // result.
    public int correlationScore; // Set this element to TRUE to specify that the
                                 // function should calculate the correlation
                                 // score and return it for each match result.
    public double minMatchSeparationDistance; // Specifies the minimum
                                              // separation distance, in pixels,
                                              // between the origins of two
                                              // matches that have unique
                                              // positions.
    public double minMatchSeparationAngle; // Specifies the minimum angular
                                           // difference, in degrees, between
                                           // two matches that have unique
                                           // angles.
    public double minMatchSeparationScale; // Specifies the minimum difference
                                           // in scale, expressed as a
                                           // percentage, between two matches
                                           // that have unique scales.
    public double maxMatchOverlap; // Specifies the maximum amount of overlap,
                                   // expressed as a percentage, allowed between
                                   // the bounding rectangles of two unique
                                   // matches.
    public int coarseResult; // Specifies whether you want the function to spend
                             // less time accurately estimating the location of
                             // a match.
    public int smoothContours; // Set this element to TRUE to specify smoothing
                               // be done on the contours of the inspection
                               // image before feature extraction.
    public int enableCalibrationSupport; // Set this element to TRUE to specify
                                         // the algorithm treat the inspection
                                         // image as a calibrated image.

    private void init() {

    }

    public MatchGeometricPatternAdvancedOptions2() {
      super(88);
      init();
    }

    public MatchGeometricPatternAdvancedOptions2(int minFeaturesUsed, int maxFeaturesUsed,
        int subpixelIterations, double subpixelTolerance, int initialMatchListLength,
        double matchTemplateCurveScore, int correlationScore, double minMatchSeparationDistance,
        double minMatchSeparationAngle, double minMatchSeparationScale, double maxMatchOverlap,
        int coarseResult, int smoothContours, int enableCalibrationSupport) {
      super(88);
      this.minFeaturesUsed = minFeaturesUsed;
      this.maxFeaturesUsed = maxFeaturesUsed;
      this.subpixelIterations = subpixelIterations;
      this.subpixelTolerance = subpixelTolerance;
      this.initialMatchListLength = initialMatchListLength;
      this.matchTemplateCurveScore = (float) matchTemplateCurveScore;
      this.correlationScore = correlationScore;
      this.minMatchSeparationDistance = minMatchSeparationDistance;
      this.minMatchSeparationAngle = minMatchSeparationAngle;
      this.minMatchSeparationScale = minMatchSeparationScale;
      this.maxMatchOverlap = maxMatchOverlap;
      this.coarseResult = coarseResult;
      this.smoothContours = smoothContours;
      this.enableCalibrationSupport = enableCalibrationSupport;
    }

    protected MatchGeometricPatternAdvancedOptions2(ByteBuffer backing, int offset) {
      super(backing, offset, 88);
      init();
    }

    protected MatchGeometricPatternAdvancedOptions2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 88);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 88);
    }

    public void read() {
      minFeaturesUsed = backing.getInt(0);
      maxFeaturesUsed = backing.getInt(4);
      subpixelIterations = backing.getInt(8);
      subpixelTolerance = backing.getDouble(16);
      initialMatchListLength = backing.getInt(24);
      matchTemplateCurveScore = backing.getFloat(28);
      correlationScore = backing.getInt(32);
      minMatchSeparationDistance = backing.getDouble(40);
      minMatchSeparationAngle = backing.getDouble(48);
      minMatchSeparationScale = backing.getDouble(56);
      maxMatchOverlap = backing.getDouble(64);
      coarseResult = backing.getInt(72);
      smoothContours = backing.getInt(76);
      enableCalibrationSupport = backing.getInt(80);
    }

    public void write() {
      backing.putInt(0, minFeaturesUsed);
      backing.putInt(4, maxFeaturesUsed);
      backing.putInt(8, subpixelIterations);
      backing.putDouble(16, subpixelTolerance);
      backing.putInt(24, initialMatchListLength);
      backing.putFloat(28, matchTemplateCurveScore);
      backing.putInt(32, correlationScore);
      backing.putDouble(40, minMatchSeparationDistance);
      backing.putDouble(48, minMatchSeparationAngle);
      backing.putDouble(56, minMatchSeparationScale);
      backing.putDouble(64, maxMatchOverlap);
      backing.putInt(72, coarseResult);
      backing.putInt(76, smoothContours);
      backing.putInt(80, enableCalibrationSupport);
    }

    public int size() {
      return 88;
    }
  }

  public static class InspectionAlignment extends DisposedStruct {
    public PointFloat position; // The location of the center of the golden
                                // template in the image under inspection.
    public float rotation; // The rotation of the golden template in the image
                           // under inspection, in degrees.
    public float scale; // The percentage of the size of the area under
                        // inspection compared to the size of the golden
                        // template.

    private void init() {
      position = new PointFloat(backing, 0);
    }

    public InspectionAlignment() {
      super(16);
      init();
    }

    public InspectionAlignment(PointFloat position, double rotation, double scale) {
      super(16);
      this.position = position;
      this.rotation = (float) rotation;
      this.scale = (float) scale;
    }

    protected InspectionAlignment(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected InspectionAlignment(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      position.read();
      rotation = backing.getFloat(8);
      scale = backing.getFloat(12);
    }

    public void write() {
      position.write();
      backing.putFloat(8, rotation);
      backing.putFloat(12, scale);
    }

    public int size() {
      return 16;
    }
  }

  public static class InspectionOptions extends DisposedStruct {
    public RegistrationMethod registrationMethod; // Specifies how the function
                                                  // registers the golden
                                                  // template and the target
                                                  // image.
    public NormalizationMethod normalizationMethod; // Specifies how the
                                                    // function normalizes the
                                                    // golden template to the
                                                    // target image.
    public int edgeThicknessToIgnore; // Specifies desired thickness of edges to
                                      // be ignored.
    public float brightThreshold; // Specifies the threshold for areas where the
                                  // target image is brighter than the golden
                                  // template.
    public float darkThreshold; // Specifies the threshold for areas where the
                                // target image is darker than the golden
                                // template.
    public int binary; // Specifies whether the function should return a binary
                       // image giving the location of defects, or a grayscale
                       // image giving the intensity of defects.

    private void init() {

    }

    public InspectionOptions() {
      super(24);
      init();
    }

    public InspectionOptions(RegistrationMethod registrationMethod,
        NormalizationMethod normalizationMethod, int edgeThicknessToIgnore, double brightThreshold,
        double darkThreshold, int binary) {
      super(24);
      this.registrationMethod = registrationMethod;
      this.normalizationMethod = normalizationMethod;
      this.edgeThicknessToIgnore = edgeThicknessToIgnore;
      this.brightThreshold = (float) brightThreshold;
      this.darkThreshold = (float) darkThreshold;
      this.binary = binary;
    }

    protected InspectionOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected InspectionOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      registrationMethod = RegistrationMethod.fromValue(backing.getInt(0));
      normalizationMethod = NormalizationMethod.fromValue(backing.getInt(4));
      edgeThicknessToIgnore = backing.getInt(8);
      brightThreshold = backing.getFloat(12);
      darkThreshold = backing.getFloat(16);
      binary = backing.getInt(20);
    }

    public void write() {
      if (registrationMethod != null)
        backing.putInt(0, registrationMethod.getValue());
      if (normalizationMethod != null)
        backing.putInt(4, normalizationMethod.getValue());
      backing.putInt(8, edgeThicknessToIgnore);
      backing.putFloat(12, brightThreshold);
      backing.putFloat(16, darkThreshold);
      backing.putInt(20, binary);
    }

    public int size() {
      return 24;
    }
  }

  public static class CharReport2 extends DisposedStruct {
    public String character; // The character value.
    public PointFloat[] corner; // An array of four points that describes the
                                // rectangle that surrounds the character.
    public int lowThreshold; // The minimum value of the threshold range used
                             // for this character.
    public int highThreshold; // The maximum value of the threshold range used
                              // for this character.
    public int classificationScore; // The degree to which the assigned
                                    // character class represents the object
                                    // better than the other character classes
                                    // in the character set.
    public int verificationScore; // The similarity of the character and the
                                  // reference character for the character
                                  // class.
    public int verified; // This element is TRUE if a reference character was
                         // found for the character class and FALSE if a
                         // reference character was not found.
    private ByteBuffer character_buf;

    private void init() {
      corner = new PointFloat[4];

      for (int i = 0, off = 4; i < 4; i++, off += 8)
        corner[i] = new PointFloat(backing, off);
    }

    public CharReport2() {
      super(56);
      init();
    }

    public CharReport2(String character, PointFloat[] corner, int lowThreshold, int highThreshold,
        int classificationScore, int verificationScore, int verified) {
      super(56);
      this.character = character;
      this.corner = corner;
      this.lowThreshold = lowThreshold;
      this.highThreshold = highThreshold;
      this.classificationScore = classificationScore;
      this.verificationScore = verificationScore;
      this.verified = verified;
    }

    protected CharReport2(ByteBuffer backing, int offset) {
      super(backing, offset, 56);
      init();
    }

    protected CharReport2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 56);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 56);
    }

    public void read() {
      long character_addr = getPointer(backing, 0);
      if (character_addr == 0)
        character = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(character_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          character = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          character = "";
        }
      }

      for (PointFloat it : corner) {
        it.read();
      }
      lowThreshold = backing.getInt(36);
      highThreshold = backing.getInt(40);
      classificationScore = backing.getInt(44);
      verificationScore = backing.getInt(48);
      verified = backing.getInt(52);
    }

    public void write() {
      if (character != null) {
        byte[] character_bytes;
        try {
          character_bytes = character.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          character_bytes = new byte[0];
        }
        character_buf = ByteBuffer.allocateDirect(character_bytes.length + 1);
        putBytes(character_buf, character_bytes, 0, character_bytes.length).put(
            character_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, character == null ? 0 : getByteBufferAddress(character_buf));
      for (PointFloat it : corner) {
        it.write();
      }
      backing.putInt(36, lowThreshold);
      backing.putInt(40, highThreshold);
      backing.putInt(44, classificationScore);
      backing.putInt(48, verificationScore);
      backing.putInt(52, verified);
    }

    public int size() {
      return 56;
    }
  }

  public static class CharInfo2 extends DisposedStruct {
    public String charValue; // Retrieves the character value of the
                             // corresponding character in the character set.
    public Image charImage; // The image you used to train this character.
    public Image internalImage; // The internal representation that NI Vision
                                // uses to match objects to this character.
    public int isReferenceChar; // This element is TRUE if the character is the
                                // reference character for the character class.
    private ByteBuffer charValue_buf;

    private void init() {

    }

    public CharInfo2() {
      super(16);
      init();
    }

    public CharInfo2(String charValue, Image charImage, Image internalImage, int isReferenceChar) {
      super(16);
      this.charValue = charValue;
      this.charImage = charImage;
      this.internalImage = internalImage;
      this.isReferenceChar = isReferenceChar;
    }

    protected CharInfo2(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected CharInfo2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      long charValue_addr = getPointer(backing, 0);
      if (charValue_addr == 0)
        charValue = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(charValue_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          charValue = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          charValue = "";
        }
      }

      long charImage_addr = getPointer(backing, 4);
      if (charImage_addr == 0)
        charImage = null;
      else
        charImage = new Image(charImage_addr, false);
      long internalImage_addr = getPointer(backing, 8);
      if (internalImage_addr == 0)
        internalImage = null;
      else
        internalImage = new Image(internalImage_addr, false);
      isReferenceChar = backing.getInt(12);
    }

    public void write() {
      if (charValue != null) {
        byte[] charValue_bytes;
        try {
          charValue_bytes = charValue.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          charValue_bytes = new byte[0];
        }
        charValue_buf = ByteBuffer.allocateDirect(charValue_bytes.length + 1);
        putBytes(charValue_buf, charValue_bytes, 0, charValue_bytes.length).put(
            charValue_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, charValue == null ? 0 : getByteBufferAddress(charValue_buf));
      putPointer(backing, 4, charImage);
      putPointer(backing, 8, internalImage);
      backing.putInt(12, isReferenceChar);
    }

    public int size() {
      return 16;
    }
  }

  public static class ReadTextReport2 extends DisposedStruct {
    public String readString; // The read string.
    public CharReport2[] characterReport; // An array of reports describing the
                                          // properties of each identified
                                          // character.
    private ByteBuffer readString_buf;
    private ByteBuffer characterReport_buf;

    private void init() {
      characterReport = new CharReport2[0];
    }

    public ReadTextReport2() {
      super(12);
      init();
    }

    public ReadTextReport2(String readString, CharReport2[] characterReport) {
      super(12);
      this.readString = readString;
      this.characterReport = characterReport;
    }

    protected ReadTextReport2(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected ReadTextReport2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      long readString_addr = getPointer(backing, 0);
      if (readString_addr == 0)
        readString = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(readString_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          readString = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          readString = "";
        }
      }

      int characterReport_numCharacterReports = backing.getInt(8);
      long characterReport_addr = getPointer(backing, 4);
      characterReport = new CharReport2[characterReport_numCharacterReports];
      if (characterReport_numCharacterReports > 0 && characterReport_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(characterReport_addr, characterReport_numCharacterReports * 56);
        for (int i = 0, off = 0; i < characterReport_numCharacterReports; i++, off += 56) {
          characterReport[i] = new CharReport2(bb, off);
          characterReport[i].read();
        }
      }
    }

    public void write() {
      if (readString != null) {
        byte[] readString_bytes;
        try {
          readString_bytes = readString.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          readString_bytes = new byte[0];
        }
        readString_buf = ByteBuffer.allocateDirect(readString_bytes.length + 1);
        putBytes(readString_buf, readString_bytes, 0, readString_bytes.length).put(
            readString_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, readString == null ? 0 : getByteBufferAddress(readString_buf));
      characterReport_buf =
          ByteBuffer.allocateDirect(characterReport.length * 56).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < characterReport.length; i++, off += 56) {
        characterReport[i].setBuffer(characterReport_buf, off);
        characterReport[i].write();
      }
      backing.putInt(8, characterReport.length);
      putPointer(backing, 4, characterReport_buf);
    }

    public int size() {
      return 12;
    }
  }

  public static class EllipseFeature extends DisposedStruct {
    public PointFloat position; // The location of the center of the ellipse.
    public double rotation; // The orientation of the semi-major axis of the
                            // ellipse with respect to the horizontal.
    public double minorRadius; // The length of the semi-minor axis of the
                               // ellipse.
    public double majorRadius; // The length of the semi-major axis of the
                               // ellipse.

    private void init() {
      position = new PointFloat(backing, 0);
    }

    public EllipseFeature() {
      super(32);
      init();
    }

    public EllipseFeature(PointFloat position, double rotation, double minorRadius,
        double majorRadius) {
      super(32);
      this.position = position;
      this.rotation = rotation;
      this.minorRadius = minorRadius;
      this.majorRadius = majorRadius;
    }

    protected EllipseFeature(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected EllipseFeature(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      position.read();
      rotation = backing.getDouble(8);
      minorRadius = backing.getDouble(16);
      majorRadius = backing.getDouble(24);
    }

    public void write() {
      position.write();
      backing.putDouble(8, rotation);
      backing.putDouble(16, minorRadius);
      backing.putDouble(24, majorRadius);
    }

    public int size() {
      return 32;
    }
  }

  public static class CircleFeature extends DisposedStruct {
    public PointFloat position; // The location of the center of the circle.
    public double radius; // The radius of the circle.

    private void init() {
      position = new PointFloat(backing, 0);
    }

    public CircleFeature() {
      super(16);
      init();
    }

    public CircleFeature(PointFloat position, double radius) {
      super(16);
      this.position = position;
      this.radius = radius;
    }

    protected CircleFeature(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected CircleFeature(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      position.read();
      radius = backing.getDouble(8);
    }

    public void write() {
      position.write();
      backing.putDouble(8, radius);
    }

    public int size() {
      return 16;
    }
  }

  public static class ConstCurveFeature extends DisposedStruct {
    public PointFloat position; // The center of the circle that this constant
                                // curve lies upon.
    public double radius; // The radius of the circle that this constant curve
                          // lies upon.
    public double startAngle; // When traveling along the constant curve from
                              // one endpoint to the next in a counterclockwise
                              // manner, this is the angular component of the
                              // vector originating at the center of the
                              // constant curve and pointing towards the first
                              // endpoint of the constant curve.
    public double endAngle; // When traveling along the constant curve from one
                            // endpoint to the next in a counterclockwise
                            // manner, this is the angular component of the
                            // vector originating at the center of the constant
                            // curve and pointing towards the second endpoint of
                            // the constant curve.

    private void init() {
      position = new PointFloat(backing, 0);
    }

    public ConstCurveFeature() {
      super(32);
      init();
    }

    public ConstCurveFeature(PointFloat position, double radius, double startAngle, double endAngle) {
      super(32);
      this.position = position;
      this.radius = radius;
      this.startAngle = startAngle;
      this.endAngle = endAngle;
    }

    protected ConstCurveFeature(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected ConstCurveFeature(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      position.read();
      radius = backing.getDouble(8);
      startAngle = backing.getDouble(16);
      endAngle = backing.getDouble(24);
    }

    public void write() {
      position.write();
      backing.putDouble(8, radius);
      backing.putDouble(16, startAngle);
      backing.putDouble(24, endAngle);
    }

    public int size() {
      return 32;
    }
  }

  public static class RectangleFeature extends DisposedStruct {
    public PointFloat position; // The center of the rectangle.
    public PointFloat[] corner; // The four corners of the rectangle.
    public double rotation; // The orientation of the rectangle with respect to
                            // the horizontal.
    public double width; // The width of the rectangle.
    public double height; // The height of the rectangle.

    private void init() {
      position = new PointFloat(backing, 0);
      corner = new PointFloat[4];

      for (int i = 0, off = 8; i < 4; i++, off += 8)
        corner[i] = new PointFloat(backing, off);
    }

    public RectangleFeature() {
      super(64);
      init();
    }

    public RectangleFeature(PointFloat position, PointFloat[] corner, double rotation,
        double width, double height) {
      super(64);
      this.position = position;
      this.corner = corner;
      this.rotation = rotation;
      this.width = width;
      this.height = height;
    }

    protected RectangleFeature(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected RectangleFeature(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      position.read();
      for (PointFloat it : corner) {
        it.read();
      }
      rotation = backing.getDouble(40);
      width = backing.getDouble(48);
      height = backing.getDouble(56);
    }

    public void write() {
      position.write();
      for (PointFloat it : corner) {
        it.write();
      }
      backing.putDouble(40, rotation);
      backing.putDouble(48, width);
      backing.putDouble(56, height);
    }

    public int size() {
      return 64;
    }
  }

  public static class LegFeature extends DisposedStruct {
    public PointFloat position; // The location of the leg feature.
    public PointFloat[] corner; // The four corners of the leg feature.
    public double rotation; // The orientation of the leg with respect to the
                            // horizontal.
    public double width; // The width of the leg.
    public double height; // The height of the leg.

    private void init() {
      position = new PointFloat(backing, 0);
      corner = new PointFloat[4];

      for (int i = 0, off = 8; i < 4; i++, off += 8)
        corner[i] = new PointFloat(backing, off);
    }

    public LegFeature() {
      super(64);
      init();
    }

    public LegFeature(PointFloat position, PointFloat[] corner, double rotation, double width,
        double height) {
      super(64);
      this.position = position;
      this.corner = corner;
      this.rotation = rotation;
      this.width = width;
      this.height = height;
    }

    protected LegFeature(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected LegFeature(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      position.read();
      for (PointFloat it : corner) {
        it.read();
      }
      rotation = backing.getDouble(40);
      width = backing.getDouble(48);
      height = backing.getDouble(56);
    }

    public void write() {
      position.write();
      for (PointFloat it : corner) {
        it.write();
      }
      backing.putDouble(40, rotation);
      backing.putDouble(48, width);
      backing.putDouble(56, height);
    }

    public int size() {
      return 64;
    }
  }

  public static class CornerFeature extends DisposedStruct {
    public PointFloat position; // The location of the corner feature.
    public double rotation; // The angular component of the vector bisecting the
                            // corner from position.
    public double enclosedAngle; // The measure of the enclosed angle of the
                                 // corner.
    public int isVirtual;

    private void init() {
      position = new PointFloat(backing, 0);
    }

    public CornerFeature() {
      super(32);
      init();
    }

    public CornerFeature(PointFloat position, double rotation, double enclosedAngle, int isVirtual) {
      super(32);
      this.position = position;
      this.rotation = rotation;
      this.enclosedAngle = enclosedAngle;
      this.isVirtual = isVirtual;
    }

    protected CornerFeature(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected CornerFeature(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      position.read();
      rotation = backing.getDouble(8);
      enclosedAngle = backing.getDouble(16);
      isVirtual = backing.getInt(24);
    }

    public void write() {
      position.write();
      backing.putDouble(8, rotation);
      backing.putDouble(16, enclosedAngle);
      backing.putInt(24, isVirtual);
    }

    public int size() {
      return 32;
    }
  }

  public static class LineFeature extends DisposedStruct {
    public PointFloat startPoint; // The starting point of the line.
    public PointFloat endPoint; // The ending point of the line.
    public double length; // The length of the line measured in pixels from the
                          // start point to the end point.
    public double rotation; // The orientation of the line with respect to the
                            // horizontal.

    private void init() {
      startPoint = new PointFloat(backing, 0);
      endPoint = new PointFloat(backing, 8);
    }

    public LineFeature() {
      super(32);
      init();
    }

    public LineFeature(PointFloat startPoint, PointFloat endPoint, double length, double rotation) {
      super(32);
      this.startPoint = startPoint;
      this.endPoint = endPoint;
      this.length = length;
      this.rotation = rotation;
    }

    protected LineFeature(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected LineFeature(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      startPoint.read();
      endPoint.read();
      length = backing.getDouble(16);
      rotation = backing.getDouble(24);
    }

    public void write() {
      startPoint.write();
      endPoint.write();
      backing.putDouble(16, length);
      backing.putDouble(24, rotation);
    }

    public int size() {
      return 32;
    }
  }

  public static class ParallelLinePairFeature extends DisposedStruct {
    public PointFloat firstStartPoint; // The starting point of the first line
                                       // of the pair.
    public PointFloat firstEndPoint; // The ending point of the first line of
                                     // the pair.
    public PointFloat secondStartPoint; // The starting point of the second line
                                        // of the pair.
    public PointFloat secondEndPoint; // The ending point of the second line of
                                      // the pair.
    public double rotation; // The orientation of the feature with respect to
                            // the horizontal.
    public double distance; // The distance from the first line to the second
                            // line.

    private void init() {
      firstStartPoint = new PointFloat(backing, 0);
      firstEndPoint = new PointFloat(backing, 8);
      secondStartPoint = new PointFloat(backing, 16);
      secondEndPoint = new PointFloat(backing, 24);
    }

    public ParallelLinePairFeature() {
      super(48);
      init();
    }

    public ParallelLinePairFeature(PointFloat firstStartPoint, PointFloat firstEndPoint,
        PointFloat secondStartPoint, PointFloat secondEndPoint, double rotation, double distance) {
      super(48);
      this.firstStartPoint = firstStartPoint;
      this.firstEndPoint = firstEndPoint;
      this.secondStartPoint = secondStartPoint;
      this.secondEndPoint = secondEndPoint;
      this.rotation = rotation;
      this.distance = distance;
    }

    protected ParallelLinePairFeature(ByteBuffer backing, int offset) {
      super(backing, offset, 48);
      init();
    }

    protected ParallelLinePairFeature(long nativeObj, boolean owned) {
      super(nativeObj, owned, 48);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 48);
    }

    public void read() {
      firstStartPoint.read();
      firstEndPoint.read();
      secondStartPoint.read();
      secondEndPoint.read();
      rotation = backing.getDouble(32);
      distance = backing.getDouble(40);
    }

    public void write() {
      firstStartPoint.write();
      firstEndPoint.write();
      secondStartPoint.write();
      secondEndPoint.write();
      backing.putDouble(32, rotation);
      backing.putDouble(40, distance);
    }

    public int size() {
      return 48;
    }
  }

  public static class PairOfParallelLinePairsFeature extends DisposedStruct {
    public ParallelLinePairFeature firstParallelLinePair; // The first parallel
                                                          // line pair.
    public ParallelLinePairFeature secondParallelLinePair; // The second
                                                           // parallel line
                                                           // pair.
    public double rotation; // The orientation of the feature with respect to
                            // the horizontal.
    public double distance; // The distance from the midline of the first
                            // parallel line pair to the midline of the second
                            // parallel line pair.

    private void init() {
      firstParallelLinePair = new ParallelLinePairFeature(backing, 0);
      secondParallelLinePair = new ParallelLinePairFeature(backing, 48);
    }

    public PairOfParallelLinePairsFeature() {
      super(112);
      init();
    }

    public PairOfParallelLinePairsFeature(ParallelLinePairFeature firstParallelLinePair,
        ParallelLinePairFeature secondParallelLinePair, double rotation, double distance) {
      super(112);
      this.firstParallelLinePair = firstParallelLinePair;
      this.secondParallelLinePair = secondParallelLinePair;
      this.rotation = rotation;
      this.distance = distance;
    }

    protected PairOfParallelLinePairsFeature(ByteBuffer backing, int offset) {
      super(backing, offset, 112);
      init();
    }

    protected PairOfParallelLinePairsFeature(long nativeObj, boolean owned) {
      super(nativeObj, owned, 112);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 112);
    }

    public void read() {
      firstParallelLinePair.read();
      secondParallelLinePair.read();
      rotation = backing.getDouble(96);
      distance = backing.getDouble(104);
    }

    public void write() {
      firstParallelLinePair.write();
      secondParallelLinePair.write();
      backing.putDouble(96, rotation);
      backing.putDouble(104, distance);
    }

    public int size() {
      return 112;
    }
  }

  public static class FeatureData extends DisposedStruct {
    public FeatureType type; // An enumeration representing the type of the
                             // feature.
    public PointFloat[] contourPoints; // A set of points describing the contour
                                       // of the feature.
    public CircleFeature circle; // A pointer to a CircleFeature.
    public EllipseFeature ellipse; // A pointer to an EllipseFeature.
    public ConstCurveFeature constCurve; // A pointer to a ConstCurveFeature.
    public RectangleFeature rectangle; // A pointer to a RectangleFeature.
    public LegFeature leg; // A pointer to a LegFeature.
    public CornerFeature corner; // A pointer to a CornerFeature.
    public ParallelLinePairFeature parallelLinePair; // A pointer to a
                                                     // ParallelLinePairFeature.
    public PairOfParallelLinePairsFeature pairOfParallelLinePairs; // A pointer
                                                                   // to a
                                                                   // PairOfParallelLinePairsFeature.
    public LineFeature line; // A pointer to a LineFeature.
    public ClosedCurveFeature closedCurve; // A pointer to a ClosedCurveFeature.
    private ByteBuffer contourPoints_buf;

    private void init() {
      contourPoints = new PointFloat[0];
    }

    public FeatureData() {
      super(16);
      init();
    }

    public FeatureData(FeatureType type, PointFloat[] contourPoints) {
      super(16);
      this.type = type;
      this.contourPoints = contourPoints;
    }

    protected FeatureData(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected FeatureData(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      type = FeatureType.fromValue(backing.getInt(0));
      int contourPoints_numContourPoints = backing.getInt(8);
      long contourPoints_addr = getPointer(backing, 4);
      contourPoints = new PointFloat[contourPoints_numContourPoints];
      if (contourPoints_numContourPoints > 0 && contourPoints_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(contourPoints_addr, contourPoints_numContourPoints * 8);
        for (int i = 0, off = 0; i < contourPoints_numContourPoints; i++, off += 8) {
          contourPoints[i] = new PointFloat(bb, off);
          contourPoints[i].read();
        }
      }
      if (type == FeatureType.CIRCLE_FEATURE) {
        long circle_addr = getPointer(backing, 12);
        if (circle_addr == 0)
          circle = null;
        else
          circle = new CircleFeature(circle_addr, false);
      }
      if (type == FeatureType.ELLIPSE_FEATURE) {
        long ellipse_addr = getPointer(backing, 12);
        if (ellipse_addr == 0)
          ellipse = null;
        else
          ellipse = new EllipseFeature(ellipse_addr, false);
      }
      if (type == FeatureType.CONST_CURVE_FEATURE) {
        long constCurve_addr = getPointer(backing, 12);
        if (constCurve_addr == 0)
          constCurve = null;
        else
          constCurve = new ConstCurveFeature(constCurve_addr, false);
      }
      if (type == FeatureType.RECTANGLE_FEATURE) {
        long rectangle_addr = getPointer(backing, 12);
        if (rectangle_addr == 0)
          rectangle = null;
        else
          rectangle = new RectangleFeature(rectangle_addr, false);
      }
      if (type == FeatureType.LEG_FEATURE) {
        long leg_addr = getPointer(backing, 12);
        if (leg_addr == 0)
          leg = null;
        else
          leg = new LegFeature(leg_addr, false);
      }
      if (type == FeatureType.CORNER_FEATURE) {
        long corner_addr = getPointer(backing, 12);
        if (corner_addr == 0)
          corner = null;
        else
          corner = new CornerFeature(corner_addr, false);
      }
      if (type == FeatureType.PARALLEL_LINE_PAIR_FEATURE) {
        long parallelLinePair_addr = getPointer(backing, 12);
        if (parallelLinePair_addr == 0)
          parallelLinePair = null;
        else
          parallelLinePair = new ParallelLinePairFeature(parallelLinePair_addr, false);
      }
      if (type == FeatureType.PAIR_OF_PARALLEL_LINE_PAIRS_FEATURE) {
        long pairOfParallelLinePairs_addr = getPointer(backing, 12);
        if (pairOfParallelLinePairs_addr == 0)
          pairOfParallelLinePairs = null;
        else
          pairOfParallelLinePairs =
              new PairOfParallelLinePairsFeature(pairOfParallelLinePairs_addr, false);
      }
      if (type == FeatureType.LINE_FEATURE) {
        long line_addr = getPointer(backing, 12);
        if (line_addr == 0)
          line = null;
        else
          line = new LineFeature(line_addr, false);
      }
      if (type == FeatureType.CLOSED_CURVE_FEATURE) {
        long closedCurve_addr = getPointer(backing, 12);
        if (closedCurve_addr == 0)
          closedCurve = null;
        else
          closedCurve = new ClosedCurveFeature(closedCurve_addr, false);
      }
    }

    public void write() {
      if (type != null)
        backing.putInt(0, type.getValue());
      contourPoints_buf =
          ByteBuffer.allocateDirect(contourPoints.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < contourPoints.length; i++, off += 8) {
        contourPoints[i].setBuffer(contourPoints_buf, off);
        contourPoints[i].write();
      }
      backing.putInt(8, contourPoints.length);
      putPointer(backing, 4, contourPoints_buf);
      if (type == FeatureType.CIRCLE_FEATURE) {
        putPointer(backing, 12, circle);
      }
      if (type == FeatureType.ELLIPSE_FEATURE) {
        putPointer(backing, 12, ellipse);
      }
      if (type == FeatureType.CONST_CURVE_FEATURE) {
        putPointer(backing, 12, constCurve);
      }
      if (type == FeatureType.RECTANGLE_FEATURE) {
        putPointer(backing, 12, rectangle);
      }
      if (type == FeatureType.LEG_FEATURE) {
        putPointer(backing, 12, leg);
      }
      if (type == FeatureType.CORNER_FEATURE) {
        putPointer(backing, 12, corner);
      }
      if (type == FeatureType.PARALLEL_LINE_PAIR_FEATURE) {
        putPointer(backing, 12, parallelLinePair);
      }
      if (type == FeatureType.PAIR_OF_PARALLEL_LINE_PAIRS_FEATURE) {
        putPointer(backing, 12, pairOfParallelLinePairs);
      }
      if (type == FeatureType.LINE_FEATURE) {
        putPointer(backing, 12, line);
      }
      if (type == FeatureType.CLOSED_CURVE_FEATURE) {
        putPointer(backing, 12, closedCurve);
      }
    }

    public int size() {
      return 16;
    }
  }

  public static class GeometricPatternMatch2 extends DisposedStruct {
    public PointFloat position; // The location of the origin of the template in
                                // the match.
    public float rotation; // The rotation of the match relative to the template
                           // image, in degrees.
    public float scale; // The size of the match relative to the size of the
                        // template image, expressed as a percentage.
    public float score; // The accuracy of the match.
    public PointFloat[] corner; // An array of four points describing the
                                // rectangle surrounding the template image.
    public int inverse; // This element is TRUE if the match is an inverse of
                        // the template image.
    public float occlusion; // The percentage of the match that is occluded.
    public float templateMatchCurveScore; // The accuracy of the match obtained
                                          // by comparing the template curves to
                                          // the curves in the match region.
    public float matchTemplateCurveScore; // The accuracy of the match obtained
                                          // by comparing the curves in the
                                          // match region to the template
                                          // curves.
    public float correlationScore; // The accuracy of the match obtained by
                                   // comparing the template image to the match
                                   // region using a correlation metric that
                                   // compares the two regions as a function of
                                   // their pixel values.
    public String label; // The label corresponding to this match when the match
                         // is returned by imaqMatchMultipleGeometricPatterns().
    public FeatureData[] featureData; // The features used in this match.
    public PointFloat calibratedPosition; // The location of the origin of the
                                          // template in the match.
    public float calibratedRotation; // The rotation of the match relative to
                                     // the template image, in degrees.
    public PointFloat[] calibratedCorner; // An array of four points describing
                                          // the rectangle surrounding the
                                          // template image.
    private ByteBuffer featureData_buf;

    private void init() {
      position = new PointFloat(backing, 0);
      corner = new PointFloat[4];

      for (int i = 0, off = 20; i < 4; i++, off += 8)
        corner[i] = new PointFloat(backing, off);
      featureData = new FeatureData[0];
      calibratedPosition = new PointFloat(backing, 336);
      calibratedCorner = new PointFloat[4];

      for (int i = 0, off = 348; i < 4; i++, off += 8)
        calibratedCorner[i] = new PointFloat(backing, off);
    }

    public GeometricPatternMatch2() {
      super(380);
      init();
    }

    public GeometricPatternMatch2(PointFloat position, double rotation, double scale, double score,
        PointFloat[] corner, int inverse, double occlusion, double templateMatchCurveScore,
        double matchTemplateCurveScore, double correlationScore, String label,
        FeatureData[] featureData, PointFloat calibratedPosition, double calibratedRotation,
        PointFloat[] calibratedCorner) {
      super(380);
      this.position = position;
      this.rotation = (float) rotation;
      this.scale = (float) scale;
      this.score = (float) score;
      this.corner = corner;
      this.inverse = inverse;
      this.occlusion = (float) occlusion;
      this.templateMatchCurveScore = (float) templateMatchCurveScore;
      this.matchTemplateCurveScore = (float) matchTemplateCurveScore;
      this.correlationScore = (float) correlationScore;
      this.label = label;
      this.featureData = featureData;
      this.calibratedPosition = calibratedPosition;
      this.calibratedRotation = (float) calibratedRotation;
      this.calibratedCorner = calibratedCorner;
    }

    protected GeometricPatternMatch2(ByteBuffer backing, int offset) {
      super(backing, offset, 380);
      init();
    }

    protected GeometricPatternMatch2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 380);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 380);
    }

    public void read() {
      position.read();
      rotation = backing.getFloat(8);
      scale = backing.getFloat(12);
      score = backing.getFloat(16);
      for (PointFloat it : corner) {
        it.read();
      }
      inverse = backing.getInt(52);
      occlusion = backing.getFloat(56);
      templateMatchCurveScore = backing.getFloat(60);
      matchTemplateCurveScore = backing.getFloat(64);
      correlationScore = backing.getFloat(68);
      {
        byte[] bytes = new byte[256];
        getBytes(backing, bytes, 72, 256);
        int len;
        for (len = 0; len < bytes.length && bytes[len] != 0; len++) {
        }
        try {
          label = new String(bytes, 0, len, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          label = "";
        }
      }
      int featureData_numFeatureData = backing.getInt(332);
      long featureData_addr = getPointer(backing, 328);
      featureData = new FeatureData[featureData_numFeatureData];
      if (featureData_numFeatureData > 0 && featureData_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(featureData_addr, featureData_numFeatureData * 16);
        for (int i = 0, off = 0; i < featureData_numFeatureData; i++, off += 16) {
          featureData[i] = new FeatureData(bb, off);
          featureData[i].read();
        }
      }
      calibratedPosition.read();
      calibratedRotation = backing.getFloat(344);
      for (PointFloat it : calibratedCorner) {
        it.read();
      }
    }

    public void write() {
      position.write();
      backing.putFloat(8, rotation);
      backing.putFloat(12, scale);
      backing.putFloat(16, score);
      for (PointFloat it : corner) {
        it.write();
      }
      backing.putInt(52, inverse);
      backing.putFloat(56, occlusion);
      backing.putFloat(60, templateMatchCurveScore);
      backing.putFloat(64, matchTemplateCurveScore);
      backing.putFloat(68, correlationScore);
      if (label != null) {
        byte[] bytes;
        try {
          bytes = label.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bytes = new byte[0];
        }
        putBytes(backing, bytes, 72, bytes.length);
        for (int i = bytes.length; i < 256; i++)
          backing.put(i, (byte) 0); // fill with zero
      }
      featureData_buf =
          ByteBuffer.allocateDirect(featureData.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < featureData.length; i++, off += 16) {
        featureData[i].setBuffer(featureData_buf, off);
        featureData[i].write();
      }
      backing.putInt(332, featureData.length);
      putPointer(backing, 328, featureData_buf);
      calibratedPosition.write();
      backing.putFloat(344, calibratedRotation);
      for (PointFloat it : calibratedCorner) {
        it.write();
      }
    }

    public int size() {
      return 380;
    }
  }

  public static class ClosedCurveFeature extends DisposedStruct {
    public PointFloat position; // The center of the closed curve feature.
    public double arcLength; // The arc length of the closed curve feature.

    private void init() {
      position = new PointFloat(backing, 0);
    }

    public ClosedCurveFeature() {
      super(16);
      init();
    }

    public ClosedCurveFeature(PointFloat position, double arcLength) {
      super(16);
      this.position = position;
      this.arcLength = arcLength;
    }

    protected ClosedCurveFeature(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ClosedCurveFeature(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      position.read();
      arcLength = backing.getDouble(8);
    }

    public void write() {
      position.write();
      backing.putDouble(8, arcLength);
    }

    public int size() {
      return 16;
    }
  }

  public static class LineMatch extends DisposedStruct {
    public PointFloat startPoint; // The starting point of the matched line.
    public PointFloat endPoint; // The ending point of the matched line.
    public double length; // The length of the line measured in pixels from the
                          // start point to the end point.
    public double rotation; // The orientation of the matched line.
    public double score; // The score of the matched line.

    private void init() {
      startPoint = new PointFloat(backing, 0);
      endPoint = new PointFloat(backing, 8);
    }

    public LineMatch() {
      super(40);
      init();
    }

    public LineMatch(PointFloat startPoint, PointFloat endPoint, double length, double rotation,
        double score) {
      super(40);
      this.startPoint = startPoint;
      this.endPoint = endPoint;
      this.length = length;
      this.rotation = rotation;
      this.score = score;
    }

    protected LineMatch(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected LineMatch(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      startPoint.read();
      endPoint.read();
      length = backing.getDouble(16);
      rotation = backing.getDouble(24);
      score = backing.getDouble(32);
    }

    public void write() {
      startPoint.write();
      endPoint.write();
      backing.putDouble(16, length);
      backing.putDouble(24, rotation);
      backing.putDouble(32, score);
    }

    public int size() {
      return 40;
    }
  }

  public static class LineDescriptor extends DisposedStruct {
    public double minLength; // Specifies the minimum length of a line the
                             // function will return.
    public double maxLength; // Specifies the maximum length of a line the
                             // function will return.

    private void init() {

    }

    public LineDescriptor() {
      super(16);
      init();
    }

    public LineDescriptor(double minLength, double maxLength) {
      super(16);
      this.minLength = minLength;
      this.maxLength = maxLength;
    }

    protected LineDescriptor(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected LineDescriptor(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      minLength = backing.getDouble(0);
      maxLength = backing.getDouble(8);
    }

    public void write() {
      backing.putDouble(0, minLength);
      backing.putDouble(8, maxLength);
    }

    public int size() {
      return 16;
    }
  }

  public static class RectangleDescriptor extends DisposedStruct {
    public double minWidth; // Specifies the minimum width of a rectangle the
                            // algorithm will return.
    public double maxWidth; // Specifies the maximum width of a rectangle the
                            // algorithm will return.
    public double minHeight; // Specifies the minimum height of a rectangle the
                             // algorithm will return.
    public double maxHeight; // Specifies the maximum height of a rectangle the
                             // algorithm will return.

    private void init() {

    }

    public RectangleDescriptor() {
      super(32);
      init();
    }

    public RectangleDescriptor(double minWidth, double maxWidth, double minHeight, double maxHeight) {
      super(32);
      this.minWidth = minWidth;
      this.maxWidth = maxWidth;
      this.minHeight = minHeight;
      this.maxHeight = maxHeight;
    }

    protected RectangleDescriptor(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected RectangleDescriptor(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      minWidth = backing.getDouble(0);
      maxWidth = backing.getDouble(8);
      minHeight = backing.getDouble(16);
      maxHeight = backing.getDouble(24);
    }

    public void write() {
      backing.putDouble(0, minWidth);
      backing.putDouble(8, maxWidth);
      backing.putDouble(16, minHeight);
      backing.putDouble(24, maxHeight);
    }

    public int size() {
      return 32;
    }
  }

  public static class RectangleMatch extends DisposedStruct {
    public PointFloat[] corner; // The corners of the matched rectangle.
    public double rotation; // The orientation of the matched rectangle.
    public double width; // The width of the matched rectangle.
    public double height; // The height of the matched rectangle.
    public double score; // The score of the matched rectangle.

    private void init() {
      corner = new PointFloat[4];

      for (int i = 0, off = 0; i < 4; i++, off += 8)
        corner[i] = new PointFloat(backing, off);
    }

    public RectangleMatch() {
      super(64);
      init();
    }

    public RectangleMatch(PointFloat[] corner, double rotation, double width, double height,
        double score) {
      super(64);
      this.corner = corner;
      this.rotation = rotation;
      this.width = width;
      this.height = height;
      this.score = score;
    }

    protected RectangleMatch(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected RectangleMatch(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      for (PointFloat it : corner) {
        it.read();
      }
      rotation = backing.getDouble(32);
      width = backing.getDouble(40);
      height = backing.getDouble(48);
      score = backing.getDouble(56);
    }

    public void write() {
      for (PointFloat it : corner) {
        it.write();
      }
      backing.putDouble(32, rotation);
      backing.putDouble(40, width);
      backing.putDouble(48, height);
      backing.putDouble(56, score);
    }

    public int size() {
      return 64;
    }
  }

  public static class EllipseDescriptor extends DisposedStruct {
    public double minMajorRadius; // Specifies the minimum length of the
                                  // semi-major axis of an ellipse the function
                                  // will return.
    public double maxMajorRadius; // Specifies the maximum length of the
                                  // semi-major axis of an ellipse the function
                                  // will return.
    public double minMinorRadius; // Specifies the minimum length of the
                                  // semi-minor axis of an ellipse the function
                                  // will return.
    public double maxMinorRadius; // Specifies the maximum length of the
                                  // semi-minor axis of an ellipse the function
                                  // will return.

    private void init() {

    }

    public EllipseDescriptor() {
      super(32);
      init();
    }

    public EllipseDescriptor(double minMajorRadius, double maxMajorRadius, double minMinorRadius,
        double maxMinorRadius) {
      super(32);
      this.minMajorRadius = minMajorRadius;
      this.maxMajorRadius = maxMajorRadius;
      this.minMinorRadius = minMinorRadius;
      this.maxMinorRadius = maxMinorRadius;
    }

    protected EllipseDescriptor(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected EllipseDescriptor(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      minMajorRadius = backing.getDouble(0);
      maxMajorRadius = backing.getDouble(8);
      minMinorRadius = backing.getDouble(16);
      maxMinorRadius = backing.getDouble(24);
    }

    public void write() {
      backing.putDouble(0, minMajorRadius);
      backing.putDouble(8, maxMajorRadius);
      backing.putDouble(16, minMinorRadius);
      backing.putDouble(24, maxMinorRadius);
    }

    public int size() {
      return 32;
    }
  }

  public static class EllipseMatch extends DisposedStruct {
    public PointFloat position; // The location of the center of the matched
                                // ellipse.
    public double rotation; // The orientation of the matched ellipse.
    public double majorRadius; // The length of the semi-major axis of the
                               // matched ellipse.
    public double minorRadius; // The length of the semi-minor axis of the
                               // matched ellipse.
    public double score; // The score of the matched ellipse.

    private void init() {
      position = new PointFloat(backing, 0);
    }

    public EllipseMatch() {
      super(40);
      init();
    }

    public EllipseMatch(PointFloat position, double rotation, double majorRadius,
        double minorRadius, double score) {
      super(40);
      this.position = position;
      this.rotation = rotation;
      this.majorRadius = majorRadius;
      this.minorRadius = minorRadius;
      this.score = score;
    }

    protected EllipseMatch(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected EllipseMatch(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      position.read();
      rotation = backing.getDouble(8);
      majorRadius = backing.getDouble(16);
      minorRadius = backing.getDouble(24);
      score = backing.getDouble(32);
    }

    public void write() {
      position.write();
      backing.putDouble(8, rotation);
      backing.putDouble(16, majorRadius);
      backing.putDouble(24, minorRadius);
      backing.putDouble(32, score);
    }

    public int size() {
      return 40;
    }
  }

  public static class CircleMatch extends DisposedStruct {
    public PointFloat position; // The location of the center of the matched
                                // circle.
    public double radius; // The radius of the matched circle.
    public double score; // The score of the matched circle.

    private void init() {
      position = new PointFloat(backing, 0);
    }

    public CircleMatch() {
      super(24);
      init();
    }

    public CircleMatch(PointFloat position, double radius, double score) {
      super(24);
      this.position = position;
      this.radius = radius;
      this.score = score;
    }

    protected CircleMatch(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected CircleMatch(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      position.read();
      radius = backing.getDouble(8);
      score = backing.getDouble(16);
    }

    public void write() {
      position.write();
      backing.putDouble(8, radius);
      backing.putDouble(16, score);
    }

    public int size() {
      return 24;
    }
  }

  public static class CircleDescriptor extends DisposedStruct {
    public double minRadius; // Specifies the minimum radius of a circle the
                             // function will return.
    public double maxRadius; // Specifies the maximum radius of a circle the
                             // function will return.

    private void init() {

    }

    public CircleDescriptor() {
      super(16);
      init();
    }

    public CircleDescriptor(double minRadius, double maxRadius) {
      super(16);
      this.minRadius = minRadius;
      this.maxRadius = maxRadius;
    }

    protected CircleDescriptor(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected CircleDescriptor(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      minRadius = backing.getDouble(0);
      maxRadius = backing.getDouble(8);
    }

    public void write() {
      backing.putDouble(0, minRadius);
      backing.putDouble(8, maxRadius);
    }

    public int size() {
      return 16;
    }
  }

  public static class ShapeDetectionOptions extends DisposedStruct {
    public int mode; // Specifies the method used when looking for the shape in
                     // the image.
    public RangeFloat[] angleRanges; // An array of angle ranges, in degrees,
                                     // where each range specifies how much you
                                     // expect the shape to be rotated in the
                                     // image.
    public RangeFloat scaleRange; // A range that specifies the sizes of the
                                  // shapes you expect to be in the image,
                                  // expressed as a ratio percentage
                                  // representing the size of the pattern in the
                                  // image divided by size of the original
                                  // pattern multiplied by 100.
    public double minMatchScore;
    private ByteBuffer angleRanges_buf;

    private void init() {
      angleRanges = new RangeFloat[0];
      scaleRange = new RangeFloat(backing, 12);
    }

    public ShapeDetectionOptions() {
      super(32);
      init();
    }

    public ShapeDetectionOptions(int mode, RangeFloat[] angleRanges, RangeFloat scaleRange,
        double minMatchScore) {
      super(32);
      this.mode = mode;
      this.angleRanges = angleRanges;
      this.scaleRange = scaleRange;
      this.minMatchScore = minMatchScore;
    }

    protected ShapeDetectionOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected ShapeDetectionOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      mode = backing.getInt(0);
      int angleRanges_numAngleRanges = backing.getInt(8);
      long angleRanges_addr = getPointer(backing, 4);
      angleRanges = new RangeFloat[angleRanges_numAngleRanges];
      if (angleRanges_numAngleRanges > 0 && angleRanges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(angleRanges_addr, angleRanges_numAngleRanges * 8);
        for (int i = 0, off = 0; i < angleRanges_numAngleRanges; i++, off += 8) {
          angleRanges[i] = new RangeFloat(bb, off);
          angleRanges[i].read();
        }
      }
      scaleRange.read();
      minMatchScore = backing.getDouble(24);
    }

    public void write() {
      backing.putInt(0, mode);
      angleRanges_buf =
          ByteBuffer.allocateDirect(angleRanges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < angleRanges.length; i++, off += 8) {
        angleRanges[i].setBuffer(angleRanges_buf, off);
        angleRanges[i].write();
      }
      backing.putInt(8, angleRanges.length);
      putPointer(backing, 4, angleRanges_buf);
      scaleRange.write();
      backing.putDouble(24, minMatchScore);
    }

    public int size() {
      return 32;
    }
  }

  public static class Curve extends DisposedStruct {
    public PointFloat[] points; // The points on the curve.
    public int closed; // This element is TRUE if the curve is closed and FALSE
                       // if the curve is open.
    public double curveLength; // The length of the curve.
    public double minEdgeStrength; // The lowest edge strength detected on the
                                   // curve.
    public double maxEdgeStrength; // The highest edge strength detected on the
                                   // curve.
    public double averageEdgeStrength; // The average of all edge strengths
                                       // detected on the curve.
    private ByteBuffer points_buf;

    private void init() {
      points = new PointFloat[0];
    }

    public Curve() {
      super(48);
      init();
    }

    public Curve(PointFloat[] points, int closed, double curveLength, double minEdgeStrength,
        double maxEdgeStrength, double averageEdgeStrength) {
      super(48);
      this.points = points;
      this.closed = closed;
      this.curveLength = curveLength;
      this.minEdgeStrength = minEdgeStrength;
      this.maxEdgeStrength = maxEdgeStrength;
      this.averageEdgeStrength = averageEdgeStrength;
    }

    protected Curve(ByteBuffer backing, int offset) {
      super(backing, offset, 48);
      init();
    }

    protected Curve(long nativeObj, boolean owned) {
      super(nativeObj, owned, 48);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 48);
    }

    public void read() {
      int points_numPoints = backing.getInt(4);
      long points_addr = getPointer(backing, 0);
      points = new PointFloat[points_numPoints];
      if (points_numPoints > 0 && points_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(points_addr, points_numPoints * 8);
        for (int i = 0, off = 0; i < points_numPoints; i++, off += 8) {
          points[i] = new PointFloat(bb, off);
          points[i].read();
        }
      }
      closed = backing.getInt(8);
      curveLength = backing.getDouble(16);
      minEdgeStrength = backing.getDouble(24);
      maxEdgeStrength = backing.getDouble(32);
      averageEdgeStrength = backing.getDouble(40);
    }

    public void write() {
      points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < points.length; i++, off += 8) {
        points[i].setBuffer(points_buf, off);
        points[i].write();
      }
      backing.putInt(4, points.length);
      putPointer(backing, 0, points_buf);
      backing.putInt(8, closed);
      backing.putDouble(16, curveLength);
      backing.putDouble(24, minEdgeStrength);
      backing.putDouble(32, maxEdgeStrength);
      backing.putDouble(40, averageEdgeStrength);
    }

    public int size() {
      return 48;
    }
  }

  public static class CurveOptions extends DisposedStruct {
    public ExtractionMode extractionMode; // Specifies the method the function
                                          // uses to identify curves in the
                                          // image.
    public int threshold; // Specifies the minimum contrast a seed point must
                          // have in order to begin a curve.
    public EdgeFilterSize filterSize; // Specifies the width of the edge filter
                                      // the function uses to identify curves in
                                      // the image.
    public int minLength; // Specifies the length, in pixels, of the smallest
                          // curve the function will extract.
    public int rowStepSize; // Specifies the distance, in the y direction,
                            // between lines the function inspects for curve
                            // seed points.
    public int columnStepSize; // Specifies the distance, in the x direction,
                               // between columns the function inspects for
                               // curve seed points.
    public int maxEndPointGap; // Specifies the maximum gap, in pixels, between
                               // the endpoints of a curve that the function
                               // identifies as a closed curve.
    public int onlyClosed; // Set this element to TRUE to specify that the
                           // function should only identify closed curves in the
                           // image.
    public int subpixelAccuracy; // Set this element to TRUE to specify that the
                                 // function identifies the location of curves
                                 // with subpixel accuracy by interpolating
                                 // between points to find the crossing of
                                 // threshold.

    private void init() {

    }

    public CurveOptions() {
      super(36);
      init();
    }

    public CurveOptions(ExtractionMode extractionMode, int threshold, EdgeFilterSize filterSize,
        int minLength, int rowStepSize, int columnStepSize, int maxEndPointGap, int onlyClosed,
        int subpixelAccuracy) {
      super(36);
      this.extractionMode = extractionMode;
      this.threshold = threshold;
      this.filterSize = filterSize;
      this.minLength = minLength;
      this.rowStepSize = rowStepSize;
      this.columnStepSize = columnStepSize;
      this.maxEndPointGap = maxEndPointGap;
      this.onlyClosed = onlyClosed;
      this.subpixelAccuracy = subpixelAccuracy;
    }

    protected CurveOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 36);
      init();
    }

    protected CurveOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 36);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 36);
    }

    public void read() {
      extractionMode = ExtractionMode.fromValue(backing.getInt(0));
      threshold = backing.getInt(4);
      filterSize = EdgeFilterSize.fromValue(backing.getInt(8));
      minLength = backing.getInt(12);
      rowStepSize = backing.getInt(16);
      columnStepSize = backing.getInt(20);
      maxEndPointGap = backing.getInt(24);
      onlyClosed = backing.getInt(28);
      subpixelAccuracy = backing.getInt(32);
    }

    public void write() {
      if (extractionMode != null)
        backing.putInt(0, extractionMode.getValue());
      backing.putInt(4, threshold);
      if (filterSize != null)
        backing.putInt(8, filterSize.getValue());
      backing.putInt(12, minLength);
      backing.putInt(16, rowStepSize);
      backing.putInt(20, columnStepSize);
      backing.putInt(24, maxEndPointGap);
      backing.putInt(28, onlyClosed);
      backing.putInt(32, subpixelAccuracy);
    }

    public int size() {
      return 36;
    }
  }

  public static class Barcode2DInfo extends DisposedStruct {
    public Barcode2DType type; // The type of the 2D barcode.
    public int binary; // This element is TRUE if the 2D barcode contains binary
                       // data and FALSE if the 2D barcode contains text data.
    public byte[] data; // The data encoded in the 2D barcode.
    public PointFloat[] boundingBox; // An array of four points describing the
                                     // rectangle surrounding the 2D barcode.
    public int numErrorsCorrected; // The number of errors the function
                                   // corrected when decoding the 2D barcode.
    public int numErasuresCorrected; // The number of erasures the function
                                     // corrected when decoding the 2D barcode.
    public int rows; // The number of rows in the 2D barcode.
    public int columns; // The number of columns in the 2D barcode.
    private ByteBuffer data_buf;

    private void init() {
      data = new byte[0];
      boundingBox = new PointFloat[4];

      for (int i = 0, off = 16; i < 4; i++, off += 8)
        boundingBox[i] = new PointFloat(backing, off);
    }

    public Barcode2DInfo() {
      super(64);
      init();
    }

    public Barcode2DInfo(Barcode2DType type, int binary, byte[] data, PointFloat[] boundingBox,
        int numErrorsCorrected, int numErasuresCorrected, int rows, int columns) {
      super(64);
      this.type = type;
      this.binary = binary;
      this.data = data;
      this.boundingBox = boundingBox;
      this.numErrorsCorrected = numErrorsCorrected;
      this.numErasuresCorrected = numErasuresCorrected;
      this.rows = rows;
      this.columns = columns;
    }

    protected Barcode2DInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected Barcode2DInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      type = Barcode2DType.fromValue(backing.getInt(0));
      binary = backing.getInt(4);
      int data_dataLength = backing.getInt(12);
      long data_addr = getPointer(backing, 8);
      data = new byte[data_dataLength];
      if (data_dataLength > 0 && data_addr != 0) {
        getBytes(newDirectByteBuffer(data_addr, data_dataLength), data, 0, data_dataLength);
      }
      for (PointFloat it : boundingBox) {
        it.read();
      }
      numErrorsCorrected = backing.getInt(48);
      numErasuresCorrected = backing.getInt(52);
      rows = backing.getInt(56);
      columns = backing.getInt(60);
    }

    public void write() {
      if (type != null)
        backing.putInt(0, type.getValue());
      backing.putInt(4, binary);
      data_buf = ByteBuffer.allocateDirect(data.length);
      putBytes(data_buf, data, 0, data.length);
      backing.putInt(12, data.length);
      putPointer(backing, 8, data_buf);
      for (PointFloat it : boundingBox) {
        it.write();
      }
      backing.putInt(48, numErrorsCorrected);
      backing.putInt(52, numErasuresCorrected);
      backing.putInt(56, rows);
      backing.putInt(60, columns);
    }

    public int size() {
      return 64;
    }
  }

  public static class DataMatrixOptions extends DisposedStruct {
    public Barcode2DSearchMode searchMode; // Specifies the mode the function
                                           // uses to search for barcodes.
    public Barcode2DContrast contrast; // Specifies the contrast of the barcodes
                                       // that the function searches for.
    public Barcode2DCellShape cellShape; // Specifies the shape of the barcode
                                         // data cells, which affects how the
                                         // function decodes the barcode.
    public Barcode2DShape barcodeShape; // Specifies the shape of the barcodes
                                        // that the function searches for.
    public DataMatrixSubtype subtype; // Specifies the Data Matrix subtypes of
                                      // the barcodes that the function searches
                                      // for.

    private void init() {

    }

    public DataMatrixOptions() {
      super(20);
      init();
    }

    public DataMatrixOptions(Barcode2DSearchMode searchMode, Barcode2DContrast contrast,
        Barcode2DCellShape cellShape, Barcode2DShape barcodeShape, DataMatrixSubtype subtype) {
      super(20);
      this.searchMode = searchMode;
      this.contrast = contrast;
      this.cellShape = cellShape;
      this.barcodeShape = barcodeShape;
      this.subtype = subtype;
    }

    protected DataMatrixOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected DataMatrixOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      searchMode = Barcode2DSearchMode.fromValue(backing.getInt(0));
      contrast = Barcode2DContrast.fromValue(backing.getInt(4));
      cellShape = Barcode2DCellShape.fromValue(backing.getInt(8));
      barcodeShape = Barcode2DShape.fromValue(backing.getInt(12));
      subtype = DataMatrixSubtype.fromValue(backing.getInt(16));
    }

    public void write() {
      if (searchMode != null)
        backing.putInt(0, searchMode.getValue());
      if (contrast != null)
        backing.putInt(4, contrast.getValue());
      if (cellShape != null)
        backing.putInt(8, cellShape.getValue());
      if (barcodeShape != null)
        backing.putInt(12, barcodeShape.getValue());
      if (subtype != null)
        backing.putInt(16, subtype.getValue());
    }

    public int size() {
      return 20;
    }
  }

  public static class ClassifierAccuracyReport extends DisposedStruct {
    public float accuracy; // The overall accuracy of the classifier, from 0 to
                           // 1000.
    public String[] classNames; // The names of the classes of this classifier.
    public double[] classAccuracy; // An array of size elements that contains
                                   // accuracy information for each class.
    public double[] classPredictiveValue; // An array containing size elements
                                          // that contains the predictive values
                                          // of each class.
    private ByteBuffer classNames_buf;
    private ByteBuffer[] classNames_bufs;
    private ByteBuffer classAccuracy_buf;
    private ByteBuffer classPredictiveValue_buf;

    private void init() {
      classNames = new String[0];
      classAccuracy = new double[0];
      classPredictiveValue = new double[0];
    }

    public ClassifierAccuracyReport() {
      super(24);
      init();
    }

    public ClassifierAccuracyReport(double accuracy, String[] classNames, double[] classAccuracy,
        double[] classPredictiveValue) {
      super(24);
      this.accuracy = (float) accuracy;
      this.classNames = classNames;
      this.classAccuracy = classAccuracy;
      this.classPredictiveValue = classPredictiveValue;
    }

    protected ClassifierAccuracyReport(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected ClassifierAccuracyReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      accuracy = backing.getFloat(4);
      int classNames_size = backing.getInt(0);
      long classNames_addr = getPointer(backing, 8);
      classNames = new String[classNames_size];
      if (classNames_size > 0 && classNames_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(classNames_addr, classNames_size * 4);
        for (int i = 0, off = 0; i < classNames_size; i++, off += 4) {
          long addr = getPointer(bb, off);
          if (addr == 0)
            classNames[i] = null;
          else {
            ByteBuffer bb2 = newDirectByteBuffer(addr, 1000); // FIXME
            while (bb2.get() != 0) {
            }
            byte[] bytes = new byte[bb2.position() - 1];
            bb2.rewind();
            getBytes(bb2, bytes, 0, bytes.length);
            try {
              classNames[i] = new String(bytes, "UTF-8");
            } catch (UnsupportedEncodingException e) {
              classNames[i] = "";
            }
          }
        }
      }
      int classAccuracy_size = backing.getInt(0);
      long classAccuracy_addr = getPointer(backing, 12);
      classAccuracy = new double[classAccuracy_size];
      if (classAccuracy_size > 0 && classAccuracy_addr != 0) {
        newDirectByteBuffer(classAccuracy_addr, classAccuracy_size * 8).asDoubleBuffer().get(
            classAccuracy);
      }
      int classPredictiveValue_size = backing.getInt(0);
      long classPredictiveValue_addr = getPointer(backing, 16);
      classPredictiveValue = new double[classPredictiveValue_size];
      if (classPredictiveValue_size > 0 && classPredictiveValue_addr != 0) {
        newDirectByteBuffer(classPredictiveValue_addr, classPredictiveValue_size * 8)
            .asDoubleBuffer().get(classPredictiveValue);
      }
    }

    public void write() {
      backing.putFloat(4, accuracy);
      classNames_buf =
          ByteBuffer.allocateDirect(classNames.length * 4).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < classNames.length; i++, off += 4) {
        if (classNames[i] == null)
          putPointer(classNames_buf, off, 0);
        else {
          byte[] bytes;
          try {
            bytes = classNames[i].getBytes("UTF-8");
          } catch (UnsupportedEncodingException e) {
            bytes = new byte[0];
          }
          classNames_bufs[i] = ByteBuffer.allocateDirect(bytes.length + 1);
          putBytes(classNames_bufs[i], bytes, 0, bytes.length).put(bytes.length, (byte) 0);
          putPointer(classNames_buf, off, getByteBufferAddress(classNames_bufs[i]));
        }
      }
      backing.putInt(0, classNames.length);
      putPointer(backing, 8, classNames_buf);
      classAccuracy_buf =
          ByteBuffer.allocateDirect(classAccuracy.length * 8).order(ByteOrder.nativeOrder());
      classAccuracy_buf.asDoubleBuffer().put(classAccuracy).rewind();
      backing.putInt(0, classAccuracy.length);
      putPointer(backing, 12, classAccuracy_buf);
      classPredictiveValue_buf =
          ByteBuffer.allocateDirect(classPredictiveValue.length * 8).order(ByteOrder.nativeOrder());
      classPredictiveValue_buf.asDoubleBuffer().put(classPredictiveValue).rewind();
      backing.putInt(0, classPredictiveValue.length);
      putPointer(backing, 16, classPredictiveValue_buf);
    }

    public int size() {
      return 24;
    }
  }

  public static class NearestNeighborClassResult extends DisposedStruct {
    public String className; // The name of the class.
    public float standardDeviation; // The standard deviation of the members of
                                    // this class.
    public int count; // The number of samples in this class.
    private ByteBuffer className_buf;

    private void init() {

    }

    public NearestNeighborClassResult() {
      super(12);
      init();
    }

    public NearestNeighborClassResult(String className, double standardDeviation, int count) {
      super(12);
      this.className = className;
      this.standardDeviation = (float) standardDeviation;
      this.count = count;
    }

    protected NearestNeighborClassResult(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected NearestNeighborClassResult(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      long className_addr = getPointer(backing, 0);
      if (className_addr == 0)
        className = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(className_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          className = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          className = "";
        }
      }

      standardDeviation = backing.getFloat(4);
      count = backing.getInt(8);
    }

    public void write() {
      if (className != null) {
        byte[] className_bytes;
        try {
          className_bytes = className.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          className_bytes = new byte[0];
        }
        className_buf = ByteBuffer.allocateDirect(className_bytes.length + 1);
        putBytes(className_buf, className_bytes, 0, className_bytes.length).put(
            className_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, className == null ? 0 : getByteBufferAddress(className_buf));
      backing.putFloat(4, standardDeviation);
      backing.putInt(8, count);
    }

    public int size() {
      return 12;
    }
  }

  public static class NearestNeighborTrainingReport extends DisposedStruct {
    public NearestNeighborClassResult[] allScores; // All classes and their
                                                   // scores.
    private ByteBuffer allScores_buf;

    private void init() {
      allScores = new NearestNeighborClassResult[0];
    }

    public NearestNeighborTrainingReport() {
      super(12);
      init();
    }

    public NearestNeighborTrainingReport(NearestNeighborClassResult[] allScores) {
      super(12);
      this.allScores = allScores;
    }

    protected NearestNeighborTrainingReport(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected NearestNeighborTrainingReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      int allScores_allScoresSize = backing.getInt(8);
      long allScores_addr = getPointer(backing, 4);
      allScores = new NearestNeighborClassResult[allScores_allScoresSize];
      if (allScores_allScoresSize > 0 && allScores_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(allScores_addr, allScores_allScoresSize * 12);
        for (int i = 0, off = 0; i < allScores_allScoresSize; i++, off += 12) {
          allScores[i] = new NearestNeighborClassResult(bb, off);
          allScores[i].read();
        }
      }
    }

    public void write() {
      allScores_buf =
          ByteBuffer.allocateDirect(allScores.length * 12).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < allScores.length; i++, off += 12) {
        allScores[i].setBuffer(allScores_buf, off);
        allScores[i].write();
      }
      backing.putInt(8, allScores.length);
      putPointer(backing, 4, allScores_buf);
    }

    public int size() {
      return 12;
    }
  }

  public static class ParticleClassifierPreprocessingOptions extends DisposedStruct {
    public int manualThreshold; // Set this element to TRUE to specify the
                                // threshold range manually.
    public RangeFloat manualThresholdRange; // If a manual threshold is being
                                            // done, the range of pixels to
                                            // keep.
    public ThresholdMethod autoThresholdMethod; // If an automatic threshold is
                                                // being done, the method used
                                                // to calculate the threshold
                                                // range.
    public RangeFloat limits; // The limits on the automatic threshold range.
    public ParticleType particleType; // Specifies what kind of particles to
                                      // look for.
    public int rejectBorder; // Set this element to TRUE to reject border
                             // particles.
    public int numErosions; // The number of erosions to perform.

    private void init() {
      manualThresholdRange = new RangeFloat(backing, 4);
      limits = new RangeFloat(backing, 16);
    }

    public ParticleClassifierPreprocessingOptions() {
      super(36);
      init();
    }

    public ParticleClassifierPreprocessingOptions(int manualThreshold,
        RangeFloat manualThresholdRange, ThresholdMethod autoThresholdMethod, RangeFloat limits,
        ParticleType particleType, int rejectBorder, int numErosions) {
      super(36);
      this.manualThreshold = manualThreshold;
      this.manualThresholdRange = manualThresholdRange;
      this.autoThresholdMethod = autoThresholdMethod;
      this.limits = limits;
      this.particleType = particleType;
      this.rejectBorder = rejectBorder;
      this.numErosions = numErosions;
    }

    protected ParticleClassifierPreprocessingOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 36);
      init();
    }

    protected ParticleClassifierPreprocessingOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 36);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 36);
    }

    public void read() {
      manualThreshold = backing.getInt(0);
      manualThresholdRange.read();
      autoThresholdMethod = ThresholdMethod.fromValue(backing.getInt(12));
      limits.read();
      particleType = ParticleType.fromValue(backing.getInt(24));
      rejectBorder = backing.getInt(28);
      numErosions = backing.getInt(32);
    }

    public void write() {
      backing.putInt(0, manualThreshold);
      manualThresholdRange.write();
      if (autoThresholdMethod != null)
        backing.putInt(12, autoThresholdMethod.getValue());
      limits.write();
      if (particleType != null)
        backing.putInt(24, particleType.getValue());
      backing.putInt(28, rejectBorder);
      backing.putInt(32, numErosions);
    }

    public int size() {
      return 36;
    }
  }

  public static class ClassifierSampleInfo extends DisposedStruct {
    public String className; // The name of the class this sample is in.
    public double[] featureVector; // The feature vector of this sample, or NULL
                                   // if this is not a custom classifier
                                   // session.
    public Image thumbnail; // A thumbnail image of this sample, or NULL if no
                            // image was specified.
    private ByteBuffer className_buf;
    private ByteBuffer featureVector_buf;

    private void init() {
      featureVector = new double[0];
    }

    public ClassifierSampleInfo() {
      super(16);
      init();
    }

    public ClassifierSampleInfo(String className, double[] featureVector, Image thumbnail) {
      super(16);
      this.className = className;
      this.featureVector = featureVector;
      this.thumbnail = thumbnail;
    }

    protected ClassifierSampleInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ClassifierSampleInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      long className_addr = getPointer(backing, 0);
      if (className_addr == 0)
        className = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(className_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          className = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          className = "";
        }
      }

      int featureVector_featureVectorSize = backing.getInt(8);
      long featureVector_addr = getPointer(backing, 4);
      featureVector = new double[featureVector_featureVectorSize];
      if (featureVector_featureVectorSize > 0 && featureVector_addr != 0) {
        newDirectByteBuffer(featureVector_addr, featureVector_featureVectorSize * 8)
            .asDoubleBuffer().get(featureVector);
      }
      long thumbnail_addr = getPointer(backing, 12);
      if (thumbnail_addr == 0)
        thumbnail = null;
      else
        thumbnail = new Image(thumbnail_addr, false);
    }

    public void write() {
      if (className != null) {
        byte[] className_bytes;
        try {
          className_bytes = className.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          className_bytes = new byte[0];
        }
        className_buf = ByteBuffer.allocateDirect(className_bytes.length + 1);
        putBytes(className_buf, className_bytes, 0, className_bytes.length).put(
            className_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, className == null ? 0 : getByteBufferAddress(className_buf));
      featureVector_buf =
          ByteBuffer.allocateDirect(featureVector.length * 8).order(ByteOrder.nativeOrder());
      featureVector_buf.asDoubleBuffer().put(featureVector).rewind();
      backing.putInt(8, featureVector.length);
      putPointer(backing, 4, featureVector_buf);
      putPointer(backing, 12, thumbnail);
    }

    public int size() {
      return 16;
    }
  }

  public static class ClassScore extends DisposedStruct {
    public String className; // The name of the class.
    public float distance; // The distance from the item to this class.
    private ByteBuffer className_buf;

    private void init() {

    }

    public ClassScore() {
      super(8);
      init();
    }

    public ClassScore(String className, double distance) {
      super(8);
      this.className = className;
      this.distance = (float) distance;
    }

    protected ClassScore(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected ClassScore(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      long className_addr = getPointer(backing, 0);
      if (className_addr == 0)
        className = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(className_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          className = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          className = "";
        }
      }

      distance = backing.getFloat(4);
    }

    public void write() {
      if (className != null) {
        byte[] className_bytes;
        try {
          className_bytes = className.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          className_bytes = new byte[0];
        }
        className_buf = ByteBuffer.allocateDirect(className_bytes.length + 1);
        putBytes(className_buf, className_bytes, 0, className_bytes.length).put(
            className_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, className == null ? 0 : getByteBufferAddress(className_buf));
      backing.putFloat(4, distance);
    }

    public int size() {
      return 8;
    }
  }

  public static class ClassifierReport extends DisposedStruct {
    public String bestClassName; // The name of the best class for the sample.
    public float classificationScore; // The similarity of the sample and the
                                      // two closest classes in the classifier.
    public float identificationScore; // The similarity of the sample and the
                                      // assigned class.
    public ClassScore[] allScores; // All classes and their scores.
    private ByteBuffer bestClassName_buf;
    private ByteBuffer allScores_buf;

    private void init() {
      allScores = new ClassScore[0];
    }

    public ClassifierReport() {
      super(20);
      init();
    }

    public ClassifierReport(String bestClassName, double classificationScore,
        double identificationScore, ClassScore[] allScores) {
      super(20);
      this.bestClassName = bestClassName;
      this.classificationScore = (float) classificationScore;
      this.identificationScore = (float) identificationScore;
      this.allScores = allScores;
    }

    protected ClassifierReport(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected ClassifierReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      long bestClassName_addr = getPointer(backing, 0);
      if (bestClassName_addr == 0)
        bestClassName = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(bestClassName_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          bestClassName = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          bestClassName = "";
        }
      }

      classificationScore = backing.getFloat(4);
      identificationScore = backing.getFloat(8);
      int allScores_allScoresSize = backing.getInt(16);
      long allScores_addr = getPointer(backing, 12);
      allScores = new ClassScore[allScores_allScoresSize];
      if (allScores_allScoresSize > 0 && allScores_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(allScores_addr, allScores_allScoresSize * 8);
        for (int i = 0, off = 0; i < allScores_allScoresSize; i++, off += 8) {
          allScores[i] = new ClassScore(bb, off);
          allScores[i].read();
        }
      }
    }

    public void write() {
      if (bestClassName != null) {
        byte[] bestClassName_bytes;
        try {
          bestClassName_bytes = bestClassName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bestClassName_bytes = new byte[0];
        }
        bestClassName_buf = ByteBuffer.allocateDirect(bestClassName_bytes.length + 1);
        putBytes(bestClassName_buf, bestClassName_bytes, 0, bestClassName_bytes.length).put(
            bestClassName_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, bestClassName == null ? 0 : getByteBufferAddress(bestClassName_buf));
      backing.putFloat(4, classificationScore);
      backing.putFloat(8, identificationScore);
      allScores_buf =
          ByteBuffer.allocateDirect(allScores.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < allScores.length; i++, off += 8) {
        allScores[i].setBuffer(allScores_buf, off);
        allScores[i].write();
      }
      backing.putInt(16, allScores.length);
      putPointer(backing, 12, allScores_buf);
    }

    public int size() {
      return 20;
    }
  }

  public static class NearestNeighborOptions extends DisposedStruct {
    public NearestNeighborMethod method; // The method to use.
    public NearestNeighborMetric metric; // The metric to use.
    public int k; // The value of k, if the IMAQ_K_NEAREST_NEIGHBOR method is
                  // used.

    private void init() {

    }

    public NearestNeighborOptions() {
      super(12);
      init();
    }

    public NearestNeighborOptions(NearestNeighborMethod method, NearestNeighborMetric metric, int k) {
      super(12);
      this.method = method;
      this.metric = metric;
      this.k = k;
    }

    protected NearestNeighborOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected NearestNeighborOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      method = NearestNeighborMethod.fromValue(backing.getInt(0));
      metric = NearestNeighborMetric.fromValue(backing.getInt(4));
      k = backing.getInt(8);
    }

    public void write() {
      if (method != null)
        backing.putInt(0, method.getValue());
      if (metric != null)
        backing.putInt(4, metric.getValue());
      backing.putInt(8, k);
    }

    public int size() {
      return 12;
    }
  }

  public static class ParticleClassifierOptions extends DisposedStruct {
    public float scaleDependence; // The relative importance of scale when
                                  // classifying particles.
    public float mirrorDependence; // The relative importance of mirror symmetry
                                   // when classifying particles.

    private void init() {

    }

    public ParticleClassifierOptions() {
      super(8);
      init();
    }

    public ParticleClassifierOptions(double scaleDependence, double mirrorDependence) {
      super(8);
      this.scaleDependence = (float) scaleDependence;
      this.mirrorDependence = (float) mirrorDependence;
    }

    protected ParticleClassifierOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected ParticleClassifierOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      scaleDependence = backing.getFloat(0);
      mirrorDependence = backing.getFloat(4);
    }

    public void write() {
      backing.putFloat(0, scaleDependence);
      backing.putFloat(4, mirrorDependence);
    }

    public int size() {
      return 8;
    }
  }

  public static class RGBU64Value extends DisposedStruct {
    public int B; // The blue value of the color.
    public int G; // The green value of the color.
    public int R; // The red value of the color.
    public int alpha; // The alpha value of the color, which represents extra
                      // information about a color image, such as gamma
                      // correction.

    private void init() {

    }

    public RGBU64Value() {
      super(8);
      init();
    }

    public RGBU64Value(int B, int G, int R, int alpha) {
      super(8);
      this.B = B;
      this.G = G;
      this.R = R;
      this.alpha = alpha;
    }

    protected RGBU64Value(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected RGBU64Value(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      B = (int) (backing.getShort(0) & 0xffff);
      G = (int) (backing.getShort(2) & 0xffff);
      R = (int) (backing.getShort(4) & 0xffff);
      alpha = (int) (backing.getShort(6) & 0xffff);
    }

    public void write() {
      backing.putShort(0, (short) (B & 0xffff));
      backing.putShort(2, (short) (G & 0xffff));
      backing.putShort(4, (short) (R & 0xffff));
      backing.putShort(6, (short) (alpha & 0xffff));
    }

    public int size() {
      return 8;
    }
  }

  public static class GeometricPatternMatch extends DisposedStruct {
    public PointFloat position; // The location of the origin of the template in
                                // the match.
    public float rotation; // The rotation of the match relative to the template
                           // image, in degrees.
    public float scale; // The size of the match relative to the size of the
                        // template image, expressed as a percentage.
    public float score; // The accuracy of the match.
    public PointFloat[] corner; // An array of four points describing the
                                // rectangle surrounding the template image.
    public int inverse; // This element is TRUE if the match is an inverse of
                        // the template image.
    public float occlusion; // The percentage of the match that is occluded.
    public float templateMatchCurveScore; // The accuracy of the match obtained
                                          // by comparing the template curves to
                                          // the curves in the match region.
    public float matchTemplateCurveScore; // The accuracy of the match obtained
                                          // by comparing the curves in the
                                          // match region to the template
                                          // curves.
    public float correlationScore; // The accuracy of the match obtained by
                                   // comparing the template image to the match
                                   // region using a correlation metric that
                                   // compares the two regions as a function of
                                   // their pixel values.

    private void init() {
      position = new PointFloat(backing, 0);
      corner = new PointFloat[4];

      for (int i = 0, off = 20; i < 4; i++, off += 8)
        corner[i] = new PointFloat(backing, off);
    }

    public GeometricPatternMatch() {
      super(72);
      init();
    }

    public GeometricPatternMatch(PointFloat position, double rotation, double scale, double score,
        PointFloat[] corner, int inverse, double occlusion, double templateMatchCurveScore,
        double matchTemplateCurveScore, double correlationScore) {
      super(72);
      this.position = position;
      this.rotation = (float) rotation;
      this.scale = (float) scale;
      this.score = (float) score;
      this.corner = corner;
      this.inverse = inverse;
      this.occlusion = (float) occlusion;
      this.templateMatchCurveScore = (float) templateMatchCurveScore;
      this.matchTemplateCurveScore = (float) matchTemplateCurveScore;
      this.correlationScore = (float) correlationScore;
    }

    protected GeometricPatternMatch(ByteBuffer backing, int offset) {
      super(backing, offset, 72);
      init();
    }

    protected GeometricPatternMatch(long nativeObj, boolean owned) {
      super(nativeObj, owned, 72);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 72);
    }

    public void read() {
      position.read();
      rotation = backing.getFloat(8);
      scale = backing.getFloat(12);
      score = backing.getFloat(16);
      for (PointFloat it : corner) {
        it.read();
      }
      inverse = backing.getInt(52);
      occlusion = backing.getFloat(56);
      templateMatchCurveScore = backing.getFloat(60);
      matchTemplateCurveScore = backing.getFloat(64);
      correlationScore = backing.getFloat(68);
    }

    public void write() {
      position.write();
      backing.putFloat(8, rotation);
      backing.putFloat(12, scale);
      backing.putFloat(16, score);
      for (PointFloat it : corner) {
        it.write();
      }
      backing.putInt(52, inverse);
      backing.putFloat(56, occlusion);
      backing.putFloat(60, templateMatchCurveScore);
      backing.putFloat(64, matchTemplateCurveScore);
      backing.putFloat(68, correlationScore);
    }

    public int size() {
      return 72;
    }
  }

  public static class MatchGeometricPatternAdvancedOptions extends DisposedStruct {
    public int minFeaturesUsed; // Specifies the minimum number of features the
                                // function uses when matching.
    public int maxFeaturesUsed; // Specifies the maximum number of features the
                                // function uses when matching.
    public int subpixelIterations; // Specifies the maximum number of
                                   // incremental improvements used to refine
                                   // matches with subpixel information.
    public double subpixelTolerance; // Specifies the maximum amount of change,
                                     // in pixels, between consecutive
                                     // incremental improvements in the match
                                     // position before the function stops
                                     // refining the match position.
    public int initialMatchListLength; // Specifies the maximum size of the
                                       // match list.
    public int matchTemplateCurveScore; // Set this element to TRUE to specify
                                        // that the function should calculate
                                        // the match curve to template curve
                                        // score and return it for each match
                                        // result.
    public int correlationScore; // Set this element to TRUE to specify that the
                                 // function should calculate the correlation
                                 // score and return it for each match result.
    public double minMatchSeparationDistance; // Specifies the minimum
                                              // separation distance, in pixels,
                                              // between the origins of two
                                              // matches that have unique
                                              // positions.
    public double minMatchSeparationAngle; // Specifies the minimum angular
                                           // difference, in degrees, between
                                           // two matches that have unique
                                           // angles.
    public double minMatchSeparationScale; // Specifies the minimum difference
                                           // in scale, expressed as a
                                           // percentage, between two matches
                                           // that have unique scales.
    public double maxMatchOverlap; // Specifies the maximum amount of overlap,
                                   // expressed as a percentage, allowed between
                                   // the bounding rectangles of two unique
                                   // matches.
    public int coarseResult; // Specifies whether you want the function to spend
                             // less time accurately estimating the location of
                             // a match.

    private void init() {

    }

    public MatchGeometricPatternAdvancedOptions() {
      super(80);
      init();
    }

    public MatchGeometricPatternAdvancedOptions(int minFeaturesUsed, int maxFeaturesUsed,
        int subpixelIterations, double subpixelTolerance, int initialMatchListLength,
        int matchTemplateCurveScore, int correlationScore, double minMatchSeparationDistance,
        double minMatchSeparationAngle, double minMatchSeparationScale, double maxMatchOverlap,
        int coarseResult) {
      super(80);
      this.minFeaturesUsed = minFeaturesUsed;
      this.maxFeaturesUsed = maxFeaturesUsed;
      this.subpixelIterations = subpixelIterations;
      this.subpixelTolerance = subpixelTolerance;
      this.initialMatchListLength = initialMatchListLength;
      this.matchTemplateCurveScore = matchTemplateCurveScore;
      this.correlationScore = correlationScore;
      this.minMatchSeparationDistance = minMatchSeparationDistance;
      this.minMatchSeparationAngle = minMatchSeparationAngle;
      this.minMatchSeparationScale = minMatchSeparationScale;
      this.maxMatchOverlap = maxMatchOverlap;
      this.coarseResult = coarseResult;
    }

    protected MatchGeometricPatternAdvancedOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 80);
      init();
    }

    protected MatchGeometricPatternAdvancedOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 80);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 80);
    }

    public void read() {
      minFeaturesUsed = backing.getInt(0);
      maxFeaturesUsed = backing.getInt(4);
      subpixelIterations = backing.getInt(8);
      subpixelTolerance = backing.getDouble(16);
      initialMatchListLength = backing.getInt(24);
      matchTemplateCurveScore = backing.getInt(28);
      correlationScore = backing.getInt(32);
      minMatchSeparationDistance = backing.getDouble(40);
      minMatchSeparationAngle = backing.getDouble(48);
      minMatchSeparationScale = backing.getDouble(56);
      maxMatchOverlap = backing.getDouble(64);
      coarseResult = backing.getInt(72);
    }

    public void write() {
      backing.putInt(0, minFeaturesUsed);
      backing.putInt(4, maxFeaturesUsed);
      backing.putInt(8, subpixelIterations);
      backing.putDouble(16, subpixelTolerance);
      backing.putInt(24, initialMatchListLength);
      backing.putInt(28, matchTemplateCurveScore);
      backing.putInt(32, correlationScore);
      backing.putDouble(40, minMatchSeparationDistance);
      backing.putDouble(48, minMatchSeparationAngle);
      backing.putDouble(56, minMatchSeparationScale);
      backing.putDouble(64, maxMatchOverlap);
      backing.putInt(72, coarseResult);
    }

    public int size() {
      return 80;
    }
  }

  public static class MatchGeometricPatternOptions extends DisposedStruct {
    public int mode; // Specifies the method imaqMatchGeometricPattern() uses
                     // when looking for the pattern in the image.
    public int subpixelAccuracy; // Set this element to TRUE to specify that the
                                 // function should calculate match locations
                                 // with subpixel accuracy.
    public RangeFloat[] angleRanges; // An array of angle ranges, in degrees,
                                     // where each range specifies how much you
                                     // expect the template to be rotated in the
                                     // image.
    public RangeFloat scaleRange; // A range that specifies the sizes of the
                                  // pattern you expect to be in the image,
                                  // expressed as a ratio percentage
                                  // representing the size of the pattern in the
                                  // image divided by size of the original
                                  // pattern multiplied by 100.
    public RangeFloat occlusionRange; // A range that specifies the percentage
                                      // of the pattern you expect to be
                                      // occluded in the image.
    public int numMatchesRequested; // Number of valid matches expected.
    public float minMatchScore; // The minimum score a match can have for the
                                // function to consider the match valid.
    private ByteBuffer angleRanges_buf;

    private void init() {
      angleRanges = new RangeFloat[0];
      scaleRange = new RangeFloat(backing, 16);
      occlusionRange = new RangeFloat(backing, 24);
    }

    public MatchGeometricPatternOptions() {
      super(40);
      init();
    }

    public MatchGeometricPatternOptions(int mode, int subpixelAccuracy, RangeFloat[] angleRanges,
        RangeFloat scaleRange, RangeFloat occlusionRange, int numMatchesRequested,
        double minMatchScore) {
      super(40);
      this.mode = mode;
      this.subpixelAccuracy = subpixelAccuracy;
      this.angleRanges = angleRanges;
      this.scaleRange = scaleRange;
      this.occlusionRange = occlusionRange;
      this.numMatchesRequested = numMatchesRequested;
      this.minMatchScore = (float) minMatchScore;
    }

    protected MatchGeometricPatternOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected MatchGeometricPatternOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      mode = backing.getInt(0);
      subpixelAccuracy = backing.getInt(4);
      int angleRanges_numAngleRanges = backing.getInt(12);
      long angleRanges_addr = getPointer(backing, 8);
      angleRanges = new RangeFloat[angleRanges_numAngleRanges];
      if (angleRanges_numAngleRanges > 0 && angleRanges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(angleRanges_addr, angleRanges_numAngleRanges * 8);
        for (int i = 0, off = 0; i < angleRanges_numAngleRanges; i++, off += 8) {
          angleRanges[i] = new RangeFloat(bb, off);
          angleRanges[i].read();
        }
      }
      scaleRange.read();
      occlusionRange.read();
      numMatchesRequested = backing.getInt(32);
      minMatchScore = backing.getFloat(36);
    }

    public void write() {
      backing.putInt(0, mode);
      backing.putInt(4, subpixelAccuracy);
      angleRanges_buf =
          ByteBuffer.allocateDirect(angleRanges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < angleRanges.length; i++, off += 8) {
        angleRanges[i].setBuffer(angleRanges_buf, off);
        angleRanges[i].write();
      }
      backing.putInt(12, angleRanges.length);
      putPointer(backing, 8, angleRanges_buf);
      scaleRange.write();
      occlusionRange.write();
      backing.putInt(32, numMatchesRequested);
      backing.putFloat(36, minMatchScore);
    }

    public int size() {
      return 40;
    }
  }

  public static class LearnGeometricPatternAdvancedOptions extends DisposedStruct {
    public int minRectLength; // Specifies the minimum length for each side of a
                              // rectangular feature.
    public double minRectAspectRatio; // Specifies the minimum aspect ratio of a
                                      // rectangular feature.
    public int minRadius; // Specifies the minimum radius for a circular
                          // feature.
    public int minLineLength; // Specifies the minimum length for a linear
                              // feature.
    public double minFeatureStrength; // Specifies the minimum strength for a
                                      // feature.
    public int maxFeaturesUsed; // Specifies the maximum number of features the
                                // function uses when learning.
    public int maxPixelDistanceFromLine; // Specifies the maximum number of
                                         // pixels between an edge pixel and a
                                         // linear feature for the function to
                                         // consider that edge pixel as part of
                                         // the linear feature.

    private void init() {

    }

    public LearnGeometricPatternAdvancedOptions() {
      super(40);
      init();
    }

    public LearnGeometricPatternAdvancedOptions(int minRectLength, double minRectAspectRatio,
        int minRadius, int minLineLength, double minFeatureStrength, int maxFeaturesUsed,
        int maxPixelDistanceFromLine) {
      super(40);
      this.minRectLength = minRectLength;
      this.minRectAspectRatio = minRectAspectRatio;
      this.minRadius = minRadius;
      this.minLineLength = minLineLength;
      this.minFeatureStrength = minFeatureStrength;
      this.maxFeaturesUsed = maxFeaturesUsed;
      this.maxPixelDistanceFromLine = maxPixelDistanceFromLine;
    }

    protected LearnGeometricPatternAdvancedOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected LearnGeometricPatternAdvancedOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      minRectLength = backing.getInt(0);
      minRectAspectRatio = backing.getDouble(8);
      minRadius = backing.getInt(16);
      minLineLength = backing.getInt(20);
      minFeatureStrength = backing.getDouble(24);
      maxFeaturesUsed = backing.getInt(32);
      maxPixelDistanceFromLine = backing.getInt(36);
    }

    public void write() {
      backing.putInt(0, minRectLength);
      backing.putDouble(8, minRectAspectRatio);
      backing.putInt(16, minRadius);
      backing.putInt(20, minLineLength);
      backing.putDouble(24, minFeatureStrength);
      backing.putInt(32, maxFeaturesUsed);
      backing.putInt(36, maxPixelDistanceFromLine);
    }

    public int size() {
      return 40;
    }
  }

  public static class FitEllipseOptions extends DisposedStruct {
    public int rejectOutliers; // Whether to use every given point or only a
                               // subset of the points to fit the ellipse.
    public double minScore; // Specifies the required quality of the fitted
                            // ellipse.
    public double pixelRadius; // The acceptable distance, in pixels, that a
                               // point determined to belong to the ellipse can
                               // be from the circumference of the ellipse.
    public int maxIterations; // Specifies the number of refinement iterations
                              // you allow the function to perform on the
                              // initial subset of points.

    private void init() {

    }

    public FitEllipseOptions() {
      super(32);
      init();
    }

    public FitEllipseOptions(int rejectOutliers, double minScore, double pixelRadius,
        int maxIterations) {
      super(32);
      this.rejectOutliers = rejectOutliers;
      this.minScore = minScore;
      this.pixelRadius = pixelRadius;
      this.maxIterations = maxIterations;
    }

    protected FitEllipseOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected FitEllipseOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      rejectOutliers = backing.getInt(0);
      minScore = backing.getDouble(8);
      pixelRadius = backing.getDouble(16);
      maxIterations = backing.getInt(24);
    }

    public void write() {
      backing.putInt(0, rejectOutliers);
      backing.putDouble(8, minScore);
      backing.putDouble(16, pixelRadius);
      backing.putInt(24, maxIterations);
    }

    public int size() {
      return 32;
    }
  }

  public static class FitCircleOptions extends DisposedStruct {
    public int rejectOutliers; // Whether to use every given point or only a
                               // subset of the points to fit the circle.
    public double minScore; // Specifies the required quality of the fitted
                            // circle.
    public double pixelRadius; // The acceptable distance, in pixels, that a
                               // point determined to belong to the circle can
                               // be from the circumference of the circle.
    public int maxIterations; // Specifies the number of refinement iterations
                              // you allow the function to perform on the
                              // initial subset of points.

    private void init() {

    }

    public FitCircleOptions() {
      super(32);
      init();
    }

    public FitCircleOptions(int rejectOutliers, double minScore, double pixelRadius,
        int maxIterations) {
      super(32);
      this.rejectOutliers = rejectOutliers;
      this.minScore = minScore;
      this.pixelRadius = pixelRadius;
      this.maxIterations = maxIterations;
    }

    protected FitCircleOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected FitCircleOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      rejectOutliers = backing.getInt(0);
      minScore = backing.getDouble(8);
      pixelRadius = backing.getDouble(16);
      maxIterations = backing.getInt(24);
    }

    public void write() {
      backing.putInt(0, rejectOutliers);
      backing.putDouble(8, minScore);
      backing.putDouble(16, pixelRadius);
      backing.putInt(24, maxIterations);
    }

    public int size() {
      return 32;
    }
  }

  public static class ConstructROIOptions2 extends DisposedStruct {
    public int windowNumber; // The window number of the image window.
    public String windowTitle; // Specifies the message string that the function
                               // displays in the title bar of the window.
    public PaletteType type; // The palette type to use.
    public RGBValue[] palette; // If type is IMAQ_PALETTE_USER, this array is
                               // the palette of colors to use with the window.
    public int maxContours; // The maximum number of contours the user will be
                            // able to select.
    private ByteBuffer windowTitle_buf;
    private ByteBuffer palette_buf;

    private void init() {
      palette = new RGBValue[0];
    }

    public ConstructROIOptions2() {
      super(24);
      init();
    }

    public ConstructROIOptions2(int windowNumber, String windowTitle, PaletteType type,
        RGBValue[] palette, int maxContours) {
      super(24);
      this.windowNumber = windowNumber;
      this.windowTitle = windowTitle;
      this.type = type;
      this.palette = palette;
      this.maxContours = maxContours;
    }

    protected ConstructROIOptions2(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected ConstructROIOptions2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      windowNumber = backing.getInt(0);
      long windowTitle_addr = getPointer(backing, 4);
      if (windowTitle_addr == 0)
        windowTitle = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(windowTitle_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          windowTitle = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          windowTitle = "";
        }
      }

      type = PaletteType.fromValue(backing.getInt(8));
      int palette_numColors = backing.getInt(16);
      long palette_addr = getPointer(backing, 12);
      palette = new RGBValue[palette_numColors];
      if (palette_numColors > 0 && palette_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(palette_addr, palette_numColors * 4);
        for (int i = 0, off = 0; i < palette_numColors; i++, off += 4) {
          palette[i] = new RGBValue(bb, off);
          palette[i].read();
        }
      }
      maxContours = backing.getInt(20);
    }

    public void write() {
      backing.putInt(0, windowNumber);
      if (windowTitle != null) {
        byte[] windowTitle_bytes;
        try {
          windowTitle_bytes = windowTitle.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          windowTitle_bytes = new byte[0];
        }
        windowTitle_buf = ByteBuffer.allocateDirect(windowTitle_bytes.length + 1);
        putBytes(windowTitle_buf, windowTitle_bytes, 0, windowTitle_bytes.length).put(
            windowTitle_bytes.length, (byte) 0);
      }
      putPointer(backing, 4, windowTitle == null ? 0 : getByteBufferAddress(windowTitle_buf));
      if (type != null)
        backing.putInt(8, type.getValue());
      palette_buf = ByteBuffer.allocateDirect(palette.length * 4).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < palette.length; i++, off += 4) {
        palette[i].setBuffer(palette_buf, off);
        palette[i].write();
      }
      backing.putInt(16, palette.length);
      putPointer(backing, 12, palette_buf);
      backing.putInt(20, maxContours);
    }

    public int size() {
      return 24;
    }
  }

  public static class HSLValue extends DisposedStruct {
    public short L; // The color luminance.
    public short S; // The color saturation.
    public short H; // The color hue.
    public short alpha; // The alpha value of the color, which represents extra
                        // information about a color image, such as gamma
                        // correction.

    private void init() {

    }

    public HSLValue() {
      super(4);
      init();
    }

    public HSLValue(int L, int S, int H, int alpha) {
      super(4);
      this.L = (short) L;
      this.S = (short) S;
      this.H = (short) H;
      this.alpha = (short) alpha;
    }

    protected HSLValue(ByteBuffer backing, int offset) {
      super(backing, offset, 4);
      init();
    }

    protected HSLValue(long nativeObj, boolean owned) {
      super(nativeObj, owned, 4);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 4);
    }

    public void read() {
      L = (short) (backing.get(0) & 0xff);
      S = (short) (backing.get(1) & 0xff);
      H = (short) (backing.get(2) & 0xff);
      alpha = (short) (backing.get(3) & 0xff);
    }

    public void write() {
      backing.put(0, (byte) (L & 0xff));
      backing.put(1, (byte) (S & 0xff));
      backing.put(2, (byte) (H & 0xff));
      backing.put(3, (byte) (alpha & 0xff));
    }

    public int size() {
      return 4;
    }
  }

  public static class HSVValue extends DisposedStruct {
    public short V; // The color value.
    public short S; // The color saturation.
    public short H; // The color hue.
    public short alpha; // The alpha value of the color, which represents extra
                        // information about a color image, such as gamma
                        // correction.

    private void init() {

    }

    public HSVValue() {
      super(4);
      init();
    }

    public HSVValue(int V, int S, int H, int alpha) {
      super(4);
      this.V = (short) V;
      this.S = (short) S;
      this.H = (short) H;
      this.alpha = (short) alpha;
    }

    protected HSVValue(ByteBuffer backing, int offset) {
      super(backing, offset, 4);
      init();
    }

    protected HSVValue(long nativeObj, boolean owned) {
      super(nativeObj, owned, 4);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 4);
    }

    public void read() {
      V = (short) (backing.get(0) & 0xff);
      S = (short) (backing.get(1) & 0xff);
      H = (short) (backing.get(2) & 0xff);
      alpha = (short) (backing.get(3) & 0xff);
    }

    public void write() {
      backing.put(0, (byte) (V & 0xff));
      backing.put(1, (byte) (S & 0xff));
      backing.put(2, (byte) (H & 0xff));
      backing.put(3, (byte) (alpha & 0xff));
    }

    public int size() {
      return 4;
    }
  }

  public static class HSIValue extends DisposedStruct {
    public short I; // The color intensity.
    public short S; // The color saturation.
    public short H; // The color hue.
    public short alpha; // The alpha value of the color, which represents extra
                        // information about a color image, such as gamma
                        // correction.

    private void init() {

    }

    public HSIValue() {
      super(4);
      init();
    }

    public HSIValue(int I, int S, int H, int alpha) {
      super(4);
      this.I = (short) I;
      this.S = (short) S;
      this.H = (short) H;
      this.alpha = (short) alpha;
    }

    protected HSIValue(ByteBuffer backing, int offset) {
      super(backing, offset, 4);
      init();
    }

    protected HSIValue(long nativeObj, boolean owned) {
      super(nativeObj, owned, 4);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 4);
    }

    public void read() {
      I = (short) (backing.get(0) & 0xff);
      S = (short) (backing.get(1) & 0xff);
      H = (short) (backing.get(2) & 0xff);
      alpha = (short) (backing.get(3) & 0xff);
    }

    public void write() {
      backing.put(0, (byte) (I & 0xff));
      backing.put(1, (byte) (S & 0xff));
      backing.put(2, (byte) (H & 0xff));
      backing.put(3, (byte) (alpha & 0xff));
    }

    public int size() {
      return 4;
    }
  }

  public static class CIELabValue extends DisposedStruct {
    public double b; // The yellow/blue information of the color.
    public double a; // The red/green information of the color.
    public double L; // The color lightness.
    public short alpha; // The alpha value of the color, which represents extra
                        // information about a color image, such as gamma
                        // correction.

    private void init() {

    }

    public CIELabValue() {
      super(32);
      init();
    }

    public CIELabValue(double b, double a, double L, int alpha) {
      super(32);
      this.b = b;
      this.a = a;
      this.L = L;
      this.alpha = (short) alpha;
    }

    protected CIELabValue(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected CIELabValue(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      b = backing.getDouble(0);
      a = backing.getDouble(8);
      L = backing.getDouble(16);
      alpha = (short) (backing.get(24) & 0xff);
    }

    public void write() {
      backing.putDouble(0, b);
      backing.putDouble(8, a);
      backing.putDouble(16, L);
      backing.put(24, (byte) (alpha & 0xff));
    }

    public int size() {
      return 32;
    }
  }

  public static class CIEXYZValue extends DisposedStruct {
    public double Z; // The Z color information.
    public double Y; // The color luminance.
    public double X; // The X color information.
    public short alpha; // The alpha value of the color, which represents extra
                        // information about a color image, such as gamma
                        // correction.

    private void init() {

    }

    public CIEXYZValue() {
      super(32);
      init();
    }

    public CIEXYZValue(double Z, double Y, double X, int alpha) {
      super(32);
      this.Z = Z;
      this.Y = Y;
      this.X = X;
      this.alpha = (short) alpha;
    }

    protected CIEXYZValue(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected CIEXYZValue(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      Z = backing.getDouble(0);
      Y = backing.getDouble(8);
      X = backing.getDouble(16);
      alpha = (short) (backing.get(24) & 0xff);
    }

    public void write() {
      backing.putDouble(0, Z);
      backing.putDouble(8, Y);
      backing.putDouble(16, X);
      backing.put(24, (byte) (alpha & 0xff));
    }

    public int size() {
      return 32;
    }
  }

  public static class BestEllipse2 extends DisposedStruct {
    public PointFloat center; // The coordinate location of the center of the
                              // ellipse.
    public PointFloat majorAxisStart; // The coordinate location of the start of
                                      // the major axis of the ellipse.
    public PointFloat majorAxisEnd; // The coordinate location of the end of the
                                    // major axis of the ellipse.
    public PointFloat minorAxisStart; // The coordinate location of the start of
                                      // the minor axis of the ellipse.
    public PointFloat minorAxisEnd; // The coordinate location of the end of the
                                    // minor axis of the ellipse.
    public double area; // The area of the ellipse.
    public double perimeter; // The length of the perimeter of the ellipse.
    public double error; // Represents the least square error of the fitted
                         // ellipse to the entire set of points.
    public int valid; // This element is TRUE if the function achieved the
                      // minimum score within the number of allowed refinement
                      // iterations and FALSE if the function did not achieve
                      // the minimum score.
    public int[] pointsUsed; // An array of the indexes for the points array
                             // indicating which points the function used to fit
                             // the ellipse.
    private ByteBuffer pointsUsed_buf;

    private void init() {
      center = new PointFloat(backing, 0);
      majorAxisStart = new PointFloat(backing, 8);
      majorAxisEnd = new PointFloat(backing, 16);
      minorAxisStart = new PointFloat(backing, 24);
      minorAxisEnd = new PointFloat(backing, 32);
      pointsUsed = new int[0];
    }

    public BestEllipse2() {
      super(80);
      init();
    }

    public BestEllipse2(PointFloat center, PointFloat majorAxisStart, PointFloat majorAxisEnd,
        PointFloat minorAxisStart, PointFloat minorAxisEnd, double area, double perimeter,
        double error, int valid, int[] pointsUsed) {
      super(80);
      this.center = center;
      this.majorAxisStart = majorAxisStart;
      this.majorAxisEnd = majorAxisEnd;
      this.minorAxisStart = minorAxisStart;
      this.minorAxisEnd = minorAxisEnd;
      this.area = area;
      this.perimeter = perimeter;
      this.error = error;
      this.valid = valid;
      this.pointsUsed = pointsUsed;
    }

    protected BestEllipse2(ByteBuffer backing, int offset) {
      super(backing, offset, 80);
      init();
    }

    protected BestEllipse2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 80);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 80);
    }

    public void read() {
      center.read();
      majorAxisStart.read();
      majorAxisEnd.read();
      minorAxisStart.read();
      minorAxisEnd.read();
      area = backing.getDouble(40);
      perimeter = backing.getDouble(48);
      error = backing.getDouble(56);
      valid = backing.getInt(64);
      int pointsUsed_numPointsUsed = backing.getInt(72);
      long pointsUsed_addr = getPointer(backing, 68);
      pointsUsed = new int[pointsUsed_numPointsUsed];
      if (pointsUsed_numPointsUsed > 0 && pointsUsed_addr != 0) {
        newDirectByteBuffer(pointsUsed_addr, pointsUsed_numPointsUsed * 4).asIntBuffer().get(
            pointsUsed);
      }
    }

    public void write() {
      center.write();
      majorAxisStart.write();
      majorAxisEnd.write();
      minorAxisStart.write();
      minorAxisEnd.write();
      backing.putDouble(40, area);
      backing.putDouble(48, perimeter);
      backing.putDouble(56, error);
      backing.putInt(64, valid);
      pointsUsed_buf =
          ByteBuffer.allocateDirect(pointsUsed.length * 4).order(ByteOrder.nativeOrder());
      pointsUsed_buf.asIntBuffer().put(pointsUsed).rewind();
      backing.putInt(72, pointsUsed.length);
      putPointer(backing, 68, pointsUsed_buf);
    }

    public int size() {
      return 80;
    }
  }

  public static class LearnPatternAdvancedOptions extends DisposedStruct {
    public LearnPatternAdvancedShiftOptions shiftOptions; // Use this element to
                                                          // control the
                                                          // behavior of
                                                          // imaqLearnPattern2()
                                                          // during the
                                                          // shift-invariant
                                                          // learning phase.
    public LearnPatternAdvancedRotationOptions rotationOptions; // Use this
                                                                // element to
                                                                // control the
                                                                // behavior of
                                                                // imaqLearnPattern2()during
                                                                // the
                                                                // rotation-invariant
                                                                // learning
                                                                // phase.

    private void init() {

    }

    public LearnPatternAdvancedOptions() {
      super(8);
      init();
    }

    public LearnPatternAdvancedOptions(LearnPatternAdvancedShiftOptions shiftOptions,
        LearnPatternAdvancedRotationOptions rotationOptions) {
      super(8);
      this.shiftOptions = shiftOptions;
      this.rotationOptions = rotationOptions;
    }

    protected LearnPatternAdvancedOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected LearnPatternAdvancedOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      long shiftOptions_addr = getPointer(backing, 0);
      if (shiftOptions_addr == 0)
        shiftOptions = null;
      else
        shiftOptions = new LearnPatternAdvancedShiftOptions(shiftOptions_addr, false);
      long rotationOptions_addr = getPointer(backing, 4);
      if (rotationOptions_addr == 0)
        rotationOptions = null;
      else
        rotationOptions = new LearnPatternAdvancedRotationOptions(rotationOptions_addr, false);
    }

    public void write() {
      putPointer(backing, 0, shiftOptions);
      putPointer(backing, 4, rotationOptions);
    }

    public int size() {
      return 8;
    }
  }

  public static class AVIInfo extends DisposedStruct {
    public int width; // The width of each frame.
    public int height; // The height of each frame.
    public ImageType imageType; // The type of images this AVI contains.
    public int numFrames; // The number of frames in the AVI.
    public int framesPerSecond; // The number of frames per second this AVI
                                // should be shown at.
    public String filterName; // The name of the compression filter used to
                              // create this AVI.
    public int hasData; // Specifies whether this AVI has data attached to each
                        // frame or not.
    public int maxDataSize; // If this AVI has data, the maximum size of the
                            // data in each frame.
    private ByteBuffer filterName_buf;

    private void init() {

    }

    public AVIInfo() {
      super(32);
      init();
    }

    public AVIInfo(int width, int height, ImageType imageType, int numFrames, int framesPerSecond,
        String filterName, int hasData, int maxDataSize) {
      super(32);
      this.width = width;
      this.height = height;
      this.imageType = imageType;
      this.numFrames = numFrames;
      this.framesPerSecond = framesPerSecond;
      this.filterName = filterName;
      this.hasData = hasData;
      this.maxDataSize = maxDataSize;
    }

    protected AVIInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected AVIInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      width = backing.getInt(0);
      height = backing.getInt(4);
      imageType = ImageType.fromValue(backing.getInt(8));
      numFrames = backing.getInt(12);
      framesPerSecond = backing.getInt(16);
      long filterName_addr = getPointer(backing, 20);
      if (filterName_addr == 0)
        filterName = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(filterName_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          filterName = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          filterName = "";
        }
      }

      hasData = backing.getInt(24);
      maxDataSize = backing.getInt(28);
    }

    public void write() {
      backing.putInt(0, width);
      backing.putInt(4, height);
      if (imageType != null)
        backing.putInt(8, imageType.getValue());
      backing.putInt(12, numFrames);
      backing.putInt(16, framesPerSecond);
      if (filterName != null) {
        byte[] filterName_bytes;
        try {
          filterName_bytes = filterName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          filterName_bytes = new byte[0];
        }
        filterName_buf = ByteBuffer.allocateDirect(filterName_bytes.length + 1);
        putBytes(filterName_buf, filterName_bytes, 0, filterName_bytes.length).put(
            filterName_bytes.length, (byte) 0);
      }
      putPointer(backing, 20, filterName == null ? 0 : getByteBufferAddress(filterName_buf));
      backing.putInt(24, hasData);
      backing.putInt(28, maxDataSize);
    }

    public int size() {
      return 32;
    }
  }

  public static class LearnPatternAdvancedShiftOptions extends DisposedStruct {
    public int initialStepSize; // The largest number of image pixels to shift
                                // the sample across the inspection image during
                                // the initial phase of shift-invariant
                                // matching.
    public int initialSampleSize; // Specifies the number of template pixels
                                  // that you want to include in a sample for
                                  // the initial phase of shift-invariant
                                  // matching.
    public double initialSampleSizeFactor; // Specifies the size of the sample
                                           // for the initial phase of
                                           // shift-invariant matching as a
                                           // percent of the template size, in
                                           // pixels.
    public int finalSampleSize; // Specifies the number of template pixels you
                                // want to add to initialSampleSize for the
                                // final phase of shift-invariant matching.
    public double finalSampleSizeFactor; // Specifies the size of the sample for
                                         // the final phase of shift-invariant
                                         // matching as a percent of the edge
                                         // points in the template, in pixels.
    public int subpixelSampleSize; // Specifies the number of template pixels
                                   // that you want to include in a sample for
                                   // the subpixel phase of shift-invariant
                                   // matching.
    public double subpixelSampleSizeFactor; // Specifies the size of the sample
                                            // for the subpixel phase of
                                            // shift-invariant matching as a
                                            // percent of the template size, in
                                            // pixels.

    private void init() {

    }

    public LearnPatternAdvancedShiftOptions() {
      super(48);
      init();
    }

    public LearnPatternAdvancedShiftOptions(int initialStepSize, int initialSampleSize,
        double initialSampleSizeFactor, int finalSampleSize, double finalSampleSizeFactor,
        int subpixelSampleSize, double subpixelSampleSizeFactor) {
      super(48);
      this.initialStepSize = initialStepSize;
      this.initialSampleSize = initialSampleSize;
      this.initialSampleSizeFactor = initialSampleSizeFactor;
      this.finalSampleSize = finalSampleSize;
      this.finalSampleSizeFactor = finalSampleSizeFactor;
      this.subpixelSampleSize = subpixelSampleSize;
      this.subpixelSampleSizeFactor = subpixelSampleSizeFactor;
    }

    protected LearnPatternAdvancedShiftOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 48);
      init();
    }

    protected LearnPatternAdvancedShiftOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 48);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 48);
    }

    public void read() {
      initialStepSize = backing.getInt(0);
      initialSampleSize = backing.getInt(4);
      initialSampleSizeFactor = backing.getDouble(8);
      finalSampleSize = backing.getInt(16);
      finalSampleSizeFactor = backing.getDouble(24);
      subpixelSampleSize = backing.getInt(32);
      subpixelSampleSizeFactor = backing.getDouble(40);
    }

    public void write() {
      backing.putInt(0, initialStepSize);
      backing.putInt(4, initialSampleSize);
      backing.putDouble(8, initialSampleSizeFactor);
      backing.putInt(16, finalSampleSize);
      backing.putDouble(24, finalSampleSizeFactor);
      backing.putInt(32, subpixelSampleSize);
      backing.putDouble(40, subpixelSampleSizeFactor);
    }

    public int size() {
      return 48;
    }
  }

  public static class LearnPatternAdvancedRotationOptions extends DisposedStruct {
    public SearchStrategy searchStrategySupport; // Specifies the aggressiveness
                                                 // of the rotation search
                                                 // strategy available during
                                                 // the matching phase.
    public int initialStepSize; // The largest number of image pixels to shift
                                // the sample across the inspection image during
                                // the initial phase of matching.
    public int initialSampleSize; // Specifies the number of template pixels
                                  // that you want to include in a sample for
                                  // the initial phase of rotation-invariant
                                  // matching.
    public double initialSampleSizeFactor; // Specifies the size of the sample
                                           // for the initial phase of
                                           // rotation-invariant matching as a
                                           // percent of the template size, in
                                           // pixels.
    public int initialAngularAccuracy; // Sets the angle accuracy, in degrees,
                                       // to use during the initial phase of
                                       // rotation-invariant matching.
    public int finalSampleSize; // Specifies the number of template pixels you
                                // want to add to initialSampleSize for the
                                // final phase of rotation-invariant matching.
    public double finalSampleSizeFactor; // Specifies the size of the sample for
                                         // the final phase of
                                         // rotation-invariant matching as a
                                         // percent of the edge points in the
                                         // template, in pixels.
    public int finalAngularAccuracy; // Sets the angle accuracy, in degrees, to
                                     // use during the final phase of the
                                     // rotation-invariant matching.
    public int subpixelSampleSize; // Specifies the number of template pixels
                                   // that you want to include in a sample for
                                   // the subpixel phase of rotation-invariant
                                   // matching.
    public double subpixelSampleSizeFactor; // Specifies the size of the sample
                                            // for the subpixel phase of
                                            // rotation-invariant matching as a
                                            // percent of the template size, in
                                            // pixels.

    private void init() {

    }

    public LearnPatternAdvancedRotationOptions() {
      super(56);
      init();
    }

    public LearnPatternAdvancedRotationOptions(SearchStrategy searchStrategySupport,
        int initialStepSize, int initialSampleSize, double initialSampleSizeFactor,
        int initialAngularAccuracy, int finalSampleSize, double finalSampleSizeFactor,
        int finalAngularAccuracy, int subpixelSampleSize, double subpixelSampleSizeFactor) {
      super(56);
      this.searchStrategySupport = searchStrategySupport;
      this.initialStepSize = initialStepSize;
      this.initialSampleSize = initialSampleSize;
      this.initialSampleSizeFactor = initialSampleSizeFactor;
      this.initialAngularAccuracy = initialAngularAccuracy;
      this.finalSampleSize = finalSampleSize;
      this.finalSampleSizeFactor = finalSampleSizeFactor;
      this.finalAngularAccuracy = finalAngularAccuracy;
      this.subpixelSampleSize = subpixelSampleSize;
      this.subpixelSampleSizeFactor = subpixelSampleSizeFactor;
    }

    protected LearnPatternAdvancedRotationOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 56);
      init();
    }

    protected LearnPatternAdvancedRotationOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 56);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 56);
    }

    public void read() {
      searchStrategySupport = SearchStrategy.fromValue(backing.getInt(0));
      initialStepSize = backing.getInt(4);
      initialSampleSize = backing.getInt(8);
      initialSampleSizeFactor = backing.getDouble(16);
      initialAngularAccuracy = backing.getInt(24);
      finalSampleSize = backing.getInt(28);
      finalSampleSizeFactor = backing.getDouble(32);
      finalAngularAccuracy = backing.getInt(40);
      subpixelSampleSize = backing.getInt(44);
      subpixelSampleSizeFactor = backing.getDouble(48);
    }

    public void write() {
      if (searchStrategySupport != null)
        backing.putInt(0, searchStrategySupport.getValue());
      backing.putInt(4, initialStepSize);
      backing.putInt(8, initialSampleSize);
      backing.putDouble(16, initialSampleSizeFactor);
      backing.putInt(24, initialAngularAccuracy);
      backing.putInt(28, finalSampleSize);
      backing.putDouble(32, finalSampleSizeFactor);
      backing.putInt(40, finalAngularAccuracy);
      backing.putInt(44, subpixelSampleSize);
      backing.putDouble(48, subpixelSampleSizeFactor);
    }

    public int size() {
      return 56;
    }
  }

  public static class MatchPatternAdvancedOptions extends DisposedStruct {
    public int subpixelIterations; // Defines the maximum number of incremental
                                   // improvements used to refine matching using
                                   // subpixel information.
    public double subpixelTolerance; // Defines the maximum amount of change, in
                                     // pixels, between consecutive incremental
                                     // improvements in the match position that
                                     // you want to trigger the end of the
                                     // refinement process.
    public int initialMatchListLength; // Specifies the maximum size of the
                                       // match list.
    public int matchListReductionFactor; // Specifies the reduction of the match
                                         // list as matches are refined.
    public int initialStepSize; // Specifies the number of pixels to shift the
                                // sample across the inspection image during the
                                // initial phase of shift-invariant matching.
    public SearchStrategy searchStrategy; // Specifies the aggressiveness of the
                                          // rotation search strategy.
    public int intermediateAngularAccuracy; // Specifies the accuracy to use
                                            // during the intermediate phase of
                                            // rotation-invariant matching.

    private void init() {

    }

    public MatchPatternAdvancedOptions() {
      super(40);
      init();
    }

    public MatchPatternAdvancedOptions(int subpixelIterations, double subpixelTolerance,
        int initialMatchListLength, int matchListReductionFactor, int initialStepSize,
        SearchStrategy searchStrategy, int intermediateAngularAccuracy) {
      super(40);
      this.subpixelIterations = subpixelIterations;
      this.subpixelTolerance = subpixelTolerance;
      this.initialMatchListLength = initialMatchListLength;
      this.matchListReductionFactor = matchListReductionFactor;
      this.initialStepSize = initialStepSize;
      this.searchStrategy = searchStrategy;
      this.intermediateAngularAccuracy = intermediateAngularAccuracy;
    }

    protected MatchPatternAdvancedOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected MatchPatternAdvancedOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      subpixelIterations = backing.getInt(0);
      subpixelTolerance = backing.getDouble(8);
      initialMatchListLength = backing.getInt(16);
      matchListReductionFactor = backing.getInt(20);
      initialStepSize = backing.getInt(24);
      searchStrategy = SearchStrategy.fromValue(backing.getInt(28));
      intermediateAngularAccuracy = backing.getInt(32);
    }

    public void write() {
      backing.putInt(0, subpixelIterations);
      backing.putDouble(8, subpixelTolerance);
      backing.putInt(16, initialMatchListLength);
      backing.putInt(20, matchListReductionFactor);
      backing.putInt(24, initialStepSize);
      if (searchStrategy != null)
        backing.putInt(28, searchStrategy.getValue());
      backing.putInt(32, intermediateAngularAccuracy);
    }

    public int size() {
      return 40;
    }
  }

  public static class ParticleFilterCriteria2 extends DisposedStruct {
    public MeasurementType parameter; // The morphological measurement that the
                                      // function uses for filtering.
    public float lower; // The lower bound of the criteria range.
    public float upper; // The upper bound of the criteria range.
    public int calibrated; // Set this element to TRUE to take calibrated
                           // measurements.
    public int exclude; // Set this element to TRUE to indicate that a match
                        // occurs when the measurement is outside the criteria
                        // range.

    private void init() {

    }

    public ParticleFilterCriteria2() {
      super(20);
      init();
    }

    public ParticleFilterCriteria2(MeasurementType parameter, double lower, double upper,
        int calibrated, int exclude) {
      super(20);
      this.parameter = parameter;
      this.lower = (float) lower;
      this.upper = (float) upper;
      this.calibrated = calibrated;
      this.exclude = exclude;
    }

    protected ParticleFilterCriteria2(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected ParticleFilterCriteria2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      parameter = MeasurementType.fromValue(backing.getInt(0));
      lower = backing.getFloat(4);
      upper = backing.getFloat(8);
      calibrated = backing.getInt(12);
      exclude = backing.getInt(16);
    }

    public void write() {
      if (parameter != null)
        backing.putInt(0, parameter.getValue());
      backing.putFloat(4, lower);
      backing.putFloat(8, upper);
      backing.putInt(12, calibrated);
      backing.putInt(16, exclude);
    }

    public int size() {
      return 20;
    }
  }

  public static class BestCircle2 extends DisposedStruct {
    public PointFloat center; // The coordinate location of the center of the
                              // circle.
    public double radius; // The radius of the circle.
    public double area; // The area of the circle.
    public double perimeter; // The length of the perimeter of the circle.
    public double error; // Represents the least square error of the fitted
                         // circle to the entire set of points.
    public int valid; // This element is TRUE if the function achieved the
                      // minimum score within the number of allowed refinement
                      // iterations and FALSE if the function did not achieve
                      // the minimum score.
    public int[] pointsUsed; // An array of the indexes for the points array
                             // indicating which points the function used to fit
                             // the circle.
    private ByteBuffer pointsUsed_buf;

    private void init() {
      center = new PointFloat(backing, 0);
      pointsUsed = new int[0];
    }

    public BestCircle2() {
      super(56);
      init();
    }

    public BestCircle2(PointFloat center, double radius, double area, double perimeter,
        double error, int valid, int[] pointsUsed) {
      super(56);
      this.center = center;
      this.radius = radius;
      this.area = area;
      this.perimeter = perimeter;
      this.error = error;
      this.valid = valid;
      this.pointsUsed = pointsUsed;
    }

    protected BestCircle2(ByteBuffer backing, int offset) {
      super(backing, offset, 56);
      init();
    }

    protected BestCircle2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 56);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 56);
    }

    public void read() {
      center.read();
      radius = backing.getDouble(8);
      area = backing.getDouble(16);
      perimeter = backing.getDouble(24);
      error = backing.getDouble(32);
      valid = backing.getInt(40);
      int pointsUsed_numPointsUsed = backing.getInt(48);
      long pointsUsed_addr = getPointer(backing, 44);
      pointsUsed = new int[pointsUsed_numPointsUsed];
      if (pointsUsed_numPointsUsed > 0 && pointsUsed_addr != 0) {
        newDirectByteBuffer(pointsUsed_addr, pointsUsed_numPointsUsed * 4).asIntBuffer().get(
            pointsUsed);
      }
    }

    public void write() {
      center.write();
      backing.putDouble(8, radius);
      backing.putDouble(16, area);
      backing.putDouble(24, perimeter);
      backing.putDouble(32, error);
      backing.putInt(40, valid);
      pointsUsed_buf =
          ByteBuffer.allocateDirect(pointsUsed.length * 4).order(ByteOrder.nativeOrder());
      pointsUsed_buf.asIntBuffer().put(pointsUsed).rewind();
      backing.putInt(48, pointsUsed.length);
      putPointer(backing, 44, pointsUsed_buf);
    }

    public int size() {
      return 56;
    }
  }

  public static class OCRSpacingOptions extends DisposedStruct {
    public int minCharSpacing; // The minimum number of pixels that must be
                               // between two characters for NI Vision to train
                               // or read the characters separately.
    public int minCharSize; // The minimum number of pixels required for an
                            // object to be a potentially identifiable
                            // character.
    public int maxCharSize; // The maximum number of pixels required for an
                            // object to be a potentially identifiable
                            // character.
    public int maxHorizontalElementSpacing; // The maximum horizontal spacing,
                                            // in pixels, allowed between
                                            // character elements to train or
                                            // read the character elements as a
                                            // single character.
    public int maxVerticalElementSpacing; // The maximum vertical element
                                          // spacing in pixels.
    public int minBoundingRectWidth; // The minimum possible width, in pixels,
                                     // for a character bounding rectangle.
    public int maxBoundingRectWidth; // The maximum possible width, in pixels,
                                     // for a character bounding rectangle.
    public int minBoundingRectHeight; // The minimum possible height, in pixels,
                                      // for a character bounding rectangle.
    public int maxBoundingRectHeight; // The maximum possible height, in pixels,
                                      // for a character bounding rectangle.
    public int autoSplit; // Set this element to TRUE to automatically adjust
                          // the location of the character bounding rectangle
                          // when characters overlap vertically.

    private void init() {

    }

    public OCRSpacingOptions() {
      super(40);
      init();
    }

    public OCRSpacingOptions(int minCharSpacing, int minCharSize, int maxCharSize,
        int maxHorizontalElementSpacing, int maxVerticalElementSpacing, int minBoundingRectWidth,
        int maxBoundingRectWidth, int minBoundingRectHeight, int maxBoundingRectHeight,
        int autoSplit) {
      super(40);
      this.minCharSpacing = minCharSpacing;
      this.minCharSize = minCharSize;
      this.maxCharSize = maxCharSize;
      this.maxHorizontalElementSpacing = maxHorizontalElementSpacing;
      this.maxVerticalElementSpacing = maxVerticalElementSpacing;
      this.minBoundingRectWidth = minBoundingRectWidth;
      this.maxBoundingRectWidth = maxBoundingRectWidth;
      this.minBoundingRectHeight = minBoundingRectHeight;
      this.maxBoundingRectHeight = maxBoundingRectHeight;
      this.autoSplit = autoSplit;
    }

    protected OCRSpacingOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected OCRSpacingOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      minCharSpacing = backing.getInt(0);
      minCharSize = backing.getInt(4);
      maxCharSize = backing.getInt(8);
      maxHorizontalElementSpacing = backing.getInt(12);
      maxVerticalElementSpacing = backing.getInt(16);
      minBoundingRectWidth = backing.getInt(20);
      maxBoundingRectWidth = backing.getInt(24);
      minBoundingRectHeight = backing.getInt(28);
      maxBoundingRectHeight = backing.getInt(32);
      autoSplit = backing.getInt(36);
    }

    public void write() {
      backing.putInt(0, minCharSpacing);
      backing.putInt(4, minCharSize);
      backing.putInt(8, maxCharSize);
      backing.putInt(12, maxHorizontalElementSpacing);
      backing.putInt(16, maxVerticalElementSpacing);
      backing.putInt(20, minBoundingRectWidth);
      backing.putInt(24, maxBoundingRectWidth);
      backing.putInt(28, minBoundingRectHeight);
      backing.putInt(32, maxBoundingRectHeight);
      backing.putInt(36, autoSplit);
    }

    public int size() {
      return 40;
    }
  }

  public static class OCRProcessingOptions extends DisposedStruct {
    public ThresholdMode mode; // The thresholding mode.
    public int lowThreshold; // The low threshold value when you set mode to
                             // IMAQ_FIXED_RANGE.
    public int highThreshold; // The high threshold value when you set mode to
                              // IMAQ_FIXED_RANGE.
    public int blockCount; // The number of blocks for threshold calculation
                           // algorithms that require blocks.
    public int fastThreshold; // Set this element to TRUE to use a faster, less
                              // accurate threshold calculation algorithm.
    public int biModalCalculation; // Set this element to TRUE to calculate both
                                   // the low and high threshold values when
                                   // using the fast thresholding method.
    public int darkCharacters; // Set this element to TRUE to read or train dark
                               // characters on a light background.
    public int removeParticlesTouchingROI; // Set this element to TRUE to remove
                                           // the particles touching the ROI.
    public int erosionCount; // The number of erosions to perform.

    private void init() {

    }

    public OCRProcessingOptions() {
      super(36);
      init();
    }

    public OCRProcessingOptions(ThresholdMode mode, int lowThreshold, int highThreshold,
        int blockCount, int fastThreshold, int biModalCalculation, int darkCharacters,
        int removeParticlesTouchingROI, int erosionCount) {
      super(36);
      this.mode = mode;
      this.lowThreshold = lowThreshold;
      this.highThreshold = highThreshold;
      this.blockCount = blockCount;
      this.fastThreshold = fastThreshold;
      this.biModalCalculation = biModalCalculation;
      this.darkCharacters = darkCharacters;
      this.removeParticlesTouchingROI = removeParticlesTouchingROI;
      this.erosionCount = erosionCount;
    }

    protected OCRProcessingOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 36);
      init();
    }

    protected OCRProcessingOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 36);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 36);
    }

    public void read() {
      mode = ThresholdMode.fromValue(backing.getInt(0));
      lowThreshold = backing.getInt(4);
      highThreshold = backing.getInt(8);
      blockCount = backing.getInt(12);
      fastThreshold = backing.getInt(16);
      biModalCalculation = backing.getInt(20);
      darkCharacters = backing.getInt(24);
      removeParticlesTouchingROI = backing.getInt(28);
      erosionCount = backing.getInt(32);
    }

    public void write() {
      if (mode != null)
        backing.putInt(0, mode.getValue());
      backing.putInt(4, lowThreshold);
      backing.putInt(8, highThreshold);
      backing.putInt(12, blockCount);
      backing.putInt(16, fastThreshold);
      backing.putInt(20, biModalCalculation);
      backing.putInt(24, darkCharacters);
      backing.putInt(28, removeParticlesTouchingROI);
      backing.putInt(32, erosionCount);
    }

    public int size() {
      return 36;
    }
  }

  public static class ReadTextOptions extends DisposedStruct {
    public String[] validChars; // An array of strings that specifies the valid
                                // characters.
    public byte substitutionChar; // The character to substitute for objects
                                  // that the function cannot match with any of
                                  // the trained characters.
    public ReadStrategy readStrategy; // The read strategy, which determines how
                                      // closely the function analyzes images in
                                      // the reading process to match objects
                                      // with trained characters.
    public int acceptanceLevel; // The minimum acceptance level at which an
                                // object is considered a trained character.
    public int aspectRatio; // The maximum aspect ratio variance percentage for
                            // valid characters.
    public ReadResolution readResolution; // The read resolution, which
                                          // determines how much of the trained
                                          // character data the function uses to
                                          // match objects to trained
                                          // characters.
    private ByteBuffer validChars_buf;
    private ByteBuffer[] validChars_bufs;

    private void init() {
      validChars = new String[0];
    }

    public ReadTextOptions() {
      super(65304);
      init();
    }

    public ReadTextOptions(String[] validChars, byte substitutionChar, ReadStrategy readStrategy,
        int acceptanceLevel, int aspectRatio, ReadResolution readResolution) {
      super(65304);
      this.validChars = validChars;
      this.substitutionChar = substitutionChar;
      this.readStrategy = readStrategy;
      this.acceptanceLevel = acceptanceLevel;
      this.aspectRatio = aspectRatio;
      this.readResolution = readResolution;
    }

    protected ReadTextOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 65304);
      init();
    }

    protected ReadTextOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 65304);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 65304);
    }

    public void read() {
      int validChars_numValidChars = backing.getInt(65280);
      long validChars_addr = getPointer(backing, 0);
      validChars = new String[validChars_numValidChars];
      if (validChars_numValidChars > 0 && validChars_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(validChars_addr, validChars_numValidChars * 4);
        for (int i = 0, off = 0; i < validChars_numValidChars; i++, off += 4) {
          long addr = getPointer(bb, off);
          if (addr == 0)
            validChars[i] = null;
          else {
            ByteBuffer bb2 = newDirectByteBuffer(addr, 1000); // FIXME
            while (bb2.get() != 0) {
            }
            byte[] bytes = new byte[bb2.position() - 1];
            bb2.rewind();
            getBytes(bb2, bytes, 0, bytes.length);
            try {
              validChars[i] = new String(bytes, "UTF-8");
            } catch (UnsupportedEncodingException e) {
              validChars[i] = "";
            }
          }
        }
      }
      substitutionChar = backing.get(65284);
      readStrategy = ReadStrategy.fromValue(backing.getInt(65288));
      acceptanceLevel = backing.getInt(65292);
      aspectRatio = backing.getInt(65296);
      readResolution = ReadResolution.fromValue(backing.getInt(65300));
    }

    public void write() {
      validChars_buf =
          ByteBuffer.allocateDirect(validChars.length * 4).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < validChars.length; i++, off += 4) {
        if (validChars[i] == null)
          putPointer(validChars_buf, off, 0);
        else {
          byte[] bytes;
          try {
            bytes = validChars[i].getBytes("UTF-8");
          } catch (UnsupportedEncodingException e) {
            bytes = new byte[0];
          }
          validChars_bufs[i] = ByteBuffer.allocateDirect(bytes.length + 1);
          putBytes(validChars_bufs[i], bytes, 0, bytes.length).put(bytes.length, (byte) 0);
          putPointer(validChars_buf, off, getByteBufferAddress(validChars_bufs[i]));
        }
      }
      backing.putInt(65280, validChars.length);
      putPointer(backing, 0, validChars_buf);
      backing.put(65284, substitutionChar);
      if (readStrategy != null)
        backing.putInt(65288, readStrategy.getValue());
      backing.putInt(65292, acceptanceLevel);
      backing.putInt(65296, aspectRatio);
      if (readResolution != null)
        backing.putInt(65300, readResolution.getValue());
    }

    public int size() {
      return 65304;
    }
  }

  public static class CharInfo extends DisposedStruct {
    public String charValue; // Retrieves the character value of the
                             // corresponding character in the character set.
    public Image charImage; // The image you used to train this character.
    public Image internalImage; // The internal representation that NI Vision
                                // uses to match objects to this character.
    private ByteBuffer charValue_buf;

    private void init() {

    }

    public CharInfo() {
      super(12);
      init();
    }

    public CharInfo(String charValue, Image charImage, Image internalImage) {
      super(12);
      this.charValue = charValue;
      this.charImage = charImage;
      this.internalImage = internalImage;
    }

    protected CharInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected CharInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      long charValue_addr = getPointer(backing, 0);
      if (charValue_addr == 0)
        charValue = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(charValue_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          charValue = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          charValue = "";
        }
      }

      long charImage_addr = getPointer(backing, 4);
      if (charImage_addr == 0)
        charImage = null;
      else
        charImage = new Image(charImage_addr, false);
      long internalImage_addr = getPointer(backing, 8);
      if (internalImage_addr == 0)
        internalImage = null;
      else
        internalImage = new Image(internalImage_addr, false);
    }

    public void write() {
      if (charValue != null) {
        byte[] charValue_bytes;
        try {
          charValue_bytes = charValue.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          charValue_bytes = new byte[0];
        }
        charValue_buf = ByteBuffer.allocateDirect(charValue_bytes.length + 1);
        putBytes(charValue_buf, charValue_bytes, 0, charValue_bytes.length).put(
            charValue_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, charValue == null ? 0 : getByteBufferAddress(charValue_buf));
      putPointer(backing, 4, charImage);
      putPointer(backing, 8, internalImage);
    }

    public int size() {
      return 12;
    }
  }

  public static class Rect extends DisposedStruct {
    public int top; // Location of the top edge of the rectangle.
    public int left; // Location of the left edge of the rectangle.
    public int height; // Height of the rectangle.
    public int width; // Width of the rectangle.

    private void init() {

    }

    public Rect() {
      super(16);
      init();
    }

    public Rect(int top, int left, int height, int width) {
      super(16);
      this.top = top;
      this.left = left;
      this.height = height;
      this.width = width;
    }

    protected Rect(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected Rect(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      top = backing.getInt(0);
      left = backing.getInt(4);
      height = backing.getInt(8);
      width = backing.getInt(12);
    }

    public void write() {
      backing.putInt(0, top);
      backing.putInt(4, left);
      backing.putInt(8, height);
      backing.putInt(12, width);
    }

    public int size() {
      return 16;
    }
  }

  public static class CharReport extends DisposedStruct {
    public String character; // The character value.
    public PointFloat[] corner; // An array of four points that describes the
                                // rectangle that surrounds the character.
    public int reserved; // This element is reserved.
    public int lowThreshold; // The minimum value of the threshold range used
                             // for this character.
    public int highThreshold; // The maximum value of the threshold range used
                              // for this character.
    private ByteBuffer character_buf;

    private void init() {
      corner = new PointFloat[4];

      for (int i = 0, off = 4; i < 4; i++, off += 8)
        corner[i] = new PointFloat(backing, off);
    }

    public CharReport() {
      super(48);
      init();
    }

    public CharReport(String character, PointFloat[] corner, int reserved, int lowThreshold,
        int highThreshold) {
      super(48);
      this.character = character;
      this.corner = corner;
      this.reserved = reserved;
      this.lowThreshold = lowThreshold;
      this.highThreshold = highThreshold;
    }

    protected CharReport(ByteBuffer backing, int offset) {
      super(backing, offset, 48);
      init();
    }

    protected CharReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 48);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 48);
    }

    public void read() {
      long character_addr = getPointer(backing, 0);
      if (character_addr == 0)
        character = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(character_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          character = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          character = "";
        }
      }

      for (PointFloat it : corner) {
        it.read();
      }
      reserved = backing.getInt(36);
      lowThreshold = backing.getInt(40);
      highThreshold = backing.getInt(44);
    }

    public void write() {
      if (character != null) {
        byte[] character_bytes;
        try {
          character_bytes = character.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          character_bytes = new byte[0];
        }
        character_buf = ByteBuffer.allocateDirect(character_bytes.length + 1);
        putBytes(character_buf, character_bytes, 0, character_bytes.length).put(
            character_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, character == null ? 0 : getByteBufferAddress(character_buf));
      for (PointFloat it : corner) {
        it.write();
      }
      backing.putInt(36, reserved);
      backing.putInt(40, lowThreshold);
      backing.putInt(44, highThreshold);
    }

    public int size() {
      return 48;
    }
  }

  public static class ReadTextReport extends DisposedStruct {
    public String readString; // The read string.
    public CharReport[] characterReport; // An array of reports describing the
                                         // properties of each identified
                                         // character.
    private ByteBuffer readString_buf;
    private ByteBuffer characterReport_buf;

    private void init() {
      characterReport = new CharReport[0];
    }

    public ReadTextReport() {
      super(12);
      init();
    }

    public ReadTextReport(String readString, CharReport[] characterReport) {
      super(12);
      this.readString = readString;
      this.characterReport = characterReport;
    }

    protected ReadTextReport(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected ReadTextReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      long readString_addr = getPointer(backing, 0);
      if (readString_addr == 0)
        readString = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(readString_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          readString = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          readString = "";
        }
      }

      int characterReport_numCharacterReports = backing.getInt(8);
      long characterReport_addr = getPointer(backing, 4);
      characterReport = new CharReport[characterReport_numCharacterReports];
      if (characterReport_numCharacterReports > 0 && characterReport_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(characterReport_addr, characterReport_numCharacterReports * 48);
        for (int i = 0, off = 0; i < characterReport_numCharacterReports; i++, off += 48) {
          characterReport[i] = new CharReport(bb, off);
          characterReport[i].read();
        }
      }
    }

    public void write() {
      if (readString != null) {
        byte[] readString_bytes;
        try {
          readString_bytes = readString.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          readString_bytes = new byte[0];
        }
        readString_buf = ByteBuffer.allocateDirect(readString_bytes.length + 1);
        putBytes(readString_buf, readString_bytes, 0, readString_bytes.length).put(
            readString_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, readString == null ? 0 : getByteBufferAddress(readString_buf));
      characterReport_buf =
          ByteBuffer.allocateDirect(characterReport.length * 48).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < characterReport.length; i++, off += 48) {
        characterReport[i].setBuffer(characterReport_buf, off);
        characterReport[i].write();
      }
      backing.putInt(8, characterReport.length);
      putPointer(backing, 4, characterReport_buf);
    }

    public int size() {
      return 12;
    }
  }

  public static class Point extends DisposedStruct {
    public int x; // The x-coordinate of the point.
    public int y; // The y-coordinate of the point.

    private void init() {

    }

    public Point() {
      super(8);
      init();
    }

    public Point(int x, int y) {
      super(8);
      this.x = x;
      this.y = y;
    }

    protected Point(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected Point(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      x = backing.getInt(0);
      y = backing.getInt(4);
    }

    public void write() {
      backing.putInt(0, x);
      backing.putInt(4, y);
    }

    public int size() {
      return 8;
    }
  }

  public static class Annulus extends DisposedStruct {
    public Point center; // The coordinate location of the center of the
                         // annulus.
    public int innerRadius; // The internal radius of the annulus.
    public int outerRadius; // The external radius of the annulus.
    public double startAngle; // The start angle, in degrees, of the annulus.
    public double endAngle; // The end angle, in degrees, of the annulus.

    private void init() {
      center = new Point(backing, 0);
    }

    public Annulus() {
      super(32);
      init();
    }

    public Annulus(Point center, int innerRadius, int outerRadius, double startAngle,
        double endAngle) {
      super(32);
      this.center = center;
      this.innerRadius = innerRadius;
      this.outerRadius = outerRadius;
      this.startAngle = startAngle;
      this.endAngle = endAngle;
    }

    protected Annulus(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected Annulus(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      center.read();
      innerRadius = backing.getInt(8);
      outerRadius = backing.getInt(12);
      startAngle = backing.getDouble(16);
      endAngle = backing.getDouble(24);
    }

    public void write() {
      center.write();
      backing.putInt(8, innerRadius);
      backing.putInt(12, outerRadius);
      backing.putDouble(16, startAngle);
      backing.putDouble(24, endAngle);
    }

    public int size() {
      return 32;
    }
  }

  public static class EdgeLocationReport extends DisposedStruct {
    public PointFloat[] edges; // The coordinate location of all edges detected
                               // by the search line.
    private ByteBuffer edges_buf;

    private void init() {
      edges = new PointFloat[0];
    }

    public EdgeLocationReport() {
      super(8);
      init();
    }

    public EdgeLocationReport(PointFloat[] edges) {
      super(8);
      this.edges = edges;
    }

    protected EdgeLocationReport(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected EdgeLocationReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      int edges_numEdges = backing.getInt(4);
      long edges_addr = getPointer(backing, 0);
      edges = new PointFloat[edges_numEdges];
      if (edges_numEdges > 0 && edges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(edges_addr, edges_numEdges * 8);
        for (int i = 0, off = 0; i < edges_numEdges; i++, off += 8) {
          edges[i] = new PointFloat(bb, off);
          edges[i].read();
        }
      }
    }

    public void write() {
      edges_buf = ByteBuffer.allocateDirect(edges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < edges.length; i++, off += 8) {
        edges[i].setBuffer(edges_buf, off);
        edges[i].write();
      }
      backing.putInt(4, edges.length);
      putPointer(backing, 0, edges_buf);
    }

    public int size() {
      return 8;
    }
  }

  public static class EdgeOptions extends DisposedStruct {
    public int threshold; // Specifies the threshold value for the contrast of
                          // the edge.
    public int width; // The number of pixels that the function averages to find
                      // the contrast at either side of the edge.
    public int steepness; // The span, in pixels, of the slope of the edge
                          // projected along the path specified by the input
                          // points.
    public InterpolationMethod subpixelType; // The method for interpolating.
    public int subpixelDivisions; // The number of samples the function obtains
                                  // from a pixel.

    private void init() {

    }

    public EdgeOptions() {
      super(20);
      init();
    }

    public EdgeOptions(int threshold, int width, int steepness, InterpolationMethod subpixelType,
        int subpixelDivisions) {
      super(20);
      this.threshold = threshold;
      this.width = width;
      this.steepness = steepness;
      this.subpixelType = subpixelType;
      this.subpixelDivisions = subpixelDivisions;
    }

    protected EdgeOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected EdgeOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      threshold = backing.getInt(0);
      width = backing.getInt(4);
      steepness = backing.getInt(8);
      subpixelType = InterpolationMethod.fromValue(backing.getInt(12));
      subpixelDivisions = backing.getInt(16);
    }

    public void write() {
      backing.putInt(0, threshold);
      backing.putInt(4, width);
      backing.putInt(8, steepness);
      if (subpixelType != null)
        backing.putInt(12, subpixelType.getValue());
      backing.putInt(16, subpixelDivisions);
    }

    public int size() {
      return 20;
    }
  }

  public static class EdgeReport extends DisposedStruct {
    public float location; // The location of the edge from the first point in
                           // the points array.
    public float contrast; // The contrast at the edge.
    public PolarityType polarity; // The polarity of the edge.
    public float reserved; // This element is reserved.
    public PointFloat coordinate; // The coordinates of the edge.

    private void init() {
      coordinate = new PointFloat(backing, 20);
    }

    public EdgeReport() {
      super(32);
      init();
    }

    public EdgeReport(double location, double contrast, PolarityType polarity, double reserved,
        PointFloat coordinate) {
      super(32);
      this.location = (float) location;
      this.contrast = (float) contrast;
      this.polarity = polarity;
      this.reserved = (float) reserved;
      this.coordinate = coordinate;
    }

    protected EdgeReport(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected EdgeReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      location = backing.getFloat(0);
      contrast = backing.getFloat(4);
      polarity = PolarityType.fromValue(backing.getInt(8));
      reserved = backing.getFloat(16);
      coordinate.read();
    }

    public void write() {
      backing.putFloat(0, location);
      backing.putFloat(4, contrast);
      if (polarity != null)
        backing.putInt(8, polarity.getValue());
      backing.putFloat(16, reserved);
      coordinate.write();
    }

    public int size() {
      return 32;
    }
  }

  public static class ExtremeReport extends DisposedStruct {
    public double location; // The locations of the extreme.
    public double amplitude; // The amplitude of the extreme.
    public double secondDerivative; // The second derivative of the extreme.

    private void init() {

    }

    public ExtremeReport() {
      super(24);
      init();
    }

    public ExtremeReport(double location, double amplitude, double secondDerivative) {
      super(24);
      this.location = location;
      this.amplitude = amplitude;
      this.secondDerivative = secondDerivative;
    }

    protected ExtremeReport(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected ExtremeReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      location = backing.getDouble(0);
      amplitude = backing.getDouble(8);
      secondDerivative = backing.getDouble(16);
    }

    public void write() {
      backing.putDouble(0, location);
      backing.putDouble(8, amplitude);
      backing.putDouble(16, secondDerivative);
    }

    public int size() {
      return 24;
    }
  }

  public static class FitLineOptions extends DisposedStruct {
    public float minScore; // Specifies the required quality of the fitted line.
    public float pixelRadius; // Specifies the neighborhood pixel relationship
                              // for the initial subset of points being used.
    public int numRefinements; // Specifies the number of refinement iterations
                               // you allow the function to perform on the
                               // initial subset of points.

    private void init() {

    }

    public FitLineOptions() {
      super(12);
      init();
    }

    public FitLineOptions(double minScore, double pixelRadius, int numRefinements) {
      super(12);
      this.minScore = (float) minScore;
      this.pixelRadius = (float) pixelRadius;
      this.numRefinements = numRefinements;
    }

    protected FitLineOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected FitLineOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      minScore = backing.getFloat(0);
      pixelRadius = backing.getFloat(4);
      numRefinements = backing.getInt(8);
    }

    public void write() {
      backing.putFloat(0, minScore);
      backing.putFloat(4, pixelRadius);
      backing.putInt(8, numRefinements);
    }

    public int size() {
      return 12;
    }
  }

  public static class DisplayMapping extends DisposedStruct {
    public MappingMethod method; // Describes the method for converting 16-bit
                                 // pixels to 8-bit pixels.
    public int minimumValue; // When method is IMAQ_RANGE, minimumValue
                             // represents the value that is mapped to 0.
    public int maximumValue; // When method is IMAQ_RANGE, maximumValue
                             // represents the value that is mapped to 255.
    public int shiftCount; // When method is IMAQ_DOWNSHIFT, shiftCount
                           // represents the number of bits the function
                           // right-shifts the 16-bit pixel values.

    private void init() {

    }

    public DisplayMapping() {
      super(16);
      init();
    }

    public DisplayMapping(MappingMethod method, int minimumValue, int maximumValue, int shiftCount) {
      super(16);
      this.method = method;
      this.minimumValue = minimumValue;
      this.maximumValue = maximumValue;
      this.shiftCount = shiftCount;
    }

    protected DisplayMapping(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected DisplayMapping(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      method = MappingMethod.fromValue(backing.getInt(0));
      minimumValue = backing.getInt(4);
      maximumValue = backing.getInt(8);
      shiftCount = backing.getInt(12);
    }

    public void write() {
      if (method != null)
        backing.putInt(0, method.getValue());
      backing.putInt(4, minimumValue);
      backing.putInt(8, maximumValue);
      backing.putInt(12, shiftCount);
    }

    public int size() {
      return 16;
    }
  }

  public static class DetectExtremesOptions extends DisposedStruct {
    public double threshold; // Defines which extremes are too small.
    public int width; // Specifies the number of consecutive data points the
                      // function uses in the quadratic least-squares fit.

    private void init() {

    }

    public DetectExtremesOptions() {
      super(16);
      init();
    }

    public DetectExtremesOptions(double threshold, int width) {
      super(16);
      this.threshold = threshold;
      this.width = width;
    }

    protected DetectExtremesOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected DetectExtremesOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      threshold = backing.getDouble(0);
      width = backing.getInt(8);
    }

    public void write() {
      backing.putDouble(0, threshold);
      backing.putInt(8, width);
    }

    public int size() {
      return 16;
    }
  }

  public static class ImageInfo extends DisposedStruct {
    public CalibrationUnit imageUnit; // If you set calibration information with
                                      // imaqSetSimpleCalibrationInfo(),
                                      // imageUnit is the calibration unit.
    public float stepX; // If you set calibration information with
                        // imaqSetCalibrationInfo(), stepX is the distance in
                        // the calibration unit between two pixels in the x
                        // direction.
    public float stepY; // If you set calibration information with
                        // imaqSetCalibrationInfo(), stepY is the distance in
                        // the calibration unit between two pixels in the y
                        // direction.
    public ImageType imageType; // The type of the image.
    public int xRes; // The number of columns in the image.
    public int yRes; // The number of rows in the image.
    public int xOffset; // If you set mask offset information with
                        // imaqSetMaskOffset(), xOffset is the offset of the
                        // mask origin in the x direction.
    public int yOffset; // If you set mask offset information with
                        // imaqSetMaskOffset(), yOffset is the offset of the
                        // mask origin in the y direction.
    public int border; // The number of border pixels around the image.
    public int pixelsPerLine; // The number of pixels stored for each line of
                              // the image.

    private void init() {

    }

    public ImageInfo() {
      super(52);
      init();
    }

    public ImageInfo(CalibrationUnit imageUnit, double stepX, double stepY, ImageType imageType,
        int xRes, int yRes, int xOffset, int yOffset, int border, int pixelsPerLine) {
      super(52);
      this.imageUnit = imageUnit;
      this.stepX = (float) stepX;
      this.stepY = (float) stepY;
      this.imageType = imageType;
      this.xRes = xRes;
      this.yRes = yRes;
      this.xOffset = xOffset;
      this.yOffset = yOffset;
      this.border = border;
      this.pixelsPerLine = pixelsPerLine;
    }

    protected ImageInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 52);
      init();
    }

    protected ImageInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 52);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 52);
    }

    public void read() {
      imageUnit = CalibrationUnit.fromValue(backing.getInt(0));
      stepX = backing.getFloat(4);
      stepY = backing.getFloat(8);
      imageType = ImageType.fromValue(backing.getInt(12));
      xRes = backing.getInt(16);
      yRes = backing.getInt(20);
      xOffset = backing.getInt(24);
      yOffset = backing.getInt(28);
      border = backing.getInt(32);
      pixelsPerLine = backing.getInt(36);
    }

    public void write() {
      if (imageUnit != null)
        backing.putInt(0, imageUnit.getValue());
      backing.putFloat(4, stepX);
      backing.putFloat(8, stepY);
      if (imageType != null)
        backing.putInt(12, imageType.getValue());
      backing.putInt(16, xRes);
      backing.putInt(20, yRes);
      backing.putInt(24, xOffset);
      backing.putInt(28, yOffset);
      backing.putInt(32, border);
      backing.putInt(36, pixelsPerLine);
    }

    public int size() {
      return 52;
    }
  }

  public static class LCDOptions extends DisposedStruct {
    public int litSegments; // Set this parameter to TRUE if the segments are
                            // brighter than the background.
    public float threshold; // Determines whether a segment is ON or OFF.
    public int sign; // Indicates whether the function must read the sign of the
                     // indicator.
    public int decimalPoint; // Determines whether to look for a decimal
                             // separator after each digit.

    private void init() {

    }

    public LCDOptions() {
      super(16);
      init();
    }

    public LCDOptions(int litSegments, double threshold, int sign, int decimalPoint) {
      super(16);
      this.litSegments = litSegments;
      this.threshold = (float) threshold;
      this.sign = sign;
      this.decimalPoint = decimalPoint;
    }

    protected LCDOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected LCDOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      litSegments = backing.getInt(0);
      threshold = backing.getFloat(4);
      sign = backing.getInt(8);
      decimalPoint = backing.getInt(12);
    }

    public void write() {
      backing.putInt(0, litSegments);
      backing.putFloat(4, threshold);
      backing.putInt(8, sign);
      backing.putInt(12, decimalPoint);
    }

    public int size() {
      return 16;
    }
  }

  public static class LCDReport extends DisposedStruct {
    public String text; // A string of the characters of the LCD.
    public LCDSegments[] segmentInfo; // An array of LCDSegment structures
                                      // describing which segments of each digit
                                      // are on.
    private ByteBuffer text_buf;
    private ByteBuffer segmentInfo_buf;

    private void init() {
      segmentInfo = new LCDSegments[0];
    }

    public LCDReport() {
      super(16);
      init();
    }

    public LCDReport(String text, LCDSegments[] segmentInfo) {
      super(16);
      this.text = text;
      this.segmentInfo = segmentInfo;
    }

    protected LCDReport(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected LCDReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      long text_addr = getPointer(backing, 0);
      if (text_addr == 0)
        text = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(text_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          text = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          text = "";
        }
      }

      int segmentInfo_numCharacters = backing.getInt(8);
      long segmentInfo_addr = getPointer(backing, 4);
      segmentInfo = new LCDSegments[segmentInfo_numCharacters];
      if (segmentInfo_numCharacters > 0 && segmentInfo_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(segmentInfo_addr, segmentInfo_numCharacters * 4);
        for (int i = 0, off = 0; i < segmentInfo_numCharacters; i++, off += 4) {
          segmentInfo[i] = new LCDSegments(bb, off);
          segmentInfo[i].read();
        }
      }
    }

    public void write() {
      if (text != null) {
        byte[] text_bytes;
        try {
          text_bytes = text.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          text_bytes = new byte[0];
        }
        text_buf = ByteBuffer.allocateDirect(text_bytes.length + 1);
        putBytes(text_buf, text_bytes, 0, text_bytes.length).put(text_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, text == null ? 0 : getByteBufferAddress(text_buf));
      segmentInfo_buf =
          ByteBuffer.allocateDirect(segmentInfo.length * 4).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < segmentInfo.length; i++, off += 4) {
        segmentInfo[i].setBuffer(segmentInfo_buf, off);
        segmentInfo[i].write();
      }
      backing.putInt(8, segmentInfo.length);
      putPointer(backing, 4, segmentInfo_buf);
    }

    public int size() {
      return 16;
    }
  }

  public static class LCDSegments extends DisposedStruct {


    private void init() {

    }

    public LCDSegments() {
      super(4);
      init();
    }

    protected LCDSegments(ByteBuffer backing, int offset) {
      super(backing, offset, 4);
      init();
    }

    protected LCDSegments(long nativeObj, boolean owned) {
      super(nativeObj, owned, 4);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 4);
    }

    public void read() {

    }

    public void write() {

    }

    public int size() {
      return 4;
    }
  }

  public static class LearnCalibrationOptions extends DisposedStruct {
    public CalibrationMode mode; // Specifies the type of algorithm you want to
                                 // use to reduce distortion in your image.
    public ScalingMethod method; // Defines the scaling method correction
                                 // functions use to correct the image.
    public CalibrationROI roi; // Specifies the ROI correction functions use
                               // when correcting an image.
    public int learnMap; // Set this element to TRUE if you want the function to
                         // calculate and store an error map during the learning
                         // process.
    public int learnTable; // Set this element to TRUE if you want the function
                           // to calculate and store the correction table.

    private void init() {

    }

    public LearnCalibrationOptions() {
      super(20);
      init();
    }

    public LearnCalibrationOptions(CalibrationMode mode, ScalingMethod method, CalibrationROI roi,
        int learnMap, int learnTable) {
      super(20);
      this.mode = mode;
      this.method = method;
      this.roi = roi;
      this.learnMap = learnMap;
      this.learnTable = learnTable;
    }

    protected LearnCalibrationOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected LearnCalibrationOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      mode = CalibrationMode.fromValue(backing.getInt(0));
      method = ScalingMethod.fromValue(backing.getInt(4));
      roi = CalibrationROI.fromValue(backing.getInt(8));
      learnMap = backing.getInt(12);
      learnTable = backing.getInt(16);
    }

    public void write() {
      if (mode != null)
        backing.putInt(0, mode.getValue());
      if (method != null)
        backing.putInt(4, method.getValue());
      if (roi != null)
        backing.putInt(8, roi.getValue());
      backing.putInt(12, learnMap);
      backing.putInt(16, learnTable);
    }

    public int size() {
      return 20;
    }
  }

  public static class LearnColorPatternOptions extends DisposedStruct {
    public LearningMode learnMode; // Specifies the invariance mode the function
                                   // uses when learning the pattern.
    public ImageFeatureMode featureMode; // Specifies the features the function
                                         // uses when learning the color
                                         // pattern.
    public int threshold; // Specifies the saturation threshold the function
                          // uses to distinguish between two colors that have
                          // the same hue values.
    public ColorIgnoreMode ignoreMode; // Specifies whether the function
                                       // excludes certain colors from the color
                                       // features of the template image.
    public ColorInformation[] colorsToIgnore; // An array of ColorInformation
                                              // structures providing a set of
                                              // colors to exclude from the
                                              // color features of the template
                                              // image.
    private ByteBuffer colorsToIgnore_buf;

    private void init() {
      colorsToIgnore = new ColorInformation[0];
    }

    public LearnColorPatternOptions() {
      super(24);
      init();
    }

    public LearnColorPatternOptions(LearningMode learnMode, ImageFeatureMode featureMode,
        int threshold, ColorIgnoreMode ignoreMode, ColorInformation[] colorsToIgnore) {
      super(24);
      this.learnMode = learnMode;
      this.featureMode = featureMode;
      this.threshold = threshold;
      this.ignoreMode = ignoreMode;
      this.colorsToIgnore = colorsToIgnore;
    }

    protected LearnColorPatternOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected LearnColorPatternOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      learnMode = LearningMode.fromValue(backing.getInt(0));
      featureMode = ImageFeatureMode.fromValue(backing.getInt(4));
      threshold = backing.getInt(8);
      ignoreMode = ColorIgnoreMode.fromValue(backing.getInt(12));
      int colorsToIgnore_numColorsToIgnore = backing.getInt(20);
      long colorsToIgnore_addr = getPointer(backing, 16);
      colorsToIgnore = new ColorInformation[colorsToIgnore_numColorsToIgnore];
      if (colorsToIgnore_numColorsToIgnore > 0 && colorsToIgnore_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(colorsToIgnore_addr, colorsToIgnore_numColorsToIgnore * 12);
        for (int i = 0, off = 0; i < colorsToIgnore_numColorsToIgnore; i++, off += 12) {
          colorsToIgnore[i] = new ColorInformation(bb, off);
          colorsToIgnore[i].read();
        }
      }
    }

    public void write() {
      if (learnMode != null)
        backing.putInt(0, learnMode.getValue());
      if (featureMode != null)
        backing.putInt(4, featureMode.getValue());
      backing.putInt(8, threshold);
      if (ignoreMode != null)
        backing.putInt(12, ignoreMode.getValue());
      colorsToIgnore_buf =
          ByteBuffer.allocateDirect(colorsToIgnore.length * 12).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < colorsToIgnore.length; i++, off += 12) {
        colorsToIgnore[i].setBuffer(colorsToIgnore_buf, off);
        colorsToIgnore[i].write();
      }
      backing.putInt(20, colorsToIgnore.length);
      putPointer(backing, 16, colorsToIgnore_buf);
    }

    public int size() {
      return 24;
    }
  }

  public static class Line extends DisposedStruct {
    public Point start; // The coordinate location of the start of the line.
    public Point end; // The coordinate location of the end of the line.

    private void init() {
      start = new Point(backing, 0);
      end = new Point(backing, 8);
    }

    public Line() {
      super(16);
      init();
    }

    public Line(Point start, Point end) {
      super(16);
      this.start = start;
      this.end = end;
    }

    protected Line(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected Line(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      start.read();
      end.read();
    }

    public void write() {
      start.write();
      end.write();
    }

    public int size() {
      return 16;
    }
  }

  public static class LinearAverages extends DisposedStruct {
    public float[] columnAverages; // An array containing the mean pixel value
                                   // of each column.
    public float[] rowAverages; // An array containing the mean pixel value of
                                // each row.
    public float[] risingDiagAverages; // An array containing the mean pixel
                                       // value of each diagonal running from
                                       // the lower left to the upper right of
                                       // the inspected area of the image.
    public float[] fallingDiagAverages; // An array containing the mean pixel
                                        // value of each diagonal running from
                                        // the upper left to the lower right of
                                        // the inspected area of the image.
    private ByteBuffer columnAverages_buf;
    private ByteBuffer rowAverages_buf;
    private ByteBuffer risingDiagAverages_buf;
    private ByteBuffer fallingDiagAverages_buf;

    private void init() {
      columnAverages = new float[0];
      rowAverages = new float[0];
      risingDiagAverages = new float[0];
      fallingDiagAverages = new float[0];
    }

    public LinearAverages() {
      super(32);
      init();
    }

    public LinearAverages(float[] columnAverages, float[] rowAverages, float[] risingDiagAverages,
        float[] fallingDiagAverages) {
      super(32);
      this.columnAverages = columnAverages;
      this.rowAverages = rowAverages;
      this.risingDiagAverages = risingDiagAverages;
      this.fallingDiagAverages = fallingDiagAverages;
    }

    protected LinearAverages(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected LinearAverages(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      int columnAverages_columnCount = backing.getInt(4);
      long columnAverages_addr = getPointer(backing, 0);
      columnAverages = new float[columnAverages_columnCount];
      if (columnAverages_columnCount > 0 && columnAverages_addr != 0) {
        newDirectByteBuffer(columnAverages_addr, columnAverages_columnCount * 4).asFloatBuffer()
            .get(columnAverages);
      }
      int rowAverages_rowCount = backing.getInt(12);
      long rowAverages_addr = getPointer(backing, 8);
      rowAverages = new float[rowAverages_rowCount];
      if (rowAverages_rowCount > 0 && rowAverages_addr != 0) {
        newDirectByteBuffer(rowAverages_addr, rowAverages_rowCount * 4).asFloatBuffer().get(
            rowAverages);
      }
      int risingDiagAverages_risingDiagCount = backing.getInt(20);
      long risingDiagAverages_addr = getPointer(backing, 16);
      risingDiagAverages = new float[risingDiagAverages_risingDiagCount];
      if (risingDiagAverages_risingDiagCount > 0 && risingDiagAverages_addr != 0) {
        newDirectByteBuffer(risingDiagAverages_addr, risingDiagAverages_risingDiagCount * 4)
            .asFloatBuffer().get(risingDiagAverages);
      }
      int fallingDiagAverages_fallingDiagCount = backing.getInt(28);
      long fallingDiagAverages_addr = getPointer(backing, 24);
      fallingDiagAverages = new float[fallingDiagAverages_fallingDiagCount];
      if (fallingDiagAverages_fallingDiagCount > 0 && fallingDiagAverages_addr != 0) {
        newDirectByteBuffer(fallingDiagAverages_addr, fallingDiagAverages_fallingDiagCount * 4)
            .asFloatBuffer().get(fallingDiagAverages);
      }
    }

    public void write() {
      columnAverages_buf =
          ByteBuffer.allocateDirect(columnAverages.length * 4).order(ByteOrder.nativeOrder());
      columnAverages_buf.asFloatBuffer().put(columnAverages).rewind();
      backing.putInt(4, columnAverages.length);
      putPointer(backing, 0, columnAverages_buf);
      rowAverages_buf =
          ByteBuffer.allocateDirect(rowAverages.length * 4).order(ByteOrder.nativeOrder());
      rowAverages_buf.asFloatBuffer().put(rowAverages).rewind();
      backing.putInt(12, rowAverages.length);
      putPointer(backing, 8, rowAverages_buf);
      risingDiagAverages_buf =
          ByteBuffer.allocateDirect(risingDiagAverages.length * 4).order(ByteOrder.nativeOrder());
      risingDiagAverages_buf.asFloatBuffer().put(risingDiagAverages).rewind();
      backing.putInt(20, risingDiagAverages.length);
      putPointer(backing, 16, risingDiagAverages_buf);
      fallingDiagAverages_buf =
          ByteBuffer.allocateDirect(fallingDiagAverages.length * 4).order(ByteOrder.nativeOrder());
      fallingDiagAverages_buf.asFloatBuffer().put(fallingDiagAverages).rewind();
      backing.putInt(28, fallingDiagAverages.length);
      putPointer(backing, 24, fallingDiagAverages_buf);
    }

    public int size() {
      return 32;
    }
  }

  public static class LineProfile extends DisposedStruct {
    public float[] profileData; // An array containing the value of each pixel
                                // in the line.
    public Rect boundingBox; // The bounding rectangle of the line.
    public float min; // The smallest pixel value in the line profile.
    public float max; // The largest pixel value in the line profile.
    public float mean; // The mean value of the pixels in the line profile.
    public float stdDev; // The standard deviation of the line profile.
    private ByteBuffer profileData_buf;

    private void init() {
      profileData = new float[0];
      boundingBox = new Rect(backing, 4);
    }

    public LineProfile() {
      super(40);
      init();
    }

    public LineProfile(float[] profileData, Rect boundingBox, double min, double max, double mean,
        double stdDev) {
      super(40);
      this.profileData = profileData;
      this.boundingBox = boundingBox;
      this.min = (float) min;
      this.max = (float) max;
      this.mean = (float) mean;
      this.stdDev = (float) stdDev;
    }

    protected LineProfile(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected LineProfile(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      int profileData_dataCount = backing.getInt(36);
      long profileData_addr = getPointer(backing, 0);
      profileData = new float[profileData_dataCount];
      if (profileData_dataCount > 0 && profileData_addr != 0) {
        newDirectByteBuffer(profileData_addr, profileData_dataCount * 4).asFloatBuffer().get(
            profileData);
      }
      boundingBox.read();
      min = backing.getFloat(20);
      max = backing.getFloat(24);
      mean = backing.getFloat(28);
      stdDev = backing.getFloat(32);
    }

    public void write() {
      profileData_buf =
          ByteBuffer.allocateDirect(profileData.length * 4).order(ByteOrder.nativeOrder());
      profileData_buf.asFloatBuffer().put(profileData).rewind();
      backing.putInt(36, profileData.length);
      putPointer(backing, 0, profileData_buf);
      boundingBox.write();
      backing.putFloat(20, min);
      backing.putFloat(24, max);
      backing.putFloat(28, mean);
      backing.putFloat(32, stdDev);
    }

    public int size() {
      return 40;
    }
  }

  public static class MatchColorPatternOptions extends DisposedStruct {
    public MatchingMode matchMode; // Specifies the method to use when looking
                                   // for the color pattern in the image.
    public ImageFeatureMode featureMode; // Specifies the features to use when
                                         // looking for the color pattern in the
                                         // image.
    public int minContrast; // Specifies the minimum contrast expected in the
                            // image.
    public int subpixelAccuracy; // Set this parameter to TRUE to return areas
                                 // in the image that match the pattern area
                                 // with subpixel accuracy.
    public RotationAngleRange[] angleRanges; // An array of angle ranges, in
                                             // degrees, where each range
                                             // specifies how much you expect
                                             // the pattern to be rotated in the
                                             // image.
    public double colorWeight; // Determines the percent contribution of the
                               // color score to the final color pattern
                               // matching score.
    public ColorSensitivity sensitivity; // Specifies the sensitivity of the
                                         // color information in the image.
    public SearchStrategy strategy; // Specifies how the color features of the
                                    // image are used during the search phase.
    public int numMatchesRequested; // Number of valid matches expected.
    public float minMatchScore; // The minimum score a match can have for the
                                // function to consider the match valid.
    private ByteBuffer angleRanges_buf;

    private void init() {
      angleRanges = new RotationAngleRange[0];
    }

    public MatchColorPatternOptions() {
      super(48);
      init();
    }

    public MatchColorPatternOptions(MatchingMode matchMode, ImageFeatureMode featureMode,
        int minContrast, int subpixelAccuracy, RotationAngleRange[] angleRanges,
        double colorWeight, ColorSensitivity sensitivity, SearchStrategy strategy,
        int numMatchesRequested, double minMatchScore) {
      super(48);
      this.matchMode = matchMode;
      this.featureMode = featureMode;
      this.minContrast = minContrast;
      this.subpixelAccuracy = subpixelAccuracy;
      this.angleRanges = angleRanges;
      this.colorWeight = colorWeight;
      this.sensitivity = sensitivity;
      this.strategy = strategy;
      this.numMatchesRequested = numMatchesRequested;
      this.minMatchScore = (float) minMatchScore;
    }

    protected MatchColorPatternOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 48);
      init();
    }

    protected MatchColorPatternOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 48);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 48);
    }

    public void read() {
      matchMode = MatchingMode.fromValue(backing.getInt(0));
      featureMode = ImageFeatureMode.fromValue(backing.getInt(4));
      minContrast = backing.getInt(8);
      subpixelAccuracy = backing.getInt(12);
      int angleRanges_numRanges = backing.getInt(20);
      long angleRanges_addr = getPointer(backing, 16);
      angleRanges = new RotationAngleRange[angleRanges_numRanges];
      if (angleRanges_numRanges > 0 && angleRanges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(angleRanges_addr, angleRanges_numRanges * 8);
        for (int i = 0, off = 0; i < angleRanges_numRanges; i++, off += 8) {
          angleRanges[i] = new RotationAngleRange(bb, off);
          angleRanges[i].read();
        }
      }
      colorWeight = backing.getDouble(24);
      sensitivity = ColorSensitivity.fromValue(backing.getInt(32));
      strategy = SearchStrategy.fromValue(backing.getInt(36));
      numMatchesRequested = backing.getInt(40);
      minMatchScore = backing.getFloat(44);
    }

    public void write() {
      if (matchMode != null)
        backing.putInt(0, matchMode.getValue());
      if (featureMode != null)
        backing.putInt(4, featureMode.getValue());
      backing.putInt(8, minContrast);
      backing.putInt(12, subpixelAccuracy);
      angleRanges_buf =
          ByteBuffer.allocateDirect(angleRanges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < angleRanges.length; i++, off += 8) {
        angleRanges[i].setBuffer(angleRanges_buf, off);
        angleRanges[i].write();
      }
      backing.putInt(20, angleRanges.length);
      putPointer(backing, 16, angleRanges_buf);
      backing.putDouble(24, colorWeight);
      if (sensitivity != null)
        backing.putInt(32, sensitivity.getValue());
      if (strategy != null)
        backing.putInt(36, strategy.getValue());
      backing.putInt(40, numMatchesRequested);
      backing.putFloat(44, minMatchScore);
    }

    public int size() {
      return 48;
    }
  }

  public static class HistogramReport extends DisposedStruct {
    public int[] histogram; // An array describing the number of pixels that
                            // fell into each class.
    public float min; // The smallest pixel value that the function classified.
    public float max; // The largest pixel value that the function classified.
    public float start; // The smallest pixel value that fell into the first
                        // class.
    public float width; // The size of each class.
    public float mean; // The mean value of the pixels that the function
                       // classified.
    public float stdDev; // The standard deviation of the pixels that the
                         // function classified.
    public int numPixels; // The number of pixels that the function classified.
    private ByteBuffer histogram_buf;

    private void init() {
      histogram = new int[0];
    }

    public HistogramReport() {
      super(36);
      init();
    }

    public HistogramReport(int[] histogram, double min, double max, double start, double width,
        double mean, double stdDev, int numPixels) {
      super(36);
      this.histogram = histogram;
      this.min = (float) min;
      this.max = (float) max;
      this.start = (float) start;
      this.width = (float) width;
      this.mean = (float) mean;
      this.stdDev = (float) stdDev;
      this.numPixels = numPixels;
    }

    protected HistogramReport(ByteBuffer backing, int offset) {
      super(backing, offset, 36);
      init();
    }

    protected HistogramReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 36);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 36);
    }

    public void read() {
      int histogram_histogramCount = backing.getInt(4);
      long histogram_addr = getPointer(backing, 0);
      histogram = new int[histogram_histogramCount];
      if (histogram_histogramCount > 0 && histogram_addr != 0) {
        newDirectByteBuffer(histogram_addr, histogram_histogramCount * 4).asIntBuffer().get(
            histogram);
      }
      min = backing.getFloat(8);
      max = backing.getFloat(12);
      start = backing.getFloat(16);
      width = backing.getFloat(20);
      mean = backing.getFloat(24);
      stdDev = backing.getFloat(28);
      numPixels = backing.getInt(32);
    }

    public void write() {
      histogram_buf =
          ByteBuffer.allocateDirect(histogram.length * 4).order(ByteOrder.nativeOrder());
      histogram_buf.asIntBuffer().put(histogram).rewind();
      backing.putInt(4, histogram.length);
      putPointer(backing, 0, histogram_buf);
      backing.putFloat(8, min);
      backing.putFloat(12, max);
      backing.putFloat(16, start);
      backing.putFloat(20, width);
      backing.putFloat(24, mean);
      backing.putFloat(28, stdDev);
      backing.putInt(32, numPixels);
    }

    public int size() {
      return 36;
    }
  }

  public static class ArcInfo extends DisposedStruct {
    public Rect boundingBox; // The coordinate location of the bounding box of
                             // the arc.
    public double startAngle; // The counterclockwise angle from the x-axis in
                              // degrees to the start of the arc.
    public double endAngle; // The counterclockwise angle from the x-axis in
                            // degrees to the end of the arc.

    private void init() {
      boundingBox = new Rect(backing, 0);
    }

    public ArcInfo() {
      super(32);
      init();
    }

    public ArcInfo(Rect boundingBox, double startAngle, double endAngle) {
      super(32);
      this.boundingBox = boundingBox;
      this.startAngle = startAngle;
      this.endAngle = endAngle;
    }

    protected ArcInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected ArcInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      boundingBox.read();
      startAngle = backing.getDouble(16);
      endAngle = backing.getDouble(24);
    }

    public void write() {
      boundingBox.write();
      backing.putDouble(16, startAngle);
      backing.putDouble(24, endAngle);
    }

    public int size() {
      return 32;
    }
  }

  public static class AxisReport extends DisposedStruct {
    public PointFloat origin; // The origin of the coordinate system, which is
                              // the intersection of the two axes of the
                              // coordinate system.
    public PointFloat mainAxisEnd; // The end of the main axis, which is the
                                   // result of the computation of the
                                   // intersection of the main axis with the
                                   // rectangular search area.
    public PointFloat secondaryAxisEnd; // The end of the secondary axis, which
                                        // is the result of the computation of
                                        // the intersection of the secondary
                                        // axis with the rectangular search
                                        // area.

    private void init() {
      origin = new PointFloat(backing, 0);
      mainAxisEnd = new PointFloat(backing, 8);
      secondaryAxisEnd = new PointFloat(backing, 16);
    }

    public AxisReport() {
      super(24);
      init();
    }

    public AxisReport(PointFloat origin, PointFloat mainAxisEnd, PointFloat secondaryAxisEnd) {
      super(24);
      this.origin = origin;
      this.mainAxisEnd = mainAxisEnd;
      this.secondaryAxisEnd = secondaryAxisEnd;
    }

    protected AxisReport(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected AxisReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      origin.read();
      mainAxisEnd.read();
      secondaryAxisEnd.read();
    }

    public void write() {
      origin.write();
      mainAxisEnd.write();
      secondaryAxisEnd.write();
    }

    public int size() {
      return 24;
    }
  }

  public static class BarcodeInfo extends DisposedStruct {
    public String outputString; // A string containing the decoded barcode data.
    public int size; // The size of the output string.
    public byte outputChar1; // The contents of this character depend on the
                             // barcode type.
    public byte outputChar2; // The contents of this character depend on the
                             // barcode type.
    public double confidenceLevel; // A quality measure of the decoded barcode
                                   // ranging from 0 to 100, with 100 being the
                                   // best.
    public BarcodeType type; // The type of barcode.
    private ByteBuffer outputString_buf;

    private void init() {

    }

    public BarcodeInfo() {
      super(32);
      init();
    }

    public BarcodeInfo(String outputString, int size, byte outputChar1, byte outputChar2,
        double confidenceLevel, BarcodeType type) {
      super(32);
      this.outputString = outputString;
      this.size = size;
      this.outputChar1 = outputChar1;
      this.outputChar2 = outputChar2;
      this.confidenceLevel = confidenceLevel;
      this.type = type;
    }

    protected BarcodeInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected BarcodeInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      long outputString_addr = getPointer(backing, 0);
      if (outputString_addr == 0)
        outputString = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(outputString_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          outputString = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          outputString = "";
        }
      }

      size = backing.getInt(4);
      outputChar1 = backing.get(8);
      outputChar2 = backing.get(9);
      confidenceLevel = backing.getDouble(16);
      type = BarcodeType.fromValue(backing.getInt(24));
    }

    public void write() {
      if (outputString != null) {
        byte[] outputString_bytes;
        try {
          outputString_bytes = outputString.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          outputString_bytes = new byte[0];
        }
        outputString_buf = ByteBuffer.allocateDirect(outputString_bytes.length + 1);
        putBytes(outputString_buf, outputString_bytes, 0, outputString_bytes.length).put(
            outputString_bytes.length, (byte) 0);
      }
      putPointer(backing, 0, outputString == null ? 0 : getByteBufferAddress(outputString_buf));
      backing.putInt(4, size);
      backing.put(8, outputChar1);
      backing.put(9, outputChar2);
      backing.putDouble(16, confidenceLevel);
      if (type != null)
        backing.putInt(24, type.getValue());
    }

    public int size() {
      return 32;
    }
  }

  public static class BCGOptions extends DisposedStruct {
    public float brightness; // Adjusts the brightness of the image.
    public float contrast; // Adjusts the contrast of the image.
    public float gamma; // Performs gamma correction.

    private void init() {

    }

    public BCGOptions() {
      super(12);
      init();
    }

    public BCGOptions(double brightness, double contrast, double gamma) {
      super(12);
      this.brightness = (float) brightness;
      this.contrast = (float) contrast;
      this.gamma = (float) gamma;
    }

    protected BCGOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected BCGOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      brightness = backing.getFloat(0);
      contrast = backing.getFloat(4);
      gamma = backing.getFloat(8);
    }

    public void write() {
      backing.putFloat(0, brightness);
      backing.putFloat(4, contrast);
      backing.putFloat(8, gamma);
    }

    public int size() {
      return 12;
    }
  }

  public static class BestCircle extends DisposedStruct {
    public PointFloat center; // The coordinate location of the center of the
                              // circle.
    public double radius; // The radius of the circle.
    public double area; // The area of the circle.
    public double perimeter; // The length of the perimeter of the circle.
    public double error; // Represents the least square error of the fitted
                         // circle to the entire set of points.

    private void init() {
      center = new PointFloat(backing, 0);
    }

    public BestCircle() {
      super(40);
      init();
    }

    public BestCircle(PointFloat center, double radius, double area, double perimeter, double error) {
      super(40);
      this.center = center;
      this.radius = radius;
      this.area = area;
      this.perimeter = perimeter;
      this.error = error;
    }

    protected BestCircle(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected BestCircle(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      center.read();
      radius = backing.getDouble(8);
      area = backing.getDouble(16);
      perimeter = backing.getDouble(24);
      error = backing.getDouble(32);
    }

    public void write() {
      center.write();
      backing.putDouble(8, radius);
      backing.putDouble(16, area);
      backing.putDouble(24, perimeter);
      backing.putDouble(32, error);
    }

    public int size() {
      return 40;
    }
  }

  public static class BestEllipse extends DisposedStruct {
    public PointFloat center; // The coordinate location of the center of the
                              // ellipse.
    public PointFloat majorAxisStart; // The coordinate location of the start of
                                      // the major axis of the ellipse.
    public PointFloat majorAxisEnd; // The coordinate location of the end of the
                                    // major axis of the ellipse.
    public PointFloat minorAxisStart; // The coordinate location of the start of
                                      // the minor axis of the ellipse.
    public PointFloat minorAxisEnd; // The coordinate location of the end of the
                                    // minor axis of the ellipse.
    public double area; // The area of the ellipse.
    public double perimeter; // The length of the perimeter of the ellipse.

    private void init() {
      center = new PointFloat(backing, 0);
      majorAxisStart = new PointFloat(backing, 8);
      majorAxisEnd = new PointFloat(backing, 16);
      minorAxisStart = new PointFloat(backing, 24);
      minorAxisEnd = new PointFloat(backing, 32);
    }

    public BestEllipse() {
      super(56);
      init();
    }

    public BestEllipse(PointFloat center, PointFloat majorAxisStart, PointFloat majorAxisEnd,
        PointFloat minorAxisStart, PointFloat minorAxisEnd, double area, double perimeter) {
      super(56);
      this.center = center;
      this.majorAxisStart = majorAxisStart;
      this.majorAxisEnd = majorAxisEnd;
      this.minorAxisStart = minorAxisStart;
      this.minorAxisEnd = minorAxisEnd;
      this.area = area;
      this.perimeter = perimeter;
    }

    protected BestEllipse(ByteBuffer backing, int offset) {
      super(backing, offset, 56);
      init();
    }

    protected BestEllipse(long nativeObj, boolean owned) {
      super(nativeObj, owned, 56);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 56);
    }

    public void read() {
      center.read();
      majorAxisStart.read();
      majorAxisEnd.read();
      minorAxisStart.read();
      minorAxisEnd.read();
      area = backing.getDouble(40);
      perimeter = backing.getDouble(48);
    }

    public void write() {
      center.write();
      majorAxisStart.write();
      majorAxisEnd.write();
      minorAxisStart.write();
      minorAxisEnd.write();
      backing.putDouble(40, area);
      backing.putDouble(48, perimeter);
    }

    public int size() {
      return 56;
    }
  }

  public static class BestLine extends DisposedStruct {
    public PointFloat start; // The coordinate location of the start of the
                             // line.
    public PointFloat end; // The coordinate location of the end of the line.
    public LineEquation equation; // Defines the three coefficients of the
                                  // equation of the best fit line.
    public int valid; // This element is TRUE if the function achieved the
                      // minimum score within the number of allowed refinement
                      // iterations and FALSE if the function did not achieve
                      // the minimum score.
    public double error; // Represents the least square error of the fitted line
                         // to the entire set of points.
    public int[] pointsUsed; // An array of the indexes for the points array
                             // indicating which points the function used to fit
                             // the line.
    private ByteBuffer pointsUsed_buf;

    private void init() {
      start = new PointFloat(backing, 0);
      end = new PointFloat(backing, 8);
      equation = new LineEquation(backing, 16);
      pointsUsed = new int[0];
    }

    public BestLine() {
      super(64);
      init();
    }

    public BestLine(PointFloat start, PointFloat end, LineEquation equation, int valid,
        double error, int[] pointsUsed) {
      super(64);
      this.start = start;
      this.end = end;
      this.equation = equation;
      this.valid = valid;
      this.error = error;
      this.pointsUsed = pointsUsed;
    }

    protected BestLine(ByteBuffer backing, int offset) {
      super(backing, offset, 64);
      init();
    }

    protected BestLine(long nativeObj, boolean owned) {
      super(nativeObj, owned, 64);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 64);
    }

    public void read() {
      start.read();
      end.read();
      equation.read();
      valid = backing.getInt(40);
      error = backing.getDouble(48);
      int pointsUsed_numPointsUsed = backing.getInt(60);
      long pointsUsed_addr = getPointer(backing, 56);
      pointsUsed = new int[pointsUsed_numPointsUsed];
      if (pointsUsed_numPointsUsed > 0 && pointsUsed_addr != 0) {
        newDirectByteBuffer(pointsUsed_addr, pointsUsed_numPointsUsed * 4).asIntBuffer().get(
            pointsUsed);
      }
    }

    public void write() {
      start.write();
      end.write();
      equation.write();
      backing.putInt(40, valid);
      backing.putDouble(48, error);
      pointsUsed_buf =
          ByteBuffer.allocateDirect(pointsUsed.length * 4).order(ByteOrder.nativeOrder());
      pointsUsed_buf.asIntBuffer().put(pointsUsed).rewind();
      backing.putInt(60, pointsUsed.length);
      putPointer(backing, 56, pointsUsed_buf);
    }

    public int size() {
      return 64;
    }
  }

  public static class BrowserOptions extends DisposedStruct {
    public int width; // The width to make the browser.
    public int height; // The height to make the browser image.
    public int imagesPerLine; // The number of images to place on a single line.
    public RGBValue backgroundColor; // The background color of the browser.
    public int frameSize; // Specifies the number of pixels with which to border
                          // each thumbnail.
    public BrowserFrameStyle style; // The style for the frame around each
                                    // thumbnail.
    public float ratio; // Specifies the width to height ratio of each
                        // thumbnail.
    public RGBValue focusColor; // The color to use to display focused cells.

    private void init() {
      backgroundColor = new RGBValue(backing, 12);
      focusColor = new RGBValue(backing, 28);
    }

    public BrowserOptions() {
      super(32);
      init();
    }

    public BrowserOptions(int width, int height, int imagesPerLine, RGBValue backgroundColor,
        int frameSize, BrowserFrameStyle style, double ratio, RGBValue focusColor) {
      super(32);
      this.width = width;
      this.height = height;
      this.imagesPerLine = imagesPerLine;
      this.backgroundColor = backgroundColor;
      this.frameSize = frameSize;
      this.style = style;
      this.ratio = (float) ratio;
      this.focusColor = focusColor;
    }

    protected BrowserOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected BrowserOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      width = backing.getInt(0);
      height = backing.getInt(4);
      imagesPerLine = backing.getInt(8);
      backgroundColor.read();
      frameSize = backing.getInt(16);
      style = BrowserFrameStyle.fromValue(backing.getInt(20));
      ratio = backing.getFloat(24);
      focusColor.read();
    }

    public void write() {
      backing.putInt(0, width);
      backing.putInt(4, height);
      backing.putInt(8, imagesPerLine);
      backgroundColor.write();
      backing.putInt(16, frameSize);
      if (style != null)
        backing.putInt(20, style.getValue());
      backing.putFloat(24, ratio);
      focusColor.write();
    }

    public int size() {
      return 32;
    }
  }

  public static class CoordinateSystem extends DisposedStruct {
    public PointFloat origin; // The origin of the coordinate system.
    public float angle; // The angle, in degrees, of the x-axis of the
                        // coordinate system relative to the image x-axis.
    public AxisOrientation axisOrientation; // The direction of the y-axis of
                                            // the coordinate reference system.

    private void init() {
      origin = new PointFloat(backing, 0);
    }

    public CoordinateSystem() {
      super(16);
      init();
    }

    public CoordinateSystem(PointFloat origin, double angle, AxisOrientation axisOrientation) {
      super(16);
      this.origin = origin;
      this.angle = (float) angle;
      this.axisOrientation = axisOrientation;
    }

    protected CoordinateSystem(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected CoordinateSystem(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      origin.read();
      angle = backing.getFloat(8);
      axisOrientation = AxisOrientation.fromValue(backing.getInt(12));
    }

    public void write() {
      origin.write();
      backing.putFloat(8, angle);
      if (axisOrientation != null)
        backing.putInt(12, axisOrientation.getValue());
    }

    public int size() {
      return 16;
    }
  }

  public static class CalibrationInfo extends DisposedStruct {
    public int mapColumns; // The number of columns in the error map.
    public int mapRows; // The number of rows in the error map.
    public ROI userRoi; // Specifies the ROI the user provided when learning the
                        // calibration.
    public ROI calibrationRoi; // Specifies the ROI that corresponds to the
                               // region of the image where the calibration
                               // information is accurate.
    public LearnCalibrationOptions options; // Specifies the calibration options
                                            // the user provided when learning
                                            // the calibration.
    public GridDescriptor grid; // Specifies the scaling constants for the
                                // image.
    public CoordinateSystem system; // Specifies the coordinate system for the
                                    // real world coordinates.
    public RangeFloat range; // The range of the grayscale the function used to
                             // represent the circles in the grid image.
    public float quality; // The quality score of the learning process, which is
                          // a value between 0-1000.

    private void init() {
      options = new LearnCalibrationOptions(backing, 20);
      grid = new GridDescriptor(backing, 40);
      system = new CoordinateSystem(backing, 52);
      range = new RangeFloat(backing, 68);
    }

    public CalibrationInfo() {
      super(80);
      init();
    }

    public CalibrationInfo(int mapColumns, int mapRows, ROI userRoi, ROI calibrationRoi,
        LearnCalibrationOptions options, GridDescriptor grid, CoordinateSystem system,
        RangeFloat range, double quality) {
      super(80);
      this.mapColumns = mapColumns;
      this.mapRows = mapRows;
      this.userRoi = userRoi;
      this.calibrationRoi = calibrationRoi;
      this.options = options;
      this.grid = grid;
      this.system = system;
      this.range = range;
      this.quality = (float) quality;
    }

    protected CalibrationInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 80);
      init();
    }

    protected CalibrationInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 80);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 80);
    }

    public void read() {
      mapColumns = backing.getInt(4);
      mapRows = backing.getInt(8);
      long userRoi_addr = getPointer(backing, 12);
      if (userRoi_addr == 0)
        userRoi = null;
      else
        userRoi = new ROI(userRoi_addr, false);
      long calibrationRoi_addr = getPointer(backing, 16);
      if (calibrationRoi_addr == 0)
        calibrationRoi = null;
      else
        calibrationRoi = new ROI(calibrationRoi_addr, false);
      options.read();
      grid.read();
      system.read();
      range.read();
      quality = backing.getFloat(76);
    }

    public void write() {
      backing.putInt(4, mapColumns);
      backing.putInt(8, mapRows);
      putPointer(backing, 12, userRoi);
      putPointer(backing, 16, calibrationRoi);
      options.write();
      grid.write();
      system.write();
      range.write();
      backing.putFloat(76, quality);
    }

    public int size() {
      return 80;
    }
  }

  public static class CalibrationPoints extends DisposedStruct {
    public PointFloat[] pixelCoordinates; // The array of pixel coordinates.
    public PointFloat[] realWorldCoordinates; // The array of corresponding
                                              // real-world coordinates.
    private ByteBuffer pixelCoordinates_buf;
    private ByteBuffer realWorldCoordinates_buf;

    private void init() {
      pixelCoordinates = new PointFloat[0];
      realWorldCoordinates = new PointFloat[0];
    }

    public CalibrationPoints() {
      super(12);
      init();
    }

    public CalibrationPoints(PointFloat[] pixelCoordinates, PointFloat[] realWorldCoordinates) {
      super(12);
      this.pixelCoordinates = pixelCoordinates;
      this.realWorldCoordinates = realWorldCoordinates;
    }

    protected CalibrationPoints(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected CalibrationPoints(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      int pixelCoordinates_numCoordinates = backing.getInt(8);
      long pixelCoordinates_addr = getPointer(backing, 0);
      pixelCoordinates = new PointFloat[pixelCoordinates_numCoordinates];
      if (pixelCoordinates_numCoordinates > 0 && pixelCoordinates_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(pixelCoordinates_addr, pixelCoordinates_numCoordinates * 8);
        for (int i = 0, off = 0; i < pixelCoordinates_numCoordinates; i++, off += 8) {
          pixelCoordinates[i] = new PointFloat(bb, off);
          pixelCoordinates[i].read();
        }
      }
      int realWorldCoordinates_numCoordinates = backing.getInt(8);
      long realWorldCoordinates_addr = getPointer(backing, 4);
      realWorldCoordinates = new PointFloat[realWorldCoordinates_numCoordinates];
      if (realWorldCoordinates_numCoordinates > 0 && realWorldCoordinates_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(realWorldCoordinates_addr, realWorldCoordinates_numCoordinates * 8);
        for (int i = 0, off = 0; i < realWorldCoordinates_numCoordinates; i++, off += 8) {
          realWorldCoordinates[i] = new PointFloat(bb, off);
          realWorldCoordinates[i].read();
        }
      }
    }

    public void write() {
      pixelCoordinates_buf =
          ByteBuffer.allocateDirect(pixelCoordinates.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < pixelCoordinates.length; i++, off += 8) {
        pixelCoordinates[i].setBuffer(pixelCoordinates_buf, off);
        pixelCoordinates[i].write();
      }
      backing.putInt(8, pixelCoordinates.length);
      putPointer(backing, 0, pixelCoordinates_buf);
      realWorldCoordinates_buf =
          ByteBuffer.allocateDirect(realWorldCoordinates.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < realWorldCoordinates.length; i++, off += 8) {
        realWorldCoordinates[i].setBuffer(realWorldCoordinates_buf, off);
        realWorldCoordinates[i].write();
      }
      backing.putInt(8, realWorldCoordinates.length);
      putPointer(backing, 4, realWorldCoordinates_buf);
    }

    public int size() {
      return 12;
    }
  }

  public static class CaliperOptions extends DisposedStruct {
    public TwoEdgePolarityType polarity; // Specifies the edge polarity of the
                                         // edge pairs.
    public float separation; // The distance between edge pairs.
    public float separationDeviation; // Sets the range around the separation
                                      // value.

    private void init() {

    }

    public CaliperOptions() {
      super(12);
      init();
    }

    public CaliperOptions(TwoEdgePolarityType polarity, double separation,
        double separationDeviation) {
      super(12);
      this.polarity = polarity;
      this.separation = (float) separation;
      this.separationDeviation = (float) separationDeviation;
    }

    protected CaliperOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected CaliperOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      polarity = TwoEdgePolarityType.fromValue(backing.getInt(0));
      separation = backing.getFloat(4);
      separationDeviation = backing.getFloat(8);
    }

    public void write() {
      if (polarity != null)
        backing.putInt(0, polarity.getValue());
      backing.putFloat(4, separation);
      backing.putFloat(8, separationDeviation);
    }

    public int size() {
      return 12;
    }
  }

  public static class CaliperReport extends DisposedStruct {
    public float edge1Contrast; // The contrast of the first edge.
    public PointFloat edge1Coord; // The coordinates of the first edge.
    public float edge2Contrast; // The contrast of the second edge.
    public PointFloat edge2Coord; // The coordinates of the second edge.
    public float separation; // The distance between the two edges.

    private void init() {
      edge1Coord = new PointFloat(backing, 4);
      edge2Coord = new PointFloat(backing, 16);
    }

    public CaliperReport() {
      super(32);
      init();
    }

    public CaliperReport(double edge1Contrast, PointFloat edge1Coord, double edge2Contrast,
        PointFloat edge2Coord, double separation) {
      super(32);
      this.edge1Contrast = (float) edge1Contrast;
      this.edge1Coord = edge1Coord;
      this.edge2Contrast = (float) edge2Contrast;
      this.edge2Coord = edge2Coord;
      this.separation = (float) separation;
    }

    protected CaliperReport(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected CaliperReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      edge1Contrast = backing.getFloat(0);
      edge1Coord.read();
      edge2Contrast = backing.getFloat(12);
      edge2Coord.read();
      separation = backing.getFloat(24);
    }

    public void write() {
      backing.putFloat(0, edge1Contrast);
      edge1Coord.write();
      backing.putFloat(12, edge2Contrast);
      edge2Coord.write();
      backing.putFloat(24, separation);
    }

    public int size() {
      return 32;
    }
  }

  public static class DrawTextOptions extends DisposedStruct {
    public String fontName; // The font name to use.
    public int fontSize; // The size of the font.
    public int bold; // Set this parameter to TRUE to bold text.
    public int italic; // Set this parameter to TRUE to italicize text.
    public int underline; // Set this parameter to TRUE to underline text.
    public int strikeout; // Set this parameter to TRUE to strikeout text.
    public TextAlignment textAlignment; // Sets the alignment of text.
    public FontColor fontColor; // Sets the font color.

    private void init() {

    }

    public DrawTextOptions() {
      super(60);
      init();
    }

    public DrawTextOptions(String fontName, int fontSize, int bold, int italic, int underline,
        int strikeout, TextAlignment textAlignment, FontColor fontColor) {
      super(60);
      this.fontName = fontName;
      this.fontSize = fontSize;
      this.bold = bold;
      this.italic = italic;
      this.underline = underline;
      this.strikeout = strikeout;
      this.textAlignment = textAlignment;
      this.fontColor = fontColor;
    }

    protected DrawTextOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 60);
      init();
    }

    protected DrawTextOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 60);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 60);
    }

    public void read() {
      {
        byte[] bytes = new byte[32];
        getBytes(backing, bytes, 0, 32);
        int len;
        for (len = 0; len < bytes.length && bytes[len] != 0; len++) {
        }
        try {
          fontName = new String(bytes, 0, len, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          fontName = "";
        }
      }
      fontSize = backing.getInt(32);
      bold = backing.getInt(36);
      italic = backing.getInt(40);
      underline = backing.getInt(44);
      strikeout = backing.getInt(48);
      textAlignment = TextAlignment.fromValue(backing.getInt(52));
      fontColor = FontColor.fromValue(backing.getInt(56));
    }

    public void write() {
      if (fontName != null) {
        byte[] bytes;
        try {
          bytes = fontName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bytes = new byte[0];
        }
        putBytes(backing, bytes, 0, bytes.length);
        for (int i = bytes.length; i < 32; i++)
          backing.put(i, (byte) 0); // fill with zero
      }
      backing.putInt(32, fontSize);
      backing.putInt(36, bold);
      backing.putInt(40, italic);
      backing.putInt(44, underline);
      backing.putInt(48, strikeout);
      if (textAlignment != null)
        backing.putInt(52, textAlignment.getValue());
      if (fontColor != null)
        backing.putInt(56, fontColor.getValue());
    }

    public int size() {
      return 60;
    }
  }

  public static class CircleReport extends DisposedStruct {
    public Point center; // The coordinate point of the center of the circle.
    public int radius; // The radius of the circle, in pixels.
    public int area; // The area of the circle, in pixels.

    private void init() {
      center = new Point(backing, 0);
    }

    public CircleReport() {
      super(16);
      init();
    }

    public CircleReport(Point center, int radius, int area) {
      super(16);
      this.center = center;
      this.radius = radius;
      this.area = area;
    }

    protected CircleReport(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected CircleReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      center.read();
      radius = backing.getInt(8);
      area = backing.getInt(12);
    }

    public void write() {
      center.write();
      backing.putInt(8, radius);
      backing.putInt(12, area);
    }

    public int size() {
      return 16;
    }
  }

  public static class ClosedContour extends DisposedStruct {
    public Point[] points; // The points that make up the closed contour.
    private ByteBuffer points_buf;

    private void init() {
      points = new Point[0];
    }

    public ClosedContour() {
      super(8);
      init();
    }

    public ClosedContour(Point[] points) {
      super(8);
      this.points = points;
    }

    protected ClosedContour(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected ClosedContour(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      int points_numPoints = backing.getInt(4);
      long points_addr = getPointer(backing, 0);
      points = new Point[points_numPoints];
      if (points_numPoints > 0 && points_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(points_addr, points_numPoints * 8);
        for (int i = 0, off = 0; i < points_numPoints; i++, off += 8) {
          points[i] = new Point(bb, off);
          points[i].read();
        }
      }
    }

    public void write() {
      points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < points.length; i++, off += 8) {
        points[i].setBuffer(points_buf, off);
        points[i].write();
      }
      backing.putInt(4, points.length);
      putPointer(backing, 0, points_buf);
    }

    public int size() {
      return 8;
    }
  }

  public static class ColorHistogramReport extends DisposedStruct {
    public HistogramReport plane1; // The histogram report of the first color
                                   // plane.
    public HistogramReport plane2; // The histogram report of the second plane.
    public HistogramReport plane3; // The histogram report of the third plane.

    private void init() {
      plane1 = new HistogramReport(backing, 0);
      plane2 = new HistogramReport(backing, 36);
      plane3 = new HistogramReport(backing, 72);
    }

    public ColorHistogramReport() {
      super(108);
      init();
    }

    public ColorHistogramReport(HistogramReport plane1, HistogramReport plane2,
        HistogramReport plane3) {
      super(108);
      this.plane1 = plane1;
      this.plane2 = plane2;
      this.plane3 = plane3;
    }

    protected ColorHistogramReport(ByteBuffer backing, int offset) {
      super(backing, offset, 108);
      init();
    }

    protected ColorHistogramReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 108);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 108);
    }

    public void read() {
      plane1.read();
      plane2.read();
      plane3.read();
    }

    public void write() {
      plane1.write();
      plane2.write();
      plane3.write();
    }

    public int size() {
      return 108;
    }
  }

  public static class ColorInformation extends DisposedStruct {
    public int saturation; // The saturation level the function uses to learn
                           // the color information.
    public double[] info; // An array of color information that represents the
                          // color spectrum analysis of a region of an image in
                          // a compact form.
    private ByteBuffer info_buf;

    private void init() {
      info = new double[0];
    }

    public ColorInformation() {
      super(12);
      init();
    }

    public ColorInformation(int saturation, double[] info) {
      super(12);
      this.saturation = saturation;
      this.info = info;
    }

    protected ColorInformation(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected ColorInformation(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      saturation = backing.getInt(4);
      int info_infoCount = backing.getInt(0);
      long info_addr = getPointer(backing, 8);
      info = new double[info_infoCount];
      if (info_infoCount > 0 && info_addr != 0) {
        newDirectByteBuffer(info_addr, info_infoCount * 8).asDoubleBuffer().get(info);
      }
    }

    public void write() {
      backing.putInt(4, saturation);
      info_buf = ByteBuffer.allocateDirect(info.length * 8).order(ByteOrder.nativeOrder());
      info_buf.asDoubleBuffer().put(info).rewind();
      backing.putInt(0, info.length);
      putPointer(backing, 8, info_buf);
    }

    public int size() {
      return 12;
    }
  }

  public static class Complex extends DisposedStruct {
    public float r; // The real part of the value.
    public float i; // The imaginary part of the value.

    private void init() {

    }

    public Complex() {
      super(8);
      init();
    }

    public Complex(double r, double i) {
      super(8);
      this.r = (float) r;
      this.i = (float) i;
    }

    protected Complex(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected Complex(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      r = backing.getFloat(0);
      i = backing.getFloat(4);
    }

    public void write() {
      backing.putFloat(0, r);
      backing.putFloat(4, i);
    }

    public int size() {
      return 8;
    }
  }

  public static class ConcentricRakeReport extends DisposedStruct {
    public ArcInfo[] rakeArcs; // An array containing the location of each
                               // concentric arc line used for edge detection.
    public PointFloat[] firstEdges; // The coordinate location of all edges
                                    // detected as first edges.
    public PointFloat[] lastEdges; // The coordinate location of all edges
                                   // detected as last edges.
    public EdgeLocationReport[] allEdges; // An array of reports describing the
                                          // location of the edges located by
                                          // each concentric rake arc line.
    public int[] linesWithEdges; // An array of indices into the rakeArcs array
                                 // indicating the concentric rake arc lines on
                                 // which the function detected at least one
                                 // edge.
    private ByteBuffer rakeArcs_buf;
    private ByteBuffer firstEdges_buf;
    private ByteBuffer lastEdges_buf;
    private ByteBuffer allEdges_buf;
    private ByteBuffer linesWithEdges_buf;

    private void init() {
      rakeArcs = new ArcInfo[0];
      firstEdges = new PointFloat[0];
      lastEdges = new PointFloat[0];
      allEdges = new EdgeLocationReport[0];
      linesWithEdges = new int[0];
    }

    public ConcentricRakeReport() {
      super(36);
      init();
    }

    public ConcentricRakeReport(ArcInfo[] rakeArcs, PointFloat[] firstEdges,
        PointFloat[] lastEdges, EdgeLocationReport[] allEdges, int[] linesWithEdges) {
      super(36);
      this.rakeArcs = rakeArcs;
      this.firstEdges = firstEdges;
      this.lastEdges = lastEdges;
      this.allEdges = allEdges;
      this.linesWithEdges = linesWithEdges;
    }

    protected ConcentricRakeReport(ByteBuffer backing, int offset) {
      super(backing, offset, 36);
      init();
    }

    protected ConcentricRakeReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 36);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 36);
    }

    public void read() {
      int rakeArcs_numArcs = backing.getInt(4);
      long rakeArcs_addr = getPointer(backing, 0);
      rakeArcs = new ArcInfo[rakeArcs_numArcs];
      if (rakeArcs_numArcs > 0 && rakeArcs_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(rakeArcs_addr, rakeArcs_numArcs * 32);
        for (int i = 0, off = 0; i < rakeArcs_numArcs; i++, off += 32) {
          rakeArcs[i] = new ArcInfo(bb, off);
          rakeArcs[i].read();
        }
      }
      int firstEdges_numFirstEdges = backing.getInt(12);
      long firstEdges_addr = getPointer(backing, 8);
      firstEdges = new PointFloat[firstEdges_numFirstEdges];
      if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges * 8);
        for (int i = 0, off = 0; i < firstEdges_numFirstEdges; i++, off += 8) {
          firstEdges[i] = new PointFloat(bb, off);
          firstEdges[i].read();
        }
      }
      int lastEdges_numLastEdges = backing.getInt(20);
      long lastEdges_addr = getPointer(backing, 16);
      lastEdges = new PointFloat[lastEdges_numLastEdges];
      if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges * 8);
        for (int i = 0, off = 0; i < lastEdges_numLastEdges; i++, off += 8) {
          lastEdges[i] = new PointFloat(bb, off);
          lastEdges[i].read();
        }
      }
      int allEdges_numLinesWithEdges = backing.getInt(32);
      long allEdges_addr = getPointer(backing, 24);
      allEdges = new EdgeLocationReport[allEdges_numLinesWithEdges];
      if (allEdges_numLinesWithEdges > 0 && allEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(allEdges_addr, allEdges_numLinesWithEdges * 8);
        for (int i = 0, off = 0; i < allEdges_numLinesWithEdges; i++, off += 8) {
          allEdges[i] = new EdgeLocationReport(bb, off);
          allEdges[i].read();
        }
      }
      int linesWithEdges_numLinesWithEdges = backing.getInt(32);
      long linesWithEdges_addr = getPointer(backing, 28);
      linesWithEdges = new int[linesWithEdges_numLinesWithEdges];
      if (linesWithEdges_numLinesWithEdges > 0 && linesWithEdges_addr != 0) {
        newDirectByteBuffer(linesWithEdges_addr, linesWithEdges_numLinesWithEdges * 4)
            .asIntBuffer().get(linesWithEdges);
      }
    }

    public void write() {
      rakeArcs_buf = ByteBuffer.allocateDirect(rakeArcs.length * 32).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < rakeArcs.length; i++, off += 32) {
        rakeArcs[i].setBuffer(rakeArcs_buf, off);
        rakeArcs[i].write();
      }
      backing.putInt(4, rakeArcs.length);
      putPointer(backing, 0, rakeArcs_buf);
      firstEdges_buf =
          ByteBuffer.allocateDirect(firstEdges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < firstEdges.length; i++, off += 8) {
        firstEdges[i].setBuffer(firstEdges_buf, off);
        firstEdges[i].write();
      }
      backing.putInt(12, firstEdges.length);
      putPointer(backing, 8, firstEdges_buf);
      lastEdges_buf =
          ByteBuffer.allocateDirect(lastEdges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < lastEdges.length; i++, off += 8) {
        lastEdges[i].setBuffer(lastEdges_buf, off);
        lastEdges[i].write();
      }
      backing.putInt(20, lastEdges.length);
      putPointer(backing, 16, lastEdges_buf);
      allEdges_buf = ByteBuffer.allocateDirect(allEdges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < allEdges.length; i++, off += 8) {
        allEdges[i].setBuffer(allEdges_buf, off);
        allEdges[i].write();
      }
      backing.putInt(32, allEdges.length);
      putPointer(backing, 24, allEdges_buf);
      linesWithEdges_buf =
          ByteBuffer.allocateDirect(linesWithEdges.length * 4).order(ByteOrder.nativeOrder());
      linesWithEdges_buf.asIntBuffer().put(linesWithEdges).rewind();
      backing.putInt(32, linesWithEdges.length);
      putPointer(backing, 28, linesWithEdges_buf);
    }

    public int size() {
      return 36;
    }
  }

  public static class ConstructROIOptions extends DisposedStruct {
    public int windowNumber; // The window number of the image window.
    public String windowTitle; // Specifies the message string that the function
                               // displays in the title bar of the window.
    public PaletteType type; // The palette type to use.
    public RGBValue[] palette; // If type is IMAQ_PALETTE_USER, this array is
                               // the palette of colors to use with the window.
    private ByteBuffer windowTitle_buf;
    private ByteBuffer palette_buf;

    private void init() {
      palette = new RGBValue[0];
    }

    public ConstructROIOptions() {
      super(20);
      init();
    }

    public ConstructROIOptions(int windowNumber, String windowTitle, PaletteType type,
        RGBValue[] palette) {
      super(20);
      this.windowNumber = windowNumber;
      this.windowTitle = windowTitle;
      this.type = type;
      this.palette = palette;
    }

    protected ConstructROIOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected ConstructROIOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      windowNumber = backing.getInt(0);
      long windowTitle_addr = getPointer(backing, 4);
      if (windowTitle_addr == 0)
        windowTitle = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(windowTitle_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          windowTitle = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          windowTitle = "";
        }
      }

      type = PaletteType.fromValue(backing.getInt(8));
      int palette_numColors = backing.getInt(16);
      long palette_addr = getPointer(backing, 12);
      palette = new RGBValue[palette_numColors];
      if (palette_numColors > 0 && palette_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(palette_addr, palette_numColors * 4);
        for (int i = 0, off = 0; i < palette_numColors; i++, off += 4) {
          palette[i] = new RGBValue(bb, off);
          palette[i].read();
        }
      }
    }

    public void write() {
      backing.putInt(0, windowNumber);
      if (windowTitle != null) {
        byte[] windowTitle_bytes;
        try {
          windowTitle_bytes = windowTitle.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          windowTitle_bytes = new byte[0];
        }
        windowTitle_buf = ByteBuffer.allocateDirect(windowTitle_bytes.length + 1);
        putBytes(windowTitle_buf, windowTitle_bytes, 0, windowTitle_bytes.length).put(
            windowTitle_bytes.length, (byte) 0);
      }
      putPointer(backing, 4, windowTitle == null ? 0 : getByteBufferAddress(windowTitle_buf));
      if (type != null)
        backing.putInt(8, type.getValue());
      palette_buf = ByteBuffer.allocateDirect(palette.length * 4).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < palette.length; i++, off += 4) {
        palette[i].setBuffer(palette_buf, off);
        palette[i].write();
      }
      backing.putInt(16, palette.length);
      putPointer(backing, 12, palette_buf);
    }

    public int size() {
      return 20;
    }
  }

  public static class ContourInfo extends DisposedStruct {
    public ContourType type; // The contour type.
    public Point[] points; // The points describing the contour.
    public RGBValue contourColor; // The contour color.
    private ByteBuffer points_buf;

    private void init() {
      points = new Point[0];
      contourColor = new RGBValue(backing, 12);
    }

    public ContourInfo() {
      super(16);
      init();
    }

    public ContourInfo(ContourType type, Point[] points, RGBValue contourColor) {
      super(16);
      this.type = type;
      this.points = points;
      this.contourColor = contourColor;
    }

    protected ContourInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ContourInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      type = ContourType.fromValue(backing.getInt(0));
      int points_numPoints = backing.getInt(4);
      long points_addr = getPointer(backing, 8);
      points = new Point[points_numPoints];
      if (points_numPoints > 0 && points_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(points_addr, points_numPoints * 8);
        for (int i = 0, off = 0; i < points_numPoints; i++, off += 8) {
          points[i] = new Point(bb, off);
          points[i].read();
        }
      }
      contourColor.read();
    }

    public void write() {
      if (type != null)
        backing.putInt(0, type.getValue());
      points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < points.length; i++, off += 8) {
        points[i].setBuffer(points_buf, off);
        points[i].write();
      }
      backing.putInt(4, points.length);
      putPointer(backing, 8, points_buf);
      contourColor.write();
    }

    public int size() {
      return 16;
    }
  }

  public static class ContourInfo2 extends DisposedStruct {
    public ContourType type; // The contour type.
    public RGBValue color; // The contour color.
    public Point point; // Use this member when the contour is of type
                        // IMAQ_POINT.
    public Line line; // Use this member when the contour is of type IMAQ_LINE.
    public Rect rect; // Use this member when the contour is of type IMAQ_RECT.
    public Rect ovalBoundingBox; // Use this member when the contour is of type
                                 // IMAQ_OVAL.
    public ClosedContour closedContour; // Use this member when the contour is
                                        // of type IMAQ_CLOSED_CONTOUR.
    public OpenContour openContour; // Use this member when the contour is of
                                    // type IMAQ_OPEN_CONTOUR.
    public Annulus annulus; // Use this member when the contour is of type
                            // IMAQ_ANNULUS.
    public RotatedRect rotatedRect; // Use this member when the contour is of
                                    // type IMAQ_ROTATED_RECT.

    private void init() {
      color = new RGBValue(backing, 4);
    }

    public ContourInfo2() {
      super(12);
      init();
    }

    public ContourInfo2(ContourType type, RGBValue color) {
      super(12);
      this.type = type;
      this.color = color;
    }

    protected ContourInfo2(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected ContourInfo2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      type = ContourType.fromValue(backing.getInt(0));
      color.read();
      if (type == ContourType.POINT) {
        long point_addr = getPointer(backing, 8);
        if (point_addr == 0)
          point = null;
        else
          point = new Point(point_addr, false);
      }
      if (type == ContourType.LINE) {
        long line_addr = getPointer(backing, 8);
        if (line_addr == 0)
          line = null;
        else
          line = new Line(line_addr, false);
      }
      if (type == ContourType.RECT) {
        long rect_addr = getPointer(backing, 8);
        if (rect_addr == 0)
          rect = null;
        else
          rect = new Rect(rect_addr, false);
      }
      if (type == ContourType.OVAL) {
        long ovalBoundingBox_addr = getPointer(backing, 8);
        if (ovalBoundingBox_addr == 0)
          ovalBoundingBox = null;
        else
          ovalBoundingBox = new Rect(ovalBoundingBox_addr, false);
      }
      if (type == ContourType.CLOSED_CONTOUR) {
        long closedContour_addr = getPointer(backing, 8);
        if (closedContour_addr == 0)
          closedContour = null;
        else
          closedContour = new ClosedContour(closedContour_addr, false);
      }
      if (type == ContourType.OPEN_CONTOUR) {
        long openContour_addr = getPointer(backing, 8);
        if (openContour_addr == 0)
          openContour = null;
        else
          openContour = new OpenContour(openContour_addr, false);
      }
      if (type == ContourType.ANNULUS) {
        long annulus_addr = getPointer(backing, 8);
        if (annulus_addr == 0)
          annulus = null;
        else
          annulus = new Annulus(annulus_addr, false);
      }
      if (type == ContourType.ROTATED_RECT) {
        long rotatedRect_addr = getPointer(backing, 8);
        if (rotatedRect_addr == 0)
          rotatedRect = null;
        else
          rotatedRect = new RotatedRect(rotatedRect_addr, false);
      }
    }

    public void write() {
      if (type != null)
        backing.putInt(0, type.getValue());
      color.write();
      if (type == ContourType.POINT) {
        putPointer(backing, 8, point);
      }
      if (type == ContourType.LINE) {
        putPointer(backing, 8, line);
      }
      if (type == ContourType.RECT) {
        putPointer(backing, 8, rect);
      }
      if (type == ContourType.OVAL) {
        putPointer(backing, 8, ovalBoundingBox);
      }
      if (type == ContourType.CLOSED_CONTOUR) {
        putPointer(backing, 8, closedContour);
      }
      if (type == ContourType.OPEN_CONTOUR) {
        putPointer(backing, 8, openContour);
      }
      if (type == ContourType.ANNULUS) {
        putPointer(backing, 8, annulus);
      }
      if (type == ContourType.ROTATED_RECT) {
        putPointer(backing, 8, rotatedRect);
      }
    }

    public int size() {
      return 12;
    }
  }

  public static class ContourPoint extends DisposedStruct {
    public double x; // The x-coordinate value in the image.
    public double y; // The y-coordinate value in the image.
    public double curvature; // The change in slope at this edge point of the
                             // segment.
    public double xDisplacement; // The x displacement of the current edge pixel
                                 // from a cubic spline fit of the current edge
                                 // segment.
    public double yDisplacement; // The y displacement of the current edge pixel
                                 // from a cubic spline fit of the current edge
                                 // segment.

    private void init() {

    }

    public ContourPoint() {
      super(40);
      init();
    }

    public ContourPoint(double x, double y, double curvature, double xDisplacement,
        double yDisplacement) {
      super(40);
      this.x = x;
      this.y = y;
      this.curvature = curvature;
      this.xDisplacement = xDisplacement;
      this.yDisplacement = yDisplacement;
    }

    protected ContourPoint(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected ContourPoint(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      x = backing.getDouble(0);
      y = backing.getDouble(8);
      curvature = backing.getDouble(16);
      xDisplacement = backing.getDouble(24);
      yDisplacement = backing.getDouble(32);
    }

    public void write() {
      backing.putDouble(0, x);
      backing.putDouble(8, y);
      backing.putDouble(16, curvature);
      backing.putDouble(24, xDisplacement);
      backing.putDouble(32, yDisplacement);
    }

    public int size() {
      return 40;
    }
  }

  public static class CoordinateTransform extends DisposedStruct {
    public Point initialOrigin; // The origin of the initial coordinate system.
    public float initialAngle; // The angle, in degrees, of the x-axis of the
                               // initial coordinate system relative to the
                               // image x-axis.
    public Point finalOrigin; // The origin of the final coordinate system.
    public float finalAngle; // The angle, in degrees, of the x-axis of the
                             // final coordinate system relative to the image
                             // x-axis.

    private void init() {
      initialOrigin = new Point(backing, 0);
      finalOrigin = new Point(backing, 12);
    }

    public CoordinateTransform() {
      super(24);
      init();
    }

    public CoordinateTransform(Point initialOrigin, double initialAngle, Point finalOrigin,
        double finalAngle) {
      super(24);
      this.initialOrigin = initialOrigin;
      this.initialAngle = (float) initialAngle;
      this.finalOrigin = finalOrigin;
      this.finalAngle = (float) finalAngle;
    }

    protected CoordinateTransform(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected CoordinateTransform(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      initialOrigin.read();
      initialAngle = backing.getFloat(8);
      finalOrigin.read();
      finalAngle = backing.getFloat(20);
    }

    public void write() {
      initialOrigin.write();
      backing.putFloat(8, initialAngle);
      finalOrigin.write();
      backing.putFloat(20, finalAngle);
    }

    public int size() {
      return 24;
    }
  }

  public static class CoordinateTransform2 extends DisposedStruct {
    public CoordinateSystem referenceSystem; // Defines the coordinate system
                                             // for input coordinates.
    public CoordinateSystem measurementSystem; // Defines the coordinate system
                                               // in which the function should
                                               // perform measurements.

    private void init() {
      referenceSystem = new CoordinateSystem(backing, 0);
      measurementSystem = new CoordinateSystem(backing, 16);
    }

    public CoordinateTransform2() {
      super(32);
      init();
    }

    public CoordinateTransform2(CoordinateSystem referenceSystem, CoordinateSystem measurementSystem) {
      super(32);
      this.referenceSystem = referenceSystem;
      this.measurementSystem = measurementSystem;
    }

    protected CoordinateTransform2(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected CoordinateTransform2(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      referenceSystem.read();
      measurementSystem.read();
    }

    public void write() {
      referenceSystem.write();
      measurementSystem.write();
    }

    public int size() {
      return 32;
    }
  }

  public static class CannyOptions extends DisposedStruct {
    public float sigma; // The sigma of the Gaussian smoothing filter that the
                        // function applies to the image before edge detection.
    public float upperThreshold; // The upper fraction of pixel values in the
                                 // image from which the function chooses a seed
                                 // or starting point of an edge segment.
    public float lowerThreshold; // The function multiplies this value by
                                 // upperThreshold to determine the lower
                                 // threshold for all the pixels in an edge
                                 // segment.
    public int windowSize; // The window size of the Gaussian filter that the
                           // function applies to the image.

    private void init() {

    }

    public CannyOptions() {
      super(16);
      init();
    }

    public CannyOptions(double sigma, double upperThreshold, double lowerThreshold, int windowSize) {
      super(16);
      this.sigma = (float) sigma;
      this.upperThreshold = (float) upperThreshold;
      this.lowerThreshold = (float) lowerThreshold;
      this.windowSize = windowSize;
    }

    protected CannyOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected CannyOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      sigma = backing.getFloat(0);
      upperThreshold = backing.getFloat(4);
      lowerThreshold = backing.getFloat(8);
      windowSize = backing.getInt(12);
    }

    public void write() {
      backing.putFloat(0, sigma);
      backing.putFloat(4, upperThreshold);
      backing.putFloat(8, lowerThreshold);
      backing.putInt(12, windowSize);
    }

    public int size() {
      return 16;
    }
  }

  public static class Range extends DisposedStruct {
    public int minValue; // The minimum value of the range.
    public int maxValue; // The maximum value of the range.

    private void init() {

    }

    public Range() {
      super(8);
      init();
    }

    public Range(int minValue, int maxValue) {
      super(8);
      this.minValue = minValue;
      this.maxValue = maxValue;
    }

    protected Range(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected Range(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      minValue = backing.getInt(0);
      maxValue = backing.getInt(4);
    }

    public void write() {
      backing.putInt(0, minValue);
      backing.putInt(4, maxValue);
    }

    public int size() {
      return 8;
    }
  }

  public static class UserPointSymbol extends DisposedStruct {
    public int cols; // Number of columns in the symbol.
    public int rows; // Number of rows in the symbol.

    private void init() {

    }

    public UserPointSymbol() {
      super(12);
      init();
    }

    public UserPointSymbol(int cols, int rows) {
      super(12);
      this.cols = cols;
      this.rows = rows;
    }

    protected UserPointSymbol(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected UserPointSymbol(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      cols = backing.getInt(0);
      rows = backing.getInt(4);
    }

    public void write() {
      backing.putInt(0, cols);
      backing.putInt(4, rows);
    }

    public int size() {
      return 12;
    }
  }

  public static class View3DOptions extends DisposedStruct {
    public int sizeReduction; // A divisor the function uses when determining
                              // the final height and width of the 3D image.
    public int maxHeight; // Defines the maximum height of a pixel from the
                          // image source drawn in 3D.
    public Direction3D direction; // Defines the 3D orientation.
    public float alpha; // Determines the angle between the horizontal and the
                        // baseline.
    public float beta; // Determines the angle between the horizontal and the
                       // second baseline.
    public int border; // Defines the border size.
    public int background; // Defines the background color.
    public Plane3D plane; // Indicates the view a function uses to show complex
                          // images.

    private void init() {

    }

    public View3DOptions() {
      super(32);
      init();
    }

    public View3DOptions(int sizeReduction, int maxHeight, Direction3D direction, double alpha,
        double beta, int border, int background, Plane3D plane) {
      super(32);
      this.sizeReduction = sizeReduction;
      this.maxHeight = maxHeight;
      this.direction = direction;
      this.alpha = (float) alpha;
      this.beta = (float) beta;
      this.border = border;
      this.background = background;
      this.plane = plane;
    }

    protected View3DOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected View3DOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      sizeReduction = backing.getInt(0);
      maxHeight = backing.getInt(4);
      direction = Direction3D.fromValue(backing.getInt(8));
      alpha = backing.getFloat(12);
      beta = backing.getFloat(16);
      border = backing.getInt(20);
      background = backing.getInt(24);
      plane = Plane3D.fromValue(backing.getInt(28));
    }

    public void write() {
      backing.putInt(0, sizeReduction);
      backing.putInt(4, maxHeight);
      if (direction != null)
        backing.putInt(8, direction.getValue());
      backing.putFloat(12, alpha);
      backing.putFloat(16, beta);
      backing.putInt(20, border);
      backing.putInt(24, background);
      if (plane != null)
        backing.putInt(28, plane.getValue());
    }

    public int size() {
      return 32;
    }
  }

  public static class MatchPatternOptions extends DisposedStruct {
    public MatchingMode mode; // Specifies the method to use when looking for
                              // the pattern in the image.
    public int minContrast; // Specifies the minimum contrast expected in the
                            // image.
    public int subpixelAccuracy; // Set this element to TRUE to return areas in
                                 // the image that match the pattern area with
                                 // subpixel accuracy.
    public RotationAngleRange[] angleRanges; // An array of angle ranges, in
                                             // degrees, where each range
                                             // specifies how much you expect
                                             // the pattern to be rotated in the
                                             // image.
    public int numMatchesRequested; // Number of valid matches expected.
    public int matchFactor; // Controls the number of potential matches that the
                            // function examines.
    public float minMatchScore; // The minimum score a match can have for the
                                // function to consider the match valid.
    private ByteBuffer angleRanges_buf;

    private void init() {
      angleRanges = new RotationAngleRange[0];
    }

    public MatchPatternOptions() {
      super(32);
      init();
    }

    public MatchPatternOptions(MatchingMode mode, int minContrast, int subpixelAccuracy,
        RotationAngleRange[] angleRanges, int numMatchesRequested, int matchFactor,
        double minMatchScore) {
      super(32);
      this.mode = mode;
      this.minContrast = minContrast;
      this.subpixelAccuracy = subpixelAccuracy;
      this.angleRanges = angleRanges;
      this.numMatchesRequested = numMatchesRequested;
      this.matchFactor = matchFactor;
      this.minMatchScore = (float) minMatchScore;
    }

    protected MatchPatternOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected MatchPatternOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      mode = MatchingMode.fromValue(backing.getInt(0));
      minContrast = backing.getInt(4);
      subpixelAccuracy = backing.getInt(8);
      int angleRanges_numRanges = backing.getInt(16);
      long angleRanges_addr = getPointer(backing, 12);
      angleRanges = new RotationAngleRange[angleRanges_numRanges];
      if (angleRanges_numRanges > 0 && angleRanges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(angleRanges_addr, angleRanges_numRanges * 8);
        for (int i = 0, off = 0; i < angleRanges_numRanges; i++, off += 8) {
          angleRanges[i] = new RotationAngleRange(bb, off);
          angleRanges[i].read();
        }
      }
      numMatchesRequested = backing.getInt(20);
      matchFactor = backing.getInt(24);
      minMatchScore = backing.getFloat(28);
    }

    public void write() {
      if (mode != null)
        backing.putInt(0, mode.getValue());
      backing.putInt(4, minContrast);
      backing.putInt(8, subpixelAccuracy);
      angleRanges_buf =
          ByteBuffer.allocateDirect(angleRanges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < angleRanges.length; i++, off += 8) {
        angleRanges[i].setBuffer(angleRanges_buf, off);
        angleRanges[i].write();
      }
      backing.putInt(16, angleRanges.length);
      putPointer(backing, 12, angleRanges_buf);
      backing.putInt(20, numMatchesRequested);
      backing.putInt(24, matchFactor);
      backing.putFloat(28, minMatchScore);
    }

    public int size() {
      return 32;
    }
  }

  public static class TIFFFileOptions extends DisposedStruct {
    public int rowsPerStrip; // Indicates the number of rows that the function
                             // writes per strip.
    public PhotometricMode photoInterp; // Designates which photometric
                                        // interpretation to use.
    public TIFFCompressionType compressionType; // Indicates the type of
                                                // compression to use on the
                                                // TIFF file.

    private void init() {

    }

    public TIFFFileOptions() {
      super(12);
      init();
    }

    public TIFFFileOptions(int rowsPerStrip, PhotometricMode photoInterp,
        TIFFCompressionType compressionType) {
      super(12);
      this.rowsPerStrip = rowsPerStrip;
      this.photoInterp = photoInterp;
      this.compressionType = compressionType;
    }

    protected TIFFFileOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected TIFFFileOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      rowsPerStrip = backing.getInt(0);
      photoInterp = PhotometricMode.fromValue(backing.getInt(4));
      compressionType = TIFFCompressionType.fromValue(backing.getInt(8));
    }

    public void write() {
      backing.putInt(0, rowsPerStrip);
      if (photoInterp != null)
        backing.putInt(4, photoInterp.getValue());
      if (compressionType != null)
        backing.putInt(8, compressionType.getValue());
    }

    public int size() {
      return 12;
    }
  }

  public static class OpenContour extends DisposedStruct {
    public Point[] points; // The points that make up the open contour.
    private ByteBuffer points_buf;

    private void init() {
      points = new Point[0];
    }

    public OpenContour() {
      super(8);
      init();
    }

    public OpenContour(Point[] points) {
      super(8);
      this.points = points;
    }

    protected OpenContour(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected OpenContour(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      int points_numPoints = backing.getInt(4);
      long points_addr = getPointer(backing, 0);
      points = new Point[points_numPoints];
      if (points_numPoints > 0 && points_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(points_addr, points_numPoints * 8);
        for (int i = 0, off = 0; i < points_numPoints; i++, off += 8) {
          points[i] = new Point(bb, off);
          points[i].read();
        }
      }
    }

    public void write() {
      points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < points.length; i++, off += 8) {
        points[i].setBuffer(points_buf, off);
        points[i].write();
      }
      backing.putInt(4, points.length);
      putPointer(backing, 0, points_buf);
    }

    public int size() {
      return 8;
    }
  }

  public static class OverlayTextOptions extends DisposedStruct {
    public String fontName; // The name of the font to use.
    public int fontSize; // The size of the font.
    public int bold; // Set this element to TRUE to bold the text.
    public int italic; // Set this element to TRUE to italicize the text.
    public int underline; // Set this element to TRUE to underline the text.
    public int strikeout; // Set this element to TRUE to strikeout the text.
    public TextAlignment horizontalTextAlignment; // Sets the alignment of the
                                                  // text.
    public VerticalTextAlignment verticalTextAlignment; // Sets the vertical
                                                        // alignment for the
                                                        // text.
    public RGBValue backgroundColor; // Sets the color for the text background
                                     // pixels.
    public double angle; // The counterclockwise angle, in degrees, of the text
                         // relative to the x-axis.
    private ByteBuffer fontName_buf;

    private void init() {
      backgroundColor = new RGBValue(backing, 32);
    }

    public OverlayTextOptions() {
      super(48);
      init();
    }

    public OverlayTextOptions(String fontName, int fontSize, int bold, int italic, int underline,
        int strikeout, TextAlignment horizontalTextAlignment,
        VerticalTextAlignment verticalTextAlignment, RGBValue backgroundColor, double angle) {
      super(48);
      this.fontName = fontName;
      this.fontSize = fontSize;
      this.bold = bold;
      this.italic = italic;
      this.underline = underline;
      this.strikeout = strikeout;
      this.horizontalTextAlignment = horizontalTextAlignment;
      this.verticalTextAlignment = verticalTextAlignment;
      this.backgroundColor = backgroundColor;
      this.angle = angle;
    }

    protected OverlayTextOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 48);
      init();
    }

    protected OverlayTextOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 48);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 48);
    }

    public void read() {
      long fontName_addr = getPointer(backing, 0);
      if (fontName_addr == 0)
        fontName = null;
      else {
        ByteBuffer bb = newDirectByteBuffer(fontName_addr, 1000); // FIXME
        while (bb.get() != 0) {
        }
        byte[] bytes = new byte[bb.position() - 1];
        getBytes(bb, bytes, 0, bytes.length);
        try {
          fontName = new String(bytes, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          fontName = "";
        }
      }

      fontSize = backing.getInt(4);
      bold = backing.getInt(8);
      italic = backing.getInt(12);
      underline = backing.getInt(16);
      strikeout = backing.getInt(20);
      horizontalTextAlignment = TextAlignment.fromValue(backing.getInt(24));
      verticalTextAlignment = VerticalTextAlignment.fromValue(backing.getInt(28));
      backgroundColor.read();
      angle = backing.getDouble(40);
    }

    public void write() {
      if (fontName != null) {
        byte[] fontName_bytes;
        try {
          fontName_bytes = fontName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          fontName_bytes = new byte[0];
        }
        fontName_buf = ByteBuffer.allocateDirect(fontName_bytes.length + 1);
        putBytes(fontName_buf, fontName_bytes, 0, fontName_bytes.length).put(fontName_bytes.length,
            (byte) 0);
      }
      putPointer(backing, 0, fontName == null ? 0 : getByteBufferAddress(fontName_buf));
      backing.putInt(4, fontSize);
      backing.putInt(8, bold);
      backing.putInt(12, italic);
      backing.putInt(16, underline);
      backing.putInt(20, strikeout);
      if (horizontalTextAlignment != null)
        backing.putInt(24, horizontalTextAlignment.getValue());
      if (verticalTextAlignment != null)
        backing.putInt(28, verticalTextAlignment.getValue());
      backgroundColor.write();
      backing.putDouble(40, angle);
    }

    public int size() {
      return 48;
    }
  }

  public static class ParticleFilterCriteria extends DisposedStruct {
    public MeasurementValue parameter; // The morphological measurement that the
                                       // function uses for filtering.
    public float lower; // The lower bound of the criteria range.
    public float upper; // The upper bound of the criteria range.
    public int exclude; // Set this element to TRUE to indicate that a match
                        // occurs when the value is outside the criteria range.

    private void init() {

    }

    public ParticleFilterCriteria() {
      super(16);
      init();
    }

    public ParticleFilterCriteria(MeasurementValue parameter, double lower, double upper,
        int exclude) {
      super(16);
      this.parameter = parameter;
      this.lower = (float) lower;
      this.upper = (float) upper;
      this.exclude = exclude;
    }

    protected ParticleFilterCriteria(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ParticleFilterCriteria(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      parameter = MeasurementValue.fromValue(backing.getInt(0));
      lower = backing.getFloat(4);
      upper = backing.getFloat(8);
      exclude = backing.getInt(12);
    }

    public void write() {
      if (parameter != null)
        backing.putInt(0, parameter.getValue());
      backing.putFloat(4, lower);
      backing.putFloat(8, upper);
      backing.putInt(12, exclude);
    }

    public int size() {
      return 16;
    }
  }

  public static class ParticleReport extends DisposedStruct {
    public int area; // The number of pixels in the particle.
    public float calibratedArea; // The size of the particle, calibrated to the
                                 // calibration information of the image.
    public float perimeter; // The length of the perimeter, calibrated to the
                            // calibration information of the image.
    public int numHoles; // The number of holes in the particle.
    public int areaOfHoles; // The total surface area, in pixels, of all the
                            // holes in a particle.
    public float perimeterOfHoles; // The length of the perimeter of all the
                                   // holes in the particle calibrated to the
                                   // calibration information of the image.
    public Rect boundingBox; // The smallest rectangle that encloses the
                             // particle.
    public float sigmaX; // The sum of the particle pixels on the x-axis.
    public float sigmaY; // The sum of the particle pixels on the y-axis.
    public float sigmaXX; // The sum of the particle pixels on the x-axis,
                          // squared.
    public float sigmaYY; // The sum of the particle pixels on the y-axis,
                          // squared.
    public float sigmaXY; // The sum of the particle pixels on the x-axis and
                          // y-axis.
    public int longestLength; // The length of the longest horizontal line
                              // segment.
    public Point longestPoint; // The location of the leftmost pixel of the
                               // longest segment in the particle.
    public int projectionX; // The length of the particle when projected onto
                            // the x-axis.
    public int projectionY; // The length of the particle when projected onto
                            // the y-axis.
    public int connect8; // This element is TRUE if the function used
                         // connectivity-8 to determine if particles are
                         // touching.

    private void init() {
      boundingBox = new Rect(backing, 24);
      longestPoint = new Point(backing, 64);
    }

    public ParticleReport() {
      super(84);
      init();
    }

    public ParticleReport(int area, double calibratedArea, double perimeter, int numHoles,
        int areaOfHoles, double perimeterOfHoles, Rect boundingBox, double sigmaX, double sigmaY,
        double sigmaXX, double sigmaYY, double sigmaXY, int longestLength, Point longestPoint,
        int projectionX, int projectionY, int connect8) {
      super(84);
      this.area = area;
      this.calibratedArea = (float) calibratedArea;
      this.perimeter = (float) perimeter;
      this.numHoles = numHoles;
      this.areaOfHoles = areaOfHoles;
      this.perimeterOfHoles = (float) perimeterOfHoles;
      this.boundingBox = boundingBox;
      this.sigmaX = (float) sigmaX;
      this.sigmaY = (float) sigmaY;
      this.sigmaXX = (float) sigmaXX;
      this.sigmaYY = (float) sigmaYY;
      this.sigmaXY = (float) sigmaXY;
      this.longestLength = longestLength;
      this.longestPoint = longestPoint;
      this.projectionX = projectionX;
      this.projectionY = projectionY;
      this.connect8 = connect8;
    }

    protected ParticleReport(ByteBuffer backing, int offset) {
      super(backing, offset, 84);
      init();
    }

    protected ParticleReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 84);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 84);
    }

    public void read() {
      area = backing.getInt(0);
      calibratedArea = backing.getFloat(4);
      perimeter = backing.getFloat(8);
      numHoles = backing.getInt(12);
      areaOfHoles = backing.getInt(16);
      perimeterOfHoles = backing.getFloat(20);
      boundingBox.read();
      sigmaX = backing.getFloat(40);
      sigmaY = backing.getFloat(44);
      sigmaXX = backing.getFloat(48);
      sigmaYY = backing.getFloat(52);
      sigmaXY = backing.getFloat(56);
      longestLength = backing.getInt(60);
      longestPoint.read();
      projectionX = backing.getInt(72);
      projectionY = backing.getInt(76);
      connect8 = backing.getInt(80);
    }

    public void write() {
      backing.putInt(0, area);
      backing.putFloat(4, calibratedArea);
      backing.putFloat(8, perimeter);
      backing.putInt(12, numHoles);
      backing.putInt(16, areaOfHoles);
      backing.putFloat(20, perimeterOfHoles);
      boundingBox.write();
      backing.putFloat(40, sigmaX);
      backing.putFloat(44, sigmaY);
      backing.putFloat(48, sigmaXX);
      backing.putFloat(52, sigmaYY);
      backing.putFloat(56, sigmaXY);
      backing.putInt(60, longestLength);
      longestPoint.write();
      backing.putInt(72, projectionX);
      backing.putInt(76, projectionY);
      backing.putInt(80, connect8);
    }

    public int size() {
      return 84;
    }
  }

  public static class PatternMatch extends DisposedStruct {
    public PointFloat position; // The location of the center of the match.
    public float rotation; // The rotation of the match relative to the template
                           // image, in degrees.
    public float scale; // The size of the match relative to the size of the
                        // template image, expressed as a percentage.
    public float score; // The accuracy of the match.
    public PointFloat[] corner; // An array of four points describing the
                                // rectangle surrounding the template image.

    private void init() {
      position = new PointFloat(backing, 0);
      corner = new PointFloat[4];

      for (int i = 0, off = 20; i < 4; i++, off += 8)
        corner[i] = new PointFloat(backing, off);
    }

    public PatternMatch() {
      super(52);
      init();
    }

    public PatternMatch(PointFloat position, double rotation, double scale, double score,
        PointFloat[] corner) {
      super(52);
      this.position = position;
      this.rotation = (float) rotation;
      this.scale = (float) scale;
      this.score = (float) score;
      this.corner = corner;
    }

    protected PatternMatch(ByteBuffer backing, int offset) {
      super(backing, offset, 52);
      init();
    }

    protected PatternMatch(long nativeObj, boolean owned) {
      super(nativeObj, owned, 52);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 52);
    }

    public void read() {
      position.read();
      rotation = backing.getFloat(8);
      scale = backing.getFloat(12);
      score = backing.getFloat(16);
      for (PointFloat it : corner) {
        it.read();
      }
    }

    public void write() {
      position.write();
      backing.putFloat(8, rotation);
      backing.putFloat(12, scale);
      backing.putFloat(16, score);
      for (PointFloat it : corner) {
        it.write();
      }
    }

    public int size() {
      return 52;
    }
  }

  public static class QuantifyData extends DisposedStruct {
    public float mean; // The mean value of the pixel values.
    public float stdDev; // The standard deviation of the pixel values.
    public float min; // The smallest pixel value.
    public float max; // The largest pixel value.
    public float calibratedArea; // The area, calibrated to the calibration
                                 // information of the image.
    public int pixelArea; // The area, in number of pixels.
    public float relativeSize; // The proportion, expressed as a percentage, of
                               // the associated region relative to the whole
                               // image.

    private void init() {

    }

    public QuantifyData() {
      super(28);
      init();
    }

    public QuantifyData(double mean, double stdDev, double min, double max, double calibratedArea,
        int pixelArea, double relativeSize) {
      super(28);
      this.mean = (float) mean;
      this.stdDev = (float) stdDev;
      this.min = (float) min;
      this.max = (float) max;
      this.calibratedArea = (float) calibratedArea;
      this.pixelArea = pixelArea;
      this.relativeSize = (float) relativeSize;
    }

    protected QuantifyData(ByteBuffer backing, int offset) {
      super(backing, offset, 28);
      init();
    }

    protected QuantifyData(long nativeObj, boolean owned) {
      super(nativeObj, owned, 28);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 28);
    }

    public void read() {
      mean = backing.getFloat(0);
      stdDev = backing.getFloat(4);
      min = backing.getFloat(8);
      max = backing.getFloat(12);
      calibratedArea = backing.getFloat(16);
      pixelArea = backing.getInt(20);
      relativeSize = backing.getFloat(24);
    }

    public void write() {
      backing.putFloat(0, mean);
      backing.putFloat(4, stdDev);
      backing.putFloat(8, min);
      backing.putFloat(12, max);
      backing.putFloat(16, calibratedArea);
      backing.putInt(20, pixelArea);
      backing.putFloat(24, relativeSize);
    }

    public int size() {
      return 28;
    }
  }

  public static class QuantifyReport extends DisposedStruct {
    public QuantifyData global; // Statistical data of the whole image.
    public QuantifyData[] regions; // An array of QuantifyData structures
                                   // containing statistical data of each region
                                   // of the image.
    private ByteBuffer regions_buf;

    private void init() {
      global = new QuantifyData(backing, 0);
      regions = new QuantifyData[0];
    }

    public QuantifyReport() {
      super(36);
      init();
    }

    public QuantifyReport(QuantifyData global, QuantifyData[] regions) {
      super(36);
      this.global = global;
      this.regions = regions;
    }

    protected QuantifyReport(ByteBuffer backing, int offset) {
      super(backing, offset, 36);
      init();
    }

    protected QuantifyReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 36);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 36);
    }

    public void read() {
      global.read();
      int regions_regionCount = backing.getInt(32);
      long regions_addr = getPointer(backing, 28);
      regions = new QuantifyData[regions_regionCount];
      if (regions_regionCount > 0 && regions_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(regions_addr, regions_regionCount * 28);
        for (int i = 0, off = 0; i < regions_regionCount; i++, off += 28) {
          regions[i] = new QuantifyData(bb, off);
          regions[i].read();
        }
      }
    }

    public void write() {
      global.write();
      regions_buf = ByteBuffer.allocateDirect(regions.length * 28).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < regions.length; i++, off += 28) {
        regions[i].setBuffer(regions_buf, off);
        regions[i].write();
      }
      backing.putInt(32, regions.length);
      putPointer(backing, 28, regions_buf);
    }

    public int size() {
      return 36;
    }
  }

  public static class RakeOptions extends DisposedStruct {
    public int threshold; // Specifies the threshold value for the contrast of
                          // the edge.
    public int width; // The number of pixels that the function averages to find
                      // the contrast at either side of the edge.
    public int steepness; // The span, in pixels, of the slope of the edge
                          // projected along the path specified by the input
                          // points.
    public int subsamplingRatio; // Specifies the number of pixels that separate
                                 // two consecutive search lines.
    public InterpolationMethod subpixelType; // The method for interpolating.
    public int subpixelDivisions; // The number of samples the function obtains
                                  // from a pixel.

    private void init() {

    }

    public RakeOptions() {
      super(24);
      init();
    }

    public RakeOptions(int threshold, int width, int steepness, int subsamplingRatio,
        InterpolationMethod subpixelType, int subpixelDivisions) {
      super(24);
      this.threshold = threshold;
      this.width = width;
      this.steepness = steepness;
      this.subsamplingRatio = subsamplingRatio;
      this.subpixelType = subpixelType;
      this.subpixelDivisions = subpixelDivisions;
    }

    protected RakeOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected RakeOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      threshold = backing.getInt(0);
      width = backing.getInt(4);
      steepness = backing.getInt(8);
      subsamplingRatio = backing.getInt(12);
      subpixelType = InterpolationMethod.fromValue(backing.getInt(16));
      subpixelDivisions = backing.getInt(20);
    }

    public void write() {
      backing.putInt(0, threshold);
      backing.putInt(4, width);
      backing.putInt(8, steepness);
      backing.putInt(12, subsamplingRatio);
      if (subpixelType != null)
        backing.putInt(16, subpixelType.getValue());
      backing.putInt(20, subpixelDivisions);
    }

    public int size() {
      return 24;
    }
  }

  public static class RakeReport extends DisposedStruct {
    public LineFloat[] rakeLines; // The coordinate location of each of the rake
                                  // lines used by the function.
    public PointFloat[] firstEdges; // The coordinate location of all edges
                                    // detected as first edges.
    public PointFloat[] lastEdges; // The coordinate location of all edges
                                   // detected as last edges.
    public EdgeLocationReport[] allEdges; // An array of reports describing the
                                          // location of the edges located by
                                          // each rake line.
    public int[] linesWithEdges; // An array of indices into the rakeLines array
                                 // indicating the rake lines on which the
                                 // function detected at least one edge.
    private ByteBuffer rakeLines_buf;
    private ByteBuffer firstEdges_buf;
    private ByteBuffer lastEdges_buf;
    private ByteBuffer allEdges_buf;
    private ByteBuffer linesWithEdges_buf;

    private void init() {
      rakeLines = new LineFloat[0];
      firstEdges = new PointFloat[0];
      lastEdges = new PointFloat[0];
      allEdges = new EdgeLocationReport[0];
      linesWithEdges = new int[0];
    }

    public RakeReport() {
      super(36);
      init();
    }

    public RakeReport(LineFloat[] rakeLines, PointFloat[] firstEdges, PointFloat[] lastEdges,
        EdgeLocationReport[] allEdges, int[] linesWithEdges) {
      super(36);
      this.rakeLines = rakeLines;
      this.firstEdges = firstEdges;
      this.lastEdges = lastEdges;
      this.allEdges = allEdges;
      this.linesWithEdges = linesWithEdges;
    }

    protected RakeReport(ByteBuffer backing, int offset) {
      super(backing, offset, 36);
      init();
    }

    protected RakeReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 36);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 36);
    }

    public void read() {
      int rakeLines_numRakeLines = backing.getInt(4);
      long rakeLines_addr = getPointer(backing, 0);
      rakeLines = new LineFloat[rakeLines_numRakeLines];
      if (rakeLines_numRakeLines > 0 && rakeLines_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(rakeLines_addr, rakeLines_numRakeLines * 16);
        for (int i = 0, off = 0; i < rakeLines_numRakeLines; i++, off += 16) {
          rakeLines[i] = new LineFloat(bb, off);
          rakeLines[i].read();
        }
      }
      int firstEdges_numFirstEdges = backing.getInt(12);
      long firstEdges_addr = getPointer(backing, 8);
      firstEdges = new PointFloat[firstEdges_numFirstEdges];
      if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges * 8);
        for (int i = 0, off = 0; i < firstEdges_numFirstEdges; i++, off += 8) {
          firstEdges[i] = new PointFloat(bb, off);
          firstEdges[i].read();
        }
      }
      int lastEdges_numLastEdges = backing.getInt(20);
      long lastEdges_addr = getPointer(backing, 16);
      lastEdges = new PointFloat[lastEdges_numLastEdges];
      if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges * 8);
        for (int i = 0, off = 0; i < lastEdges_numLastEdges; i++, off += 8) {
          lastEdges[i] = new PointFloat(bb, off);
          lastEdges[i].read();
        }
      }
      int allEdges_numLinesWithEdges = backing.getInt(32);
      long allEdges_addr = getPointer(backing, 24);
      allEdges = new EdgeLocationReport[allEdges_numLinesWithEdges];
      if (allEdges_numLinesWithEdges > 0 && allEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(allEdges_addr, allEdges_numLinesWithEdges * 8);
        for (int i = 0, off = 0; i < allEdges_numLinesWithEdges; i++, off += 8) {
          allEdges[i] = new EdgeLocationReport(bb, off);
          allEdges[i].read();
        }
      }
      int linesWithEdges_numLinesWithEdges = backing.getInt(32);
      long linesWithEdges_addr = getPointer(backing, 28);
      linesWithEdges = new int[linesWithEdges_numLinesWithEdges];
      if (linesWithEdges_numLinesWithEdges > 0 && linesWithEdges_addr != 0) {
        newDirectByteBuffer(linesWithEdges_addr, linesWithEdges_numLinesWithEdges * 4)
            .asIntBuffer().get(linesWithEdges);
      }
    }

    public void write() {
      rakeLines_buf =
          ByteBuffer.allocateDirect(rakeLines.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < rakeLines.length; i++, off += 16) {
        rakeLines[i].setBuffer(rakeLines_buf, off);
        rakeLines[i].write();
      }
      backing.putInt(4, rakeLines.length);
      putPointer(backing, 0, rakeLines_buf);
      firstEdges_buf =
          ByteBuffer.allocateDirect(firstEdges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < firstEdges.length; i++, off += 8) {
        firstEdges[i].setBuffer(firstEdges_buf, off);
        firstEdges[i].write();
      }
      backing.putInt(12, firstEdges.length);
      putPointer(backing, 8, firstEdges_buf);
      lastEdges_buf =
          ByteBuffer.allocateDirect(lastEdges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < lastEdges.length; i++, off += 8) {
        lastEdges[i].setBuffer(lastEdges_buf, off);
        lastEdges[i].write();
      }
      backing.putInt(20, lastEdges.length);
      putPointer(backing, 16, lastEdges_buf);
      allEdges_buf = ByteBuffer.allocateDirect(allEdges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < allEdges.length; i++, off += 8) {
        allEdges[i].setBuffer(allEdges_buf, off);
        allEdges[i].write();
      }
      backing.putInt(32, allEdges.length);
      putPointer(backing, 24, allEdges_buf);
      linesWithEdges_buf =
          ByteBuffer.allocateDirect(linesWithEdges.length * 4).order(ByteOrder.nativeOrder());
      linesWithEdges_buf.asIntBuffer().put(linesWithEdges).rewind();
      backing.putInt(32, linesWithEdges.length);
      putPointer(backing, 28, linesWithEdges_buf);
    }

    public int size() {
      return 36;
    }
  }

  public static class TransformReport extends DisposedStruct {
    public PointFloat[] points; // An array of transformed coordinates.
    public int[] validPoints; // An array of values that describe the validity
                              // of each of the coordinates according to the
                              // region of interest you calibrated using either
                              // imaqLearnCalibrationGrid() or
                              // imaqLearnCalibrationPoints().
    private ByteBuffer points_buf;
    private ByteBuffer validPoints_buf;

    private void init() {
      points = new PointFloat[0];
      validPoints = new int[0];
    }

    public TransformReport() {
      super(12);
      init();
    }

    public TransformReport(PointFloat[] points, int[] validPoints) {
      super(12);
      this.points = points;
      this.validPoints = validPoints;
    }

    protected TransformReport(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected TransformReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      int points_numPoints = backing.getInt(8);
      long points_addr = getPointer(backing, 0);
      points = new PointFloat[points_numPoints];
      if (points_numPoints > 0 && points_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(points_addr, points_numPoints * 8);
        for (int i = 0, off = 0; i < points_numPoints; i++, off += 8) {
          points[i] = new PointFloat(bb, off);
          points[i].read();
        }
      }
      int validPoints_numPoints = backing.getInt(8);
      long validPoints_addr = getPointer(backing, 4);
      validPoints = new int[validPoints_numPoints];
      if (validPoints_numPoints > 0 && validPoints_addr != 0) {
        newDirectByteBuffer(validPoints_addr, validPoints_numPoints * 4).asIntBuffer().get(
            validPoints);
      }
    }

    public void write() {
      points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < points.length; i++, off += 8) {
        points[i].setBuffer(points_buf, off);
        points[i].write();
      }
      backing.putInt(8, points.length);
      putPointer(backing, 0, points_buf);
      validPoints_buf =
          ByteBuffer.allocateDirect(validPoints.length * 4).order(ByteOrder.nativeOrder());
      validPoints_buf.asIntBuffer().put(validPoints).rewind();
      backing.putInt(8, validPoints.length);
      putPointer(backing, 4, validPoints_buf);
    }

    public int size() {
      return 12;
    }
  }

  public static class ShapeReport extends DisposedStruct {
    public Rect coordinates; // The bounding rectangle of the object.
    public Point centroid; // The coordinate location of the centroid of the
                           // object.
    public int size; // The size, in pixels, of the object.
    public double score; // A value ranging between 1 and 1,000 that specifies
                         // how similar the object in the image is to the
                         // template.

    private void init() {
      coordinates = new Rect(backing, 0);
      centroid = new Point(backing, 16);
    }

    public ShapeReport() {
      super(40);
      init();
    }

    public ShapeReport(Rect coordinates, Point centroid, int size, double score) {
      super(40);
      this.coordinates = coordinates;
      this.centroid = centroid;
      this.size = size;
      this.score = score;
    }

    protected ShapeReport(ByteBuffer backing, int offset) {
      super(backing, offset, 40);
      init();
    }

    protected ShapeReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 40);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 40);
    }

    public void read() {
      coordinates.read();
      centroid.read();
      size = backing.getInt(24);
      score = backing.getDouble(32);
    }

    public void write() {
      coordinates.write();
      centroid.write();
      backing.putInt(24, size);
      backing.putDouble(32, score);
    }

    public int size() {
      return 40;
    }
  }

  public static class MeterArc extends DisposedStruct {
    public PointFloat needleBase; // The coordinate location of the base of the
                                  // meter needle.
    public PointFloat[] arcCoordPoints; // An array of points describing the
                                        // coordinate location of the meter arc.
    public int needleColor; // This element is TRUE when the meter has a
                            // light-colored needle on a dark background.
    private ByteBuffer arcCoordPoints_buf;

    private void init() {
      needleBase = new PointFloat(backing, 0);
      arcCoordPoints = new PointFloat[0];
    }

    public MeterArc() {
      super(20);
      init();
    }

    public MeterArc(PointFloat needleBase, PointFloat[] arcCoordPoints, int needleColor) {
      super(20);
      this.needleBase = needleBase;
      this.arcCoordPoints = arcCoordPoints;
      this.needleColor = needleColor;
    }

    protected MeterArc(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected MeterArc(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      needleBase.read();
      int arcCoordPoints_numOfArcCoordPoints = backing.getInt(12);
      long arcCoordPoints_addr = getPointer(backing, 8);
      arcCoordPoints = new PointFloat[arcCoordPoints_numOfArcCoordPoints];
      if (arcCoordPoints_numOfArcCoordPoints > 0 && arcCoordPoints_addr != 0) {
        ByteBuffer bb =
            newDirectByteBuffer(arcCoordPoints_addr, arcCoordPoints_numOfArcCoordPoints * 8);
        for (int i = 0, off = 0; i < arcCoordPoints_numOfArcCoordPoints; i++, off += 8) {
          arcCoordPoints[i] = new PointFloat(bb, off);
          arcCoordPoints[i].read();
        }
      }
      needleColor = backing.getInt(16);
    }

    public void write() {
      needleBase.write();
      arcCoordPoints_buf =
          ByteBuffer.allocateDirect(arcCoordPoints.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < arcCoordPoints.length; i++, off += 8) {
        arcCoordPoints[i].setBuffer(arcCoordPoints_buf, off);
        arcCoordPoints[i].write();
      }
      backing.putInt(12, arcCoordPoints.length);
      putPointer(backing, 8, arcCoordPoints_buf);
      backing.putInt(16, needleColor);
    }

    public int size() {
      return 20;
    }
  }

  public static class ThresholdData extends DisposedStruct {
    public float rangeMin; // The lower boundary of the range to keep.
    public float rangeMax; // The upper boundary of the range to keep.
    public float newValue; // If useNewValue is TRUE, newValue is the
                           // replacement value for pixels within the range.
    public int useNewValue; // If TRUE, the function sets pixel values within
                            // [rangeMin, rangeMax] to the value specified in
                            // newValue.

    private void init() {

    }

    public ThresholdData() {
      super(16);
      init();
    }

    public ThresholdData(double rangeMin, double rangeMax, double newValue, int useNewValue) {
      super(16);
      this.rangeMin = (float) rangeMin;
      this.rangeMax = (float) rangeMax;
      this.newValue = (float) newValue;
      this.useNewValue = useNewValue;
    }

    protected ThresholdData(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected ThresholdData(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      rangeMin = backing.getFloat(0);
      rangeMax = backing.getFloat(4);
      newValue = backing.getFloat(8);
      useNewValue = backing.getInt(12);
    }

    public void write() {
      backing.putFloat(0, rangeMin);
      backing.putFloat(4, rangeMax);
      backing.putFloat(8, newValue);
      backing.putInt(12, useNewValue);
    }

    public int size() {
      return 16;
    }
  }

  public static class StructuringElement extends DisposedStruct {
    public int matrixCols; // Number of columns in the matrix.
    public int matrixRows; // Number of rows in the matrix.
    public int hexa; // Set this element to TRUE if you specify a hexagonal
                     // structuring element in kernel.

    private void init() {

    }

    public StructuringElement() {
      super(16);
      init();
    }

    public StructuringElement(int matrixCols, int matrixRows, int hexa) {
      super(16);
      this.matrixCols = matrixCols;
      this.matrixRows = matrixRows;
      this.hexa = hexa;
    }

    protected StructuringElement(ByteBuffer backing, int offset) {
      super(backing, offset, 16);
      init();
    }

    protected StructuringElement(long nativeObj, boolean owned) {
      super(nativeObj, owned, 16);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 16);
    }

    public void read() {
      matrixCols = backing.getInt(0);
      matrixRows = backing.getInt(4);
      hexa = backing.getInt(8);
    }

    public void write() {
      backing.putInt(0, matrixCols);
      backing.putInt(4, matrixRows);
      backing.putInt(8, hexa);
    }

    public int size() {
      return 16;
    }
  }

  public static class SpokeReport extends DisposedStruct {
    public LineFloat[] spokeLines; // The coordinate location of each of the
                                   // spoke lines used by the function.
    public PointFloat[] firstEdges; // The coordinate location of all edges
                                    // detected as first edges.
    public PointFloat[] lastEdges; // The coordinate location of all edges
                                   // detected as last edges.
    public EdgeLocationReport[] allEdges; // An array of reports describing the
                                          // location of the edges located by
                                          // each spoke line.
    public int[] linesWithEdges; // An array of indices into the spokeLines
                                 // array indicating the rake lines on which the
                                 // function detected at least one edge.
    private ByteBuffer spokeLines_buf;
    private ByteBuffer firstEdges_buf;
    private ByteBuffer lastEdges_buf;
    private ByteBuffer allEdges_buf;
    private ByteBuffer linesWithEdges_buf;

    private void init() {
      spokeLines = new LineFloat[0];
      firstEdges = new PointFloat[0];
      lastEdges = new PointFloat[0];
      allEdges = new EdgeLocationReport[0];
      linesWithEdges = new int[0];
    }

    public SpokeReport() {
      super(36);
      init();
    }

    public SpokeReport(LineFloat[] spokeLines, PointFloat[] firstEdges, PointFloat[] lastEdges,
        EdgeLocationReport[] allEdges, int[] linesWithEdges) {
      super(36);
      this.spokeLines = spokeLines;
      this.firstEdges = firstEdges;
      this.lastEdges = lastEdges;
      this.allEdges = allEdges;
      this.linesWithEdges = linesWithEdges;
    }

    protected SpokeReport(ByteBuffer backing, int offset) {
      super(backing, offset, 36);
      init();
    }

    protected SpokeReport(long nativeObj, boolean owned) {
      super(nativeObj, owned, 36);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 36);
    }

    public void read() {
      int spokeLines_numSpokeLines = backing.getInt(4);
      long spokeLines_addr = getPointer(backing, 0);
      spokeLines = new LineFloat[spokeLines_numSpokeLines];
      if (spokeLines_numSpokeLines > 0 && spokeLines_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(spokeLines_addr, spokeLines_numSpokeLines * 16);
        for (int i = 0, off = 0; i < spokeLines_numSpokeLines; i++, off += 16) {
          spokeLines[i] = new LineFloat(bb, off);
          spokeLines[i].read();
        }
      }
      int firstEdges_numFirstEdges = backing.getInt(12);
      long firstEdges_addr = getPointer(backing, 8);
      firstEdges = new PointFloat[firstEdges_numFirstEdges];
      if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges * 8);
        for (int i = 0, off = 0; i < firstEdges_numFirstEdges; i++, off += 8) {
          firstEdges[i] = new PointFloat(bb, off);
          firstEdges[i].read();
        }
      }
      int lastEdges_numLastEdges = backing.getInt(20);
      long lastEdges_addr = getPointer(backing, 16);
      lastEdges = new PointFloat[lastEdges_numLastEdges];
      if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges * 8);
        for (int i = 0, off = 0; i < lastEdges_numLastEdges; i++, off += 8) {
          lastEdges[i] = new PointFloat(bb, off);
          lastEdges[i].read();
        }
      }
      int allEdges_numLinesWithEdges = backing.getInt(32);
      long allEdges_addr = getPointer(backing, 24);
      allEdges = new EdgeLocationReport[allEdges_numLinesWithEdges];
      if (allEdges_numLinesWithEdges > 0 && allEdges_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(allEdges_addr, allEdges_numLinesWithEdges * 8);
        for (int i = 0, off = 0; i < allEdges_numLinesWithEdges; i++, off += 8) {
          allEdges[i] = new EdgeLocationReport(bb, off);
          allEdges[i].read();
        }
      }
      int linesWithEdges_numLinesWithEdges = backing.getInt(32);
      long linesWithEdges_addr = getPointer(backing, 28);
      linesWithEdges = new int[linesWithEdges_numLinesWithEdges];
      if (linesWithEdges_numLinesWithEdges > 0 && linesWithEdges_addr != 0) {
        newDirectByteBuffer(linesWithEdges_addr, linesWithEdges_numLinesWithEdges * 4)
            .asIntBuffer().get(linesWithEdges);
      }
    }

    public void write() {
      spokeLines_buf =
          ByteBuffer.allocateDirect(spokeLines.length * 16).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < spokeLines.length; i++, off += 16) {
        spokeLines[i].setBuffer(spokeLines_buf, off);
        spokeLines[i].write();
      }
      backing.putInt(4, spokeLines.length);
      putPointer(backing, 0, spokeLines_buf);
      firstEdges_buf =
          ByteBuffer.allocateDirect(firstEdges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < firstEdges.length; i++, off += 8) {
        firstEdges[i].setBuffer(firstEdges_buf, off);
        firstEdges[i].write();
      }
      backing.putInt(12, firstEdges.length);
      putPointer(backing, 8, firstEdges_buf);
      lastEdges_buf =
          ByteBuffer.allocateDirect(lastEdges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < lastEdges.length; i++, off += 8) {
        lastEdges[i].setBuffer(lastEdges_buf, off);
        lastEdges[i].write();
      }
      backing.putInt(20, lastEdges.length);
      putPointer(backing, 16, lastEdges_buf);
      allEdges_buf = ByteBuffer.allocateDirect(allEdges.length * 8).order(ByteOrder.nativeOrder());
      for (int i = 0, off = 0; i < allEdges.length; i++, off += 8) {
        allEdges[i].setBuffer(allEdges_buf, off);
        allEdges[i].write();
      }
      backing.putInt(32, allEdges.length);
      putPointer(backing, 24, allEdges_buf);
      linesWithEdges_buf =
          ByteBuffer.allocateDirect(linesWithEdges.length * 4).order(ByteOrder.nativeOrder());
      linesWithEdges_buf.asIntBuffer().put(linesWithEdges).rewind();
      backing.putInt(32, linesWithEdges.length);
      putPointer(backing, 28, linesWithEdges_buf);
    }

    public int size() {
      return 36;
    }
  }

  public static class SimpleEdgeOptions extends DisposedStruct {
    public LevelType type; // Determines how the function evaluates the
                           // threshold and hysteresis values.
    public int threshold; // The pixel value at which an edge occurs.
    public int hysteresis; // A value that helps determine edges in noisy
                           // images.
    public EdgeProcess process; // Determines which edges the function looks
                                // for.
    public int subpixel; // Set this element to TRUE to find edges with subpixel
                         // accuracy by interpolating between points to find the
                         // crossing of the given threshold.

    private void init() {

    }

    public SimpleEdgeOptions() {
      super(20);
      init();
    }

    public SimpleEdgeOptions(LevelType type, int threshold, int hysteresis, EdgeProcess process,
        int subpixel) {
      super(20);
      this.type = type;
      this.threshold = threshold;
      this.hysteresis = hysteresis;
      this.process = process;
      this.subpixel = subpixel;
    }

    protected SimpleEdgeOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 20);
      init();
    }

    protected SimpleEdgeOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 20);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 20);
    }

    public void read() {
      type = LevelType.fromValue(backing.getInt(0));
      threshold = backing.getInt(4);
      hysteresis = backing.getInt(8);
      process = EdgeProcess.fromValue(backing.getInt(12));
      subpixel = backing.getInt(16);
    }

    public void write() {
      if (type != null)
        backing.putInt(0, type.getValue());
      backing.putInt(4, threshold);
      backing.putInt(8, hysteresis);
      if (process != null)
        backing.putInt(12, process.getValue());
      backing.putInt(16, subpixel);
    }

    public int size() {
      return 20;
    }
  }

  public static class SelectParticleCriteria extends DisposedStruct {
    public MeasurementValue parameter; // The morphological measurement that the
                                       // function uses for filtering.
    public float lower; // The lower boundary of the criteria range.
    public float upper; // The upper boundary of the criteria range.

    private void init() {

    }

    public SelectParticleCriteria() {
      super(12);
      init();
    }

    public SelectParticleCriteria(MeasurementValue parameter, double lower, double upper) {
      super(12);
      this.parameter = parameter;
      this.lower = (float) lower;
      this.upper = (float) upper;
    }

    protected SelectParticleCriteria(ByteBuffer backing, int offset) {
      super(backing, offset, 12);
      init();
    }

    protected SelectParticleCriteria(long nativeObj, boolean owned) {
      super(nativeObj, owned, 12);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 12);
    }

    public void read() {
      parameter = MeasurementValue.fromValue(backing.getInt(0));
      lower = backing.getFloat(4);
      upper = backing.getFloat(8);
    }

    public void write() {
      if (parameter != null)
        backing.putInt(0, parameter.getValue());
      backing.putFloat(4, lower);
      backing.putFloat(8, upper);
    }

    public int size() {
      return 12;
    }
  }

  public static class SegmentInfo extends DisposedStruct {
    public int numberOfPoints; // The number of points in the segment.
    public int isOpen; // If TRUE, the contour is open.
    public double weight; // The significance of the edge in terms of the gray
                          // values that constitute the edge.
    public ContourPoint points; // The points of the segment.

    private void init() {

    }

    public SegmentInfo() {
      super(24);
      init();
    }

    public SegmentInfo(int numberOfPoints, int isOpen, double weight, ContourPoint points) {
      super(24);
      this.numberOfPoints = numberOfPoints;
      this.isOpen = isOpen;
      this.weight = weight;
      this.points = points;
    }

    protected SegmentInfo(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected SegmentInfo(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      numberOfPoints = backing.getInt(0);
      isOpen = backing.getInt(4);
      weight = backing.getDouble(8);
      long points_addr = getPointer(backing, 16);
      if (points_addr == 0)
        points = null;
      else
        points = new ContourPoint(points_addr, false);
    }

    public void write() {
      backing.putInt(0, numberOfPoints);
      backing.putInt(4, isOpen);
      backing.putDouble(8, weight);
      putPointer(backing, 16, points);
    }

    public int size() {
      return 24;
    }
  }

  public static class RotationAngleRange extends DisposedStruct {
    public float lower; // The lowest amount of rotation, in degrees, a valid
                        // pattern can have.
    public float upper; // The highest amount of rotation, in degrees, a valid
                        // pattern can have.

    private void init() {

    }

    public RotationAngleRange() {
      super(8);
      init();
    }

    public RotationAngleRange(double lower, double upper) {
      super(8);
      this.lower = (float) lower;
      this.upper = (float) upper;
    }

    protected RotationAngleRange(ByteBuffer backing, int offset) {
      super(backing, offset, 8);
      init();
    }

    protected RotationAngleRange(long nativeObj, boolean owned) {
      super(nativeObj, owned, 8);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 8);
    }

    public void read() {
      lower = backing.getFloat(0);
      upper = backing.getFloat(4);
    }

    public void write() {
      backing.putFloat(0, lower);
      backing.putFloat(4, upper);
    }

    public int size() {
      return 8;
    }
  }

  public static class RotatedRect extends DisposedStruct {
    public int top; // Location of the top edge of the rectangle before
                    // rotation.
    public int left; // Location of the left edge of the rectangle before
                     // rotation.
    public int height; // Height of the rectangle.
    public int width; // Width of the rectangle.
    public double angle; // The rotation, in degrees, of the rectangle.

    private void init() {

    }

    public RotatedRect() {
      super(24);
      init();
    }

    public RotatedRect(int top, int left, int height, int width, double angle) {
      super(24);
      this.top = top;
      this.left = left;
      this.height = height;
      this.width = width;
      this.angle = angle;
    }

    protected RotatedRect(ByteBuffer backing, int offset) {
      super(backing, offset, 24);
      init();
    }

    protected RotatedRect(long nativeObj, boolean owned) {
      super(nativeObj, owned, 24);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 24);
    }

    public void read() {
      top = backing.getInt(0);
      left = backing.getInt(4);
      height = backing.getInt(8);
      width = backing.getInt(12);
      angle = backing.getDouble(16);
    }

    public void write() {
      backing.putInt(0, top);
      backing.putInt(4, left);
      backing.putInt(8, height);
      backing.putInt(12, width);
      backing.putDouble(16, angle);
    }

    public int size() {
      return 24;
    }
  }

  public static class ROIProfile extends DisposedStruct {
    public LineProfile report; // Quantifying information about the points along
                               // the edge of each contour in the ROI.
    public Point pixels; // An array of the points along the edge of each
                         // contour in the ROI.

    private void init() {
      report = new LineProfile(backing, 0);
    }

    public ROIProfile() {
      super(44);
      init();
    }

    public ROIProfile(LineProfile report, Point pixels) {
      super(44);
      this.report = report;
      this.pixels = pixels;
    }

    protected ROIProfile(ByteBuffer backing, int offset) {
      super(backing, offset, 44);
      init();
    }

    protected ROIProfile(long nativeObj, boolean owned) {
      super(nativeObj, owned, 44);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 44);
    }

    public void read() {
      report.read();
      long pixels_addr = getPointer(backing, 40);
      if (pixels_addr == 0)
        pixels = null;
      else
        pixels = new Point(pixels_addr, false);
    }

    public void write() {
      report.write();
      putPointer(backing, 40, pixels);
    }

    public int size() {
      return 44;
    }
  }

  public static class ToolWindowOptions extends DisposedStruct {
    public int showSelectionTool; // If TRUE, the selection tool becomes
                                  // visible.
    public int showZoomTool; // If TRUE, the zoom tool becomes visible.
    public int showPointTool; // If TRUE, the point tool becomes visible.
    public int showLineTool; // If TRUE, the line tool becomes visible.
    public int showRectangleTool; // If TRUE, the rectangle tool becomes
                                  // visible.
    public int showOvalTool; // If TRUE, the oval tool becomes visible.
    public int showPolygonTool; // If TRUE, the polygon tool becomes visible.
    public int showClosedFreehandTool; // If TRUE, the closed freehand tool
                                       // becomes visible.
    public int showPolyLineTool; // If TRUE, the polyline tool becomes visible.
    public int showFreehandTool; // If TRUE, the freehand tool becomes visible.
    public int showAnnulusTool; // If TRUE, the annulus becomes visible.
    public int showRotatedRectangleTool; // If TRUE, the rotated rectangle tool
                                         // becomes visible.
    public int showPanTool; // If TRUE, the pan tool becomes visible.
    public int showZoomOutTool; // If TRUE, the zoom out tool becomes visible.

    private void init() {

    }

    public ToolWindowOptions() {
      super(68);
      init();
    }

    public ToolWindowOptions(int showSelectionTool, int showZoomTool, int showPointTool,
        int showLineTool, int showRectangleTool, int showOvalTool, int showPolygonTool,
        int showClosedFreehandTool, int showPolyLineTool, int showFreehandTool,
        int showAnnulusTool, int showRotatedRectangleTool, int showPanTool, int showZoomOutTool) {
      super(68);
      this.showSelectionTool = showSelectionTool;
      this.showZoomTool = showZoomTool;
      this.showPointTool = showPointTool;
      this.showLineTool = showLineTool;
      this.showRectangleTool = showRectangleTool;
      this.showOvalTool = showOvalTool;
      this.showPolygonTool = showPolygonTool;
      this.showClosedFreehandTool = showClosedFreehandTool;
      this.showPolyLineTool = showPolyLineTool;
      this.showFreehandTool = showFreehandTool;
      this.showAnnulusTool = showAnnulusTool;
      this.showRotatedRectangleTool = showRotatedRectangleTool;
      this.showPanTool = showPanTool;
      this.showZoomOutTool = showZoomOutTool;
    }

    protected ToolWindowOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 68);
      init();
    }

    protected ToolWindowOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 68);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 68);
    }

    public void read() {
      showSelectionTool = backing.getInt(0);
      showZoomTool = backing.getInt(4);
      showPointTool = backing.getInt(8);
      showLineTool = backing.getInt(12);
      showRectangleTool = backing.getInt(16);
      showOvalTool = backing.getInt(20);
      showPolygonTool = backing.getInt(24);
      showClosedFreehandTool = backing.getInt(28);
      showPolyLineTool = backing.getInt(32);
      showFreehandTool = backing.getInt(36);
      showAnnulusTool = backing.getInt(40);
      showRotatedRectangleTool = backing.getInt(44);
      showPanTool = backing.getInt(48);
      showZoomOutTool = backing.getInt(52);
    }

    public void write() {
      backing.putInt(0, showSelectionTool);
      backing.putInt(4, showZoomTool);
      backing.putInt(8, showPointTool);
      backing.putInt(12, showLineTool);
      backing.putInt(16, showRectangleTool);
      backing.putInt(20, showOvalTool);
      backing.putInt(24, showPolygonTool);
      backing.putInt(28, showClosedFreehandTool);
      backing.putInt(32, showPolyLineTool);
      backing.putInt(36, showFreehandTool);
      backing.putInt(40, showAnnulusTool);
      backing.putInt(44, showRotatedRectangleTool);
      backing.putInt(48, showPanTool);
      backing.putInt(52, showZoomOutTool);
    }

    public int size() {
      return 68;
    }
  }

  public static class SpokeOptions extends DisposedStruct {
    public int threshold; // Specifies the threshold value for the contrast of
                          // the edge.
    public int width; // The number of pixels that the function averages to find
                      // the contrast at either side of the edge.
    public int steepness; // The span, in pixels, of the slope of the edge
                          // projected along the path specified by the input
                          // points.
    public double subsamplingRatio; // The angle, in degrees, between each
                                    // radial search line in the spoke.
    public InterpolationMethod subpixelType; // The method for interpolating.
    public int subpixelDivisions; // The number of samples the function obtains
                                  // from a pixel.

    private void init() {

    }

    public SpokeOptions() {
      super(32);
      init();
    }

    public SpokeOptions(int threshold, int width, int steepness, double subsamplingRatio,
        InterpolationMethod subpixelType, int subpixelDivisions) {
      super(32);
      this.threshold = threshold;
      this.width = width;
      this.steepness = steepness;
      this.subsamplingRatio = subsamplingRatio;
      this.subpixelType = subpixelType;
      this.subpixelDivisions = subpixelDivisions;
    }

    protected SpokeOptions(ByteBuffer backing, int offset) {
      super(backing, offset, 32);
      init();
    }

    protected SpokeOptions(long nativeObj, boolean owned) {
      super(nativeObj, owned, 32);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 32);
    }

    public void read() {
      threshold = backing.getInt(0);
      width = backing.getInt(4);
      steepness = backing.getInt(8);
      subsamplingRatio = backing.getDouble(16);
      subpixelType = InterpolationMethod.fromValue(backing.getInt(24));
      subpixelDivisions = backing.getInt(28);
    }

    public void write() {
      backing.putInt(0, threshold);
      backing.putInt(4, width);
      backing.putInt(8, steepness);
      backing.putDouble(16, subsamplingRatio);
      if (subpixelType != null)
        backing.putInt(24, subpixelType.getValue());
      backing.putInt(28, subpixelDivisions);
    }

    public int size() {
      return 32;
    }
  }

  /**
   * Globals
   */
  public static final Rect NO_RECT = new Rect(0, 0, 0x7FFFFFFF, 0x7FFFFFFF);
  public static final RotatedRect NO_ROTATED_RECT =
      new RotatedRect(0, 0, 0x7FFFFFFF, 0x7FFFFFFF, 0);
  public static final Point NO_POINT = new Point(-1, -1);
  public static final PointFloat NO_POINT_FLOAT = new PointFloat(-1.0, -1.0);
  public static final PointFloat NO_OFFSET = new PointFloat(0.0, 0.0);
  public static final RGBValue RGB_TRANSPARENT = new RGBValue(0, 0, 0, 1);
  public static final RGBValue RGB_RED = new RGBValue(0, 0, 255, 0);
  public static final RGBValue RGB_BLUE = new RGBValue(255, 0, 0, 0);
  public static final RGBValue RGB_GREEN = new RGBValue(0, 255, 0, 0);
  public static final RGBValue RGB_YELLOW = new RGBValue(0, 255, 255, 0);
  public static final RGBValue RGB_WHITE = new RGBValue(255, 255, 255, 0);
  public static final RGBValue RGB_BLACK = new RGBValue(0, 0, 0, 0);

  /**
   * Logical functions
   */

  public static void imaqAnd(Image dest, Image sourceA, Image sourceB) {

    _imaqAnd(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqAnd(long dest, long sourceA, long sourceB);

  public static void imaqCompare(Image dest, Image source, Image compareImage,
      ComparisonFunction compare) {

    _imaqCompare(dest.getAddress(), source.getAddress(), compareImage.getAddress(),
        compare.getValue());

  }

  private static native void _imaqCompare(long dest, long source, long compareImage, int compare);

  public static void imaqLogicalDifference(Image dest, Image sourceA, Image sourceB) {

    _imaqLogicalDifference(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqLogicalDifference(long dest, long sourceA, long sourceB);

  public static void imaqNand(Image dest, Image sourceA, Image sourceB) {

    _imaqNand(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqNand(long dest, long sourceA, long sourceB);

  public static void imaqNor(Image dest, Image sourceA, Image sourceB) {

    _imaqNor(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqNor(long dest, long sourceA, long sourceB);

  public static void imaqOr(Image dest, Image sourceA, Image sourceB) {

    _imaqOr(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqOr(long dest, long sourceA, long sourceB);

  public static void imaqXnor(Image dest, Image sourceA, Image sourceB) {

    _imaqXnor(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqXnor(long dest, long sourceA, long sourceB);

  public static void imaqXor(Image dest, Image sourceA, Image sourceB) {

    _imaqXor(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqXor(long dest, long sourceA, long sourceB);

  /**
   * Particle Analysis functions
   */

  public static int imaqCountParticles(Image image, int connectivity8) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqCountParticles(image.getAddress(), connectivity8, rv_addr + 0);
    int numParticles;
    numParticles = rv_buf.getInt(0);
    return numParticles;
  }

  private static native void _imaqCountParticles(long image, int connectivity8, long numParticles);

  public static double imaqMeasureParticle(Image image, int particleNumber, int calibrated,
      MeasurementType measurement) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqMeasureParticle(image.getAddress(), particleNumber, calibrated, measurement.getValue(),
        rv_addr + 0);
    double value;
    value = rv_buf.getDouble(0);
    return value;
  }

  private static native void _imaqMeasureParticle(long image, int particleNumber, int calibrated,
      int measurement, long value);

  public static MeasureParticlesReport imaqMeasureParticles(Image image,
      MeasureParticlesCalibrationMode calibrationMode, MeasurementType[] measurements) {
    int numMeasurements = measurements.length;
    ByteBuffer measurements_buf = null;
    measurements_buf =
        ByteBuffer.allocateDirect(measurements.length * 4).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < measurements.length; i++, off += 4) {
      if (measurements != null)
        measurements_buf.putInt(off, measurements[i].getValue());
    }
    long jn_rv =
        _imaqMeasureParticles(image.getAddress(), calibrationMode.getValue(),
            getByteBufferAddress(measurements_buf), numMeasurements);

    return new MeasureParticlesReport(jn_rv, true);
  }

  private static native long _imaqMeasureParticles(long image, int calibrationMode,
      long measurements, int numMeasurements);

  public static int imaqParticleFilter4(Image dest, Image source,
      ParticleFilterCriteria2[] criteria, ParticleFilterOptions2 options, ROI roi) {
    int criteriaCount = criteria.length;
    ByteBuffer criteria_buf = null;
    criteria_buf = ByteBuffer.allocateDirect(criteria.length * 20).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < criteria.length; i++, off += 20) {
      criteria[i].setBuffer(criteria_buf, off);
      criteria[i].write();
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqParticleFilter4(dest.getAddress(), source.getAddress(),
        getByteBufferAddress(criteria_buf), criteriaCount, options.getAddress(), roi == null ? 0
            : roi.getAddress(), rv_addr + 0);
    int numParticles;
    numParticles = rv_buf.getInt(0);
    return numParticles;
  }

  private static native void _imaqParticleFilter4(long dest, long source, long criteria,
      int criteriaCount, long options, long roi, long numParticles);

  /**
   * Morphology functions
   */

  public static void imaqConvexHull(Image dest, Image source, int connectivity8) {

    _imaqConvexHull(dest.getAddress(), source.getAddress(), connectivity8);

  }

  private static native void _imaqConvexHull(long dest, long source, int connectivity8);

  public static void imaqDanielssonDistance(Image dest, Image source) {

    _imaqDanielssonDistance(dest.getAddress(), source.getAddress());

  }

  private static native void _imaqDanielssonDistance(long dest, long source);

  public static void imaqFillHoles(Image dest, Image source, int connectivity8) {

    _imaqFillHoles(dest.getAddress(), source.getAddress(), connectivity8);

  }

  private static native void _imaqFillHoles(long dest, long source, int connectivity8);

  public static class FindCirclesResult {
    public CircleReport[] array;
    private long array_addr;

    private FindCirclesResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numCircles;
      array_numCircles = rv_buf.getInt(0);
      array = new CircleReport[array_numCircles];
      if (array_numCircles > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numCircles * 16);
        for (int i = 0, off = 0; i < array_numCircles; i++, off += 16) {
          array[i] = new CircleReport(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static FindCirclesResult imaqFindCircles(Image dest, Image source, float minRadius,
      float maxRadius) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqFindCircles(dest.getAddress(), source.getAddress(), minRadius, maxRadius, rv_addr + 0);
    FindCirclesResult rv = new FindCirclesResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqFindCircles(long dest, long source, float minRadius,
      float maxRadius, long numCircles);

  public static int imaqLabel2(Image dest, Image source, int connectivity8) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqLabel2(dest.getAddress(), source.getAddress(), connectivity8, rv_addr + 0);
    int particleCount;
    particleCount = rv_buf.getInt(0);
    return particleCount;
  }

  private static native void _imaqLabel2(long dest, long source, int connectivity8,
      long particleCount);

  public static void imaqMorphology(Image dest, Image source, MorphologyMethod method,
      StructuringElement structuringElement) {

    _imaqMorphology(dest.getAddress(), source.getAddress(), method.getValue(),
        structuringElement == null ? 0 : structuringElement.getAddress());

  }

  private static native void _imaqMorphology(long dest, long source, int method,
      long structuringElement);

  public static void imaqRejectBorder(Image dest, Image source, int connectivity8) {

    _imaqRejectBorder(dest.getAddress(), source.getAddress(), connectivity8);

  }

  private static native void _imaqRejectBorder(long dest, long source, int connectivity8);

  public static void imaqSegmentation(Image dest, Image source) {

    _imaqSegmentation(dest.getAddress(), source.getAddress());

  }

  private static native void _imaqSegmentation(long dest, long source);

  public static void imaqSeparation(Image dest, Image source, int erosions,
      StructuringElement structuringElement) {

    _imaqSeparation(dest.getAddress(), source.getAddress(), erosions,
        structuringElement == null ? 0 : structuringElement.getAddress());

  }

  private static native void _imaqSeparation(long dest, long source, int erosions,
      long structuringElement);

  public static void imaqSimpleDistance(Image dest, Image source,
      StructuringElement structuringElement) {

    _imaqSimpleDistance(dest.getAddress(), source.getAddress(), structuringElement == null ? 0
        : structuringElement.getAddress());

  }

  private static native void _imaqSimpleDistance(long dest, long source, long structuringElement);

  public static void imaqSizeFilter(Image dest, Image source, int connectivity8, int erosions,
      SizeType keepSize, StructuringElement structuringElement) {

    _imaqSizeFilter(dest.getAddress(), source.getAddress(), connectivity8, erosions,
        keepSize.getValue(), structuringElement == null ? 0 : structuringElement.getAddress());

  }

  private static native void _imaqSizeFilter(long dest, long source, int connectivity8,
      int erosions, int keepSize, long structuringElement);

  public static void imaqSkeleton(Image dest, Image source, SkeletonMethod method) {

    _imaqSkeleton(dest.getAddress(), source.getAddress(), method.getValue());

  }

  private static native void _imaqSkeleton(long dest, long source, int method);

  /**
   * Acquisition functions
   */

  /**
   * Arithmetic functions
   */

  public static void imaqAbsoluteDifference(Image dest, Image sourceA, Image sourceB) {

    _imaqAbsoluteDifference(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqAbsoluteDifference(long dest, long sourceA, long sourceB);

  public static void imaqAdd(Image dest, Image sourceA, Image sourceB) {

    _imaqAdd(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqAdd(long dest, long sourceA, long sourceB);

  public static void imaqAverage(Image dest, Image sourceA, Image sourceB) {

    _imaqAverage(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqAverage(long dest, long sourceA, long sourceB);

  public static void imaqDivide2(Image dest, Image sourceA, Image sourceB, RoundingMode roundingMode) {

    _imaqDivide2(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress(),
        roundingMode.getValue());

  }

  private static native void _imaqDivide2(long dest, long sourceA, long sourceB, int roundingMode);

  public static void imaqMax(Image dest, Image sourceA, Image sourceB) {

    _imaqMax(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqMax(long dest, long sourceA, long sourceB);

  public static void imaqMin(Image dest, Image sourceA, Image sourceB) {

    _imaqMin(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqMin(long dest, long sourceA, long sourceB);

  public static void imaqModulo(Image dest, Image sourceA, Image sourceB) {

    _imaqModulo(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqModulo(long dest, long sourceA, long sourceB);

  public static void imaqMulDiv(Image dest, Image sourceA, Image sourceB, float value) {

    _imaqMulDiv(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress(), value);

  }

  private static native void _imaqMulDiv(long dest, long sourceA, long sourceB, float value);

  public static void imaqMultiply(Image dest, Image sourceA, Image sourceB) {

    _imaqMultiply(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqMultiply(long dest, long sourceA, long sourceB);

  public static void imaqSubtract(Image dest, Image sourceA, Image sourceB) {

    _imaqSubtract(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqSubtract(long dest, long sourceA, long sourceB);

  /**
   * Caliper functions
   */

  public static class CaliperToolResult {
    public CaliperReport[] array;
    private long array_addr;

    private CaliperToolResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numEdgePairs;
      array_numEdgePairs = rv_buf.getInt(0);
      array = new CaliperReport[array_numEdgePairs];
      if (array_numEdgePairs > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numEdgePairs * 32);
        for (int i = 0, off = 0; i < array_numEdgePairs; i++, off += 32) {
          array[i] = new CaliperReport(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static CaliperToolResult imaqCaliperTool(Image image, Point[] points,
      EdgeOptions edgeOptions, CaliperOptions caliperOptions) {
    int numPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqCaliperTool(image.getAddress(), getByteBufferAddress(points_buf), numPoints,
            edgeOptions.getAddress(), caliperOptions.getAddress(), rv_addr + 0);
    CaliperToolResult rv = new CaliperToolResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqCaliperTool(long image, long points, int numPoints,
      long edgeOptions, long caliperOptions, long numEdgePairs);

  public static class ConcentricRake2Result {
    public EdgeOptions2 edgeOptions;
    public ConcentricRakeReport2 val;

    private ConcentricRake2Result(ByteBuffer rv_buf) {
      edgeOptions = new EdgeOptions2(rv_buf, 0);
      edgeOptions.read();
    }
  }

  public static ConcentricRake2Result imaqConcentricRake2(Image image, ROI roi,
      ConcentricRakeDirection direction, EdgeProcess process, int stepSize) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqConcentricRake2(image.getAddress(), roi.getAddress(), direction.getValue(),
            process.getValue(), stepSize, rv_addr + 0);
    ConcentricRake2Result rv = new ConcentricRake2Result(rv_buf);
    rv.val = new ConcentricRakeReport2(jn_rv, true);
    return rv;
  }

  private static native long _imaqConcentricRake2(long image, long roi, int direction, int process,
      int stepSize, long edgeOptions);

  public static class DetectExtremesResult {
    public ExtremeReport[] array;
    private long array_addr;

    private DetectExtremesResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numExtremes;
      array_numExtremes = rv_buf.getInt(0);
      array = new ExtremeReport[array_numExtremes];
      if (array_numExtremes > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numExtremes * 24);
        for (int i = 0, off = 0; i < array_numExtremes; i++, off += 24) {
          array[i] = new ExtremeReport(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static DetectExtremesResult imaqDetectExtremes(double[] pixels, DetectionMode mode,
      DetectExtremesOptions options) {
    int numPixels = pixels.length;
    ByteBuffer pixels_buf = null;
    pixels_buf = ByteBuffer.allocateDirect(pixels.length * 8).order(ByteOrder.nativeOrder());
    pixels_buf.asDoubleBuffer().put(pixels).rewind();
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqDetectExtremes(getByteBufferAddress(pixels_buf), numPixels, mode.getValue(),
            options.getAddress(), rv_addr + 0);
    DetectExtremesResult rv = new DetectExtremesResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqDetectExtremes(long pixels, int numPixels, int mode,
      long options, long numExtremes);

  public static double imaqDetectRotation(Image referenceImage, Image testImage,
      PointFloat referenceCenter, PointFloat testCenter, int radius, float precision) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqDetectRotation(referenceImage.getAddress(), testImage.getAddress(),
        referenceCenter.getAddress(), testCenter.getAddress(), radius, precision, rv_addr + 0);
    double angle;
    angle = rv_buf.getDouble(0);
    return angle;
  }

  private static native void _imaqDetectRotation(long referenceImage, long testImage,
      long referenceCenter, long testCenter, int radius, float precision, long angle);

  public static class EdgeTool4Result {
    public EdgeOptions2 edgeOptions;
    public EdgeReport2 val;

    private EdgeTool4Result(ByteBuffer rv_buf) {
      edgeOptions = new EdgeOptions2(rv_buf, 0);
      edgeOptions.read();
    }
  }

  public static EdgeTool4Result imaqEdgeTool4(Image image, ROI roi, EdgeProcess processType,
      int reverseDirection) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqEdgeTool4(image.getAddress(), roi.getAddress(), processType.getValue(), rv_addr + 0,
            reverseDirection);
    EdgeTool4Result rv = new EdgeTool4Result(rv_buf);
    rv.val = new EdgeReport2(jn_rv, true);
    return rv;
  }

  private static native long _imaqEdgeTool4(long image, long roi, int processType,
      long edgeOptions, int reverseDirection);

  public static FindEdgeReport imaqFindEdge2(Image image, ROI roi, CoordinateSystem baseSystem,
      CoordinateSystem newSystem, FindEdgeOptions2 findEdgeOptions,
      StraightEdgeOptions straightEdgeOptions) {

    long jn_rv =
        _imaqFindEdge2(image.getAddress(), roi.getAddress(), baseSystem.getAddress(),
            newSystem.getAddress(), findEdgeOptions.getAddress(), straightEdgeOptions.getAddress());

    return new FindEdgeReport(jn_rv, true);
  }

  private static native long _imaqFindEdge2(long image, long roi, long baseSystem, long newSystem,
      long findEdgeOptions, long straightEdgeOptions);

  public static class FindTransformRect2Result {
    public CoordinateSystem baseSystem;
    public CoordinateSystem newSystem;
    public AxisReport axisReport;

    private FindTransformRect2Result(ByteBuffer rv_buf) {
      baseSystem = new CoordinateSystem(rv_buf, 0);
      baseSystem.read();
      newSystem = new CoordinateSystem(rv_buf, 8);
      newSystem.read();
      axisReport = new AxisReport(rv_buf, 16);
      axisReport.read();
    }
  }

  public static FindTransformRect2Result imaqFindTransformRect2(Image image, ROI roi,
      FindTransformMode mode, FindTransformRectOptions2 findTransformOptions,
      StraightEdgeOptions straightEdgeOptions) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqFindTransformRect2(image.getAddress(), roi.getAddress(), mode.getValue(), rv_addr + 0,
        rv_addr + 8, findTransformOptions.getAddress(), straightEdgeOptions.getAddress(),
        rv_addr + 16);
    FindTransformRect2Result rv = new FindTransformRect2Result(rv_buf);
    return rv;
  }

  private static native void _imaqFindTransformRect2(long image, long roi, int mode,
      long baseSystem, long newSystem, long findTransformOptions, long straightEdgeOptions,
      long axisReport);

  public static class FindTransformRects2Result {
    public CoordinateSystem baseSystem;
    public CoordinateSystem newSystem;
    public AxisReport axisReport;

    private FindTransformRects2Result(ByteBuffer rv_buf) {
      baseSystem = new CoordinateSystem(rv_buf, 0);
      baseSystem.read();
      newSystem = new CoordinateSystem(rv_buf, 8);
      newSystem.read();
      axisReport = new AxisReport(rv_buf, 16);
      axisReport.read();
    }
  }

  public static FindTransformRects2Result imaqFindTransformRects2(Image image, ROI primaryROI,
      ROI secondaryROI, FindTransformMode mode, FindTransformRectsOptions2 findTransformOptions,
      StraightEdgeOptions primaryStraightEdgeOptions,
      StraightEdgeOptions secondaryStraightEdgeOptions) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqFindTransformRects2(image.getAddress(), primaryROI.getAddress(),
        secondaryROI.getAddress(), mode.getValue(), rv_addr + 0, rv_addr + 8,
        findTransformOptions.getAddress(), primaryStraightEdgeOptions.getAddress(),
        secondaryStraightEdgeOptions.getAddress(), rv_addr + 16);
    FindTransformRects2Result rv = new FindTransformRects2Result(rv_buf);
    return rv;
  }

  private static native void _imaqFindTransformRects2(long image, long primaryROI,
      long secondaryROI, int mode, long baseSystem, long newSystem, long findTransformOptions,
      long primaryStraightEdgeOptions, long secondaryStraightEdgeOptions, long axisReport);

  public static float imaqLineGaugeTool2(Image image, Point start, Point end,
      LineGaugeMethod method, EdgeOptions edgeOptions, CoordinateTransform2 transform) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqLineGaugeTool2(image.getAddress(), start.getAddress(), end.getAddress(),
        method.getValue(), edgeOptions.getAddress(), transform.getAddress(), rv_addr + 0);
    float distance;
    distance = rv_buf.getFloat(0);
    return distance;
  }

  private static native void _imaqLineGaugeTool2(long image, long start, long end, int method,
      long edgeOptions, long transform, long distance);

  public static class Rake2Result {
    public EdgeOptions2 edgeOptions;
    public RakeReport2 val;

    private Rake2Result(ByteBuffer rv_buf) {
      edgeOptions = new EdgeOptions2(rv_buf, 0);
      edgeOptions.read();
    }
  }

  public static Rake2Result imaqRake2(Image image, ROI roi, RakeDirection direction,
      EdgeProcess process, int stepSize) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqRake2(image.getAddress(), roi.getAddress(), direction.getValue(), process.getValue(),
            stepSize, rv_addr + 0);
    Rake2Result rv = new Rake2Result(rv_buf);
    rv.val = new RakeReport2(jn_rv, true);
    return rv;
  }

  private static native long _imaqRake2(long image, long roi, int direction, int process,
      int stepSize, long edgeOptions);

  public static class SimpleEdgeResult {
    public PointFloat[] array;
    private long array_addr;

    private SimpleEdgeResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numEdges;
      array_numEdges = rv_buf.getInt(0);
      array = new PointFloat[array_numEdges];
      if (array_numEdges > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numEdges * 8);
        for (int i = 0, off = 0; i < array_numEdges; i++, off += 8) {
          array[i] = new PointFloat(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static SimpleEdgeResult imaqSimpleEdge(Image image, Point[] points,
      SimpleEdgeOptions options) {
    int numPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqSimpleEdge(image.getAddress(), getByteBufferAddress(points_buf), numPoints,
            options.getAddress(), rv_addr + 0);
    SimpleEdgeResult rv = new SimpleEdgeResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqSimpleEdge(long image, long points, int numPoints, long options,
      long numEdges);

  public static class Spoke2Result {
    public EdgeOptions2 edgeOptions;
    public SpokeReport2 val;

    private Spoke2Result(ByteBuffer rv_buf) {
      edgeOptions = new EdgeOptions2(rv_buf, 0);
      edgeOptions.read();
    }
  }

  public static Spoke2Result imaqSpoke2(Image image, ROI roi, SpokeDirection direction,
      EdgeProcess process, int stepSize) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqSpoke2(image.getAddress(), roi.getAddress(), direction.getValue(), process.getValue(),
            stepSize, rv_addr + 0);
    Spoke2Result rv = new Spoke2Result(rv_buf);
    rv.val = new SpokeReport2(jn_rv, true);
    return rv;
  }

  private static native long _imaqSpoke2(long image, long roi, int direction, int process,
      int stepSize, long edgeOptions);

  public static StraightEdgeReport2 imaqStraightEdge(Image image, ROI roi,
      SearchDirection searchDirection, EdgeOptions2 edgeOptions,
      StraightEdgeOptions straightEdgeOptions) {

    long jn_rv =
        _imaqStraightEdge(image.getAddress(), roi.getAddress(), searchDirection.getValue(),
            edgeOptions.getAddress(), straightEdgeOptions.getAddress());

    return new StraightEdgeReport2(jn_rv, true);
  }

  private static native long _imaqStraightEdge(long image, long roi, int searchDirection,
      long edgeOptions, long straightEdgeOptions);

  public static StraightEdgeReport2 imaqStraightEdge2(Image image, ROI roi,
      SearchDirection searchDirection, EdgeOptions2 edgeOptions,
      StraightEdgeOptions straightEdgeOptions, int optimizedMode) {

    long jn_rv =
        _imaqStraightEdge2(image.getAddress(), roi.getAddress(), searchDirection.getValue(),
            edgeOptions.getAddress(), straightEdgeOptions.getAddress(), optimizedMode);

    return new StraightEdgeReport2(jn_rv, true);
  }

  private static native long _imaqStraightEdge2(long image, long roi, int searchDirection,
      long edgeOptions, long straightEdgeOptions, int optimizedMode);

  /**
   * Spatial Filters functions
   */

  public static void imaqCannyEdgeFilter(Image dest, Image source, CannyOptions options) {

    _imaqCannyEdgeFilter(dest.getAddress(), source.getAddress(),
        options == null ? 0 : options.getAddress());

  }

  private static native void _imaqCannyEdgeFilter(long dest, long source, long options);

  public static void imaqCorrelate(Image dest, Image source, Image templateImage, Rect rect) {

    _imaqCorrelate(dest.getAddress(), source.getAddress(), templateImage.getAddress(),
        rect.getAddress());

  }

  private static native void _imaqCorrelate(long dest, long source, long templateImage, long rect);

  public static void imaqEdgeFilter(Image dest, Image source, OutlineMethod method, Image mask) {

    _imaqEdgeFilter(dest.getAddress(), source.getAddress(), method.getValue(), mask == null ? 0
        : mask.getAddress());

  }

  private static native void _imaqEdgeFilter(long dest, long source, int method, long mask);

  public static void imaqLowPass(Image dest, Image source, int width, int height, float tolerance,
      Image mask) {

    _imaqLowPass(dest.getAddress(), source.getAddress(), width, height, tolerance, mask == null ? 0
        : mask.getAddress());

  }

  private static native void _imaqLowPass(long dest, long source, int width, int height,
      float tolerance, long mask);

  public static void imaqMedianFilter(Image dest, Image source, int width, int height, Image mask) {

    _imaqMedianFilter(dest.getAddress(), source.getAddress(), width, height, mask == null ? 0
        : mask.getAddress());

  }

  private static native void _imaqMedianFilter(long dest, long source, int width, int height,
      long mask);

  public static void imaqNthOrderFilter(Image dest, Image source, int width, int height, int n,
      Image mask) {

    _imaqNthOrderFilter(dest.getAddress(), source.getAddress(), width, height, n, mask == null ? 0
        : mask.getAddress());

  }

  private static native void _imaqNthOrderFilter(long dest, long source, int width, int height,
      int n, long mask);

  /**
   * Drawing functions
   */

  public static void imaqDrawLineOnImage(Image dest, Image source, DrawMode mode, Point start,
      Point end, float newPixelValue) {

    _imaqDrawLineOnImage(dest.getAddress(), source.getAddress(), mode.getValue(),
        start.getAddress(), end.getAddress(), newPixelValue);

  }

  private static native void _imaqDrawLineOnImage(long dest, long source, int mode, long start,
      long end, float newPixelValue);

  public static void imaqDrawShapeOnImage(Image dest, Image source, Rect rect, DrawMode mode,
      ShapeMode shape, float newPixelValue) {

    _imaqDrawShapeOnImage(dest.getAddress(), source.getAddress(), rect.getAddress(),
        mode.getValue(), shape.getValue(), newPixelValue);

  }

  private static native void _imaqDrawShapeOnImage(long dest, long source, long rect, int mode,
      int shape, float newPixelValue);

  /**
   * Interlacing functions
   */

  public static void imaqInterlaceCombine(Image frame, Image odd, Image even) {

    _imaqInterlaceCombine(frame.getAddress(), odd.getAddress(), even.getAddress());

  }

  private static native void _imaqInterlaceCombine(long frame, long odd, long even);

  public static void imaqInterlaceSeparate(Image frame, Image odd, Image even) {

    _imaqInterlaceSeparate(frame.getAddress(), odd == null ? 0 : odd.getAddress(), even == null ? 0
        : even.getAddress());

  }

  private static native void _imaqInterlaceSeparate(long frame, long odd, long even);

  /**
   * Image Information functions
   */

  public static class EnumerateCustomKeysResult {
    public String[] array;
    private long array_addr;

    private EnumerateCustomKeysResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_size;
      array_size = rv_buf.getInt(0);
      array = new String[array_size];
      if (array_size > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_size * 4);
        for (int i = 0, off = 0; i < array_size; i++, off += 4) {
          long addr = getPointer(bb, off);
          if (addr == 0)
            array[i] = null;
          else {
            ByteBuffer bb2 = newDirectByteBuffer(addr, 1000); // FIXME
            while (bb2.get() != 0) {
            }
            byte[] bytes = new byte[bb2.position() - 1];
            bb2.rewind();
            getBytes(bb2, bytes, 0, bytes.length);
            try {
              array[i] = new String(bytes, "UTF-8");
            } catch (UnsupportedEncodingException e) {
              array[i] = "";
            }
          }
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static EnumerateCustomKeysResult imaqEnumerateCustomKeys(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv = _imaqEnumerateCustomKeys(image.getAddress(), rv_addr + 0);
    EnumerateCustomKeysResult rv = new EnumerateCustomKeysResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqEnumerateCustomKeys(long image, long size);

  public static int imaqGetBitDepth(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetBitDepth(image.getAddress(), rv_addr + 0);
    int bitDepth;
    bitDepth = rv_buf.getInt(0);
    return bitDepth;
  }

  private static native void _imaqGetBitDepth(long image, long bitDepth);

  public static int imaqGetBytesPerPixel(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetBytesPerPixel(image.getAddress(), rv_addr + 0);
    int byteCount;
    byteCount = rv_buf.getInt(0);
    return byteCount;
  }

  private static native void _imaqGetBytesPerPixel(long image, long byteCount);

  public static ImageInfo imaqGetImageInfo(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetImageInfo(image.getAddress(), rv_addr + 0);
    ImageInfo info;
    info = new ImageInfo(rv_buf, 0);
    info.read();
    return info;
  }

  private static native void _imaqGetImageInfo(long image, long info);

  public static class GetImageSizeResult {
    public int width;
    public int height;

    private GetImageSizeResult(ByteBuffer rv_buf) {
      width = rv_buf.getInt(0);
      height = rv_buf.getInt(8);
    }
  }

  public static GetImageSizeResult imaqGetImageSize(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetImageSize(image.getAddress(), rv_addr + 0, rv_addr + 8);
    GetImageSizeResult rv = new GetImageSizeResult(rv_buf);
    return rv;
  }

  private static native void _imaqGetImageSize(long image, long width, long height);

  public static ImageType imaqGetImageType(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetImageType(image.getAddress(), rv_addr + 0);
    ImageType type;
    type = ImageType.fromValue(rv_buf.getInt(0));
    return type;
  }

  private static native void _imaqGetImageType(long image, long type);

  public static Point imaqGetMaskOffset(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetMaskOffset(image.getAddress(), rv_addr + 0);
    Point offset;
    offset = new Point(rv_buf, 0);
    offset.read();
    return offset;
  }

  private static native void _imaqGetMaskOffset(long image, long offset);

  public static int imaqGetVisionInfoTypes(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetVisionInfoTypes(image.getAddress(), rv_addr + 0);
    int present;
    present = rv_buf.getInt(0);
    return present;
  }

  private static native void _imaqGetVisionInfoTypes(long image, long present);

  public static int imaqIsImageEmpty(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqIsImageEmpty(image.getAddress(), rv_addr + 0);
    int empty;
    empty = rv_buf.getInt(0);
    return empty;
  }

  private static native void _imaqIsImageEmpty(long image, long empty);

  public static RawData imaqReadCustomData(Image image, String key) {
    ByteBuffer key_buf = null;
    if (key != null) {
      byte[] key_bytes;
      try {
        key_bytes = key.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        key_bytes = new byte[0];
      }
      key_buf = ByteBuffer.allocateDirect(key_bytes.length + 1);
      putBytes(key_buf, key_bytes, 0, key_bytes.length).put(key_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqReadCustomData(image.getAddress(), key == null ? 0 : getByteBufferAddress(key_buf),
            rv_addr + 0);
    int size;
    RawData val;
    size = rv_buf.getInt(0);
    val = new RawData(jn_rv, false, size);
    return val;
  }

  private static native long _imaqReadCustomData(long image, long key, long size);

  public static void imaqRemoveCustomData(Image image, String key) {
    ByteBuffer key_buf = null;
    if (key != null) {
      byte[] key_bytes;
      try {
        key_bytes = key.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        key_bytes = new byte[0];
      }
      key_buf = ByteBuffer.allocateDirect(key_bytes.length + 1);
      putBytes(key_buf, key_bytes, 0, key_bytes.length).put(key_bytes.length, (byte) 0);
    }
    _imaqRemoveCustomData(image.getAddress(), key == null ? 0 : getByteBufferAddress(key_buf));

  }

  private static native void _imaqRemoveCustomData(long image, long key);

  public static void imaqRemoveVisionInfo2(Image image, int info) {

    _imaqRemoveVisionInfo2(image.getAddress(), info);

  }

  private static native void _imaqRemoveVisionInfo2(long image, int info);

  public static void imaqSetBitDepth(Image image, int bitDepth) {

    _imaqSetBitDepth(image.getAddress(), bitDepth);

  }

  private static native void _imaqSetBitDepth(long image, int bitDepth);

  public static void imaqSetImageSize(Image image, int width, int height) {

    _imaqSetImageSize(image.getAddress(), width, height);

  }

  private static native void _imaqSetImageSize(long image, int width, int height);

  public static void imaqSetMaskOffset(Image image, Point offset) {

    _imaqSetMaskOffset(image.getAddress(), offset.getAddress());

  }

  private static native void _imaqSetMaskOffset(long image, long offset);

  public static void imaqWriteCustomData(Image image, String key, RawData data, int size) {
    ByteBuffer key_buf = null;
    if (key != null) {
      byte[] key_bytes;
      try {
        key_bytes = key.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        key_bytes = new byte[0];
      }
      key_buf = ByteBuffer.allocateDirect(key_bytes.length + 1);
      putBytes(key_buf, key_bytes, 0, key_bytes.length).put(key_bytes.length, (byte) 0);
    }
    _imaqWriteCustomData(image.getAddress(), key == null ? 0 : getByteBufferAddress(key_buf),
        data.getAddress(), size);

  }

  private static native void _imaqWriteCustomData(long image, long key, long data, int size);

  /**
   * Display functions
   */

  /**
   * Image Manipulation functions
   */

  public static void imaqCopyRect(Image dest, Image source, Rect rect, Point destLoc) {

    _imaqCopyRect(dest.getAddress(), source.getAddress(), rect.getAddress(), destLoc.getAddress());

  }

  private static native void _imaqCopyRect(long dest, long source, long rect, long destLoc);

  public static void imaqDuplicate(Image dest, Image source) {

    _imaqDuplicate(dest.getAddress(), source.getAddress());

  }

  private static native void _imaqDuplicate(long dest, long source);

  public static RawData imaqFlatten(Image image, FlattenType type, CompressionType compression,
      int quality) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqFlatten(image.getAddress(), type.getValue(), compression.getValue(), quality,
            rv_addr + 0);
    int size;
    RawData val;
    size = rv_buf.getInt(0);
    val = new RawData(jn_rv, true, size);
    return val;
  }

  private static native long _imaqFlatten(long image, int type, int compression, int quality,
      long size);

  public static void imaqFlip(Image dest, Image source, FlipAxis axis) {

    _imaqFlip(dest.getAddress(), source.getAddress(), axis.getValue());

  }

  private static native void _imaqFlip(long dest, long source, int axis);

  public static void imaqMask(Image dest, Image source, Image mask) {

    _imaqMask(dest.getAddress(), source.getAddress(), mask.getAddress());

  }

  private static native void _imaqMask(long dest, long source, long mask);

  public static void imaqResample(Image dest, Image source, int newWidth, int newHeight,
      InterpolationMethod method, Rect rect) {

    _imaqResample(dest.getAddress(), source.getAddress(), newWidth, newHeight, method.getValue(),
        rect.getAddress());

  }

  private static native void _imaqResample(long dest, long source, int newWidth, int newHeight,
      int method, long rect);

  public static void imaqScale(Image dest, Image source, int xScale, int yScale,
      ScalingMode scaleMode, Rect rect) {

    _imaqScale(dest.getAddress(), source.getAddress(), xScale, yScale, scaleMode.getValue(),
        rect.getAddress());

  }

  private static native void _imaqScale(long dest, long source, int xScale, int yScale,
      int scaleMode, long rect);

  public static void imaqTranspose(Image dest, Image source) {

    _imaqTranspose(dest.getAddress(), source.getAddress());

  }

  private static native void _imaqTranspose(long dest, long source);

  public static void imaqUnflatten(Image image, RawData data, int size) {

    _imaqUnflatten(image.getAddress(), data.getAddress(), size);

  }

  private static native void _imaqUnflatten(long image, long data, int size);

  public static void imaqUnwrapImage(Image dest, Image source, Annulus annulus,
      RectOrientation orientation, InterpolationMethod method) {

    _imaqUnwrapImage(dest.getAddress(), source.getAddress(), annulus.getAddress(),
        orientation.getValue(), method.getValue());

  }

  private static native void _imaqUnwrapImage(long dest, long source, long annulus,
      int orientation, int method);

  public static void imaqView3D(Image dest, Image source, View3DOptions options) {

    _imaqView3D(dest.getAddress(), source.getAddress(), options.getAddress());

  }

  private static native void _imaqView3D(long dest, long source, long options);

  /**
   * File I/O functions
   */

  public static class GetFileInfoResult {
    public CalibrationUnit calibrationUnit;
    public float calibrationX;
    public float calibrationY;
    public int width;
    public int height;
    public ImageType imageType;

    private GetFileInfoResult(ByteBuffer rv_buf) {
      calibrationUnit = CalibrationUnit.fromValue(rv_buf.getInt(0));
      calibrationX = rv_buf.getFloat(8);
      calibrationY = rv_buf.getFloat(16);
      width = rv_buf.getInt(24);
      height = rv_buf.getInt(32);
      imageType = ImageType.fromValue(rv_buf.getInt(40));
    }
  }

  public static GetFileInfoResult imaqGetFileInfo(String fileName) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    ByteBuffer rv_buf =
        ByteBuffer.allocateDirect(8 + 8 + 8 + 8 + 8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetFileInfo(fileName == null ? 0 : getByteBufferAddress(fileName_buf), rv_addr + 0,
        rv_addr + 8, rv_addr + 16, rv_addr + 24, rv_addr + 32, rv_addr + 40);
    GetFileInfoResult rv = new GetFileInfoResult(rv_buf);
    return rv;
  }

  private static native void _imaqGetFileInfo(long fileName, long calibrationUnit,
      long calibrationX, long calibrationY, long width, long height, long imageType);

  public static void imaqReadFile(Image image, String fileName) {
    ByteBuffer fileName_buf;
    byte[] fileName_bytes;
    try {
      fileName_bytes = fileName.getBytes("UTF-8");
    } catch (UnsupportedEncodingException e) {
      fileName_bytes = new byte[0];
    }
    fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
    putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
        (byte) 0);
    _imaqReadFile(image.getAddress(), getByteBufferAddress(fileName_buf), 0, 0);
  }

  private static native void _imaqReadFile(long image, long fileName, long colorTable,
      long numColors);

  public static class ReadVisionFileResult {
    public RGBValue colorTable;
    public int numColors;

    private ReadVisionFileResult(ByteBuffer rv_buf) {
      colorTable = new RGBValue(rv_buf, 0);
      colorTable.read();
      numColors = rv_buf.getInt(8);
    }
  }

  public static ReadVisionFileResult imaqReadVisionFile(Image image, String fileName) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqReadVisionFile(image.getAddress(), fileName == null ? 0
        : getByteBufferAddress(fileName_buf), rv_addr + 0, rv_addr + 8);
    ReadVisionFileResult rv = new ReadVisionFileResult(rv_buf);
    return rv;
  }

  private static native void _imaqReadVisionFile(long image, long fileName, long colorTable,
      long numColors);

  public static void imaqWriteBMPFile(Image image, String fileName, int compress,
      RGBValue colorTable) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    _imaqWriteBMPFile(image.getAddress(),
        fileName == null ? 0 : getByteBufferAddress(fileName_buf), compress, colorTable == null ? 0
            : colorTable.getAddress());

  }

  private static native void _imaqWriteBMPFile(long image, long fileName, int compress,
      long colorTable);

  public static void imaqWriteFile(Image image, String fileName, RGBValue colorTable) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    _imaqWriteFile(image.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf),
        colorTable == null ? 0 : colorTable.getAddress());

  }

  private static native void _imaqWriteFile(long image, long fileName, long colorTable);

  public static void imaqWriteJPEGFile(Image image, String fileName, int quality, RawData colorTable) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    _imaqWriteJPEGFile(image.getAddress(), fileName == null ? 0
        : getByteBufferAddress(fileName_buf), quality,
        colorTable == null ? 0 : colorTable.getAddress());

  }

  private static native void _imaqWriteJPEGFile(long image, long fileName, int quality,
      long colorTable);

  public static void imaqWritePNGFile2(Image image, String fileName, int compressionSpeed,
      RGBValue colorTable, int useBitDepth) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    _imaqWritePNGFile2(image.getAddress(), fileName == null ? 0
        : getByteBufferAddress(fileName_buf), compressionSpeed,
        colorTable == null ? 0 : colorTable.getAddress(), useBitDepth);

  }

  private static native void _imaqWritePNGFile2(long image, long fileName, int compressionSpeed,
      long colorTable, int useBitDepth);

  public static void imaqWriteTIFFFile(Image image, String fileName, TIFFFileOptions options,
      RGBValue colorTable) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    _imaqWriteTIFFFile(image.getAddress(), fileName == null ? 0
        : getByteBufferAddress(fileName_buf), options == null ? 0 : options.getAddress(),
        colorTable == null ? 0 : colorTable.getAddress());

  }

  private static native void _imaqWriteTIFFFile(long image, long fileName, long options,
      long colorTable);

  public static void imaqWriteVisionFile(Image image, String fileName, RGBValue colorTable) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    _imaqWriteVisionFile(image.getAddress(), fileName == null ? 0
        : getByteBufferAddress(fileName_buf), colorTable.getAddress());

  }

  private static native void _imaqWriteVisionFile(long image, long fileName, long colorTable);

  /**
   * Analytic Geometry functions
   */

  public static CoordinateSystem imaqBuildCoordinateSystem(Point points, ReferenceMode mode,
      AxisOrientation orientation) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqBuildCoordinateSystem(points.getAddress(), mode.getValue(), orientation.getValue(),
        rv_addr + 0);
    CoordinateSystem system;
    system = new CoordinateSystem(rv_buf, 0);
    system.read();
    return system;
  }

  private static native void _imaqBuildCoordinateSystem(long points, int mode, int orientation,
      long system);

  public static BestCircle2 imaqFitCircle2(PointFloat[] points, FitCircleOptions options) {
    int numPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    long jn_rv = _imaqFitCircle2(getByteBufferAddress(points_buf), numPoints, options.getAddress());

    return new BestCircle2(jn_rv, true);
  }

  private static native long _imaqFitCircle2(long points, int numPoints, long options);

  public static BestEllipse2 imaqFitEllipse2(PointFloat[] points, FitEllipseOptions options) {
    int numPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    long jn_rv =
        _imaqFitEllipse2(getByteBufferAddress(points_buf), numPoints, options.getAddress());

    return new BestEllipse2(jn_rv, true);
  }

  private static native long _imaqFitEllipse2(long points, int numPoints, long options);

  public static BestLine imaqFitLine(PointFloat[] points, FitLineOptions options) {
    int numPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    long jn_rv = _imaqFitLine(getByteBufferAddress(points_buf), numPoints, options.getAddress());

    return new BestLine(jn_rv, true);
  }

  private static native long _imaqFitLine(long points, int numPoints, long options);

  public static float imaqGetAngle(PointFloat start1, PointFloat end1, PointFloat start2,
      PointFloat end2) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetAngle(start1.getAddress(), end1.getAddress(), start2.getAddress(), end2.getAddress(),
        rv_addr + 0);
    float angle;
    angle = rv_buf.getFloat(0);
    return angle;
  }

  private static native void _imaqGetAngle(long start1, long end1, long start2, long end2,
      long angle);

  public static class GetBisectingLineResult {
    public PointFloat bisectStart;
    public PointFloat bisectEnd;

    private GetBisectingLineResult(ByteBuffer rv_buf) {
      bisectStart = new PointFloat(rv_buf, 0);
      bisectStart.read();
      bisectEnd = new PointFloat(rv_buf, 8);
      bisectEnd.read();
    }
  }

  public static GetBisectingLineResult imaqGetBisectingLine(PointFloat start1, PointFloat end1,
      PointFloat start2, PointFloat end2) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetBisectingLine(start1.getAddress(), end1.getAddress(), start2.getAddress(),
        end2.getAddress(), rv_addr + 0, rv_addr + 8);
    GetBisectingLineResult rv = new GetBisectingLineResult(rv_buf);
    return rv;
  }

  private static native void _imaqGetBisectingLine(long start1, long end1, long start2, long end2,
      long bisectStart, long bisectEnd);

  public static float imaqGetDistance(PointFloat point1, PointFloat point2) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetDistance(point1.getAddress(), point2.getAddress(), rv_addr + 0);
    float distance;
    distance = rv_buf.getFloat(0);
    return distance;
  }

  private static native void _imaqGetDistance(long point1, long point2, long distance);

  public static PointFloat imaqGetIntersection(PointFloat start1, PointFloat end1,
      PointFloat start2, PointFloat end2) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetIntersection(start1.getAddress(), end1.getAddress(), start2.getAddress(),
        end2.getAddress(), rv_addr + 0);
    PointFloat intersection;
    intersection = new PointFloat(rv_buf, 0);
    intersection.read();
    return intersection;
  }

  private static native void _imaqGetIntersection(long start1, long end1, long start2, long end2,
      long intersection);

  public static class GetMidLineResult {
    public PointFloat midLineStart;
    public PointFloat midLineEnd;

    private GetMidLineResult(ByteBuffer rv_buf) {
      midLineStart = new PointFloat(rv_buf, 0);
      midLineStart.read();
      midLineEnd = new PointFloat(rv_buf, 8);
      midLineEnd.read();
    }
  }

  public static GetMidLineResult imaqGetMidLine(PointFloat refLineStart, PointFloat refLineEnd,
      PointFloat point) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetMidLine(refLineStart.getAddress(), refLineEnd.getAddress(), point.getAddress(),
        rv_addr + 0, rv_addr + 8);
    GetMidLineResult rv = new GetMidLineResult(rv_buf);
    return rv;
  }

  private static native void _imaqGetMidLine(long refLineStart, long refLineEnd, long point,
      long midLineStart, long midLineEnd);

  public static class GetPerpendicularLineResult {
    public PointFloat perpLineStart;
    public PointFloat perpLineEnd;
    public double distance;

    private GetPerpendicularLineResult(ByteBuffer rv_buf) {
      perpLineStart = new PointFloat(rv_buf, 0);
      perpLineStart.read();
      perpLineEnd = new PointFloat(rv_buf, 8);
      perpLineEnd.read();
      distance = rv_buf.getDouble(16);
    }
  }

  public static GetPerpendicularLineResult imaqGetPerpendicularLine(PointFloat refLineStart,
      PointFloat refLineEnd, PointFloat point) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetPerpendicularLine(refLineStart.getAddress(), refLineEnd.getAddress(),
        point.getAddress(), rv_addr + 0, rv_addr + 8, rv_addr + 16);
    GetPerpendicularLineResult rv = new GetPerpendicularLineResult(rv_buf);
    return rv;
  }

  private static native void _imaqGetPerpendicularLine(long refLineStart, long refLineEnd,
      long point, long perpLineStart, long perpLineEnd, long distance);

  public static class GetPointsOnContourResult {
    public SegmentInfo[] array;
    private long array_addr;

    private GetPointsOnContourResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numSegments;
      array_numSegments = rv_buf.getInt(0);
      array = new SegmentInfo[array_numSegments];
      if (array_numSegments > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numSegments * 24);
        for (int i = 0, off = 0; i < array_numSegments; i++, off += 24) {
          array[i] = new SegmentInfo(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static GetPointsOnContourResult imaqGetPointsOnContour(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv = _imaqGetPointsOnContour(image.getAddress(), rv_addr + 0);
    GetPointsOnContourResult rv = new GetPointsOnContourResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqGetPointsOnContour(long image, long numSegments);

  public static class GetPointsOnLineResult {
    public Point[] array;
    private long array_addr;

    private GetPointsOnLineResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numPoints;
      array_numPoints = rv_buf.getInt(0);
      array = new Point[array_numPoints];
      if (array_numPoints > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numPoints * 8);
        for (int i = 0, off = 0; i < array_numPoints; i++, off += 8) {
          array[i] = new Point(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static GetPointsOnLineResult imaqGetPointsOnLine(Point start, Point end) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv = _imaqGetPointsOnLine(start.getAddress(), end.getAddress(), rv_addr + 0);
    GetPointsOnLineResult rv = new GetPointsOnLineResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqGetPointsOnLine(long start, long end, long numPoints);

  public static float imaqGetPolygonArea(PointFloat points, int numPoints) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetPolygonArea(points.getAddress(), numPoints, rv_addr + 0);
    float area;
    area = rv_buf.getFloat(0);
    return area;
  }

  private static native void _imaqGetPolygonArea(long points, int numPoints, long area);

  public static class InterpolatePointsResult {
    public float[] array;
    private long array_addr;

    private InterpolatePointsResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_interpCount;
      array_interpCount = rv_buf.getInt(0);
      array = new float[array_interpCount];
      if (array_interpCount > 0 && array_addr != 0) {
        newDirectByteBuffer(array_addr, array_interpCount * 4).asFloatBuffer().get(array);
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static InterpolatePointsResult imaqInterpolatePoints(Image image, Point[] points,
      InterpolationMethod method, int subpixel) {
    int numPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqInterpolatePoints(image.getAddress(), getByteBufferAddress(points_buf), numPoints,
            method.getValue(), subpixel, rv_addr + 0);
    InterpolatePointsResult rv = new InterpolatePointsResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqInterpolatePoints(long image, long points, int numPoints,
      int method, int subpixel, long interpCount);

  /**
   * Clipboard functions
   */

  /**
   * Border functions
   */

  public static void imaqFillBorder(Image image, BorderMethod method) {

    _imaqFillBorder(image.getAddress(), method.getValue());

  }

  private static native void _imaqFillBorder(long image, int method);

  public static int imaqGetBorderSize(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetBorderSize(image.getAddress(), rv_addr + 0);
    int borderSize;
    borderSize = rv_buf.getInt(0);
    return borderSize;
  }

  private static native void _imaqGetBorderSize(long image, long borderSize);

  public static void imaqSetBorderSize(Image image, int size) {

    _imaqSetBorderSize(image.getAddress(), size);

  }

  private static native void _imaqSetBorderSize(long image, int size);

  /**
   * Image Management functions
   */

  public static void imaqArrayToImage(Image image, RawData array, int numCols, int numRows) {

    _imaqArrayToImage(image.getAddress(), array.getAddress(), numCols, numRows);

  }

  private static native void _imaqArrayToImage(long image, long array, int numCols, int numRows);

  public static Image imaqCreateImage(ImageType type, int borderSize) {

    long jn_rv = _imaqCreateImage(type.getValue(), borderSize);

    return new Image(jn_rv, true);
  }

  private static native long _imaqCreateImage(int type, int borderSize);

  /**
   * Color Processing functions
   */

  public static void imaqColorBCGTransform(Image dest, Image source, BCGOptions redOptions,
      BCGOptions greenOptions, BCGOptions blueOptions, Image mask) {

    _imaqColorBCGTransform(dest.getAddress(), source.getAddress(), redOptions == null ? 0
        : redOptions.getAddress(), greenOptions == null ? 0 : greenOptions.getAddress(),
        blueOptions == null ? 0 : blueOptions.getAddress(), mask == null ? 0 : mask.getAddress());

  }

  private static native void _imaqColorBCGTransform(long dest, long source, long redOptions,
      long greenOptions, long blueOptions, long mask);

  public static void imaqColorEqualize(Image dest, Image source, int colorEqualization) {

    _imaqColorEqualize(dest.getAddress(), source.getAddress(), colorEqualization);

  }

  private static native void _imaqColorEqualize(long dest, long source, int colorEqualization);

  public static ColorHistogramReport imaqColorHistogram2(Image image, int numClasses,
      ColorMode mode, CIEXYZValue whiteReference, Image mask) {

    long jn_rv =
        _imaqColorHistogram2(image.getAddress(), numClasses, mode.getValue(),
            whiteReference.getAddress(), mask == null ? 0 : mask.getAddress());

    return new ColorHistogramReport(jn_rv, true);
  }

  private static native long _imaqColorHistogram2(long image, int numClasses, int mode,
      long whiteReference, long mask);

  public static void imaqColorThreshold(Image dest, Image source, int replaceValue, ColorMode mode,
      Range plane1Range, Range plane2Range, Range plane3Range) {

    _imaqColorThreshold(dest.getAddress(), source.getAddress(), replaceValue, mode.getValue(),
        plane1Range == null ? 0 : plane1Range.getAddress(),
        plane2Range == null ? 0 : plane2Range.getAddress(),
        plane3Range == null ? 0 : plane3Range.getAddress());

  }

  private static native void _imaqColorThreshold(long dest, long source, int replaceValue,
      int mode, long plane1Range, long plane2Range, long plane3Range);

  public static SupervisedColorSegmentationReport imaqSupervisedColorSegmentation(
      ClassifierSession session, Image labelImage, Image srcImage, ROI roi, ROILabel labelIn,
      int numLabelIn, int maxDistance, int minIdentificationScore,
      ColorSegmenationOptions segmentOptions) {

    long jn_rv =
        _imaqSupervisedColorSegmentation(session.getAddress(), labelImage.getAddress(),
            srcImage.getAddress(), roi.getAddress(), labelIn.getAddress(), numLabelIn, maxDistance,
            minIdentificationScore, segmentOptions.getAddress());

    return new SupervisedColorSegmentationReport(jn_rv, true);
  }

  private static native long _imaqSupervisedColorSegmentation(long session, long labelImage,
      long srcImage, long roi, long labelIn, int numLabelIn, int maxDistance,
      int minIdentificationScore, long segmentOptions);

  public static int imaqGetColorSegmentationMaxDistance(ClassifierSession session,
      ColorSegmenationOptions segmentOptions, SegmentationDistanceLevel distLevel) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetColorSegmentationMaxDistance(session.getAddress(), segmentOptions.getAddress(),
        distLevel.getValue(), rv_addr + 0);
    int maxDistance;
    maxDistance = rv_buf.getInt(0);
    return maxDistance;
  }

  private static native void _imaqGetColorSegmentationMaxDistance(long session,
      long segmentOptions, int distLevel, long maxDistance);

  /**
   * Transform functions
   */

  public static void imaqBCGTransform(Image dest, Image source, BCGOptions options, Image mask) {

    _imaqBCGTransform(dest.getAddress(), source.getAddress(), options.getAddress(),
        mask == null ? 0 : mask.getAddress());

  }

  private static native void _imaqBCGTransform(long dest, long source, long options, long mask);

  public static void imaqEqualize(Image dest, Image source, float min, float max, Image mask) {

    _imaqEqualize(dest.getAddress(), source.getAddress(), min, max,
        mask == null ? 0 : mask.getAddress());

  }

  private static native void _imaqEqualize(long dest, long source, float min, float max, long mask);

  public static void imaqInverse(Image dest, Image source, Image mask) {

    _imaqInverse(dest.getAddress(), source.getAddress(), mask == null ? 0 : mask.getAddress());

  }

  private static native void _imaqInverse(long dest, long source, long mask);

  public static void imaqMathTransform(Image dest, Image source, MathTransformMethod method,
      float rangeMin, float rangeMax, float power, Image mask) {

    _imaqMathTransform(dest.getAddress(), source.getAddress(), method.getValue(), rangeMin,
        rangeMax, power, mask == null ? 0 : mask.getAddress());

  }

  private static native void _imaqMathTransform(long dest, long source, int method, float rangeMin,
      float rangeMax, float power, long mask);

  public static int imaqWatershedTransform(Image dest, Image source, int connectivity8) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqWatershedTransform(dest.getAddress(), source.getAddress(), connectivity8, rv_addr + 0);
    int zoneCount;
    zoneCount = rv_buf.getInt(0);
    return zoneCount;
  }

  private static native void _imaqWatershedTransform(long dest, long source, int connectivity8,
      long zoneCount);

  /**
   * Window Management functions
   */

  /**
   * Utilities functions
   */

  public static int imaqMulticoreOptions(MulticoreOperation operation) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqMulticoreOptions(operation.getValue(), rv_addr + 0);
    int customNumCores;
    customNumCores = rv_buf.getInt(0);
    return customNumCores;
  }

  private static native void _imaqMulticoreOptions(int operation, long customNumCores);

  /**
   * Tool Window functions
   */

  /**
   * Meter functions
   */

  public static MeterArc imaqGetMeterArc(int lightNeedle, MeterArcMode mode, ROI roi,
      PointFloat base, PointFloat start, PointFloat end) {

    long jn_rv =
        _imaqGetMeterArc(lightNeedle, mode.getValue(), roi.getAddress(), base.getAddress(),
            start.getAddress(), end.getAddress());

    return new MeterArc(jn_rv, true);
  }

  private static native long _imaqGetMeterArc(int lightNeedle, int mode, long roi, long base,
      long start, long end);

  public static class ReadMeterResult {
    public double percentage;
    public PointFloat endOfNeedle;

    private ReadMeterResult(ByteBuffer rv_buf) {
      percentage = rv_buf.getDouble(0);
      endOfNeedle = new PointFloat(rv_buf, 8);
      endOfNeedle.read();
    }
  }

  public static ReadMeterResult imaqReadMeter(Image image, MeterArc arcInfo) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqReadMeter(image.getAddress(), arcInfo.getAddress(), rv_addr + 0, rv_addr + 8);
    ReadMeterResult rv = new ReadMeterResult(rv_buf);
    return rv;
  }

  private static native void _imaqReadMeter(long image, long arcInfo, long percentage,
      long endOfNeedle);

  /**
   * Calibration functions
   */

  public static void imaqCopyCalibrationInfo2(Image dest, Image source, Point offset) {

    _imaqCopyCalibrationInfo2(dest.getAddress(), source.getAddress(), offset.getAddress());

  }

  private static native void _imaqCopyCalibrationInfo2(long dest, long source, long offset);

  public static CalibrationInfo imaqGetCalibrationInfo2(Image image) {

    long jn_rv = _imaqGetCalibrationInfo2(image.getAddress());

    return new CalibrationInfo(jn_rv, true);
  }

  private static native long _imaqGetCalibrationInfo2(long image);

  public static CalibrationInfo imaqGetCalibrationInfo3(Image image, int isGetErrorMap) {

    long jn_rv = _imaqGetCalibrationInfo3(image.getAddress(), isGetErrorMap);

    return new CalibrationInfo(jn_rv, true);
  }

  private static native long _imaqGetCalibrationInfo3(long image, int isGetErrorMap);

  public static float imaqLearnCalibrationGrid(Image image, ROI roi,
      LearnCalibrationOptions options, GridDescriptor grid, CoordinateSystem system,
      RangeFloat range) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqLearnCalibrationGrid(image.getAddress(), roi.getAddress(), options.getAddress(),
        grid.getAddress(), system.getAddress(), range.getAddress(), rv_addr + 0);
    float quality;
    quality = rv_buf.getFloat(0);
    return quality;
  }

  private static native void _imaqLearnCalibrationGrid(long image, long roi, long options,
      long grid, long system, long range, long quality);

  public static float imaqLearnCalibrationPoints(Image image, CalibrationPoints points, ROI roi,
      LearnCalibrationOptions options, GridDescriptor grid, CoordinateSystem system) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqLearnCalibrationPoints(image.getAddress(), points.getAddress(), roi.getAddress(),
        options.getAddress(), grid.getAddress(), system.getAddress(), rv_addr + 0);
    float quality;
    quality = rv_buf.getFloat(0);
    return quality;
  }

  private static native void _imaqLearnCalibrationPoints(long image, long points, long roi,
      long options, long grid, long system, long quality);

  public static void imaqSetCoordinateSystem(Image image, CoordinateSystem system) {

    _imaqSetCoordinateSystem(image.getAddress(), system.getAddress());

  }

  private static native void _imaqSetCoordinateSystem(long image, long system);

  public static void imaqSetSimpleCalibration(Image image, ScalingMethod method, int learnTable,
      GridDescriptor grid, CoordinateSystem system) {

    _imaqSetSimpleCalibration(image.getAddress(), method.getValue(), learnTable, grid.getAddress(),
        system.getAddress());

  }

  private static native void _imaqSetSimpleCalibration(long image, int method, int learnTable,
      long grid, long system);

  public static TransformReport imaqTransformPixelToRealWorld(Image image,
      PointFloat[] pixelCoordinates) {
    int numCoordinates = pixelCoordinates.length;
    ByteBuffer pixelCoordinates_buf = null;
    pixelCoordinates_buf =
        ByteBuffer.allocateDirect(pixelCoordinates.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < pixelCoordinates.length; i++, off += 8) {
      pixelCoordinates[i].setBuffer(pixelCoordinates_buf, off);
      pixelCoordinates[i].write();
    }
    long jn_rv =
        _imaqTransformPixelToRealWorld(image.getAddress(),
            getByteBufferAddress(pixelCoordinates_buf), numCoordinates);

    return new TransformReport(jn_rv, true);
  }

  private static native long _imaqTransformPixelToRealWorld(long image, long pixelCoordinates,
      int numCoordinates);

  public static TransformReport imaqTransformRealWorldToPixel(Image image,
      PointFloat[] realWorldCoordinates) {
    int numCoordinates = realWorldCoordinates.length;
    ByteBuffer realWorldCoordinates_buf = null;
    realWorldCoordinates_buf =
        ByteBuffer.allocateDirect(realWorldCoordinates.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < realWorldCoordinates.length; i++, off += 8) {
      realWorldCoordinates[i].setBuffer(realWorldCoordinates_buf, off);
      realWorldCoordinates[i].write();
    }
    long jn_rv =
        _imaqTransformRealWorldToPixel(image.getAddress(),
            getByteBufferAddress(realWorldCoordinates_buf), numCoordinates);

    return new TransformReport(jn_rv, true);
  }

  private static native long _imaqTransformRealWorldToPixel(long image, long realWorldCoordinates,
      int numCoordinates);

  public static void imaqSetSimpleCalibration2(Image image, GridDescriptor gridDescriptor) {

    _imaqSetSimpleCalibration2(image.getAddress(), gridDescriptor.getAddress());

  }

  private static native void _imaqSetSimpleCalibration2(long image, long gridDescriptor);

  public static CoordinateSystem imaqCalibrationSetAxisInfo(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqCalibrationSetAxisInfo(image.getAddress(), rv_addr + 0);
    CoordinateSystem axisInfo;
    axisInfo = new CoordinateSystem(rv_buf, 0);
    axisInfo.read();
    return axisInfo;
  }

  private static native void _imaqCalibrationSetAxisInfo(long image, long axisInfo);

  public static void imaqCalibrationGetThumbnailImage(Image templateImage, Image image,
      CalibrationThumbnailType type, int index) {

    _imaqCalibrationGetThumbnailImage(templateImage.getAddress(), image.getAddress(),
        type.getValue(), index);

  }

  private static native void _imaqCalibrationGetThumbnailImage(long templateImage, long image,
      int type, int index);

  public static GetCalibrationInfoReport imaqCalibrationGetCalibrationInfo(Image image,
      int isGetErrorMap) {

    long jn_rv = _imaqCalibrationGetCalibrationInfo(image.getAddress(), isGetErrorMap);

    return new GetCalibrationInfoReport(jn_rv, true);
  }

  private static native long _imaqCalibrationGetCalibrationInfo(long image, int isGetErrorMap);

  public static GetCameraParametersReport imaqCalibrationGetCameraParameters(Image templateImage) {

    long jn_rv = _imaqCalibrationGetCameraParameters(templateImage.getAddress());

    return new GetCameraParametersReport(jn_rv, true);
  }

  private static native long _imaqCalibrationGetCameraParameters(long templateImage);

  public static void imaqCalibrationCompactInformation(Image image) {

    _imaqCalibrationCompactInformation(image.getAddress());

  }

  private static native void _imaqCalibrationCompactInformation(long image);

  /**
   * Pixel Manipulation functions
   */

  public static void imaqExtractColorPlanes(Image image, ColorMode mode, Image plane1,
      Image plane2, Image plane3) {

    _imaqExtractColorPlanes(image.getAddress(), mode.getValue(),
        plane1 == null ? 0 : plane1.getAddress(), plane2 == null ? 0 : plane2.getAddress(),
        plane3 == null ? 0 : plane3.getAddress());

  }

  private static native void _imaqExtractColorPlanes(long image, int mode, long plane1,
      long plane2, long plane3);

  public static void imaqExtractComplexPlane(Image dest, Image source, ComplexPlane plane) {

    _imaqExtractComplexPlane(dest.getAddress(), source.getAddress(), plane.getValue());

  }

  private static native void _imaqExtractComplexPlane(long dest, long source, int plane);

  public static void imaqReplaceColorPlanes(Image dest, Image source, ColorMode mode, Image plane1,
      Image plane2, Image plane3) {

    _imaqReplaceColorPlanes(dest.getAddress(), source.getAddress(), mode.getValue(),
        plane1 == null ? 0 : plane1.getAddress(), plane2 == null ? 0 : plane2.getAddress(),
        plane3 == null ? 0 : plane3.getAddress());

  }

  private static native void _imaqReplaceColorPlanes(long dest, long source, int mode, long plane1,
      long plane2, long plane3);

  public static void imaqReplaceComplexPlane(Image dest, Image source, Image newValues,
      ComplexPlane plane) {

    _imaqReplaceComplexPlane(dest.getAddress(), source.getAddress(), newValues.getAddress(),
        plane.getValue());

  }

  private static native void _imaqReplaceComplexPlane(long dest, long source, long newValues,
      int plane);

  /**
   * Color Matching functions
   */

  public static ColorInformation imaqLearnColor(Image image, ROI roi, ColorSensitivity sensitivity,
      int saturation) {

    long jn_rv =
        _imaqLearnColor(image.getAddress(), roi == null ? 0 : roi.getAddress(),
            sensitivity.getValue(), saturation);

    return new ColorInformation(jn_rv, true);
  }

  private static native long _imaqLearnColor(long image, long roi, int sensitivity, int saturation);

  public static class MatchColorResult {
    public int[] array;
    private long array_addr;

    private MatchColorResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numScores;
      array_numScores = rv_buf.getInt(0);
      array = new int[array_numScores];
      if (array_numScores > 0 && array_addr != 0) {
        newDirectByteBuffer(array_addr, array_numScores * 4).asIntBuffer().get(array);
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static MatchColorResult imaqMatchColor(Image image, ColorInformation info, ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqMatchColor(image.getAddress(), info.getAddress(), roi == null ? 0 : roi.getAddress(),
            rv_addr + 0);
    MatchColorResult rv = new MatchColorResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqMatchColor(long image, long info, long roi, long numScores);

  /**
   * Frequency Domain Analysis functions
   */

  public static void imaqAttenuate(Image dest, Image source, AttenuateMode highlow) {

    _imaqAttenuate(dest.getAddress(), source.getAddress(), highlow.getValue());

  }

  private static native void _imaqAttenuate(long dest, long source, int highlow);

  public static void imaqConjugate(Image dest, Image source) {

    _imaqConjugate(dest.getAddress(), source.getAddress());

  }

  private static native void _imaqConjugate(long dest, long source);

  public static void imaqFFT(Image dest, Image source) {

    _imaqFFT(dest.getAddress(), source.getAddress());

  }

  private static native void _imaqFFT(long dest, long source);

  public static void imaqFlipFrequencies(Image dest, Image source) {

    _imaqFlipFrequencies(dest.getAddress(), source.getAddress());

  }

  private static native void _imaqFlipFrequencies(long dest, long source);

  public static void imaqInverseFFT(Image dest, Image source) {

    _imaqInverseFFT(dest.getAddress(), source.getAddress());

  }

  private static native void _imaqInverseFFT(long dest, long source);

  public static void imaqTruncate(Image dest, Image source, TruncateMode highlow, float ratioToKeep) {

    _imaqTruncate(dest.getAddress(), source.getAddress(), highlow.getValue(), ratioToKeep);

  }

  private static native void _imaqTruncate(long dest, long source, int highlow, float ratioToKeep);

  /**
   * Barcode I/O functions
   */

  public static AIMGradeReport imaqGradeDataMatrixBarcodeAIM(Image image) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGradeDataMatrixBarcodeAIM(image.getAddress(), rv_addr + 0);
    AIMGradeReport report;
    report = new AIMGradeReport(rv_buf, 0);
    report.read();
    return report;
  }

  private static native void _imaqGradeDataMatrixBarcodeAIM(long image, long report);

  public static BarcodeInfo imaqReadBarcode(Image image, BarcodeType type, ROI roi, int validate) {

    long jn_rv =
        _imaqReadBarcode(image.getAddress(), type.getValue(), roi == null ? 0 : roi.getAddress(),
            validate);

    return new BarcodeInfo(jn_rv, true);
  }

  private static native long _imaqReadBarcode(long image, int type, long roi, int validate);

  public static DataMatrixReport imaqReadDataMatrixBarcode2(Image image, ROI roi,
      DataMatrixGradingMode prepareForGrading, DataMatrixDescriptionOptions descriptionOptions,
      DataMatrixSizeOptions sizeOptions, DataMatrixSearchOptions searchOptions) {

    long jn_rv =
        _imaqReadDataMatrixBarcode2(image.getAddress(), roi.getAddress(),
            prepareForGrading.getValue(), descriptionOptions.getAddress(),
            sizeOptions.getAddress(), searchOptions.getAddress());

    return new DataMatrixReport(jn_rv, true);
  }

  private static native long _imaqReadDataMatrixBarcode2(long image, long roi,
      int prepareForGrading, long descriptionOptions, long sizeOptions, long searchOptions);

  public static class ReadPDF417BarcodeResult {
    public Barcode2DInfo[] array;
    private long array_addr;

    private ReadPDF417BarcodeResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numBarcodes;
      array_numBarcodes = rv_buf.getInt(0);
      array = new Barcode2DInfo[array_numBarcodes];
      if (array_numBarcodes > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numBarcodes * 64);
        for (int i = 0, off = 0; i < array_numBarcodes; i++, off += 64) {
          array[i] = new Barcode2DInfo(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static ReadPDF417BarcodeResult imaqReadPDF417Barcode(Image image, ROI roi,
      Barcode2DSearchMode searchMode) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqReadPDF417Barcode(image.getAddress(), roi.getAddress(), searchMode.getValue(),
            rv_addr + 0);
    ReadPDF417BarcodeResult rv = new ReadPDF417BarcodeResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqReadPDF417Barcode(long image, long roi, int searchMode,
      long numBarcodes);

  public static QRCodeReport imaqReadQRCode(Image image, ROI roi, QRGradingMode reserved,
      QRCodeDescriptionOptions descriptionOptions, QRCodeSizeOptions sizeOptions,
      QRCodeSearchOptions searchOptions) {

    long jn_rv =
        _imaqReadQRCode(image.getAddress(), roi.getAddress(), reserved.getValue(),
            descriptionOptions.getAddress(), sizeOptions.getAddress(), searchOptions.getAddress());

    return new QRCodeReport(jn_rv, true);
  }

  private static native long _imaqReadQRCode(long image, long roi, int reserved,
      long descriptionOptions, long sizeOptions, long searchOptions);

  /**
   * LCD functions
   */

  public static void imaqFindLCDSegments(ROI roi, Image image, LCDOptions options) {

    _imaqFindLCDSegments(roi.getAddress(), image.getAddress(),
        options == null ? 0 : options.getAddress());

  }

  private static native void _imaqFindLCDSegments(long roi, long image, long options);

  public static LCDReport imaqReadLCD(Image image, ROI roi, LCDOptions options) {

    long jn_rv =
        _imaqReadLCD(image.getAddress(), roi.getAddress(),
            options == null ? 0 : options.getAddress());

    return new LCDReport(jn_rv, true);
  }

  private static native long _imaqReadLCD(long image, long roi, long options);

  /**
   * Shape Matching functions
   */

  public static class MatchShapeResult {
    public ShapeReport[] array;
    private long array_addr;

    private MatchShapeResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numMatches;
      array_numMatches = rv_buf.getInt(0);
      array = new ShapeReport[array_numMatches];
      if (array_numMatches > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches * 40);
        for (int i = 0, off = 0; i < array_numMatches; i++, off += 40) {
          array[i] = new ShapeReport(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static MatchShapeResult imaqMatchShape(Image dest, Image source, Image templateImage,
      int scaleInvariant, int connectivity8, double tolerance) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqMatchShape(dest.getAddress(), source.getAddress(), templateImage.getAddress(),
            scaleInvariant, connectivity8, tolerance, rv_addr + 0);
    MatchShapeResult rv = new MatchShapeResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqMatchShape(long dest, long source, long templateImage,
      int scaleInvariant, int connectivity8, double tolerance, long numMatches);

  /**
   * Contours functions
   */

  public static int imaqAddAnnulusContour(ROI roi, Annulus annulus) {

    int jn_rv = _imaqAddAnnulusContour(roi.getAddress(), annulus.getAddress());

    return jn_rv;
  }

  private static native int _imaqAddAnnulusContour(long roi, long annulus);

  public static int imaqAddClosedContour(ROI roi, Point[] points) {
    int numPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    int jn_rv =
        _imaqAddClosedContour(roi.getAddress(), getByteBufferAddress(points_buf), numPoints);

    return jn_rv;
  }

  private static native int _imaqAddClosedContour(long roi, long points, int numPoints);

  public static int imaqAddLineContour(ROI roi, Point start, Point end) {

    int jn_rv = _imaqAddLineContour(roi.getAddress(), start.getAddress(), end.getAddress());

    return jn_rv;
  }

  private static native int _imaqAddLineContour(long roi, long start, long end);

  public static int imaqAddOpenContour(ROI roi, Point[] points) {
    int numPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    int jn_rv = _imaqAddOpenContour(roi.getAddress(), getByteBufferAddress(points_buf), numPoints);

    return jn_rv;
  }

  private static native int _imaqAddOpenContour(long roi, long points, int numPoints);

  public static int imaqAddOvalContour(ROI roi, Rect boundingBox) {

    int jn_rv = _imaqAddOvalContour(roi.getAddress(), boundingBox.getAddress());

    return jn_rv;
  }

  private static native int _imaqAddOvalContour(long roi, long boundingBox);

  public static int imaqAddPointContour(ROI roi, Point point) {

    int jn_rv = _imaqAddPointContour(roi.getAddress(), point.getAddress());

    return jn_rv;
  }

  private static native int _imaqAddPointContour(long roi, long point);

  public static int imaqAddRectContour(ROI roi, Rect rect) {

    int jn_rv = _imaqAddRectContour(roi.getAddress(), rect.getAddress());

    return jn_rv;
  }

  private static native int _imaqAddRectContour(long roi, long rect);

  public static int imaqAddRotatedRectContour2(ROI roi, RotatedRect rect) {

    int jn_rv = _imaqAddRotatedRectContour2(roi.getAddress(), rect.getAddress());

    return jn_rv;
  }

  private static native int _imaqAddRotatedRectContour2(long roi, long rect);

  public static int imaqCopyContour(ROI destRoi, ROI sourceRoi, int id) {

    int jn_rv = _imaqCopyContour(destRoi.getAddress(), sourceRoi.getAddress(), id);

    return jn_rv;
  }

  private static native int _imaqCopyContour(long destRoi, long sourceRoi, int id);

  public static int imaqGetContour(ROI roi, int index) {

    int jn_rv = _imaqGetContour(roi.getAddress(), index);

    return jn_rv;
  }

  private static native int _imaqGetContour(long roi, int index);

  public static RGBValue imaqGetContourColor(ROI roi, int id) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetContourColor(roi.getAddress(), id, rv_addr + 0);
    RGBValue contourColor;
    contourColor = new RGBValue(rv_buf, 0);
    contourColor.read();
    return contourColor;
  }

  private static native void _imaqGetContourColor(long roi, int id, long contourColor);

  public static void imaqGetContourCount(ROI roi) {

    _imaqGetContourCount(roi.getAddress());

  }

  private static native void _imaqGetContourCount(long roi);

  public static ContourInfo2 imaqGetContourInfo2(ROI roi, int id) {

    long jn_rv = _imaqGetContourInfo2(roi.getAddress(), id);

    return new ContourInfo2(jn_rv, true);
  }

  private static native long _imaqGetContourInfo2(long roi, int id);

  public static void imaqMoveContour(ROI roi, int id, int deltaX, int deltaY) {

    _imaqMoveContour(roi.getAddress(), id, deltaX, deltaY);

  }

  private static native void _imaqMoveContour(long roi, int id, int deltaX, int deltaY);

  public static void imaqRemoveContour(ROI roi, int id) {

    _imaqRemoveContour(roi.getAddress(), id);

  }

  private static native void _imaqRemoveContour(long roi, int id);

  public static void imaqSetContourColor(ROI roi, int id, RGBValue color) {

    _imaqSetContourColor(roi.getAddress(), id, color.getAddress());

  }

  private static native void _imaqSetContourColor(long roi, int id, long color);

  /**
   * Regions of Interest functions
   */

  public static ROI imaqCreateROI() {

    long jn_rv = _imaqCreateROI();

    return new ROI(jn_rv, true);
  }

  private static native long _imaqCreateROI();

  public static Rect imaqGetROIBoundingBox(ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetROIBoundingBox(roi.getAddress(), rv_addr + 0);
    Rect boundingBox;
    boundingBox = new Rect(rv_buf, 0);
    boundingBox.read();
    return boundingBox;
  }

  private static native void _imaqGetROIBoundingBox(long roi, long boundingBox);

  public static RGBValue imaqGetROIColor(ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetROIColor(roi.getAddress(), rv_addr + 0);
    RGBValue roiColor;
    roiColor = new RGBValue(rv_buf, 0);
    roiColor.read();
    return roiColor;
  }

  private static native void _imaqGetROIColor(long roi, long roiColor);

  public static void imaqSetROIColor(ROI roi, RGBValue color) {

    _imaqSetROIColor(roi.getAddress(), color.getAddress());

  }

  private static native void _imaqSetROIColor(long roi, long color);

  /**
   * Image Analysis functions
   */

  public static PointFloat imaqCentroid(Image image, Image mask) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqCentroid(image.getAddress(), rv_addr + 0, mask.getAddress());
    PointFloat centroid;
    centroid = new PointFloat(rv_buf, 0);
    centroid.read();
    return centroid;
  }

  private static native void _imaqCentroid(long image, long centroid, long mask);

  public static class ExtractCurvesResult {
    public Curve[] array;
    private long array_addr;

    private ExtractCurvesResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numCurves;
      array_numCurves = rv_buf.getInt(0);
      array = new Curve[array_numCurves];
      if (array_numCurves > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numCurves * 48);
        for (int i = 0, off = 0; i < array_numCurves; i++, off += 48) {
          array[i] = new Curve(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static ExtractCurvesResult imaqExtractCurves(Image image, ROI roi,
      CurveOptions curveOptions) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqExtractCurves(image.getAddress(), roi.getAddress(), curveOptions.getAddress(),
            rv_addr + 0);
    ExtractCurvesResult rv = new ExtractCurvesResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqExtractCurves(long image, long roi, long curveOptions,
      long numCurves);

  public static HistogramReport imaqHistogram(Image image, int numClasses, float min, float max,
      Image mask) {

    long jn_rv =
        _imaqHistogram(image.getAddress(), numClasses, min, max,
            mask == null ? 0 : mask.getAddress());

    return new HistogramReport(jn_rv, true);
  }

  private static native long _imaqHistogram(long image, int numClasses, float min, float max,
      long mask);

  public static LinearAverages imaqLinearAverages2(Image image, LinearAveragesMode mode, Rect rect) {

    long jn_rv = _imaqLinearAverages2(image.getAddress(), mode.getValue(), rect.getAddress());

    return new LinearAverages(jn_rv, true);
  }

  private static native long _imaqLinearAverages2(long image, int mode, long rect);

  public static LineProfile imaqLineProfile(Image image, Point start, Point end) {

    long jn_rv = _imaqLineProfile(image.getAddress(), start.getAddress(), end.getAddress());

    return new LineProfile(jn_rv, true);
  }

  private static native long _imaqLineProfile(long image, long start, long end);

  public static QuantifyReport imaqQuantify(Image image, Image mask) {

    long jn_rv = _imaqQuantify(image.getAddress(), mask == null ? 0 : mask.getAddress());

    return new QuantifyReport(jn_rv, true);
  }

  private static native long _imaqQuantify(long image, long mask);

  /**
   * Threshold functions
   */

  public static ThresholdData imaqAutoThreshold2(Image dest, Image source, int numClasses,
      ThresholdMethod method, Image mask) {

    long jn_rv =
        _imaqAutoThreshold2(dest.getAddress(), source.getAddress(), numClasses, method.getValue(),
            mask.getAddress());

    return new ThresholdData(jn_rv, true);
  }

  private static native long _imaqAutoThreshold2(long dest, long source, int numClasses,
      int method, long mask);

  public static void imaqLocalThreshold(Image dest, Image source, int windowWidth,
      int windowHeight, LocalThresholdMethod method, double deviationWeight, ObjectType type,
      float replaceValue) {

    _imaqLocalThreshold(dest.getAddress(), source.getAddress(), windowWidth, windowHeight,
        method.getValue(), deviationWeight, type.getValue(), replaceValue);

  }

  private static native void _imaqLocalThreshold(long dest, long source, int windowWidth,
      int windowHeight, int method, double deviationWeight, int type, float replaceValue);

  public static void imaqMagicWand(Image dest, Image source, Point coord, float tolerance,
      int connectivity8, float replaceValue) {

    _imaqMagicWand(dest.getAddress(), source.getAddress(), coord.getAddress(), tolerance,
        connectivity8, replaceValue);

  }

  private static native void _imaqMagicWand(long dest, long source, long coord, float tolerance,
      int connectivity8, float replaceValue);

  public static void imaqMultithreshold(Image dest, Image source, ThresholdData[] ranges) {
    int numRanges = ranges.length;
    ByteBuffer ranges_buf = null;
    ranges_buf = ByteBuffer.allocateDirect(ranges.length * 16).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < ranges.length; i++, off += 16) {
      ranges[i].setBuffer(ranges_buf, off);
      ranges[i].write();
    }
    _imaqMultithreshold(dest.getAddress(), source.getAddress(), getByteBufferAddress(ranges_buf),
        numRanges);

  }

  private static native void _imaqMultithreshold(long dest, long source, long ranges, int numRanges);

  public static void imaqThreshold(Image dest, Image source, float rangeMin, float rangeMax,
      int useNewValue, float newValue) {

    _imaqThreshold(dest.getAddress(), source.getAddress(), rangeMin, rangeMax, useNewValue,
        newValue);

  }

  private static native void _imaqThreshold(long dest, long source, float rangeMin, float rangeMax,
      int useNewValue, float newValue);

  /**
   * Memory Management functions
   */

  /**
   * Pattern Matching functions
   */

  public static class DetectCirclesResult {
    public CircleMatch[] array;
    private long array_addr;

    private DetectCirclesResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numMatchesReturned;
      array_numMatchesReturned = rv_buf.getInt(0);
      array = new CircleMatch[array_numMatchesReturned];
      if (array_numMatchesReturned > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatchesReturned * 24);
        for (int i = 0, off = 0; i < array_numMatchesReturned; i++, off += 24) {
          array[i] = new CircleMatch(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static DetectCirclesResult imaqDetectCircles(Image image,
      CircleDescriptor circleDescriptor, CurveOptions curveOptions,
      ShapeDetectionOptions shapeDetectionOptions, ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqDetectCircles(image.getAddress(), circleDescriptor.getAddress(),
            curveOptions.getAddress(), shapeDetectionOptions.getAddress(), roi.getAddress(),
            rv_addr + 0);
    DetectCirclesResult rv = new DetectCirclesResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqDetectCircles(long image, long circleDescriptor,
      long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned);

  public static class DetectEllipsesResult {
    public EllipseMatch[] array;
    private long array_addr;

    private DetectEllipsesResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numMatchesReturned;
      array_numMatchesReturned = rv_buf.getInt(0);
      array = new EllipseMatch[array_numMatchesReturned];
      if (array_numMatchesReturned > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatchesReturned * 40);
        for (int i = 0, off = 0; i < array_numMatchesReturned; i++, off += 40) {
          array[i] = new EllipseMatch(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static DetectEllipsesResult imaqDetectEllipses(Image image,
      EllipseDescriptor ellipseDescriptor, CurveOptions curveOptions,
      ShapeDetectionOptions shapeDetectionOptions, ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqDetectEllipses(image.getAddress(), ellipseDescriptor.getAddress(),
            curveOptions.getAddress(), shapeDetectionOptions.getAddress(), roi.getAddress(),
            rv_addr + 0);
    DetectEllipsesResult rv = new DetectEllipsesResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqDetectEllipses(long image, long ellipseDescriptor,
      long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned);

  public static class DetectLinesResult {
    public LineMatch[] array;
    private long array_addr;

    private DetectLinesResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numMatchesReturned;
      array_numMatchesReturned = rv_buf.getInt(0);
      array = new LineMatch[array_numMatchesReturned];
      if (array_numMatchesReturned > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatchesReturned * 40);
        for (int i = 0, off = 0; i < array_numMatchesReturned; i++, off += 40) {
          array[i] = new LineMatch(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static DetectLinesResult imaqDetectLines(Image image, LineDescriptor lineDescriptor,
      CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqDetectLines(image.getAddress(), lineDescriptor.getAddress(),
            curveOptions.getAddress(), shapeDetectionOptions.getAddress(), roi.getAddress(),
            rv_addr + 0);
    DetectLinesResult rv = new DetectLinesResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqDetectLines(long image, long lineDescriptor, long curveOptions,
      long shapeDetectionOptions, long roi, long numMatchesReturned);

  public static class DetectRectanglesResult {
    public RectangleMatch[] array;
    private long array_addr;

    private DetectRectanglesResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numMatchesReturned;
      array_numMatchesReturned = rv_buf.getInt(0);
      array = new RectangleMatch[array_numMatchesReturned];
      if (array_numMatchesReturned > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatchesReturned * 64);
        for (int i = 0, off = 0; i < array_numMatchesReturned; i++, off += 64) {
          array[i] = new RectangleMatch(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static DetectRectanglesResult imaqDetectRectangles(Image image,
      RectangleDescriptor rectangleDescriptor, CurveOptions curveOptions,
      ShapeDetectionOptions shapeDetectionOptions, ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqDetectRectangles(image.getAddress(), rectangleDescriptor.getAddress(),
            curveOptions.getAddress(), shapeDetectionOptions.getAddress(), roi.getAddress(),
            rv_addr + 0);
    DetectRectanglesResult rv = new DetectRectanglesResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqDetectRectangles(long image, long rectangleDescriptor,
      long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned);

  public static class GetGeometricFeaturesFromCurvesResult {
    public FeatureData[] array;
    private long array_addr;

    private GetGeometricFeaturesFromCurvesResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numFeatures;
      array_numFeatures = rv_buf.getInt(0);
      array = new FeatureData[array_numFeatures];
      if (array_numFeatures > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numFeatures * 16);
        for (int i = 0, off = 0; i < array_numFeatures; i++, off += 16) {
          array[i] = new FeatureData(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static GetGeometricFeaturesFromCurvesResult imaqGetGeometricFeaturesFromCurves(
      Curve[] curves, FeatureType[] featureTypes) {
    int numCurves = curves.length;
    ByteBuffer curves_buf = null;
    curves_buf = ByteBuffer.allocateDirect(curves.length * 48).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < curves.length; i++, off += 48) {
      curves[i].setBuffer(curves_buf, off);
      curves[i].write();
    }
    int numFeatureTypes = featureTypes.length;
    ByteBuffer featureTypes_buf = null;
    featureTypes_buf =
        ByteBuffer.allocateDirect(featureTypes.length * 4).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < featureTypes.length; i++, off += 4) {
      if (featureTypes != null)
        featureTypes_buf.putInt(off, featureTypes[i].getValue());
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqGetGeometricFeaturesFromCurves(getByteBufferAddress(curves_buf), numCurves,
            getByteBufferAddress(featureTypes_buf), numFeatureTypes, rv_addr + 0);
    GetGeometricFeaturesFromCurvesResult rv =
        new GetGeometricFeaturesFromCurvesResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqGetGeometricFeaturesFromCurves(long curves, int numCurves,
      long featureTypes, int numFeatureTypes, long numFeatures);

  public static class GetGeometricTemplateFeatureInfoResult {
    public FeatureData[] array;
    private long array_addr;

    private GetGeometricTemplateFeatureInfoResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numFeatures;
      array_numFeatures = rv_buf.getInt(0);
      array = new FeatureData[array_numFeatures];
      if (array_numFeatures > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numFeatures * 16);
        for (int i = 0, off = 0; i < array_numFeatures; i++, off += 16) {
          array[i] = new FeatureData(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static GetGeometricTemplateFeatureInfoResult imaqGetGeometricTemplateFeatureInfo(
      Image pattern) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv = _imaqGetGeometricTemplateFeatureInfo(pattern.getAddress(), rv_addr + 0);
    GetGeometricTemplateFeatureInfoResult rv =
        new GetGeometricTemplateFeatureInfoResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqGetGeometricTemplateFeatureInfo(long pattern, long numFeatures);

  public static void imaqLearnColorPattern(Image image, LearnColorPatternOptions options) {

    _imaqLearnColorPattern(image.getAddress(), options.getAddress());

  }

  private static native void _imaqLearnColorPattern(long image, long options);

  public static void imaqLearnGeometricPattern(Image image, PointFloat originOffset,
      CurveOptions curveOptions, LearnGeometricPatternAdvancedOptions advancedLearnOptions,
      Image mask) {

    _imaqLearnGeometricPattern(image.getAddress(), originOffset.getAddress(),
        curveOptions.getAddress(), advancedLearnOptions.getAddress(), mask.getAddress());

  }

  private static native void _imaqLearnGeometricPattern(long image, long originOffset,
      long curveOptions, long advancedLearnOptions, long mask);

  public static LearnPatternAdvancedOptions imaqLearnPattern3(Image image,
      LearningMode learningMode, Image mask) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqLearnPattern3(image.getAddress(), learningMode.getValue(), rv_addr + 0, mask.getAddress());
    LearnPatternAdvancedOptions advancedOptions;
    advancedOptions = new LearnPatternAdvancedOptions(rv_buf, 0);
    advancedOptions.read();
    return advancedOptions;
  }

  private static native void _imaqLearnPattern3(long image, int learningMode, long advancedOptions,
      long mask);

  public static class MatchColorPatternResult {
    public PatternMatch[] array;
    private long array_addr;

    private MatchColorPatternResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numMatches;
      array_numMatches = rv_buf.getInt(0);
      array = new PatternMatch[array_numMatches];
      if (array_numMatches > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches * 52);
        for (int i = 0, off = 0; i < array_numMatches; i++, off += 52) {
          array[i] = new PatternMatch(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static MatchColorPatternResult imaqMatchColorPattern(Image image, Image pattern,
      MatchColorPatternOptions options, Rect searchRect) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqMatchColorPattern(image.getAddress(), pattern.getAddress(), options.getAddress(),
            searchRect.getAddress(), rv_addr + 0);
    MatchColorPatternResult rv = new MatchColorPatternResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqMatchColorPattern(long image, long pattern, long options,
      long searchRect, long numMatches);

  public static class MatchGeometricPattern2Result {
    public GeometricPatternMatch2[] array;
    private long array_addr;

    private MatchGeometricPattern2Result(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numMatches;
      array_numMatches = rv_buf.getInt(0);
      array = new GeometricPatternMatch2[array_numMatches];
      if (array_numMatches > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches * 380);
        for (int i = 0, off = 0; i < array_numMatches; i++, off += 380) {
          array[i] = new GeometricPatternMatch2(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static MatchGeometricPattern2Result imaqMatchGeometricPattern2(Image image, Image pattern,
      CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions,
      MatchGeometricPatternAdvancedOptions2 advancedMatchOptions, ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqMatchGeometricPattern2(image.getAddress(), pattern.getAddress(),
            curveOptions.getAddress(), matchOptions.getAddress(),
            advancedMatchOptions.getAddress(), roi.getAddress(), rv_addr + 0);
    MatchGeometricPattern2Result rv = new MatchGeometricPattern2Result(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqMatchGeometricPattern2(long image, long pattern,
      long curveOptions, long matchOptions, long advancedMatchOptions, long roi, long numMatches);

  public static class MatchMultipleGeometricPatternsResult {
    public GeometricPatternMatch2[] array;
    private long array_addr;

    private MatchMultipleGeometricPatternsResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numMatches;
      array_numMatches = rv_buf.getInt(0);
      array = new GeometricPatternMatch2[array_numMatches];
      if (array_numMatches > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches * 380);
        for (int i = 0, off = 0; i < array_numMatches; i++, off += 380) {
          array[i] = new GeometricPatternMatch2(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static MatchMultipleGeometricPatternsResult imaqMatchMultipleGeometricPatterns(
      Image image, MultipleGeometricPattern multiplePattern, ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqMatchMultipleGeometricPatterns(image.getAddress(), multiplePattern.getAddress(),
            roi.getAddress(), rv_addr + 0);
    MatchMultipleGeometricPatternsResult rv =
        new MatchMultipleGeometricPatternsResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqMatchMultipleGeometricPatterns(long image, long multiplePattern,
      long roi, long numMatches);

  public static MultipleGeometricPattern imaqReadMultipleGeometricPatternFile(String fileName,
      String description) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    ByteBuffer description_buf = ByteBuffer.allocateDirect(256).order(ByteOrder.nativeOrder());
    if (description != null) {
      byte[] bytes;
      try {
        bytes = description.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        bytes = new byte[0];
      }
      putBytes(description_buf, bytes, 0, bytes.length);
      for (int i = bytes.length; i < 256; i++)
        description_buf.put(i, (byte) 0); // fill with zero
    }
    long jn_rv =
        _imaqReadMultipleGeometricPatternFile(fileName == null ? 0
            : getByteBufferAddress(fileName_buf), description == null ? 0
            : getByteBufferAddress(description_buf));

    return new MultipleGeometricPattern(jn_rv, true);
  }

  private static native long _imaqReadMultipleGeometricPatternFile(long fileName, long description);

  public static class RefineMatchesResult {
    public MatchPatternOptions options;
    public MatchPatternAdvancedOptions advancedOptions;
    public PatternMatch[] array;
    private long array_addr;

    private RefineMatchesResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      options = new MatchPatternOptions(rv_buf, 0);
      options.read();
      advancedOptions = new MatchPatternAdvancedOptions(rv_buf, 8);
      advancedOptions.read();
      int array_numCandidatesOut;
      array_numCandidatesOut = rv_buf.getInt(16);
      array = new PatternMatch[array_numCandidatesOut];
      if (array_numCandidatesOut > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numCandidatesOut * 52);
        for (int i = 0, off = 0; i < array_numCandidatesOut; i++, off += 52) {
          array[i] = new PatternMatch(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static RefineMatchesResult imaqRefineMatches(Image image, Image pattern,
      PatternMatch[] candidatesIn) {
    int numCandidatesIn = candidatesIn.length;
    ByteBuffer candidatesIn_buf = null;
    candidatesIn_buf =
        ByteBuffer.allocateDirect(candidatesIn.length * 52).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < candidatesIn.length; i++, off += 52) {
      candidatesIn[i].setBuffer(candidatesIn_buf, off);
      candidatesIn[i].write();
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqRefineMatches(image.getAddress(), pattern.getAddress(),
            getByteBufferAddress(candidatesIn_buf), numCandidatesIn, rv_addr + 0, rv_addr + 8,
            rv_addr + 16);
    RefineMatchesResult rv = new RefineMatchesResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqRefineMatches(long image, long pattern, long candidatesIn,
      int numCandidatesIn, long options, long advancedOptions, long numCandidatesOut);

  public static void imaqSetMultipleGeometricPatternsOptions(
      MultipleGeometricPattern multiplePattern, String label, CurveOptions curveOptions,
      MatchGeometricPatternOptions matchOptions,
      MatchGeometricPatternAdvancedOptions2 advancedMatchOptions) {
    ByteBuffer label_buf = null;
    if (label != null) {
      byte[] label_bytes;
      try {
        label_bytes = label.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        label_bytes = new byte[0];
      }
      label_buf = ByteBuffer.allocateDirect(label_bytes.length + 1);
      putBytes(label_buf, label_bytes, 0, label_bytes.length).put(label_bytes.length, (byte) 0);
    }
    _imaqSetMultipleGeometricPatternsOptions(multiplePattern.getAddress(), label == null ? 0
        : getByteBufferAddress(label_buf), curveOptions.getAddress(), matchOptions.getAddress(),
        advancedMatchOptions.getAddress());

  }

  private static native void _imaqSetMultipleGeometricPatternsOptions(long multiplePattern,
      long label, long curveOptions, long matchOptions, long advancedMatchOptions);

  public static void imaqWriteMultipleGeometricPatternFile(
      MultipleGeometricPattern multiplePattern, String fileName, String description) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    ByteBuffer description_buf = null;
    if (description != null) {
      byte[] description_bytes;
      try {
        description_bytes = description.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        description_bytes = new byte[0];
      }
      description_buf = ByteBuffer.allocateDirect(description_bytes.length + 1);
      putBytes(description_buf, description_bytes, 0, description_bytes.length).put(
          description_bytes.length, (byte) 0);
    }
    _imaqWriteMultipleGeometricPatternFile(multiplePattern.getAddress(), fileName == null ? 0
        : getByteBufferAddress(fileName_buf), description == null ? 0
        : getByteBufferAddress(description_buf));

  }

  private static native void _imaqWriteMultipleGeometricPatternFile(long multiplePattern,
      long fileName, long description);

  public static class MatchGeometricPattern3Result {
    public GeometricPatternMatch3[] array;
    private long array_addr;

    private MatchGeometricPattern3Result(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numMatches;
      array_numMatches = rv_buf.getInt(0);
      array = new GeometricPatternMatch3[array_numMatches];
      if (array_numMatches > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches * 116);
        for (int i = 0, off = 0; i < array_numMatches; i++, off += 116) {
          array[i] = new GeometricPatternMatch3(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static MatchGeometricPattern3Result imaqMatchGeometricPattern3(Image image, Image pattern,
      CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions,
      MatchGeometricPatternAdvancedOptions3 advancedMatchOptions, ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqMatchGeometricPattern3(image.getAddress(), pattern.getAddress(),
            curveOptions.getAddress(), matchOptions.getAddress(),
            advancedMatchOptions.getAddress(), roi.getAddress(), rv_addr + 0);
    MatchGeometricPattern3Result rv = new MatchGeometricPattern3Result(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqMatchGeometricPattern3(long image, long pattern,
      long curveOptions, long matchOptions, long advancedMatchOptions, long roi, long numMatches);

  public static void imaqLearnGeometricPattern2(Image image, PointFloat originOffset,
      double angleOffset, CurveOptions curveOptions,
      LearnGeometricPatternAdvancedOptions2 advancedLearnOptions, Image mask) {

    _imaqLearnGeometricPattern2(image.getAddress(), originOffset.getAddress(), angleOffset,
        curveOptions.getAddress(), advancedLearnOptions.getAddress(), mask.getAddress());

  }

  private static native void _imaqLearnGeometricPattern2(long image, long originOffset,
      double angleOffset, long curveOptions, long advancedLearnOptions, long mask);

  public static class MatchPattern3Result {
    public PatternMatch[] array;
    private long array_addr;

    private MatchPattern3Result(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numMatches;
      array_numMatches = rv_buf.getInt(0);
      array = new PatternMatch[array_numMatches];
      if (array_numMatches > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches * 52);
        for (int i = 0, off = 0; i < array_numMatches; i++, off += 52) {
          array[i] = new PatternMatch(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static MatchPattern3Result imaqMatchPattern3(Image image, Image pattern,
      MatchPatternOptions options, MatchPatternAdvancedOptions advancedOptions, ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqMatchPattern3(image.getAddress(), pattern.getAddress(),
            options == null ? 0 : options.getAddress(), advancedOptions.getAddress(),
            roi.getAddress(), rv_addr + 0);
    MatchPattern3Result rv = new MatchPattern3Result(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqMatchPattern3(long image, long pattern, long options,
      long advancedOptions, long roi, long numMatches);

  /**
   * Overlay functions
   */

  public static void imaqClearOverlay(Image image, String group) {
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqClearOverlay(image.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf));

  }

  private static native void _imaqClearOverlay(long image, long group);

  public static void imaqCopyOverlay(Image dest, Image source, String group) {
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqCopyOverlay(dest.getAddress(), source.getAddress(), group == null ? 0
        : getByteBufferAddress(group_buf));

  }

  private static native void _imaqCopyOverlay(long dest, long source, long group);

  public static TransformBehaviors imaqGetOverlayProperties(Image image, String group) {
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetOverlayProperties(image.getAddress(), group == null ? 0
        : getByteBufferAddress(group_buf), rv_addr + 0);
    TransformBehaviors transformBehaviors;
    transformBehaviors = new TransformBehaviors(rv_buf, 0);
    transformBehaviors.read();
    return transformBehaviors;
  }

  private static native void _imaqGetOverlayProperties(long image, long group,
      long transformBehaviors);

  public static void imaqMergeOverlay(Image dest, Image source, RGBValue[] palette, String group) {
    int numColors = palette.length;
    ByteBuffer palette_buf = null;
    palette_buf = ByteBuffer.allocateDirect(palette.length * 4).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < palette.length; i++, off += 4) {
      palette[i].setBuffer(palette_buf, off);
      palette[i].write();
    }
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqMergeOverlay(dest.getAddress(), source.getAddress(), getByteBufferAddress(palette_buf),
        numColors, group == null ? 0 : getByteBufferAddress(group_buf));

  }

  private static native void _imaqMergeOverlay(long dest, long source, long palette, int numColors,
      long group);

  public static void imaqOverlayArc(Image image, ArcInfo arc, RGBValue color, DrawMode drawMode,
      String group) {
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqOverlayArc(image.getAddress(), arc.getAddress(), color.getAddress(), drawMode.getValue(),
        group == null ? 0 : getByteBufferAddress(group_buf));

  }

  private static native void _imaqOverlayArc(long image, long arc, long color, int drawMode,
      long group);

  public static void imaqOverlayBitmap(Image image, Point destLoc, RGBValue bitmap, int numCols,
      int numRows, String group) {
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqOverlayBitmap(image.getAddress(), destLoc.getAddress(), bitmap.getAddress(), numCols,
        numRows, group == null ? 0 : getByteBufferAddress(group_buf));

  }

  private static native void _imaqOverlayBitmap(long image, long destLoc, long bitmap, int numCols,
      int numRows, long group);

  public static void imaqOverlayClosedContour(Image image, Point[] points, RGBValue color,
      DrawMode drawMode, String group) {
    int numPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqOverlayClosedContour(image.getAddress(), getByteBufferAddress(points_buf), numPoints,
        color.getAddress(), drawMode.getValue(), group == null ? 0
            : getByteBufferAddress(group_buf));

  }

  private static native void _imaqOverlayClosedContour(long image, long points, int numPoints,
      long color, int drawMode, long group);

  public static void imaqOverlayLine(Image image, Point start, Point end, RGBValue color,
      String group) {
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqOverlayLine(image.getAddress(), start.getAddress(), end.getAddress(), color.getAddress(),
        group == null ? 0 : getByteBufferAddress(group_buf));

  }

  private static native void _imaqOverlayLine(long image, long start, long end, long color,
      long group);

  public static void imaqOverlayOpenContour(Image image, Point[] points, RGBValue color,
      String group) {
    int numPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqOverlayOpenContour(image.getAddress(), getByteBufferAddress(points_buf), numPoints,
        color.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf));

  }

  private static native void _imaqOverlayOpenContour(long image, long points, int numPoints,
      long color, long group);

  public static byte imaqOverlayOval(Image image, Rect boundingBox, RGBValue color,
      DrawMode drawMode) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqOverlayOval(image.getAddress(), boundingBox.getAddress(), color.getAddress(),
        drawMode.getValue(), rv_addr + 0);
    byte group;
    group = rv_buf.get(0);
    return group;
  }

  private static native void _imaqOverlayOval(long image, long boundingBox, long color,
      int drawMode, long group);

  public static void imaqOverlayPoints(Image image, Point[] points, RGBValue[] colors,
      PointSymbol symbol, UserPointSymbol userSymbol, String group) {
    int numPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    int numColors = colors.length;
    ByteBuffer colors_buf = null;
    colors_buf = ByteBuffer.allocateDirect(colors.length * 4).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < colors.length; i++, off += 4) {
      colors[i].setBuffer(colors_buf, off);
      colors[i].write();
    }
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqOverlayPoints(image.getAddress(), getByteBufferAddress(points_buf), numPoints,
        getByteBufferAddress(colors_buf), numColors, symbol.getValue(), userSymbol.getAddress(),
        group == null ? 0 : getByteBufferAddress(group_buf));

  }

  private static native void _imaqOverlayPoints(long image, long points, int numPoints,
      long colors, int numColors, int symbol, long userSymbol, long group);

  public static void imaqOverlayRect(Image image, Rect rect, RGBValue color, DrawMode drawMode,
      String group) {
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqOverlayRect(image.getAddress(), rect.getAddress(), color.getAddress(),
        drawMode.getValue(), group == null ? 0 : getByteBufferAddress(group_buf));

  }

  private static native void _imaqOverlayRect(long image, long rect, long color, int drawMode,
      long group);

  public static void imaqOverlayROI(Image image, ROI roi, PointSymbol symbol,
      UserPointSymbol userSymbol, String group) {
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqOverlayROI(image.getAddress(), roi.getAddress(), symbol.getValue(),
        userSymbol.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf));

  }

  private static native void _imaqOverlayROI(long image, long roi, int symbol, long userSymbol,
      long group);

  public static void imaqOverlayText(Image image, Point origin, String text, RGBValue color,
      OverlayTextOptions options, String group) {
    ByteBuffer text_buf = null;
    if (text != null) {
      byte[] text_bytes;
      try {
        text_bytes = text.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        text_bytes = new byte[0];
      }
      text_buf = ByteBuffer.allocateDirect(text_bytes.length + 1);
      putBytes(text_buf, text_bytes, 0, text_bytes.length).put(text_bytes.length, (byte) 0);
    }
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    _imaqOverlayText(image.getAddress(), origin.getAddress(), text == null ? 0
        : getByteBufferAddress(text_buf), color.getAddress(), options.getAddress(),
        group == null ? 0 : getByteBufferAddress(group_buf));

  }

  private static native void _imaqOverlayText(long image, long origin, long text, long color,
      long options, long group);

  public static TransformBehaviors imaqSetOverlayProperties(Image image, String group) {
    ByteBuffer group_buf = null;
    if (group != null) {
      byte[] group_bytes;
      try {
        group_bytes = group.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        group_bytes = new byte[0];
      }
      group_buf = ByteBuffer.allocateDirect(group_bytes.length + 1);
      putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqSetOverlayProperties(image.getAddress(), group == null ? 0
        : getByteBufferAddress(group_buf), rv_addr + 0);
    TransformBehaviors transformBehaviors;
    transformBehaviors = new TransformBehaviors(rv_buf, 0);
    transformBehaviors.read();
    return transformBehaviors;
  }

  private static native void _imaqSetOverlayProperties(long image, long group,
      long transformBehaviors);

  /**
   * OCR functions
   */

  public static CharSet imaqCreateCharSet() {

    long jn_rv = _imaqCreateCharSet();

    return new CharSet(jn_rv, true);
  }

  private static native long _imaqCreateCharSet();

  public static void imaqDeleteChar(CharSet set, int index) {

    _imaqDeleteChar(set.getAddress(), index);

  }

  private static native void _imaqDeleteChar(long set, int index);

  public static void imaqGetCharCount(CharSet set) {

    _imaqGetCharCount(set.getAddress());

  }

  private static native void _imaqGetCharCount(long set);

  public static CharInfo2 imaqGetCharInfo2(CharSet set, int index) {

    long jn_rv = _imaqGetCharInfo2(set.getAddress(), index);

    return new CharInfo2(jn_rv, true);
  }

  private static native long _imaqGetCharInfo2(long set, int index);

  public static class ReadOCRFileResult {
    public ReadTextOptions readOptions;
    public OCRProcessingOptions processingOptions;
    public OCRSpacingOptions spacingOptions;

    private ReadOCRFileResult(ByteBuffer rv_buf) {
      readOptions = new ReadTextOptions(rv_buf, 0);
      readOptions.read();
      processingOptions = new OCRProcessingOptions(rv_buf, 8);
      processingOptions.read();
      spacingOptions = new OCRSpacingOptions(rv_buf, 16);
      spacingOptions.read();
    }
  }

  public static ReadOCRFileResult imaqReadOCRFile(String fileName, CharSet set,
      String setDescription) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    ByteBuffer setDescription_buf = ByteBuffer.allocateDirect(256).order(ByteOrder.nativeOrder());
    if (setDescription != null) {
      byte[] bytes;
      try {
        bytes = setDescription.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        bytes = new byte[0];
      }
      putBytes(setDescription_buf, bytes, 0, bytes.length);
      for (int i = bytes.length; i < 256; i++)
        setDescription_buf.put(i, (byte) 0); // fill with zero
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqReadOCRFile(fileName == null ? 0 : getByteBufferAddress(fileName_buf), set.getAddress(),
        setDescription == null ? 0 : getByteBufferAddress(setDescription_buf), rv_addr + 0,
        rv_addr + 8, rv_addr + 16);
    ReadOCRFileResult rv = new ReadOCRFileResult(rv_buf);
    return rv;
  }

  private static native void _imaqReadOCRFile(long fileName, long set, long setDescription,
      long readOptions, long processingOptions, long spacingOptions);

  public static ReadTextReport3 imaqReadText3(Image image, CharSet set, ROI roi,
      ReadTextOptions readOptions, OCRProcessingOptions processingOptions,
      OCRSpacingOptions spacingOptions) {

    long jn_rv =
        _imaqReadText3(image.getAddress(), set.getAddress(), roi.getAddress(),
            readOptions.getAddress(), processingOptions.getAddress(), spacingOptions.getAddress());

    return new ReadTextReport3(jn_rv, true);
  }

  private static native long _imaqReadText3(long image, long set, long roi, long readOptions,
      long processingOptions, long spacingOptions);

  public static void imaqRenameChar(CharSet set, int index, String newCharValue) {
    ByteBuffer newCharValue_buf = null;
    if (newCharValue != null) {
      byte[] newCharValue_bytes;
      try {
        newCharValue_bytes = newCharValue.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        newCharValue_bytes = new byte[0];
      }
      newCharValue_buf = ByteBuffer.allocateDirect(newCharValue_bytes.length + 1);
      putBytes(newCharValue_buf, newCharValue_bytes, 0, newCharValue_bytes.length).put(
          newCharValue_bytes.length, (byte) 0);
    }
    _imaqRenameChar(set.getAddress(), index, newCharValue == null ? 0
        : getByteBufferAddress(newCharValue_buf));

  }

  private static native void _imaqRenameChar(long set, int index, long newCharValue);

  public static void imaqSetReferenceChar(CharSet set, int index, int isReferenceChar) {

    _imaqSetReferenceChar(set.getAddress(), index, isReferenceChar);

  }

  private static native void _imaqSetReferenceChar(long set, int index, int isReferenceChar);

  public static void imaqTrainChars(Image image, CharSet set, int index, String charValue, ROI roi,
      OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions) {
    ByteBuffer charValue_buf = null;
    if (charValue != null) {
      byte[] charValue_bytes;
      try {
        charValue_bytes = charValue.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        charValue_bytes = new byte[0];
      }
      charValue_buf = ByteBuffer.allocateDirect(charValue_bytes.length + 1);
      putBytes(charValue_buf, charValue_bytes, 0, charValue_bytes.length).put(
          charValue_bytes.length, (byte) 0);
    }
    _imaqTrainChars(image.getAddress(), set.getAddress(), index, charValue == null ? 0
        : getByteBufferAddress(charValue_buf), roi.getAddress(), processingOptions.getAddress(),
        spacingOptions.getAddress());

  }

  private static native void _imaqTrainChars(long image, long set, int index, long charValue,
      long roi, long processingOptions, long spacingOptions);

  public static class VerifyTextResult {
    public int[] array;
    private long array_addr;

    private VerifyTextResult(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numScores;
      array_numScores = rv_buf.getInt(0);
      array = new int[array_numScores];
      if (array_numScores > 0 && array_addr != 0) {
        newDirectByteBuffer(array_addr, array_numScores * 4).asIntBuffer().get(array);
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static VerifyTextResult imaqVerifyText(Image image, CharSet set, String expectedString,
      ROI roi) {
    ByteBuffer expectedString_buf = null;
    if (expectedString != null) {
      byte[] expectedString_bytes;
      try {
        expectedString_bytes = expectedString.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        expectedString_bytes = new byte[0];
      }
      expectedString_buf = ByteBuffer.allocateDirect(expectedString_bytes.length + 1);
      putBytes(expectedString_buf, expectedString_bytes, 0, expectedString_bytes.length).put(
          expectedString_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqVerifyText(image.getAddress(), set.getAddress(), expectedString == null ? 0
            : getByteBufferAddress(expectedString_buf), roi.getAddress(), rv_addr + 0);
    VerifyTextResult rv = new VerifyTextResult(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqVerifyText(long image, long set, long expectedString, long roi,
      long numScores);

  public static void imaqWriteOCRFile(String fileName, CharSet set, String setDescription,
      ReadTextOptions readOptions, OCRProcessingOptions processingOptions,
      OCRSpacingOptions spacingOptions) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    ByteBuffer setDescription_buf = null;
    if (setDescription != null) {
      byte[] setDescription_bytes;
      try {
        setDescription_bytes = setDescription.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        setDescription_bytes = new byte[0];
      }
      setDescription_buf = ByteBuffer.allocateDirect(setDescription_bytes.length + 1);
      putBytes(setDescription_buf, setDescription_bytes, 0, setDescription_bytes.length).put(
          setDescription_bytes.length, (byte) 0);
    }
    _imaqWriteOCRFile(fileName == null ? 0 : getByteBufferAddress(fileName_buf), set.getAddress(),
        setDescription == null ? 0 : getByteBufferAddress(setDescription_buf),
        readOptions.getAddress(), processingOptions.getAddress(), spacingOptions.getAddress());

  }

  private static native void _imaqWriteOCRFile(long fileName, long set, long setDescription,
      long readOptions, long processingOptions, long spacingOptions);

  /**
   * Geometric Matching functions
   */

  public static class ExtractContourResult {
    public CurveParameters curveParams;
    public ExtractContourReport val;

    private ExtractContourResult(ByteBuffer rv_buf) {
      curveParams = new CurveParameters(rv_buf, 0);
      curveParams.read();
    }
  }

  public static ExtractContourResult imaqExtractContour(Image image, ROI roi,
      ExtractContourDirection direction, ConnectionConstraint connectionConstraintParams,
      int numOfConstraints, ExtractContourSelection selection, Image contourImage) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqExtractContour(image.getAddress(), roi.getAddress(), direction.getValue(),
            rv_addr + 0, connectionConstraintParams.getAddress(), numOfConstraints,
            selection.getValue(), contourImage.getAddress());
    ExtractContourResult rv = new ExtractContourResult(rv_buf);
    rv.val = new ExtractContourReport(jn_rv, true);
    return rv;
  }

  private static native long _imaqExtractContour(long image, long roi, int direction,
      long curveParams, long connectionConstraintParams, int numOfConstraints, int selection,
      long contourImage);

  public static void imaqContourOverlay(Image image, Image contourImage,
      ContourOverlaySettings pointsSettings, ContourOverlaySettings eqnSettings, String groupName) {
    ByteBuffer groupName_buf = null;
    if (groupName != null) {
      byte[] groupName_bytes;
      try {
        groupName_bytes = groupName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        groupName_bytes = new byte[0];
      }
      groupName_buf = ByteBuffer.allocateDirect(groupName_bytes.length + 1);
      putBytes(groupName_buf, groupName_bytes, 0, groupName_bytes.length).put(
          groupName_bytes.length, (byte) 0);
    }
    _imaqContourOverlay(image.getAddress(), contourImage.getAddress(), pointsSettings.getAddress(),
        eqnSettings.getAddress(), groupName == null ? 0 : getByteBufferAddress(groupName_buf));

  }

  private static native void _imaqContourOverlay(long image, long contourImage,
      long pointsSettings, long eqnSettings, long groupName);

  public static ContourComputeCurvatureReport imaqContourComputeCurvature(Image contourImage,
      int kernel) {

    long jn_rv = _imaqContourComputeCurvature(contourImage.getAddress(), kernel);

    return new ContourComputeCurvatureReport(jn_rv, true);
  }

  private static native long _imaqContourComputeCurvature(long contourImage, int kernel);

  public static CurvatureAnalysisReport imaqContourClassifyCurvature(Image contourImage,
      int kernel, RangeLabel[] curvatureClasses) {
    int numCurvatureClasses = curvatureClasses.length;
    ByteBuffer curvatureClasses_buf = null;
    curvatureClasses_buf =
        ByteBuffer.allocateDirect(curvatureClasses.length * 24).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < curvatureClasses.length; i++, off += 24) {
      curvatureClasses[i].setBuffer(curvatureClasses_buf, off);
      curvatureClasses[i].write();
    }
    long jn_rv =
        _imaqContourClassifyCurvature(contourImage.getAddress(), kernel,
            getByteBufferAddress(curvatureClasses_buf), numCurvatureClasses);

    return new CurvatureAnalysisReport(jn_rv, true);
  }

  private static native long _imaqContourClassifyCurvature(long contourImage, int kernel,
      long curvatureClasses, int numCurvatureClasses);

  public static ComputeDistancesReport imaqContourComputeDistances(Image targetImage,
      Image templateImage, SetupMatchPatternData matchSetupData, int smoothingKernel) {

    long jn_rv =
        _imaqContourComputeDistances(targetImage.getAddress(), templateImage.getAddress(),
            matchSetupData.getAddress(), smoothingKernel);

    return new ComputeDistancesReport(jn_rv, true);
  }

  private static native long _imaqContourComputeDistances(long targetImage, long templateImage,
      long matchSetupData, int smoothingKernel);

  public static ClassifyDistancesReport imaqContourClassifyDistances(Image targetImage,
      Image templateImage, SetupMatchPatternData matchSetupData, int smoothingKernel,
      RangeLabel[] distanceRanges) {
    int numDistanceRanges = distanceRanges.length;
    ByteBuffer distanceRanges_buf = null;
    distanceRanges_buf =
        ByteBuffer.allocateDirect(distanceRanges.length * 24).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < distanceRanges.length; i++, off += 24) {
      distanceRanges[i].setBuffer(distanceRanges_buf, off);
      distanceRanges[i].write();
    }
    long jn_rv =
        _imaqContourClassifyDistances(targetImage.getAddress(), templateImage.getAddress(),
            matchSetupData.getAddress(), smoothingKernel, getByteBufferAddress(distanceRanges_buf),
            numDistanceRanges);

    return new ClassifyDistancesReport(jn_rv, true);
  }

  private static native long _imaqContourClassifyDistances(long targetImage, long templateImage,
      long matchSetupData, int smoothingKernel, long distanceRanges, int numDistanceRanges);

  public static ContourInfoReport imaqContourInfo(Image contourImage) {

    long jn_rv = _imaqContourInfo(contourImage.getAddress());

    return new ContourInfoReport(jn_rv, true);
  }

  private static native long _imaqContourInfo(long contourImage);

  public static class ContourSetupMatchPatternResult {
    public MatchMode matchMode;
    public CurveParameters curveParams;
    public SetupMatchPatternData val;

    private ContourSetupMatchPatternResult(ByteBuffer rv_buf) {
      matchMode = new MatchMode(rv_buf, 0);
      matchMode.read();
      curveParams = new CurveParameters(rv_buf, 8);
      curveParams.read();
    }
  }

  public static ContourSetupMatchPatternResult imaqContourSetupMatchPattern(
      int enableSubPixelAccuracy, int useLearnCurveParameters, RangeSettingDouble[] rangeSettings) {
    int numRangeSettings = rangeSettings.length;
    ByteBuffer rangeSettings_buf = null;
    rangeSettings_buf =
        ByteBuffer.allocateDirect(rangeSettings.length * 24).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < rangeSettings.length; i++, off += 24) {
      rangeSettings[i].setBuffer(rangeSettings_buf, off);
      rangeSettings[i].write();
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqContourSetupMatchPattern(rv_addr + 0, enableSubPixelAccuracy, rv_addr + 8,
            useLearnCurveParameters, getByteBufferAddress(rangeSettings_buf), numRangeSettings);
    ContourSetupMatchPatternResult rv = new ContourSetupMatchPatternResult(rv_buf);
    rv.val = new SetupMatchPatternData(jn_rv, true);
    return rv;
  }

  private static native long _imaqContourSetupMatchPattern(long matchMode,
      int enableSubPixelAccuracy, long curveParams, int useLearnCurveParameters,
      long rangeSettings, int numRangeSettings);

  public static SetupMatchPatternData imaqContourAdvancedSetupMatchPattern(
      GeometricAdvancedSetupDataOption[] geometricOptions) {
    int numGeometricOptions = geometricOptions.length;
    ByteBuffer geometricOptions_buf = null;
    geometricOptions_buf =
        ByteBuffer.allocateDirect(geometricOptions.length * 16).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < geometricOptions.length; i++, off += 16) {
      geometricOptions[i].setBuffer(geometricOptions_buf, off);
      geometricOptions[i].write();
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqContourAdvancedSetupMatchPattern(rv_addr + 0, getByteBufferAddress(geometricOptions_buf),
        numGeometricOptions);
    SetupMatchPatternData matchSetupData;
    matchSetupData = new SetupMatchPatternData(rv_buf, 0);
    matchSetupData.read();
    return matchSetupData;
  }

  private static native void _imaqContourAdvancedSetupMatchPattern(long matchSetupData,
      long geometricOptions, int numGeometricOptions);

  public static ContourFitLineReport imaqContourFitLine(Image image, double pixelRadius) {

    long jn_rv = _imaqContourFitLine(image.getAddress(), pixelRadius);

    return new ContourFitLineReport(jn_rv, true);
  }

  private static native long _imaqContourFitLine(long image, double pixelRadius);

  public static PartialCircle imaqContourFitCircle(Image image, double pixelRadius,
      int rejectOutliers) {

    long jn_rv = _imaqContourFitCircle(image.getAddress(), pixelRadius, rejectOutliers);

    return new PartialCircle(jn_rv, true);
  }

  private static native long _imaqContourFitCircle(long image, double pixelRadius,
      int rejectOutliers);

  public static PartialEllipse imaqContourFitEllipse(Image image, double pixelRadius,
      int rejectOutliers) {

    long jn_rv = _imaqContourFitEllipse(image.getAddress(), pixelRadius, rejectOutliers);

    return new PartialEllipse(jn_rv, true);
  }

  private static native long _imaqContourFitEllipse(long image, double pixelRadius,
      int rejectOutliers);

  public static ContourFitSplineReport imaqContourFitSpline(Image image, int degree,
      int numberOfControlPoints) {

    long jn_rv = _imaqContourFitSpline(image.getAddress(), degree, numberOfControlPoints);

    return new ContourFitSplineReport(jn_rv, true);
  }

  private static native long _imaqContourFitSpline(long image, int degree, int numberOfControlPoints);

  public static ContourFitPolynomialReport imaqContourFitPolynomial(Image image, int order) {

    long jn_rv = _imaqContourFitPolynomial(image.getAddress(), order);

    return new ContourFitPolynomialReport(jn_rv, true);
  }

  private static native long _imaqContourFitPolynomial(long image, int order);

  /**
   * Edge Detection functions
   */

  public static FindCircularEdgeReport imaqFindCircularEdge2(Image image, ROI roi,
      CoordinateSystem baseSystem, CoordinateSystem newSystem, FindCircularEdgeOptions edgeOptions,
      CircleFitOptions circleFitOptions) {

    long jn_rv =
        _imaqFindCircularEdge2(image.getAddress(), roi.getAddress(), baseSystem.getAddress(),
            newSystem.getAddress(), edgeOptions.getAddress(), circleFitOptions.getAddress());

    return new FindCircularEdgeReport(jn_rv, true);
  }

  private static native long _imaqFindCircularEdge2(long image, long roi, long baseSystem,
      long newSystem, long edgeOptions, long circleFitOptions);

  public static FindConcentricEdgeReport imaqFindConcentricEdge2(Image image, ROI roi,
      CoordinateSystem baseSystem, CoordinateSystem newSystem,
      FindConcentricEdgeOptions edgeOptions, ConcentricEdgeFitOptions concentricEdgeFitOptions) {

    long jn_rv =
        _imaqFindConcentricEdge2(image.getAddress(), roi.getAddress(), baseSystem.getAddress(),
            newSystem.getAddress(), edgeOptions.getAddress(), concentricEdgeFitOptions.getAddress());

    return new FindConcentricEdgeReport(jn_rv, true);
  }

  private static native long _imaqFindConcentricEdge2(long image, long roi, long baseSystem,
      long newSystem, long edgeOptions, long concentricEdgeFitOptions);

  /**
   * Morphology Reconstruction functions
   */

  public static void imaqGrayMorphologyReconstruct(Image dstImage, Image srcImage,
      Image markerImage, PointFloat[] points, MorphologyReconstructOperation operation,
      StructuringElement structuringElement, ROI roi) {
    int numOfPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    _imaqGrayMorphologyReconstruct(dstImage.getAddress(), srcImage.getAddress(),
        markerImage.getAddress(), getByteBufferAddress(points_buf), numOfPoints,
        operation.getValue(), structuringElement.getAddress(), roi.getAddress());

  }

  private static native void _imaqGrayMorphologyReconstruct(long dstImage, long srcImage,
      long markerImage, long points, int numOfPoints, int operation, long structuringElement,
      long roi);

  public static void imaqMorphologyReconstruct(Image dstImage, Image srcImage, Image markerImage,
      PointFloat[] points, MorphologyReconstructOperation operation, Connectivity connectivity,
      ROI roi) {
    int numOfPoints = points.length;
    ByteBuffer points_buf = null;
    points_buf = ByteBuffer.allocateDirect(points.length * 8).order(ByteOrder.nativeOrder());
    for (int i = 0, off = 0; i < points.length; i++, off += 8) {
      points[i].setBuffer(points_buf, off);
      points[i].write();
    }
    _imaqMorphologyReconstruct(dstImage.getAddress(), srcImage.getAddress(),
        markerImage.getAddress(), getByteBufferAddress(points_buf), numOfPoints,
        operation.getValue(), connectivity.getValue(), roi.getAddress());

  }

  private static native void _imaqMorphologyReconstruct(long dstImage, long srcImage,
      long markerImage, long points, int numOfPoints, int operation, int connectivity, long roi);

  /**
   * Texture functions
   */

  public static void imaqDetectTextureDefect(ClassifierSession session, Image destImage,
      Image srcImage, ROI roi, int initialStepSize, int finalStepSize, short defectPixelValue,
      double minClassificationScore) {

    _imaqDetectTextureDefect(session.getAddress(), destImage.getAddress(), srcImage.getAddress(),
        roi.getAddress(), initialStepSize, finalStepSize, defectPixelValue, minClassificationScore);

  }

  private static native void _imaqDetectTextureDefect(long session, long destImage, long srcImage,
      long roi, int initialStepSize, int finalStepSize, short defectPixelValue,
      double minClassificationScore);

  /**
   * Regions of Interest Manipulation functions
   */

  public static class MaskToROIResult {
    public int withinLimit;
    public ROI val;

    private MaskToROIResult(ByteBuffer rv_buf) {
      withinLimit = rv_buf.getInt(0);
    }
  }

  public static MaskToROIResult imaqMaskToROI(Image mask) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv = _imaqMaskToROI(mask.getAddress(), rv_addr + 0);
    MaskToROIResult rv = new MaskToROIResult(rv_buf);
    rv.val = new ROI(jn_rv, true);
    return rv;
  }

  private static native long _imaqMaskToROI(long mask, long withinLimit);

  public static ROIProfile imaqROIProfile(Image image, ROI roi) {

    long jn_rv = _imaqROIProfile(image.getAddress(), roi.getAddress());

    return new ROIProfile(jn_rv, true);
  }

  private static native long _imaqROIProfile(long image, long roi);

  public static int imaqROIToMask(Image mask, ROI roi, int fillValue, Image imageModel) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqROIToMask(mask.getAddress(), roi.getAddress(), fillValue, imageModel == null ? 0
        : imageModel.getAddress(), rv_addr + 0);
    int inSpace;
    inSpace = rv_buf.getInt(0);
    return inSpace;
  }

  private static native void _imaqROIToMask(long mask, long roi, int fillValue, long imageModel,
      long inSpace);

  public static void imaqTransformROI2(ROI roi, CoordinateSystem baseSystem,
      CoordinateSystem newSystem) {

    _imaqTransformROI2(roi.getAddress(), baseSystem.getAddress(), newSystem.getAddress());

  }

  private static native void _imaqTransformROI2(long roi, long baseSystem, long newSystem);

  public static LabelToROIReport imaqLabelToROI(Image image, int[] labelsIn, int maxNumVectors,
      int isExternelEdges) {
    int numLabelsIn = labelsIn.length;
    ByteBuffer labelsIn_buf = null;
    labelsIn_buf = ByteBuffer.allocateDirect(labelsIn.length * 4).order(ByteOrder.nativeOrder());
    labelsIn_buf.asIntBuffer().put(labelsIn).rewind();
    long jn_rv =
        _imaqLabelToROI(image.getAddress(), getByteBufferAddress(labelsIn_buf), numLabelsIn,
            maxNumVectors, isExternelEdges);

    return new LabelToROIReport(jn_rv, true);
  }

  private static native long _imaqLabelToROI(long image, long labelsIn, int numLabelsIn,
      int maxNumVectors, int isExternelEdges);

  /**
   * Morphology functions
   */

  public static void imaqGrayMorphology(Image dest, Image source, MorphologyMethod method,
      StructuringElement structuringElement) {

    _imaqGrayMorphology(dest.getAddress(), source.getAddress(), method.getValue(),
        structuringElement == null ? 0 : structuringElement.getAddress());

  }

  private static native void _imaqGrayMorphology(long dest, long source, int method,
      long structuringElement);

  /**
   * Classification functions
   */

  public static void imaqAddClassifierSample(Image image, ClassifierSession session, ROI roi,
      String sampleClass, double[] featureVector) {
    ByteBuffer sampleClass_buf = null;
    if (sampleClass != null) {
      byte[] sampleClass_bytes;
      try {
        sampleClass_bytes = sampleClass.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        sampleClass_bytes = new byte[0];
      }
      sampleClass_buf = ByteBuffer.allocateDirect(sampleClass_bytes.length + 1);
      putBytes(sampleClass_buf, sampleClass_bytes, 0, sampleClass_bytes.length).put(
          sampleClass_bytes.length, (byte) 0);
    }
    int vectorSize = featureVector.length;
    ByteBuffer featureVector_buf = null;
    featureVector_buf =
        ByteBuffer.allocateDirect(featureVector.length * 8).order(ByteOrder.nativeOrder());
    featureVector_buf.asDoubleBuffer().put(featureVector).rewind();
    _imaqAddClassifierSample(image.getAddress(), session.getAddress(), roi.getAddress(),
        sampleClass == null ? 0 : getByteBufferAddress(sampleClass_buf),
        getByteBufferAddress(featureVector_buf), vectorSize);

  }

  private static native void _imaqAddClassifierSample(long image, long session, long roi,
      long sampleClass, long featureVector, int vectorSize);

  public static ClassifierReportAdvanced imaqAdvanceClassify(Image image,
      ClassifierSession session, ROI roi, double[] featureVector) {
    int vectorSize = featureVector.length;
    ByteBuffer featureVector_buf = null;
    featureVector_buf =
        ByteBuffer.allocateDirect(featureVector.length * 8).order(ByteOrder.nativeOrder());
    featureVector_buf.asDoubleBuffer().put(featureVector).rewind();
    long jn_rv =
        _imaqAdvanceClassify(image.getAddress(), session.getAddress(), roi.getAddress(),
            getByteBufferAddress(featureVector_buf), vectorSize);

    return new ClassifierReportAdvanced(jn_rv, true);
  }

  private static native long _imaqAdvanceClassify(long image, long session, long roi,
      long featureVector, int vectorSize);

  public static ClassifierReport imaqClassify(Image image, ClassifierSession session, ROI roi,
      double[] featureVector) {
    int vectorSize = featureVector.length;
    ByteBuffer featureVector_buf = null;
    featureVector_buf =
        ByteBuffer.allocateDirect(featureVector.length * 8).order(ByteOrder.nativeOrder());
    featureVector_buf.asDoubleBuffer().put(featureVector).rewind();
    long jn_rv =
        _imaqClassify(image.getAddress(), session.getAddress(), roi.getAddress(),
            getByteBufferAddress(featureVector_buf), vectorSize);

    return new ClassifierReport(jn_rv, true);
  }

  private static native long _imaqClassify(long image, long session, long roi, long featureVector,
      int vectorSize);

  public static ClassifierSession imaqCreateClassifier(ClassifierType type) {

    long jn_rv = _imaqCreateClassifier(type.getValue());

    return new ClassifierSession(jn_rv, true);
  }

  private static native long _imaqCreateClassifier(int type);

  public static void imaqDeleteClassifierSample(ClassifierSession session, int index) {

    _imaqDeleteClassifierSample(session.getAddress(), index);

  }

  private static native void _imaqDeleteClassifierSample(long session, int index);

  public static ClassifierAccuracyReport imaqGetClassifierAccuracy(ClassifierSession session) {

    long jn_rv = _imaqGetClassifierAccuracy(session.getAddress());

    return new ClassifierAccuracyReport(jn_rv, true);
  }

  private static native long _imaqGetClassifierAccuracy(long session);

  public static class GetClassifierSampleInfoResult {
    public int numSamples;
    public ClassifierSampleInfo val;

    private GetClassifierSampleInfoResult(ByteBuffer rv_buf) {
      numSamples = rv_buf.getInt(0);
    }
  }

  public static GetClassifierSampleInfoResult imaqGetClassifierSampleInfo(
      ClassifierSession session, int index) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv = _imaqGetClassifierSampleInfo(session.getAddress(), index, rv_addr + 0);
    GetClassifierSampleInfoResult rv = new GetClassifierSampleInfoResult(rv_buf);
    rv.val = new ClassifierSampleInfo(jn_rv, true);
    return rv;
  }

  private static native long _imaqGetClassifierSampleInfo(long session, int index, long numSamples);

  public static ColorOptions imaqGetColorClassifierOptions(ClassifierSession session) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetColorClassifierOptions(session.getAddress(), rv_addr + 0);
    ColorOptions options;
    options = new ColorOptions(rv_buf, 0);
    options.read();
    return options;
  }

  private static native void _imaqGetColorClassifierOptions(long session, long options);

  public static NearestNeighborOptions imaqGetNearestNeighborOptions(ClassifierSession session) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetNearestNeighborOptions(session.getAddress(), rv_addr + 0);
    NearestNeighborOptions options;
    options = new NearestNeighborOptions(rv_buf, 0);
    options.read();
    return options;
  }

  private static native void _imaqGetNearestNeighborOptions(long session, long options);

  public static class GetParticleClassifierOptions2Result {
    public ParticleClassifierPreprocessingOptions2 preprocessingOptions;
    public ParticleClassifierOptions options;

    private GetParticleClassifierOptions2Result(ByteBuffer rv_buf) {
      preprocessingOptions = new ParticleClassifierPreprocessingOptions2(rv_buf, 0);
      preprocessingOptions.read();
      options = new ParticleClassifierOptions(rv_buf, 8);
      options.read();
    }
  }

  public static GetParticleClassifierOptions2Result imaqGetParticleClassifierOptions2(
      ClassifierSession session) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetParticleClassifierOptions2(session.getAddress(), rv_addr + 0, rv_addr + 8);
    GetParticleClassifierOptions2Result rv = new GetParticleClassifierOptions2Result(rv_buf);
    return rv;
  }

  private static native void _imaqGetParticleClassifierOptions2(long session,
      long preprocessingOptions, long options);

  public static class ReadClassifierFileResult {
    public ClassifierType type;
    public ClassifierEngineType engine;
    public ClassifierSession val;

    private ReadClassifierFileResult(ByteBuffer rv_buf) {
      type = ClassifierType.fromValue(rv_buf.getInt(0));
      engine = ClassifierEngineType.fromValue(rv_buf.getInt(8));
    }
  }

  public static ReadClassifierFileResult imaqReadClassifierFile(ClassifierSession session,
      String fileName, ReadClassifierFileMode mode, String description) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    ByteBuffer description_buf = ByteBuffer.allocateDirect(256).order(ByteOrder.nativeOrder());
    if (description != null) {
      byte[] bytes;
      try {
        bytes = description.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        bytes = new byte[0];
      }
      putBytes(description_buf, bytes, 0, bytes.length);
      for (int i = bytes.length; i < 256; i++)
        description_buf.put(i, (byte) 0); // fill with zero
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqReadClassifierFile(session.getAddress(), fileName == null ? 0
            : getByteBufferAddress(fileName_buf), mode.getValue(), rv_addr + 0, rv_addr + 8,
            description == null ? 0 : getByteBufferAddress(description_buf));
    ReadClassifierFileResult rv = new ReadClassifierFileResult(rv_buf);
    rv.val = new ClassifierSession(jn_rv, true);
    return rv;
  }

  private static native long _imaqReadClassifierFile(long session, long fileName, int mode,
      long type, long engine, long description);

  public static void imaqRelabelClassifierSample(ClassifierSession session, int index,
      String newClass) {
    ByteBuffer newClass_buf = null;
    if (newClass != null) {
      byte[] newClass_bytes;
      try {
        newClass_bytes = newClass.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        newClass_bytes = new byte[0];
      }
      newClass_buf = ByteBuffer.allocateDirect(newClass_bytes.length + 1);
      putBytes(newClass_buf, newClass_bytes, 0, newClass_bytes.length).put(newClass_bytes.length,
          (byte) 0);
    }
    _imaqRelabelClassifierSample(session.getAddress(), index, newClass == null ? 0
        : getByteBufferAddress(newClass_buf));

  }

  private static native void _imaqRelabelClassifierSample(long session, int index, long newClass);

  public static void imaqSetParticleClassifierOptions2(ClassifierSession session,
      ParticleClassifierPreprocessingOptions2 preprocessingOptions,
      ParticleClassifierOptions options) {

    _imaqSetParticleClassifierOptions2(session.getAddress(), preprocessingOptions.getAddress(),
        options.getAddress());

  }

  private static native void _imaqSetParticleClassifierOptions2(long session,
      long preprocessingOptions, long options);

  public static void imaqSetColorClassifierOptions(ClassifierSession session, ColorOptions options) {

    _imaqSetColorClassifierOptions(session.getAddress(), options.getAddress());

  }

  private static native void _imaqSetColorClassifierOptions(long session, long options);

  public static NearestNeighborTrainingReport imaqTrainNearestNeighborClassifier(
      ClassifierSession session, NearestNeighborOptions options) {

    long jn_rv = _imaqTrainNearestNeighborClassifier(session.getAddress(), options.getAddress());

    return new NearestNeighborTrainingReport(jn_rv, true);
  }

  private static native long _imaqTrainNearestNeighborClassifier(long session, long options);

  public static void imaqWriteClassifierFile(ClassifierSession session, String fileName,
      WriteClassifierFileMode mode, String description) {
    ByteBuffer fileName_buf = null;
    if (fileName != null) {
      byte[] fileName_bytes;
      try {
        fileName_bytes = fileName.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        fileName_bytes = new byte[0];
      }
      fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length + 1);
      putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length,
          (byte) 0);
    }
    ByteBuffer description_buf = ByteBuffer.allocateDirect(256).order(ByteOrder.nativeOrder());
    if (description != null) {
      byte[] bytes;
      try {
        bytes = description.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        bytes = new byte[0];
      }
      putBytes(description_buf, bytes, 0, bytes.length);
      for (int i = bytes.length; i < 256; i++)
        description_buf.put(i, (byte) 0); // fill with zero
    }
    _imaqWriteClassifierFile(session.getAddress(), fileName == null ? 0
        : getByteBufferAddress(fileName_buf), mode.getValue(), description == null ? 0
        : getByteBufferAddress(description_buf));

  }

  private static native void _imaqWriteClassifierFile(long session, long fileName, int mode,
      long description);

  /**
   * Measure Distances functions
   */

  public static ClampMax2Report imaqClampMax2(Image image, ROI roi, CoordinateSystem baseSystem,
      CoordinateSystem newSystem, CurveOptions curveSettings, ClampSettings clampSettings,
      ClampOverlaySettings clampOverlaySettings) {

    long jn_rv =
        _imaqClampMax2(image.getAddress(), roi.getAddress(), baseSystem.getAddress(),
            newSystem.getAddress(), curveSettings.getAddress(), clampSettings.getAddress(),
            clampOverlaySettings.getAddress());

    return new ClampMax2Report(jn_rv, true);
  }

  private static native long _imaqClampMax2(long image, long roi, long baseSystem, long newSystem,
      long curveSettings, long clampSettings, long clampOverlaySettings);

  /**
   * Inspection functions
   */

  public static void imaqCompareGoldenTemplate(Image image, Image goldenTemplate,
      Image brightDefects, Image darkDefects, InspectionAlignment alignment,
      InspectionOptions options) {

    _imaqCompareGoldenTemplate(image.getAddress(), goldenTemplate.getAddress(),
        brightDefects.getAddress(), darkDefects.getAddress(), alignment.getAddress(),
        options.getAddress());

  }

  private static native void _imaqCompareGoldenTemplate(long image, long goldenTemplate,
      long brightDefects, long darkDefects, long alignment, long options);

  public static void imaqLearnGoldenTemplate(Image goldenTemplate, PointFloat originOffset,
      Image mask) {

    _imaqLearnGoldenTemplate(goldenTemplate.getAddress(), originOffset.getAddress(),
        mask.getAddress());

  }

  private static native void _imaqLearnGoldenTemplate(long goldenTemplate, long originOffset,
      long mask);

  /**
   * Obsolete functions
   */

  public static class GetParticleClassifierOptionsResult {
    public ParticleClassifierPreprocessingOptions preprocessingOptions;
    public ParticleClassifierOptions options;

    private GetParticleClassifierOptionsResult(ByteBuffer rv_buf) {
      preprocessingOptions = new ParticleClassifierPreprocessingOptions(rv_buf, 0);
      preprocessingOptions.read();
      options = new ParticleClassifierOptions(rv_buf, 8);
      options.read();
    }
  }

  public static GetParticleClassifierOptionsResult imaqGetParticleClassifierOptions(
      ClassifierSession session) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqGetParticleClassifierOptions(session.getAddress(), rv_addr + 0, rv_addr + 8);
    GetParticleClassifierOptionsResult rv = new GetParticleClassifierOptionsResult(rv_buf);
    return rv;
  }

  private static native void _imaqGetParticleClassifierOptions(long session,
      long preprocessingOptions, long options);

  public static int imaqParticleFilter3(Image dest, Image source, ParticleFilterCriteria2 criteria,
      int criteriaCount, ParticleFilterOptions options, ROI roi) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqParticleFilter3(dest.getAddress(), source.getAddress(), criteria.getAddress(),
        criteriaCount, options.getAddress(), roi.getAddress(), rv_addr + 0);
    int numParticles;
    numParticles = rv_buf.getInt(0);
    return numParticles;
  }

  private static native void _imaqParticleFilter3(long dest, long source, long criteria,
      int criteriaCount, long options, long roi, long numParticles);

  public static LearnPatternAdvancedOptions imaqLearnPattern2(Image image, LearningMode learningMode) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _imaqLearnPattern2(image.getAddress(), learningMode.getValue(), rv_addr + 0);
    LearnPatternAdvancedOptions advancedOptions;
    advancedOptions = new LearnPatternAdvancedOptions(rv_buf, 0);
    advancedOptions.read();
    return advancedOptions;
  }

  private static native void _imaqLearnPattern2(long image, int learningMode, long advancedOptions);

  public static void imaqDivide(Image dest, Image sourceA, Image sourceB) {

    _imaqDivide(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());

  }

  private static native void _imaqDivide(long dest, long sourceA, long sourceB);

  public static EdgeReport2 imaqEdgeTool3(Image image, ROI roi, EdgeProcess processType,
      EdgeOptions2 edgeOptions) {

    long jn_rv =
        _imaqEdgeTool3(image.getAddress(), roi.getAddress(), processType.getValue(),
            edgeOptions.getAddress());

    return new EdgeReport2(jn_rv, true);
  }

  private static native long _imaqEdgeTool3(long image, long roi, int processType, long edgeOptions);

  public static ConcentricRakeReport imaqConcentricRake(Image image, ROI roi,
      ConcentricRakeDirection direction, EdgeProcess process, RakeOptions options) {

    long jn_rv =
        _imaqConcentricRake(image.getAddress(), roi.getAddress(), direction.getValue(),
            process.getValue(), options.getAddress());

    return new ConcentricRakeReport(jn_rv, true);
  }

  private static native long _imaqConcentricRake(long image, long roi, int direction, int process,
      long options);

  public static SpokeReport imaqSpoke(Image image, ROI roi, SpokeDirection direction,
      EdgeProcess process, SpokeOptions options) {

    long jn_rv =
        _imaqSpoke(image.getAddress(), roi.getAddress(), direction.getValue(), process.getValue(),
            options.getAddress());

    return new SpokeReport(jn_rv, true);
  }

  private static native long _imaqSpoke(long image, long roi, int direction, int process,
      long options);

  public static class MatchPattern2Result {
    public PatternMatch[] array;
    private long array_addr;

    private MatchPattern2Result(ByteBuffer rv_buf, long jn_rv) {
      array_addr = jn_rv;
      int array_numMatches;
      array_numMatches = rv_buf.getInt(0);
      array = new PatternMatch[array_numMatches];
      if (array_numMatches > 0 && array_addr != 0) {
        ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches * 52);
        for (int i = 0, off = 0; i < array_numMatches; i++, off += 52) {
          array[i] = new PatternMatch(bb, off);
          array[i].read();
        }
      }
    }

    @Override
    protected void finalize() throws Throwable {
      imaqDispose(array_addr);
      super.finalize();
    }
  }

  public static MatchPattern2Result imaqMatchPattern2(Image image, Image pattern,
      MatchPatternOptions options, MatchPatternAdvancedOptions advancedOptions, Rect searchRect) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    long jn_rv =
        _imaqMatchPattern2(image.getAddress(), pattern.getAddress(),
            options == null ? 0 : options.getAddress(), advancedOptions.getAddress(),
            searchRect.getAddress(), rv_addr + 0);
    MatchPattern2Result rv = new MatchPattern2Result(rv_buf, jn_rv);
    return rv;
  }

  private static native long _imaqMatchPattern2(long image, long pattern, long options,
      long advancedOptions, long searchRect, long numMatches);

  public static void imaqSetParticleClassifierOptions(ClassifierSession session,
      ParticleClassifierPreprocessingOptions preprocessingOptions, ParticleClassifierOptions options) {

    _imaqSetParticleClassifierOptions(session.getAddress(), preprocessingOptions.getAddress(),
        options.getAddress());

  }

  private static native void _imaqSetParticleClassifierOptions(long session,
      long preprocessingOptions, long options);

  public static RakeReport imaqRake(Image image, ROI roi, RakeDirection direction,
      EdgeProcess process, RakeOptions options) {

    long jn_rv =
        _imaqRake(image.getAddress(), roi.getAddress(), direction.getValue(), process.getValue(),
            options.getAddress());

    return new RakeReport(jn_rv, true);
  }

  private static native long _imaqRake(long image, long roi, int direction, int process,
      long options);

  public static void Priv_ReadJPEGString_C(Image image, byte[] string) {
    int stringLength = string.length;
    ByteBuffer string_buf = null;
    string_buf = ByteBuffer.allocateDirect(string.length);
    putBytes(string_buf, string, 0, string.length);
    _Priv_ReadJPEGString_C(image.getAddress(), getByteBufferAddress(string_buf), stringLength);

  }

  private static native void _Priv_ReadJPEGString_C(long image, long string, int stringLength);

  /**
   * Purpose : Include file for NI-IMAQdx library support.
   */
  public static final int IMAQDX_MAX_API_STRING_LENGTH = 512;

  /**
   * Bus Type Enumeration
   */

  public static enum IMAQdxBusType {
    BusTypeFireWire(0x31333934), BusTypeEthernet(0x69707634), BusTypeSimulator(0x2073696D), BusTypeDirectShow(
        0x64736877), BusTypeIP(0x4950636D), BusTypeSmartCam2(0x53436132), BusTypeUSB3Vision(
        0x55534233), BusTypeUVC(0x55564320), BusTypeGuard(0xFFFFFFFF), ;
    private final int value;

    private IMAQdxBusType(int value) {
      this.value = value;
    }

    public static IMAQdxBusType fromValue(int val) {
      for (IMAQdxBusType v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Camera Control Mode Enumeration
   */

  public static enum IMAQdxCameraControlMode {
    CameraControlModeController(0), CameraControlModeListener(1), CameraControlModeGuard(0xFFFFFFFF), ;
    private final int value;

    private IMAQdxCameraControlMode(int value) {
      this.value = value;
    }

    public static IMAQdxCameraControlMode fromValue(int val) {
      for (IMAQdxCameraControlMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Buffer Number Mode Enumeration
   */

  public static enum IMAQdxBufferNumberMode {
    BufferNumberModeNext(0), BufferNumberModeLast(1), BufferNumberModeBufferNumber(2), BufferNumberModeGuard(
        0xFFFFFFFF), ;
    private final int value;

    private IMAQdxBufferNumberMode(int value) {
      this.value = value;
    }

    public static IMAQdxBufferNumberMode fromValue(int val) {
      for (IMAQdxBufferNumberMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Plug n Play Event Enumeration
   */

  public static enum IMAQdxPnpEvent {
    PnpEventCameraAttached(0), PnpEventCameraDetached(1), PnpEventBusReset(2), PnpEventGuard(
        0xFFFFFFFF), ;
    private final int value;

    private IMAQdxPnpEvent(int value) {
      this.value = value;
    }

    public static IMAQdxPnpEvent fromValue(int val) {
      for (IMAQdxPnpEvent v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Bayer Pattern Enumeration
   */

  public static enum IMAQdxBayerPattern {
    BayerPatternNone(0), BayerPatternGB(1), BayerPatternGR(2), BayerPatternBG(3), BayerPatternRG(4), BayerPatternHardware(
        5), BayerPatternGuard(0xFFFFFFFF), ;
    private final int value;

    private IMAQdxBayerPattern(int value) {
      this.value = value;
    }

    public static IMAQdxBayerPattern fromValue(int val) {
      for (IMAQdxBayerPattern v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Bayer Decode Algorithm Enumeration
   */

  public static enum IMAQdxBayerAlgorithm {
    BayerAlgorithmBilinear(0), BayerAlgorithmVNG(1), BayerAlgorithmGuard(0xFFFFFFFF), ;
    private final int value;

    private IMAQdxBayerAlgorithm(int value) {
      this.value = value;
    }

    public static IMAQdxBayerAlgorithm fromValue(int val) {
      for (IMAQdxBayerAlgorithm v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Output Image Types -- Values match Vision Development Module image types
   */

  public static enum IMAQdxOutputImageType {
    OutputImageTypeU8(0), OutputImageTypeI16(1), OutputImageTypeU16(7), OutputImageTypeRGB32(4), OutputImageTypeRGB64(
        6), OutputImageTypeAuto(0x7FFFFFFF), OutputImageTypeGuard(0xFFFFFFFF), ;
    private final int value;

    private IMAQdxOutputImageType(int value) {
      this.value = value;
    }

    public static IMAQdxOutputImageType fromValue(int val) {
      for (IMAQdxOutputImageType v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Controller Destination Mode Enumeration
   */

  public static enum IMAQdxDestinationMode {
    DestinationModeUnicast(0), DestinationModeBroadcast(1), DestinationModeMulticast(2), DestinationModeGuard(
        0xFFFFFFFF), ;
    private final int value;

    private IMAQdxDestinationMode(int value) {
      this.value = value;
    }

    public static IMAQdxDestinationMode fromValue(int val) {
      for (IMAQdxDestinationMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Attribute Type Enumeration
   */

  public static enum IMAQdxAttributeType {
    AttributeTypeU32(0), AttributeTypeI64(1), AttributeTypeF64(2), AttributeTypeString(3), AttributeTypeEnum(
        4), AttributeTypeBool(5), AttributeTypeCommand(6), AttributeTypeBlob(7), AttributeTypeGuard(
        0xFFFFFFFF), ;
    private final int value;

    private IMAQdxAttributeType(int value) {
      this.value = value;
    }

    public static IMAQdxAttributeType fromValue(int val) {
      for (IMAQdxAttributeType v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Value Type Enumeration
   */

  public static enum IMAQdxValueType {
    ValueTypeU32(0), ValueTypeI64(1), ValueTypeF64(2), ValueTypeString(3), ValueTypeEnumItem(4), ValueTypeBool(
        5), ValueTypeDisposableString(6), ValueTypeGuard(0xFFFFFFFF), ;
    private final int value;

    private IMAQdxValueType(int value) {
      this.value = value;
    }

    public static IMAQdxValueType fromValue(int val) {
      for (IMAQdxValueType v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Interface File Flags Enumeration
   */

  public static enum IMAQdxInterfaceFileFlags {
    InterfaceFileFlagsConnected(0x1), InterfaceFileFlagsDirty(0x2), InterfaceFileFlagsGuard(
        0xFFFFFFFF), ;
    private final int value;

    private IMAQdxInterfaceFileFlags(int value) {
      this.value = value;
    }

    public static IMAQdxInterfaceFileFlags fromValue(int val) {
      for (IMAQdxInterfaceFileFlags v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Overwrite Mode Enumeration
   */

  public static enum IMAQdxOverwriteMode {
    OverwriteModeGetOldest(0x0), OverwriteModeFail(0x2), OverwriteModeGetNewest(0x3), OverwriteModeGuard(
        0xFFFFFFFF), ;
    private final int value;

    private IMAQdxOverwriteMode(int value) {
      this.value = value;
    }

    public static IMAQdxOverwriteMode fromValue(int val) {
      for (IMAQdxOverwriteMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Incomplete Buffer Mode Enumeration
   */

  public static enum IMAQdxIncompleteBufferMode {
    IncompleteBufferModeIgnore(0), IncompleteBufferModeFail(1), IncompleteBufferModeGuard(
        0xFFFFFFFF), ;
    private final int value;

    private IMAQdxIncompleteBufferMode(int value) {
      this.value = value;
    }

    public static IMAQdxIncompleteBufferMode fromValue(int val) {
      for (IMAQdxIncompleteBufferMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Lost Packet Mode Enumeration
   */

  public static enum IMAQdxLostPacketMode {
    LostPacketModeIgnore(0), LostPacketModeFail(1), LostPacketModeGuard(0xFFFFFFFF), ;
    private final int value;

    private IMAQdxLostPacketMode(int value) {
      this.value = value;
    }

    public static IMAQdxLostPacketMode fromValue(int val) {
      for (IMAQdxLostPacketMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Attribute Visibility Enumeration
   */

  public static enum IMAQdxAttributeVisibility {
    AttributeVisibilitySimple(0x00001000), AttributeVisibilityIntermediate(0x00002000), AttributeVisibilityAdvanced(
        0x00004000), AttributeVisibilityGuard(0xFFFFFFFF), ;
    private final int value;

    private IMAQdxAttributeVisibility(int value) {
      this.value = value;
    }

    public static IMAQdxAttributeVisibility fromValue(int val) {
      for (IMAQdxAttributeVisibility v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Stream Channel Mode Enumeration
   */

  public static enum IMAQdxStreamChannelMode {
    StreamChannelModeAutomatic(0), StreamChannelModeManual(1), StreamChannelModeGuard(0xFFFFFFFF), ;
    private final int value;

    private IMAQdxStreamChannelMode(int value) {
      this.value = value;
    }

    public static IMAQdxStreamChannelMode fromValue(int val) {
      for (IMAQdxStreamChannelMode v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * Pixel Signedness Enumeration
   */

  public static enum IMAQdxPixelSignedness {
    PixelSignednessUnsigned(0), PixelSignednessSigned(1), PixelSignednessHardware(2), PixelSignednessGuard(
        0xFFFFFFFF), ;
    private final int value;

    private IMAQdxPixelSignedness(int value) {
      this.value = value;
    }

    public static IMAQdxPixelSignedness fromValue(int val) {
      for (IMAQdxPixelSignedness v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * USB Connection Speed Enumeration
   */

  public static enum IMAQdxUSBConnectionSpeed {
    USBConnectionSpeedLow(1), USBConnectionSpeedFull(2), USBConnectionSpeedHigh(4), USBConnectionSpeedSuper(
        8), USBConnectionSpeedGuard(0xFFFFFFFF), ;
    private final int value;

    private IMAQdxUSBConnectionSpeed(int value) {
      this.value = value;
    }

    public static IMAQdxUSBConnectionSpeed fromValue(int val) {
      for (IMAQdxUSBConnectionSpeed v : values()) {
        if (v.value == val)
          return v;
      }
      return null;
    }

    public int getValue() {
      return value;
    }
  }

  /**
   * CVI Structures
   */

  /**
   * Camera Information Structure
   */

  public static class IMAQdxCameraInformation extends DisposedStruct {
    public int Type;
    public int Version;
    public int Flags;
    public int SerialNumberHi;
    public int SerialNumberLo;
    public IMAQdxBusType BusType;
    public String InterfaceName;
    public String VendorName;
    public String ModelName;
    public String CameraFileName;
    public String CameraAttributeURL;

    private void init() {

    }

    public IMAQdxCameraInformation() {
      super(2584);
      init();
    }

    public IMAQdxCameraInformation(int Type, int Version, int Flags, int SerialNumberHi,
        int SerialNumberLo, IMAQdxBusType BusType, String InterfaceName, String VendorName,
        String ModelName, String CameraFileName, String CameraAttributeURL) {
      super(2584);
      this.Type = Type;
      this.Version = Version;
      this.Flags = Flags;
      this.SerialNumberHi = SerialNumberHi;
      this.SerialNumberLo = SerialNumberLo;
      this.BusType = BusType;
      this.InterfaceName = InterfaceName;
      this.VendorName = VendorName;
      this.ModelName = ModelName;
      this.CameraFileName = CameraFileName;
      this.CameraAttributeURL = CameraAttributeURL;
    }

    protected IMAQdxCameraInformation(ByteBuffer backing, int offset) {
      super(backing, offset, 2584);
      init();
    }

    protected IMAQdxCameraInformation(long nativeObj, boolean owned) {
      super(nativeObj, owned, 2584);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 2584);
    }

    public void read() {
      Type = backing.getInt(0);
      Version = backing.getInt(4);
      Flags = backing.getInt(8);
      SerialNumberHi = backing.getInt(12);
      SerialNumberLo = backing.getInt(16);
      BusType = IMAQdxBusType.fromValue(backing.getInt(20));
      {
        byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
        getBytes(backing, bytes, 24, IMAQDX_MAX_API_STRING_LENGTH);
        int len;
        for (len = 0; len < bytes.length && bytes[len] != 0; len++) {
        }
        try {
          InterfaceName = new String(bytes, 0, len, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          InterfaceName = "";
        }
      }
      {
        byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
        getBytes(backing, bytes, 536, IMAQDX_MAX_API_STRING_LENGTH);
        int len;
        for (len = 0; len < bytes.length && bytes[len] != 0; len++) {
        }
        try {
          VendorName = new String(bytes, 0, len, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          VendorName = "";
        }
      }
      {
        byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
        getBytes(backing, bytes, 1048, IMAQDX_MAX_API_STRING_LENGTH);
        int len;
        for (len = 0; len < bytes.length && bytes[len] != 0; len++) {
        }
        try {
          ModelName = new String(bytes, 0, len, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          ModelName = "";
        }
      }
      {
        byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
        getBytes(backing, bytes, 1560, IMAQDX_MAX_API_STRING_LENGTH);
        int len;
        for (len = 0; len < bytes.length && bytes[len] != 0; len++) {
        }
        try {
          CameraFileName = new String(bytes, 0, len, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          CameraFileName = "";
        }
      }
      {
        byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
        getBytes(backing, bytes, 2072, IMAQDX_MAX_API_STRING_LENGTH);
        int len;
        for (len = 0; len < bytes.length && bytes[len] != 0; len++) {
        }
        try {
          CameraAttributeURL = new String(bytes, 0, len, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          CameraAttributeURL = "";
        }
      }
    }

    public void write() {
      backing.putInt(0, Type);
      backing.putInt(4, Version);
      backing.putInt(8, Flags);
      backing.putInt(12, SerialNumberHi);
      backing.putInt(16, SerialNumberLo);
      if (BusType != null)
        backing.putInt(20, BusType.getValue());
      if (InterfaceName != null) {
        byte[] bytes;
        try {
          bytes = InterfaceName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bytes = new byte[0];
        }
        putBytes(backing, bytes, 24, bytes.length);
        for (int i = bytes.length; i < IMAQDX_MAX_API_STRING_LENGTH; i++)
          backing.put(i, (byte) 0); // fill with zero
      }
      if (VendorName != null) {
        byte[] bytes;
        try {
          bytes = VendorName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bytes = new byte[0];
        }
        putBytes(backing, bytes, 536, bytes.length);
        for (int i = bytes.length; i < IMAQDX_MAX_API_STRING_LENGTH; i++)
          backing.put(i, (byte) 0); // fill with zero
      }
      if (ModelName != null) {
        byte[] bytes;
        try {
          bytes = ModelName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bytes = new byte[0];
        }
        putBytes(backing, bytes, 1048, bytes.length);
        for (int i = bytes.length; i < IMAQDX_MAX_API_STRING_LENGTH; i++)
          backing.put(i, (byte) 0); // fill with zero
      }
      if (CameraFileName != null) {
        byte[] bytes;
        try {
          bytes = CameraFileName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bytes = new byte[0];
        }
        putBytes(backing, bytes, 1560, bytes.length);
        for (int i = bytes.length; i < IMAQDX_MAX_API_STRING_LENGTH; i++)
          backing.put(i, (byte) 0); // fill with zero
      }
      if (CameraAttributeURL != null) {
        byte[] bytes;
        try {
          bytes = CameraAttributeURL.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bytes = new byte[0];
        }
        putBytes(backing, bytes, 2072, bytes.length);
        for (int i = bytes.length; i < IMAQDX_MAX_API_STRING_LENGTH; i++)
          backing.put(i, (byte) 0); // fill with zero
      }
    }

    public int size() {
      return 2584;
    }
  }

  /**
   * Camera File Structure
   */

  public static class IMAQdxCameraFile extends DisposedStruct {
    public int Type;
    public int Version;
    public String FileName;

    private void init() {

    }

    public IMAQdxCameraFile() {
      super(520);
      init();
    }

    public IMAQdxCameraFile(int Type, int Version, String FileName) {
      super(520);
      this.Type = Type;
      this.Version = Version;
      this.FileName = FileName;
    }

    protected IMAQdxCameraFile(ByteBuffer backing, int offset) {
      super(backing, offset, 520);
      init();
    }

    protected IMAQdxCameraFile(long nativeObj, boolean owned) {
      super(nativeObj, owned, 520);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 520);
    }

    public void read() {
      Type = backing.getInt(0);
      Version = backing.getInt(4);
      {
        byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
        getBytes(backing, bytes, 8, IMAQDX_MAX_API_STRING_LENGTH);
        int len;
        for (len = 0; len < bytes.length && bytes[len] != 0; len++) {
        }
        try {
          FileName = new String(bytes, 0, len, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          FileName = "";
        }
      }
    }

    public void write() {
      backing.putInt(0, Type);
      backing.putInt(4, Version);
      if (FileName != null) {
        byte[] bytes;
        try {
          bytes = FileName.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bytes = new byte[0];
        }
        putBytes(backing, bytes, 8, bytes.length);
        for (int i = bytes.length; i < IMAQDX_MAX_API_STRING_LENGTH; i++)
          backing.put(i, (byte) 0); // fill with zero
      }
    }

    public int size() {
      return 520;
    }
  }

  /**
   * Attribute Information Structure
   */

  public static class IMAQdxAttributeInformation extends DisposedStruct {
    public IMAQdxAttributeType Type;
    public int Readable;
    public int Writable;
    public String Name;

    private void init() {

    }

    public IMAQdxAttributeInformation() {
      super(524);
      init();
    }

    public IMAQdxAttributeInformation(IMAQdxAttributeType Type, int Readable, int Writable,
        String Name) {
      super(524);
      this.Type = Type;
      this.Readable = Readable;
      this.Writable = Writable;
      this.Name = Name;
    }

    protected IMAQdxAttributeInformation(ByteBuffer backing, int offset) {
      super(backing, offset, 524);
      init();
    }

    protected IMAQdxAttributeInformation(long nativeObj, boolean owned) {
      super(nativeObj, owned, 524);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 524);
    }

    public void read() {
      Type = IMAQdxAttributeType.fromValue(backing.getInt(0));
      Readable = backing.getInt(4);
      Writable = backing.getInt(8);
      {
        byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
        getBytes(backing, bytes, 12, IMAQDX_MAX_API_STRING_LENGTH);
        int len;
        for (len = 0; len < bytes.length && bytes[len] != 0; len++) {
        }
        try {
          Name = new String(bytes, 0, len, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          Name = "";
        }
      }
    }

    public void write() {
      if (Type != null)
        backing.putInt(0, Type.getValue());
      backing.putInt(4, Readable);
      backing.putInt(8, Writable);
      if (Name != null) {
        byte[] bytes;
        try {
          bytes = Name.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bytes = new byte[0];
        }
        putBytes(backing, bytes, 12, bytes.length);
        for (int i = bytes.length; i < IMAQDX_MAX_API_STRING_LENGTH; i++)
          backing.put(i, (byte) 0); // fill with zero
      }
    }

    public int size() {
      return 524;
    }
  }

  /**
   * Enumeration Item Structure
   */

  public static class IMAQdxEnumItem extends DisposedStruct {
    public int Value;
    public int Reserved;
    public String Name;

    private void init() {

    }

    public IMAQdxEnumItem() {
      super(520);
      init();
    }

    public IMAQdxEnumItem(int Value, int Reserved, String Name) {
      super(520);
      this.Value = Value;
      this.Reserved = Reserved;
      this.Name = Name;
    }

    protected IMAQdxEnumItem(ByteBuffer backing, int offset) {
      super(backing, offset, 520);
      init();
    }

    protected IMAQdxEnumItem(long nativeObj, boolean owned) {
      super(nativeObj, owned, 520);
      init();
    }

    protected void setBuffer(ByteBuffer backing, int offset) {
      super.setBuffer(backing, offset, 520);
    }

    public void read() {
      Value = backing.getInt(0);
      Reserved = backing.getInt(4);
      {
        byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
        getBytes(backing, bytes, 8, IMAQDX_MAX_API_STRING_LENGTH);
        int len;
        for (len = 0; len < bytes.length && bytes[len] != 0; len++) {
        }
        try {
          Name = new String(bytes, 0, len, "UTF-8");
        } catch (UnsupportedEncodingException e) {
          Name = "";
        }
      }
    }

    public void write() {
      backing.putInt(0, Value);
      backing.putInt(4, Reserved);
      if (Name != null) {
        byte[] bytes;
        try {
          bytes = Name.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
          bytes = new byte[0];
        }
        putBytes(backing, bytes, 8, bytes.length);
        for (int i = bytes.length; i < IMAQDX_MAX_API_STRING_LENGTH; i++)
          backing.put(i, (byte) 0); // fill with zero
      }
    }

    public int size() {
      return 520;
    }
  }

  /**
   * Camera Information Structure
   */

  /**
   * Attributes
   */

  /**
   * Functions
   */

  public static void IMAQdxSnap(int id, Image image) {

    _IMAQdxSnap(id, image.getAddress());

  }

  private static native void _IMAQdxSnap(int id, long image);

  public static void IMAQdxConfigureGrab(int id) {

    _IMAQdxConfigureGrab(id);

  }

  private static native void _IMAQdxConfigureGrab(int id);

  public static int IMAQdxGrab(int id, Image image, int waitForNextBuffer) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGrab(id, image.getAddress(), waitForNextBuffer, rv_addr + 0);
    int actualBufferNumber;
    actualBufferNumber = rv_buf.getInt(0);
    return actualBufferNumber;
  }

  private static native void _IMAQdxGrab(int id, long image, int waitForNextBuffer,
      long actualBufferNumber);

  public static void IMAQdxDiscoverEthernetCameras(String address, int timeout) {
    ByteBuffer address_buf = null;
    if (address != null) {
      byte[] address_bytes;
      try {
        address_bytes = address.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        address_bytes = new byte[0];
      }
      address_buf = ByteBuffer.allocateDirect(address_bytes.length + 1);
      putBytes(address_buf, address_bytes, 0, address_bytes.length).put(address_bytes.length,
          (byte) 0);
    }
    _IMAQdxDiscoverEthernetCameras(address == null ? 0 : getByteBufferAddress(address_buf), timeout);

  }

  private static native void _IMAQdxDiscoverEthernetCameras(long address, int timeout);

  public static void IMAQdxResetCamera(String name, int resetAll) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    _IMAQdxResetCamera(name == null ? 0 : getByteBufferAddress(name_buf), resetAll);

  }

  private static native void _IMAQdxResetCamera(long name, int resetAll);

  public static int IMAQdxOpenCamera(String name, IMAQdxCameraControlMode mode) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxOpenCamera(name == null ? 0 : getByteBufferAddress(name_buf), mode.getValue(),
        rv_addr + 0);
    int id;
    id = rv_buf.getInt(0);
    return id;
  }

  private static native void _IMAQdxOpenCamera(long name, int mode, long id);

  public static void IMAQdxCloseCamera(int id) {

    _IMAQdxCloseCamera(id);

  }

  private static native void _IMAQdxCloseCamera(int id);

  public static void IMAQdxConfigureAcquisition(int id, int continuous, int bufferCount) {

    _IMAQdxConfigureAcquisition(id, continuous, bufferCount);

  }

  private static native void _IMAQdxConfigureAcquisition(int id, int continuous, int bufferCount);

  public static void IMAQdxStartAcquisition(int id) {

    _IMAQdxStartAcquisition(id);

  }

  private static native void _IMAQdxStartAcquisition(int id);

  public static int IMAQdxGetImage(int id, Image image, IMAQdxBufferNumberMode mode,
      int desiredBufferNumber) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetImage(id, image.getAddress(), mode.getValue(), desiredBufferNumber, rv_addr + 0);
    int actualBufferNumber;
    actualBufferNumber = rv_buf.getInt(0);
    return actualBufferNumber;
  }

  private static native void _IMAQdxGetImage(int id, long image, int mode, int desiredBufferNumber,
      long actualBufferNumber);

  public static int IMAQdxGetImageData(int id, ByteBuffer buffer, IMAQdxBufferNumberMode mode,
      int desiredBufferNumber) {
    long buffer_addr = getByteBufferAddress(buffer);
    int buffer_size = buffer.capacity();
    return _IMAQdxGetImageData(id, buffer_addr, buffer_size, mode.getValue(), desiredBufferNumber);
  }

  private static native int _IMAQdxGetImageData(int id, long buffer, int bufferSize, int mode,
      int desiredBufferNumber);

  public static void IMAQdxStopAcquisition(int id) {

    _IMAQdxStopAcquisition(id);

  }

  private static native void _IMAQdxStopAcquisition(int id);

  public static void IMAQdxUnconfigureAcquisition(int id) {

    _IMAQdxUnconfigureAcquisition(id);

  }

  private static native void _IMAQdxUnconfigureAcquisition(int id);

  public static class dxEnumerateVideoModesResult {
    public IMAQdxEnumItem[] videoModeArray;
    public int currentMode;
    private ByteBuffer videoModeArray_buf;

    private dxEnumerateVideoModesResult(ByteBuffer rv_buf, ByteBuffer videoModeArray_buf) {
      this.videoModeArray_buf = videoModeArray_buf;
      int count = rv_buf.getInt(0);
      videoModeArray = new IMAQdxEnumItem[count];
      for (int i = 0, off = 0; i < count; i++, off += 520) {
        videoModeArray[i] = new IMAQdxEnumItem(videoModeArray_buf, off);
        videoModeArray[i].read();
      }
      currentMode = rv_buf.getInt(8);
    }
  }

  public static dxEnumerateVideoModesResult IMAQdxEnumerateVideoModes(int id) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8 + 8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxEnumerateVideoModes(id, 0, rv_addr + 0, rv_addr + 8);
    int count = rv_buf.getInt(0);
    ByteBuffer videoModeArray_buf =
        ByteBuffer.allocateDirect(count * 520).order(ByteOrder.nativeOrder());
    _IMAQdxEnumerateVideoModes(id, getByteBufferAddress(videoModeArray_buf), rv_addr + 0,
        rv_addr + 8);
    dxEnumerateVideoModesResult rv = new dxEnumerateVideoModesResult(rv_buf, videoModeArray_buf);
    return rv;
  }

  private static native void _IMAQdxEnumerateVideoModes(int id, long videoModeArray, long count,
      long currentMode);

  public static IMAQdxAttributeType IMAQdxGetAttributeType(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeType(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr + 0);
    IMAQdxAttributeType type;
    type = IMAQdxAttributeType.fromValue(rv_buf.getInt(0));
    return type;
  }

  private static native void _IMAQdxGetAttributeType(int id, long name, long type);

  public static int IMAQdxIsAttributeReadable(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxIsAttributeReadable(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr + 0);
    int readable;
    readable = rv_buf.getInt(0);
    return readable;
  }

  private static native void _IMAQdxIsAttributeReadable(int id, long name, long readable);

  public static int IMAQdxIsAttributeWritable(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxIsAttributeWritable(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr + 0);
    int writable;
    writable = rv_buf.getInt(0);
    return writable;
  }

  private static native void _IMAQdxIsAttributeWritable(int id, long name, long writable);

  public static void IMAQdxWriteRegister(int id, int offset, int value) {

    _IMAQdxWriteRegister(id, offset, value);

  }

  private static native void _IMAQdxWriteRegister(int id, int offset, int value);

  public static int IMAQdxReadRegister(int id, int offset) {
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxReadRegister(id, offset, rv_addr + 0);
    int value;
    value = rv_buf.getInt(0);
    return value;
  }

  private static native void _IMAQdxReadRegister(int id, int offset, long value);

  public static void IMAQdxWriteAttributes(int id, String filename) {
    ByteBuffer filename_buf = null;
    if (filename != null) {
      byte[] filename_bytes;
      try {
        filename_bytes = filename.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        filename_bytes = new byte[0];
      }
      filename_buf = ByteBuffer.allocateDirect(filename_bytes.length + 1);
      putBytes(filename_buf, filename_bytes, 0, filename_bytes.length).put(filename_bytes.length,
          (byte) 0);
    }
    _IMAQdxWriteAttributes(id, filename == null ? 0 : getByteBufferAddress(filename_buf));

  }

  private static native void _IMAQdxWriteAttributes(int id, long filename);

  public static void IMAQdxReadAttributes(int id, String filename) {
    ByteBuffer filename_buf = null;
    if (filename != null) {
      byte[] filename_bytes;
      try {
        filename_bytes = filename.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        filename_bytes = new byte[0];
      }
      filename_buf = ByteBuffer.allocateDirect(filename_bytes.length + 1);
      putBytes(filename_buf, filename_bytes, 0, filename_bytes.length).put(filename_bytes.length,
          (byte) 0);
    }
    _IMAQdxReadAttributes(id, filename == null ? 0 : getByteBufferAddress(filename_buf));

  }

  private static native void _IMAQdxReadAttributes(int id, long filename);

  public static void IMAQdxResetEthernetCameraAddress(String name, String address, String subnet,
      String gateway, int timeout) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer address_buf = null;
    if (address != null) {
      byte[] address_bytes;
      try {
        address_bytes = address.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        address_bytes = new byte[0];
      }
      address_buf = ByteBuffer.allocateDirect(address_bytes.length + 1);
      putBytes(address_buf, address_bytes, 0, address_bytes.length).put(address_bytes.length,
          (byte) 0);
    }
    ByteBuffer subnet_buf = null;
    if (subnet != null) {
      byte[] subnet_bytes;
      try {
        subnet_bytes = subnet.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        subnet_bytes = new byte[0];
      }
      subnet_buf = ByteBuffer.allocateDirect(subnet_bytes.length + 1);
      putBytes(subnet_buf, subnet_bytes, 0, subnet_bytes.length).put(subnet_bytes.length, (byte) 0);
    }
    ByteBuffer gateway_buf = null;
    if (gateway != null) {
      byte[] gateway_bytes;
      try {
        gateway_bytes = gateway.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        gateway_bytes = new byte[0];
      }
      gateway_buf = ByteBuffer.allocateDirect(gateway_bytes.length + 1);
      putBytes(gateway_buf, gateway_bytes, 0, gateway_bytes.length).put(gateway_bytes.length,
          (byte) 0);
    }
    _IMAQdxResetEthernetCameraAddress(name == null ? 0 : getByteBufferAddress(name_buf),
        address == null ? 0 : getByteBufferAddress(address_buf), subnet == null ? 0
            : getByteBufferAddress(subnet_buf), gateway == null ? 0
            : getByteBufferAddress(gateway_buf), timeout);

  }

  private static native void _IMAQdxResetEthernetCameraAddress(long name, long address,
      long subnet, long gateway, int timeout);

  public static IMAQdxAttributeVisibility IMAQdxGetAttributeVisibility(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeVisibility(id, name == null ? 0 : getByteBufferAddress(name_buf),
        rv_addr + 0);
    IMAQdxAttributeVisibility visibility;
    visibility = IMAQdxAttributeVisibility.fromValue(rv_buf.getInt(0));
    return visibility;
  }

  private static native void _IMAQdxGetAttributeVisibility(int id, long name, long visibility);

  public static int IMAQdxGetAttributeU32(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeU32(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr + 0);
    int value;
    value = rv_buf.getInt(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeU32(int id, long name, long value);

  public static long IMAQdxGetAttributeI64(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeI64(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr + 0);
    long value;
    value = rv_buf.getLong(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeI64(int id, long name, long value);

  public static double IMAQdxGetAttributeF64(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeF64(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr + 0);
    double value;
    value = rv_buf.getDouble(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeF64(int id, long name, long value);

  public static String IMAQdxGetAttributeString(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf =
        ByteBuffer.allocateDirect(IMAQDX_MAX_API_STRING_LENGTH).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeString(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr + 0);
    String value;
    {
      byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
      getBytes(rv_buf, bytes, 0, IMAQDX_MAX_API_STRING_LENGTH);
      int len;
      for (len = 0; len < bytes.length && bytes[len] != 0; len++) {
      }
      try {
        value = new String(bytes, 0, len, "UTF-8");
      } catch (UnsupportedEncodingException e) {
        value = "";
      }
    }
    return value;
  }

  private static native void _IMAQdxGetAttributeString(int id, long name, long value);

  public static IMAQdxEnumItem IMAQdxGetAttributeEnum(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeEnum(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr + 0);
    IMAQdxEnumItem value;
    value = new IMAQdxEnumItem(rv_buf, 0);
    value.read();
    return value;
  }

  private static native void _IMAQdxGetAttributeEnum(int id, long name, long value);

  public static int IMAQdxGetAttributeBool(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeBool(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr + 0);
    int value;
    value = rv_buf.getInt(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeBool(int id, long name, long value);

  public static int IMAQdxGetAttributeMinimumU32(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeMinimumU32(id, name == null ? 0 : getByteBufferAddress(name_buf),
        rv_addr + 0);
    int value;
    value = rv_buf.getInt(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeMinimumU32(int id, long name, long value);

  public static long IMAQdxGetAttributeMinimumI64(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeMinimumI64(id, name == null ? 0 : getByteBufferAddress(name_buf),
        rv_addr + 0);
    long value;
    value = rv_buf.getLong(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeMinimumI64(int id, long name, long value);

  public static double IMAQdxGetAttributeMinimumF64(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeMinimumF64(id, name == null ? 0 : getByteBufferAddress(name_buf),
        rv_addr + 0);
    double value;
    value = rv_buf.getDouble(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeMinimumF64(int id, long name, long value);

  public static int IMAQdxGetAttributeMaximumU32(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeMaximumU32(id, name == null ? 0 : getByteBufferAddress(name_buf),
        rv_addr + 0);
    int value;
    value = rv_buf.getInt(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeMaximumU32(int id, long name, long value);

  public static long IMAQdxGetAttributeMaximumI64(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeMaximumI64(id, name == null ? 0 : getByteBufferAddress(name_buf),
        rv_addr + 0);
    long value;
    value = rv_buf.getLong(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeMaximumI64(int id, long name, long value);

  public static double IMAQdxGetAttributeMaximumF64(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeMaximumF64(id, name == null ? 0 : getByteBufferAddress(name_buf),
        rv_addr + 0);
    double value;
    value = rv_buf.getDouble(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeMaximumF64(int id, long name, long value);

  public static int IMAQdxGetAttributeIncrementU32(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeIncrementU32(id, name == null ? 0 : getByteBufferAddress(name_buf),
        rv_addr + 0);
    int value;
    value = rv_buf.getInt(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeIncrementU32(int id, long name, long value);

  public static long IMAQdxGetAttributeIncrementI64(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeIncrementI64(id, name == null ? 0 : getByteBufferAddress(name_buf),
        rv_addr + 0);
    long value;
    value = rv_buf.getLong(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeIncrementI64(int id, long name, long value);

  public static double IMAQdxGetAttributeIncrementF64(int id, String name) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer rv_buf = ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
    long rv_addr = getByteBufferAddress(rv_buf);
    _IMAQdxGetAttributeIncrementF64(id, name == null ? 0 : getByteBufferAddress(name_buf),
        rv_addr + 0);
    double value;
    value = rv_buf.getDouble(0);
    return value;
  }

  private static native void _IMAQdxGetAttributeIncrementF64(int id, long name, long value);

  public static void IMAQdxSetAttributeU32(int id, String name, int value) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    _IMAQdxSetAttributeU32(id, name == null ? 0 : getByteBufferAddress(name_buf), value);

  }

  private static native void _IMAQdxSetAttributeU32(int id, long name, int value);

  public static void IMAQdxSetAttributeI64(int id, String name, long value) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    _IMAQdxSetAttributeI64(id, name == null ? 0 : getByteBufferAddress(name_buf), value);

  }

  private static native void _IMAQdxSetAttributeI64(int id, long name, long value);

  public static void IMAQdxSetAttributeF64(int id, String name, double value) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    _IMAQdxSetAttributeF64(id, name == null ? 0 : getByteBufferAddress(name_buf), value);

  }

  private static native void _IMAQdxSetAttributeF64(int id, long name, double value);

  public static void IMAQdxSetAttributeString(int id, String name, String value) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    ByteBuffer value_buf = null;
    if (value != null) {
      byte[] value_bytes;
      try {
        value_bytes = value.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        value_bytes = new byte[0];
      }
      value_buf = ByteBuffer.allocateDirect(value_bytes.length + 1);
      putBytes(value_buf, value_bytes, 0, value_bytes.length).put(value_bytes.length, (byte) 0);
    }
    _IMAQdxSetAttributeString(id, name == null ? 0 : getByteBufferAddress(name_buf),
        value == null ? 0 : getByteBufferAddress(value_buf));

  }

  private static native void _IMAQdxSetAttributeString(int id, long name, long value);

  public static void IMAQdxSetAttributeEnum(int id, String name, IMAQdxEnumItem value) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    _IMAQdxSetAttributeEnum(id, name == null ? 0 : getByteBufferAddress(name_buf),
        value.getAddress());

  }

  private static native void _IMAQdxSetAttributeEnum(int id, long name, long value);

  public static void IMAQdxSetAttributeBool(int id, String name, int value) {
    ByteBuffer name_buf = null;
    if (name != null) {
      byte[] name_bytes;
      try {
        name_bytes = name.getBytes("UTF-8");
      } catch (UnsupportedEncodingException e) {
        name_bytes = new byte[0];
      }
      name_buf = ByteBuffer.allocateDirect(name_bytes.length + 1);
      putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte) 0);
    }
    _IMAQdxSetAttributeBool(id, name == null ? 0 : getByteBufferAddress(name_buf), value);

  }

  private static native void _IMAQdxSetAttributeBool(int id, long name, int value);
}
