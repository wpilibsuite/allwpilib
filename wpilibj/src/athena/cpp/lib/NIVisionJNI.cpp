//
// This file is auto-generated by wpilibj/wpilibJavaJNI/nivision/gen_java.py
// Please do not edit!
//

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <jni.h>
#include <nivision.h>
#include <NIIMAQdx.h>

static const char* getErrorText(int err);

// throw java exception
static void throwJavaException(JNIEnv *env) {
    jclass je = env->FindClass("com/ni/vision/VisionException");
    int err = imaqGetLastError();
    const char* err_text = getErrorText(err);
    char* full_err_msg = static_cast<char*>(malloc(30+strlen(err_text)));
    sprintf(full_err_msg, "imaqError: %d: %s", err, err_text);
    env->ThrowNew(je, full_err_msg);
    free(full_err_msg);
}

// throw IMAQdx java exception
static void dxthrowJavaException(JNIEnv *env, IMAQdxError err) {
    jclass je = env->FindClass("com/ni/vision/VisionException");
    const char* err_text = getErrorText(err);
    char* full_err_msg = static_cast<char*>(malloc(30+strlen(err_text)));
    sprintf(full_err_msg, "IMAQdxError: %d: %s", err, err_text);
    env->ThrowNew(je, full_err_msg);
    free(full_err_msg);
}

extern "C" {

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision_imaqDispose(JNIEnv* , jclass , jlong addr)
{
    imaqDispose((void*)addr);
}

static inline IMAQdxError NI_FUNC IMAQdxGetAttributeU32(IMAQdxSession id, const char* name, uInt32* value)
{
    return IMAQdxGetAttribute(id, name, IMAQdxValueTypeU32, (void*)value);
}
static inline IMAQdxError NI_FUNC IMAQdxGetAttributeI64(IMAQdxSession id, const char* name, Int64* value)
{
    return IMAQdxGetAttribute(id, name, IMAQdxValueTypeI64, (void*)value);
}
static inline IMAQdxError NI_FUNC IMAQdxGetAttributeF64(IMAQdxSession id, const char* name, float64* value)
{
    return IMAQdxGetAttribute(id, name, IMAQdxValueTypeF64, (void*)value);
}
static inline IMAQdxError NI_FUNC IMAQdxGetAttributeString(IMAQdxSession id, const char* name, char value[IMAQDX_MAX_API_STRING_LENGTH])
{
    return IMAQdxGetAttribute(id, name, IMAQdxValueTypeString, (void*)value);
}
static inline IMAQdxError NI_FUNC IMAQdxGetAttributeEnum(IMAQdxSession id, const char* name, IMAQdxEnumItem* value)
{
    return IMAQdxGetAttribute(id, name, IMAQdxValueTypeEnumItem, (void*)value);
}
static inline IMAQdxError NI_FUNC IMAQdxGetAttributeBool(IMAQdxSession id, const char* name, bool32* value)
{
    return IMAQdxGetAttribute(id, name, IMAQdxValueTypeBool, (void*)value);
}

static inline IMAQdxError NI_FUNC IMAQdxGetAttributeMinimumU32(IMAQdxSession id, const char* name, uInt32* value)
{
    return IMAQdxGetAttributeMinimum(id, name, IMAQdxValueTypeU32, (void*)value);
}
static inline IMAQdxError NI_FUNC IMAQdxGetAttributeMinimumI64(IMAQdxSession id, const char* name, Int64* value)
{
    return IMAQdxGetAttributeMinimum(id, name, IMAQdxValueTypeI64, (void*)value);
}
static inline IMAQdxError NI_FUNC IMAQdxGetAttributeMinimumF64(IMAQdxSession id, const char* name, float64* value)
{
    return IMAQdxGetAttributeMinimum(id, name, IMAQdxValueTypeF64, (void*)value);
}

static inline IMAQdxError NI_FUNC IMAQdxGetAttributeMaximumU32(IMAQdxSession id, const char* name, uInt32* value)
{
    return IMAQdxGetAttributeMaximum(id, name, IMAQdxValueTypeU32, (void*)value);
}
static inline IMAQdxError NI_FUNC IMAQdxGetAttributeMaximumI64(IMAQdxSession id, const char* name, Int64* value)
{
    return IMAQdxGetAttributeMaximum(id, name, IMAQdxValueTypeI64, (void*)value);
}
static inline IMAQdxError NI_FUNC IMAQdxGetAttributeMaximumF64(IMAQdxSession id, const char* name, float64* value)
{
    return IMAQdxGetAttributeMaximum(id, name, IMAQdxValueTypeF64, (void*)value);
}

static inline IMAQdxError NI_FUNC IMAQdxGetAttributeIncrementU32(IMAQdxSession id, const char* name, uInt32* value)
{
    return IMAQdxGetAttributeIncrement(id, name, IMAQdxValueTypeU32, (void*)value);
}
static inline IMAQdxError NI_FUNC IMAQdxGetAttributeIncrementI64(IMAQdxSession id, const char* name, Int64* value)
{
    return IMAQdxGetAttributeIncrement(id, name, IMAQdxValueTypeI64, (void*)value);
}
static inline IMAQdxError NI_FUNC IMAQdxGetAttributeIncrementF64(IMAQdxSession id, const char* name, float64* value)
{
    return IMAQdxGetAttributeIncrement(id, name, IMAQdxValueTypeF64, (void*)value);
}

static inline IMAQdxError NI_FUNC IMAQdxSetAttributeU32(IMAQdxSession id, const char* name, uInt32 value)
{
    return IMAQdxSetAttribute(id, name, IMAQdxValueTypeU32, value);
}
static inline IMAQdxError NI_FUNC IMAQdxSetAttributeI64(IMAQdxSession id, const char* name, Int64 value)
{
    return IMAQdxSetAttribute(id, name, IMAQdxValueTypeI64, value);
}
static inline IMAQdxError NI_FUNC IMAQdxSetAttributeF64(IMAQdxSession id, const char* name, float64 value)
{
    return IMAQdxSetAttribute(id, name, IMAQdxValueTypeF64, value);
}
static inline IMAQdxError NI_FUNC IMAQdxSetAttributeString(IMAQdxSession id, const char* name, const char* value)
{
    return IMAQdxSetAttribute(id, name, IMAQdxValueTypeString, value);
}
static inline IMAQdxError NI_FUNC IMAQdxSetAttributeEnum(IMAQdxSession id, const char* name, const IMAQdxEnumItem* value)
{
    return IMAQdxSetAttribute(id, name, IMAQdxValueTypeU32, value->Value);
}
static inline IMAQdxError NI_FUNC IMAQdxSetAttributeBool(IMAQdxSession id, const char* name, bool32 value)
{
    return IMAQdxSetAttribute(id, name, IMAQdxValueTypeBool, value);
}


/*
 * Opaque Structures
 */

/*
 * Manifest Constants
 */

/*
 * Predefined Valid Characters
 */

/*
 * Enumerated Types
 */

/*
 * Forward Declare Data Structures
 */

/*
 * Data Structures
 */

/*
 * Globals
 */

/*
 * Logical functions
 */

/* J: void imaqAnd(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqAnd(long dest, long sourceA, long sourceB)
 * C: int imaqAnd(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAnd(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqAnd((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqCompare(Image dest, Image source, Image compareImage, ComparisonFunction compare)
 * JN: void imaqCompare(long dest, long source, long compareImage, int compare)
 * C: int imaqCompare(Image* dest, const Image* source, const Image* compareImage, ComparisonFunction compare)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCompare(JNIEnv* env, jclass , jlong dest, jlong source, jlong compareImage, jint compare)
{
    int rv = imaqCompare((Image*)dest, (const Image*)source, (const Image*)compareImage, (ComparisonFunction)compare);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqLogicalDifference(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqLogicalDifference(long dest, long sourceA, long sourceB)
 * C: int imaqLogicalDifference(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLogicalDifference(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqLogicalDifference((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqNand(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqNand(long dest, long sourceA, long sourceB)
 * C: int imaqNand(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqNand(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqNand((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqNor(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqNor(long dest, long sourceA, long sourceB)
 * C: int imaqNor(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqNor(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqNor((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqOr(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqOr(long dest, long sourceA, long sourceB)
 * C: int imaqOr(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOr(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqOr((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqXnor(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqXnor(long dest, long sourceA, long sourceB)
 * C: int imaqXnor(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqXnor(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqXnor((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqXor(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqXor(long dest, long sourceA, long sourceB)
 * C: int imaqXor(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqXor(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqXor((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/*
 * Particle Analysis functions
 */

/* J: void imaqCountParticles(Image image, int connectivity8)
 * JN: void imaqCountParticles(long image, int connectivity8, long numParticles)
 * C: int imaqCountParticles(Image* image, int connectivity8, int* numParticles)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCountParticles(JNIEnv* env, jclass , jlong image, jint connectivity8, jlong numParticles)
{
    int rv = imaqCountParticles((Image*)image, (int)connectivity8, (int*)numParticles);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMeasureParticle(Image image, int particleNumber, int calibrated, MeasurementType measurement)
 * JN: void imaqMeasureParticle(long image, int particleNumber, int calibrated, int measurement, long value)
 * C: int imaqMeasureParticle(Image* image, int particleNumber, int calibrated, MeasurementType measurement, double* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMeasureParticle(JNIEnv* env, jclass , jlong image, jint particleNumber, jint calibrated, jint measurement, jlong value)
{
    int rv = imaqMeasureParticle((Image*)image, (int)particleNumber, (int)calibrated, (MeasurementType)measurement, (double*)value);
    if (rv == 0) throwJavaException(env);
}

/* J: MeasureParticlesReport imaqMeasureParticles(Image image, MeasureParticlesCalibrationMode calibrationMode, MeasurementType[] measurements)
 * JN: long imaqMeasureParticles(long image, int calibrationMode, long measurements, int numMeasurements)
 * C: MeasureParticlesReport* imaqMeasureParticles(Image* image, MeasureParticlesCalibrationMode calibrationMode, const MeasurementType* measurements, size_t numMeasurements)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMeasureParticles(JNIEnv* env, jclass , jlong image, jint calibrationMode, jlong measurements, jint numMeasurements)
{
    MeasureParticlesReport* rv = imaqMeasureParticles((Image*)image, (MeasureParticlesCalibrationMode)calibrationMode, (const MeasurementType*)measurements, (size_t)numMeasurements);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqParticleFilter4(Image dest, Image source, ParticleFilterCriteria2[] criteria, ParticleFilterOptions2 options, ROI roi)
 * JN: void imaqParticleFilter4(long dest, long source, long criteria, int criteriaCount, long options, long roi, long numParticles)
 * C: int imaqParticleFilter4(Image* dest, Image* source, const ParticleFilterCriteria2* criteria, int criteriaCount, const ParticleFilterOptions2* options, const ROI* roi, int* numParticles)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqParticleFilter4(JNIEnv* env, jclass , jlong dest, jlong source, jlong criteria, jint criteriaCount, jlong options, jlong roi, jlong numParticles)
{
    int rv = imaqParticleFilter4((Image*)dest, (Image*)source, (const ParticleFilterCriteria2*)criteria, (int)criteriaCount, (const ParticleFilterOptions2*)options, (const ROI*)roi, (int*)numParticles);
    if (rv == 0) throwJavaException(env);
}

/*
 * Morphology functions
 */

/* J: void imaqConvexHull(Image dest, Image source, int connectivity8)
 * JN: void imaqConvexHull(long dest, long source, int connectivity8)
 * C: int imaqConvexHull(Image* dest, Image* source, int connectivity8)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqConvexHull(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8)
{
    int rv = imaqConvexHull((Image*)dest, (Image*)source, (int)connectivity8);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqDanielssonDistance(Image dest, Image source)
 * JN: void imaqDanielssonDistance(long dest, long source)
 * C: int imaqDanielssonDistance(Image* dest, Image* source)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDanielssonDistance(JNIEnv* env, jclass , jlong dest, jlong source)
{
    int rv = imaqDanielssonDistance((Image*)dest, (Image*)source);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqFillHoles(Image dest, Image source, int connectivity8)
 * JN: void imaqFillHoles(long dest, long source, int connectivity8)
 * C: int imaqFillHoles(Image* dest, const Image* source, int connectivity8)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFillHoles(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8)
{
    int rv = imaqFillHoles((Image*)dest, (const Image*)source, (int)connectivity8);
    if (rv == 0) throwJavaException(env);
}

/* J: FindCirclesResult imaqFindCircles(Image dest, Image source, float minRadius, float maxRadius)
 * JN: long imaqFindCircles(long dest, long source, float minRadius, float maxRadius, long numCircles)
 * C: CircleReport* imaqFindCircles(Image* dest, Image* source, float minRadius, float maxRadius, int* numCircles)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFindCircles(JNIEnv* env, jclass , jlong dest, jlong source, jfloat minRadius, jfloat maxRadius, jlong numCircles)
{
    CircleReport* rv = imaqFindCircles((Image*)dest, (Image*)source, (float)minRadius, (float)maxRadius, (int*)numCircles);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqLabel2(Image dest, Image source, int connectivity8)
 * JN: void imaqLabel2(long dest, long source, int connectivity8, long particleCount)
 * C: int imaqLabel2(Image* dest, Image* source, int connectivity8, int* particleCount)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLabel2(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8, jlong particleCount)
{
    int rv = imaqLabel2((Image*)dest, (Image*)source, (int)connectivity8, (int*)particleCount);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMorphology(Image dest, Image source, MorphologyMethod method, StructuringElement structuringElement)
 * JN: void imaqMorphology(long dest, long source, int method, long structuringElement)
 * C: int imaqMorphology(Image* dest, Image* source, MorphologyMethod method, const StructuringElement* structuringElement)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMorphology(JNIEnv* env, jclass , jlong dest, jlong source, jint method, jlong structuringElement)
{
    int rv = imaqMorphology((Image*)dest, (Image*)source, (MorphologyMethod)method, (const StructuringElement*)structuringElement);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqRejectBorder(Image dest, Image source, int connectivity8)
 * JN: void imaqRejectBorder(long dest, long source, int connectivity8)
 * C: int imaqRejectBorder(Image* dest, Image* source, int connectivity8)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRejectBorder(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8)
{
    int rv = imaqRejectBorder((Image*)dest, (Image*)source, (int)connectivity8);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSegmentation(Image dest, Image source)
 * JN: void imaqSegmentation(long dest, long source)
 * C: int imaqSegmentation(Image* dest, Image* source)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSegmentation(JNIEnv* env, jclass , jlong dest, jlong source)
{
    int rv = imaqSegmentation((Image*)dest, (Image*)source);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSeparation(Image dest, Image source, int erosions, StructuringElement structuringElement)
 * JN: void imaqSeparation(long dest, long source, int erosions, long structuringElement)
 * C: int imaqSeparation(Image* dest, Image* source, int erosions, const StructuringElement* structuringElement)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSeparation(JNIEnv* env, jclass , jlong dest, jlong source, jint erosions, jlong structuringElement)
{
    int rv = imaqSeparation((Image*)dest, (Image*)source, (int)erosions, (const StructuringElement*)structuringElement);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSimpleDistance(Image dest, Image source, StructuringElement structuringElement)
 * JN: void imaqSimpleDistance(long dest, long source, long structuringElement)
 * C: int imaqSimpleDistance(Image* dest, Image* source, const StructuringElement* structuringElement)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSimpleDistance(JNIEnv* env, jclass , jlong dest, jlong source, jlong structuringElement)
{
    int rv = imaqSimpleDistance((Image*)dest, (Image*)source, (const StructuringElement*)structuringElement);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSizeFilter(Image dest, Image source, int connectivity8, int erosions, SizeType keepSize, StructuringElement structuringElement)
 * JN: void imaqSizeFilter(long dest, long source, int connectivity8, int erosions, int keepSize, long structuringElement)
 * C: int imaqSizeFilter(Image* dest, Image* source, int connectivity8, int erosions, SizeType keepSize, const StructuringElement* structuringElement)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSizeFilter(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8, jint erosions, jint keepSize, jlong structuringElement)
{
    int rv = imaqSizeFilter((Image*)dest, (Image*)source, (int)connectivity8, (int)erosions, (SizeType)keepSize, (const StructuringElement*)structuringElement);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSkeleton(Image dest, Image source, SkeletonMethod method)
 * JN: void imaqSkeleton(long dest, long source, int method)
 * C: int imaqSkeleton(Image* dest, Image* source, SkeletonMethod method)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSkeleton(JNIEnv* env, jclass , jlong dest, jlong source, jint method)
{
    int rv = imaqSkeleton((Image*)dest, (Image*)source, (SkeletonMethod)method);
    if (rv == 0) throwJavaException(env);
}

/*
 * Acquisition functions
 */

/*
 * Arithmetic functions
 */

/* J: void imaqAbsoluteDifference(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqAbsoluteDifference(long dest, long sourceA, long sourceB)
 * C: int imaqAbsoluteDifference(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAbsoluteDifference(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqAbsoluteDifference((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqAdd(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqAdd(long dest, long sourceA, long sourceB)
 * C: int imaqAdd(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAdd(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqAdd((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqAverage(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqAverage(long dest, long sourceA, long sourceB)
 * C: int imaqAverage(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAverage(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqAverage((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqDivide2(Image dest, Image sourceA, Image sourceB, RoundingMode roundingMode)
 * JN: void imaqDivide2(long dest, long sourceA, long sourceB, int roundingMode)
 * C: int imaqDivide2(Image* dest, const Image* sourceA, const Image* sourceB, RoundingMode roundingMode)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDivide2(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB, jint roundingMode)
{
    int rv = imaqDivide2((Image*)dest, (const Image*)sourceA, (const Image*)sourceB, (RoundingMode)roundingMode);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMax(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqMax(long dest, long sourceA, long sourceB)
 * C: int imaqMax(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMax(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqMax((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMin(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqMin(long dest, long sourceA, long sourceB)
 * C: int imaqMin(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMin(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqMin((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqModulo(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqModulo(long dest, long sourceA, long sourceB)
 * C: int imaqModulo(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqModulo(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqModulo((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMulDiv(Image dest, Image sourceA, Image sourceB, float value)
 * JN: void imaqMulDiv(long dest, long sourceA, long sourceB, float value)
 * C: int imaqMulDiv(Image* dest, const Image* sourceA, const Image* sourceB, float value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMulDiv(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB, jfloat value)
{
    int rv = imaqMulDiv((Image*)dest, (const Image*)sourceA, (const Image*)sourceB, (float)value);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMultiply(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqMultiply(long dest, long sourceA, long sourceB)
 * C: int imaqMultiply(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMultiply(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqMultiply((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSubtract(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqSubtract(long dest, long sourceA, long sourceB)
 * C: int imaqSubtract(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSubtract(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqSubtract((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/*
 * Caliper functions
 */

/* J: CaliperToolResult imaqCaliperTool(Image image, Point[] points, EdgeOptions edgeOptions, CaliperOptions caliperOptions)
 * JN: long imaqCaliperTool(long image, long points, int numPoints, long edgeOptions, long caliperOptions, long numEdgePairs)
 * C: CaliperReport* imaqCaliperTool(const Image* image, const Point* points, int numPoints, const EdgeOptions* edgeOptions, const CaliperOptions* caliperOptions, int* numEdgePairs)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCaliperTool(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jlong edgeOptions, jlong caliperOptions, jlong numEdgePairs)
{
    CaliperReport* rv = imaqCaliperTool((const Image*)image, (const Point*)points, (int)numPoints, (const EdgeOptions*)edgeOptions, (const CaliperOptions*)caliperOptions, (int*)numEdgePairs);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ConcentricRakeReport2 imaqConcentricRake2(Image image, ROI roi, ConcentricRakeDirection direction, EdgeProcess process, int stepSize)
 * JN: long imaqConcentricRake2(long image, long roi, int direction, int process, int stepSize, long edgeOptions)
 * C: ConcentricRakeReport2* imaqConcentricRake2(Image* image, ROI* roi, ConcentricRakeDirection direction, EdgeProcess process, int stepSize, EdgeOptions2* edgeOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqConcentricRake2(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jint stepSize, jlong edgeOptions)
{
    ConcentricRakeReport2* rv = imaqConcentricRake2((Image*)image, (ROI*)roi, (ConcentricRakeDirection)direction, (EdgeProcess)process, (int)stepSize, (EdgeOptions2*)edgeOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: DetectExtremesResult imaqDetectExtremes(double[] pixels, DetectionMode mode, DetectExtremesOptions options)
 * JN: long imaqDetectExtremes(long pixels, int numPixels, int mode, long options, long numExtremes)
 * C: ExtremeReport* imaqDetectExtremes(const double* pixels, int numPixels, DetectionMode mode, const DetectExtremesOptions* options, int* numExtremes)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqDetectExtremes(JNIEnv* env, jclass , jlong pixels, jint numPixels, jint mode, jlong options, jlong numExtremes)
{
    ExtremeReport* rv = imaqDetectExtremes((const double*)pixels, (int)numPixels, (DetectionMode)mode, (const DetectExtremesOptions*)options, (int*)numExtremes);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqDetectRotation(Image referenceImage, Image testImage, PointFloat referenceCenter, PointFloat testCenter, int radius, float precision)
 * JN: void imaqDetectRotation(long referenceImage, long testImage, long referenceCenter, long testCenter, int radius, float precision, long angle)
 * C: int imaqDetectRotation(const Image* referenceImage, const Image* testImage, PointFloat referenceCenter, PointFloat testCenter, int radius, float precision, double* angle)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDetectRotation(JNIEnv* env, jclass , jlong referenceImage, jlong testImage, jlong referenceCenter, jlong testCenter, jint radius, jfloat precision, jlong angle)
{
    int rv = imaqDetectRotation((const Image*)referenceImage, (const Image*)testImage, *((PointFloat*)referenceCenter), *((PointFloat*)testCenter), (int)radius, (float)precision, (double*)angle);
    if (rv == 0) throwJavaException(env);
}

/* J: EdgeReport2 imaqEdgeTool4(Image image, ROI roi, EdgeProcess processType, int reverseDirection)
 * JN: long imaqEdgeTool4(long image, long roi, int processType, long edgeOptions, int reverseDirection)
 * C: EdgeReport2* imaqEdgeTool4(Image* image, ROI* roi, EdgeProcess processType, EdgeOptions2* edgeOptions, const unsigned int reverseDirection)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqEdgeTool4(JNIEnv* env, jclass , jlong image, jlong roi, jint processType, jlong edgeOptions, jint reverseDirection)
{
    EdgeReport2* rv = imaqEdgeTool4((Image*)image, (ROI*)roi, (EdgeProcess)processType, (EdgeOptions2*)edgeOptions, (const unsigned int)reverseDirection);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: FindEdgeReport imaqFindEdge2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, FindEdgeOptions2 findEdgeOptions, StraightEdgeOptions straightEdgeOptions)
 * JN: long imaqFindEdge2(long image, long roi, long baseSystem, long newSystem, long findEdgeOptions, long straightEdgeOptions)
 * C: FindEdgeReport* imaqFindEdge2(Image* image, const ROI* roi, const CoordinateSystem* baseSystem, const CoordinateSystem* newSystem, const FindEdgeOptions2* findEdgeOptions, const StraightEdgeOptions* straightEdgeOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFindEdge2(JNIEnv* env, jclass , jlong image, jlong roi, jlong baseSystem, jlong newSystem, jlong findEdgeOptions, jlong straightEdgeOptions)
{
    FindEdgeReport* rv = imaqFindEdge2((Image*)image, (const ROI*)roi, (const CoordinateSystem*)baseSystem, (const CoordinateSystem*)newSystem, (const FindEdgeOptions2*)findEdgeOptions, (const StraightEdgeOptions*)straightEdgeOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqFindTransformRect2(Image image, ROI roi, FindTransformMode mode, FindTransformRectOptions2 findTransformOptions, StraightEdgeOptions straightEdgeOptions)
 * JN: void imaqFindTransformRect2(long image, long roi, int mode, long baseSystem, long newSystem, long findTransformOptions, long straightEdgeOptions, long axisReport)
 * C: int imaqFindTransformRect2(Image* image, const ROI* roi, FindTransformMode mode, CoordinateSystem* baseSystem, CoordinateSystem* newSystem, const FindTransformRectOptions2* findTransformOptions, const StraightEdgeOptions* straightEdgeOptions, AxisReport* axisReport)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFindTransformRect2(JNIEnv* env, jclass , jlong image, jlong roi, jint mode, jlong baseSystem, jlong newSystem, jlong findTransformOptions, jlong straightEdgeOptions, jlong axisReport)
{
    int rv = imaqFindTransformRect2((Image*)image, (const ROI*)roi, (FindTransformMode)mode, (CoordinateSystem*)baseSystem, (CoordinateSystem*)newSystem, (const FindTransformRectOptions2*)findTransformOptions, (const StraightEdgeOptions*)straightEdgeOptions, (AxisReport*)axisReport);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqFindTransformRects2(Image image, ROI primaryROI, ROI secondaryROI, FindTransformMode mode, FindTransformRectsOptions2 findTransformOptions, StraightEdgeOptions primaryStraightEdgeOptions, StraightEdgeOptions secondaryStraightEdgeOptions)
 * JN: void imaqFindTransformRects2(long image, long primaryROI, long secondaryROI, int mode, long baseSystem, long newSystem, long findTransformOptions, long primaryStraightEdgeOptions, long secondaryStraightEdgeOptions, long axisReport)
 * C: int imaqFindTransformRects2(Image* image, const ROI* primaryROI, const ROI* secondaryROI, FindTransformMode mode, CoordinateSystem* baseSystem, CoordinateSystem* newSystem, const FindTransformRectsOptions2* findTransformOptions, const StraightEdgeOptions* primaryStraightEdgeOptions, const StraightEdgeOptions* secondaryStraightEdgeOptions, AxisReport* axisReport)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFindTransformRects2(JNIEnv* env, jclass , jlong image, jlong primaryROI, jlong secondaryROI, jint mode, jlong baseSystem, jlong newSystem, jlong findTransformOptions, jlong primaryStraightEdgeOptions, jlong secondaryStraightEdgeOptions, jlong axisReport)
{
    int rv = imaqFindTransformRects2((Image*)image, (const ROI*)primaryROI, (const ROI*)secondaryROI, (FindTransformMode)mode, (CoordinateSystem*)baseSystem, (CoordinateSystem*)newSystem, (const FindTransformRectsOptions2*)findTransformOptions, (const StraightEdgeOptions*)primaryStraightEdgeOptions, (const StraightEdgeOptions*)secondaryStraightEdgeOptions, (AxisReport*)axisReport);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqLineGaugeTool2(Image image, Point start, Point end, LineGaugeMethod method, EdgeOptions edgeOptions, CoordinateTransform2 transform)
 * JN: void imaqLineGaugeTool2(long image, long start, long end, int method, long edgeOptions, long transform, long distance)
 * C: int imaqLineGaugeTool2(const Image* image, Point start, Point end, LineGaugeMethod method, const EdgeOptions* edgeOptions, const CoordinateTransform2* transform, float* distance)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLineGaugeTool2(JNIEnv* env, jclass , jlong image, jlong start, jlong end, jint method, jlong edgeOptions, jlong transform, jlong distance)
{
    int rv = imaqLineGaugeTool2((const Image*)image, *((Point*)start), *((Point*)end), (LineGaugeMethod)method, (const EdgeOptions*)edgeOptions, (const CoordinateTransform2*)transform, (float*)distance);
    if (rv == 0) throwJavaException(env);
}

/* J: RakeReport2 imaqRake2(Image image, ROI roi, RakeDirection direction, EdgeProcess process, int stepSize)
 * JN: long imaqRake2(long image, long roi, int direction, int process, int stepSize, long edgeOptions)
 * C: RakeReport2* imaqRake2(Image* image, ROI* roi, RakeDirection direction, EdgeProcess process, int stepSize, EdgeOptions2* edgeOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqRake2(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jint stepSize, jlong edgeOptions)
{
    RakeReport2* rv = imaqRake2((Image*)image, (ROI*)roi, (RakeDirection)direction, (EdgeProcess)process, (int)stepSize, (EdgeOptions2*)edgeOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: SimpleEdgeResult imaqSimpleEdge(Image image, Point[] points, SimpleEdgeOptions options)
 * JN: long imaqSimpleEdge(long image, long points, int numPoints, long options, long numEdges)
 * C: PointFloat* imaqSimpleEdge(const Image* image, const Point* points, int numPoints, const SimpleEdgeOptions* options, int* numEdges)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqSimpleEdge(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jlong options, jlong numEdges)
{
    PointFloat* rv = imaqSimpleEdge((const Image*)image, (const Point*)points, (int)numPoints, (const SimpleEdgeOptions*)options, (int*)numEdges);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: SpokeReport2 imaqSpoke2(Image image, ROI roi, SpokeDirection direction, EdgeProcess process, int stepSize)
 * JN: long imaqSpoke2(long image, long roi, int direction, int process, int stepSize, long edgeOptions)
 * C: SpokeReport2* imaqSpoke2(Image* image, ROI* roi, SpokeDirection direction, EdgeProcess process, int stepSize, EdgeOptions2* edgeOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqSpoke2(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jint stepSize, jlong edgeOptions)
{
    SpokeReport2* rv = imaqSpoke2((Image*)image, (ROI*)roi, (SpokeDirection)direction, (EdgeProcess)process, (int)stepSize, (EdgeOptions2*)edgeOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: StraightEdgeReport2 imaqStraightEdge(Image image, ROI roi, SearchDirection searchDirection, EdgeOptions2 edgeOptions, StraightEdgeOptions straightEdgeOptions)
 * JN: long imaqStraightEdge(long image, long roi, int searchDirection, long edgeOptions, long straightEdgeOptions)
 * C: StraightEdgeReport2* imaqStraightEdge(const Image* image, const ROI* roi, SearchDirection searchDirection, const EdgeOptions2* edgeOptions, const StraightEdgeOptions* straightEdgeOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqStraightEdge(JNIEnv* env, jclass , jlong image, jlong roi, jint searchDirection, jlong edgeOptions, jlong straightEdgeOptions)
{
    StraightEdgeReport2* rv = imaqStraightEdge((const Image*)image, (const ROI*)roi, (SearchDirection)searchDirection, (const EdgeOptions2*)edgeOptions, (const StraightEdgeOptions*)straightEdgeOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: StraightEdgeReport2 imaqStraightEdge2(Image image, ROI roi, SearchDirection searchDirection, EdgeOptions2 edgeOptions, StraightEdgeOptions straightEdgeOptions, int optimizedMode)
 * JN: long imaqStraightEdge2(long image, long roi, int searchDirection, long edgeOptions, long straightEdgeOptions, int optimizedMode)
 * C: StraightEdgeReport2* imaqStraightEdge2(const Image* image, const ROI* roi, SearchDirection searchDirection, const EdgeOptions2* edgeOptions, const StraightEdgeOptions* straightEdgeOptions, unsigned int optimizedMode)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqStraightEdge2(JNIEnv* env, jclass , jlong image, jlong roi, jint searchDirection, jlong edgeOptions, jlong straightEdgeOptions, jint optimizedMode)
{
    StraightEdgeReport2* rv = imaqStraightEdge2((const Image*)image, (const ROI*)roi, (SearchDirection)searchDirection, (const EdgeOptions2*)edgeOptions, (const StraightEdgeOptions*)straightEdgeOptions, (unsigned int)optimizedMode);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Spatial Filters functions
 */

/* J: void imaqCannyEdgeFilter(Image dest, Image source, CannyOptions options)
 * JN: void imaqCannyEdgeFilter(long dest, long source, long options)
 * C: int imaqCannyEdgeFilter(Image* dest, const Image* source, const CannyOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCannyEdgeFilter(JNIEnv* env, jclass , jlong dest, jlong source, jlong options)
{
    int rv = imaqCannyEdgeFilter((Image*)dest, (const Image*)source, (const CannyOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqCorrelate(Image dest, Image source, Image templateImage, Rect rect)
 * JN: void imaqCorrelate(long dest, long source, long templateImage, long rect)
 * C: int imaqCorrelate(Image* dest, Image* source, const Image* templateImage, Rect rect)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCorrelate(JNIEnv* env, jclass , jlong dest, jlong source, jlong templateImage, jlong rect)
{
    int rv = imaqCorrelate((Image*)dest, (Image*)source, (const Image*)templateImage, *((Rect*)rect));
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqEdgeFilter(Image dest, Image source, OutlineMethod method, Image mask)
 * JN: void imaqEdgeFilter(long dest, long source, int method, long mask)
 * C: int imaqEdgeFilter(Image* dest, Image* source, OutlineMethod method, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqEdgeFilter(JNIEnv* env, jclass , jlong dest, jlong source, jint method, jlong mask)
{
    int rv = imaqEdgeFilter((Image*)dest, (Image*)source, (OutlineMethod)method, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqLowPass(Image dest, Image source, int width, int height, float tolerance, Image mask)
 * JN: void imaqLowPass(long dest, long source, int width, int height, float tolerance, long mask)
 * C: int imaqLowPass(Image* dest, Image* source, int width, int height, float tolerance, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLowPass(JNIEnv* env, jclass , jlong dest, jlong source, jint width, jint height, jfloat tolerance, jlong mask)
{
    int rv = imaqLowPass((Image*)dest, (Image*)source, (int)width, (int)height, (float)tolerance, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMedianFilter(Image dest, Image source, int width, int height, Image mask)
 * JN: void imaqMedianFilter(long dest, long source, int width, int height, long mask)
 * C: int imaqMedianFilter(Image* dest, Image* source, int width, int height, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMedianFilter(JNIEnv* env, jclass , jlong dest, jlong source, jint width, jint height, jlong mask)
{
    int rv = imaqMedianFilter((Image*)dest, (Image*)source, (int)width, (int)height, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqNthOrderFilter(Image dest, Image source, int width, int height, int n, Image mask)
 * JN: void imaqNthOrderFilter(long dest, long source, int width, int height, int n, long mask)
 * C: int imaqNthOrderFilter(Image* dest, Image* source, int width, int height, int n, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqNthOrderFilter(JNIEnv* env, jclass , jlong dest, jlong source, jint width, jint height, jint n, jlong mask)
{
    int rv = imaqNthOrderFilter((Image*)dest, (Image*)source, (int)width, (int)height, (int)n, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/*
 * Drawing functions
 */

/* J: void imaqDrawLineOnImage(Image dest, Image source, DrawMode mode, Point start, Point end, float newPixelValue)
 * JN: void imaqDrawLineOnImage(long dest, long source, int mode, long start, long end, float newPixelValue)
 * C: int imaqDrawLineOnImage(Image* dest, const Image* source, DrawMode mode, Point start, Point end, float newPixelValue)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDrawLineOnImage(JNIEnv* env, jclass , jlong dest, jlong source, jint mode, jlong start, jlong end, jfloat newPixelValue)
{
    int rv = imaqDrawLineOnImage((Image*)dest, (const Image*)source, (DrawMode)mode, *((Point*)start), *((Point*)end), (float)newPixelValue);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqDrawShapeOnImage(Image dest, Image source, Rect rect, DrawMode mode, ShapeMode shape, float newPixelValue)
 * JN: void imaqDrawShapeOnImage(long dest, long source, long rect, int mode, int shape, float newPixelValue)
 * C: int imaqDrawShapeOnImage(Image* dest, const Image* source, Rect rect, DrawMode mode, ShapeMode shape, float newPixelValue)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDrawShapeOnImage(JNIEnv* env, jclass , jlong dest, jlong source, jlong rect, jint mode, jint shape, jfloat newPixelValue)
{
    int rv = imaqDrawShapeOnImage((Image*)dest, (const Image*)source, *((Rect*)rect), (DrawMode)mode, (ShapeMode)shape, (float)newPixelValue);
    if (rv == 0) throwJavaException(env);
}

/*
 * Interlacing functions
 */

/* J: void imaqInterlaceCombine(Image frame, Image odd, Image even)
 * JN: void imaqInterlaceCombine(long frame, long odd, long even)
 * C: int imaqInterlaceCombine(Image* frame, const Image* odd, const Image* even)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqInterlaceCombine(JNIEnv* env, jclass , jlong frame, jlong odd, jlong even)
{
    int rv = imaqInterlaceCombine((Image*)frame, (const Image*)odd, (const Image*)even);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqInterlaceSeparate(Image frame, Image odd, Image even)
 * JN: void imaqInterlaceSeparate(long frame, long odd, long even)
 * C: int imaqInterlaceSeparate(const Image* frame, Image* odd, Image* even)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqInterlaceSeparate(JNIEnv* env, jclass , jlong frame, jlong odd, jlong even)
{
    int rv = imaqInterlaceSeparate((const Image*)frame, (Image*)odd, (Image*)even);
    if (rv == 0) throwJavaException(env);
}

/*
 * Image Information functions
 */

/* J: EnumerateCustomKeysResult imaqEnumerateCustomKeys(Image image)
 * JN: long imaqEnumerateCustomKeys(long image, long size)
 * C: char** imaqEnumerateCustomKeys(const Image* image, unsigned int* size)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqEnumerateCustomKeys(JNIEnv* env, jclass , jlong image, jlong size)
{
    char** rv = imaqEnumerateCustomKeys((const Image*)image, (unsigned int*)size);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqGetBitDepth(Image image)
 * JN: void imaqGetBitDepth(long image, long bitDepth)
 * C: int imaqGetBitDepth(const Image* image, unsigned int* bitDepth)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetBitDepth(JNIEnv* env, jclass , jlong image, jlong bitDepth)
{
    int rv = imaqGetBitDepth((const Image*)image, (unsigned int*)bitDepth);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetBytesPerPixel(Image image)
 * JN: void imaqGetBytesPerPixel(long image, long byteCount)
 * C: int imaqGetBytesPerPixel(const Image* image, int* byteCount)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetBytesPerPixel(JNIEnv* env, jclass , jlong image, jlong byteCount)
{
    int rv = imaqGetBytesPerPixel((const Image*)image, (int*)byteCount);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetImageInfo(Image image)
 * JN: void imaqGetImageInfo(long image, long info)
 * C: int imaqGetImageInfo(const Image* image, ImageInfo* info)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetImageInfo(JNIEnv* env, jclass , jlong image, jlong info)
{
    int rv = imaqGetImageInfo((const Image*)image, (ImageInfo*)info);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetImageSize(Image image)
 * JN: void imaqGetImageSize(long image, long width, long height)
 * C: int imaqGetImageSize(const Image* image, int* width, int* height)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetImageSize(JNIEnv* env, jclass , jlong image, jlong width, jlong height)
{
    int rv = imaqGetImageSize((const Image*)image, (int*)width, (int*)height);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetImageType(Image image)
 * JN: void imaqGetImageType(long image, long type)
 * C: int imaqGetImageType(const Image* image, ImageType* type)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetImageType(JNIEnv* env, jclass , jlong image, jlong type)
{
    int rv = imaqGetImageType((const Image*)image, (ImageType*)type);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetMaskOffset(Image image)
 * JN: void imaqGetMaskOffset(long image, long offset)
 * C: int imaqGetMaskOffset(const Image* image, Point* offset)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetMaskOffset(JNIEnv* env, jclass , jlong image, jlong offset)
{
    int rv = imaqGetMaskOffset((const Image*)image, (Point*)offset);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetVisionInfoTypes(Image image)
 * JN: void imaqGetVisionInfoTypes(long image, long present)
 * C: int imaqGetVisionInfoTypes(const Image* image, unsigned int* present)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetVisionInfoTypes(JNIEnv* env, jclass , jlong image, jlong present)
{
    int rv = imaqGetVisionInfoTypes((const Image*)image, (unsigned int*)present);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqIsImageEmpty(Image image)
 * JN: void imaqIsImageEmpty(long image, long empty)
 * C: int imaqIsImageEmpty(const Image* image, int* empty)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqIsImageEmpty(JNIEnv* env, jclass , jlong image, jlong empty)
{
    int rv = imaqIsImageEmpty((const Image*)image, (int*)empty);
    if (rv == 0) throwJavaException(env);
}

/* J: RawData imaqReadCustomData(Image image, String key)
 * JN: long imaqReadCustomData(long image, long key, long size)
 * C: void* imaqReadCustomData(const Image* image, const char* key, unsigned int* size)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadCustomData(JNIEnv* env, jclass , jlong image, jlong key, jlong size)
{
    void* rv = imaqReadCustomData((const Image*)image, (const char*)key, (unsigned int*)size);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqRemoveCustomData(Image image, String key)
 * JN: void imaqRemoveCustomData(long image, long key)
 * C: int imaqRemoveCustomData(Image* image, const char* key)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRemoveCustomData(JNIEnv* env, jclass , jlong image, jlong key)
{
    int rv = imaqRemoveCustomData((Image*)image, (const char*)key);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqRemoveVisionInfo2(Image image, int info)
 * JN: void imaqRemoveVisionInfo2(long image, int info)
 * C: int imaqRemoveVisionInfo2(const Image* image, unsigned int info)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRemoveVisionInfo2(JNIEnv* env, jclass , jlong image, jint info)
{
    int rv = imaqRemoveVisionInfo2((const Image*)image, (unsigned int)info);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetBitDepth(Image image, int bitDepth)
 * JN: void imaqSetBitDepth(long image, int bitDepth)
 * C: int imaqSetBitDepth(Image* image, unsigned int bitDepth)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetBitDepth(JNIEnv* env, jclass , jlong image, jint bitDepth)
{
    int rv = imaqSetBitDepth((Image*)image, (unsigned int)bitDepth);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetImageSize(Image image, int width, int height)
 * JN: void imaqSetImageSize(long image, int width, int height)
 * C: int imaqSetImageSize(Image* image, int width, int height)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetImageSize(JNIEnv* env, jclass , jlong image, jint width, jint height)
{
    int rv = imaqSetImageSize((Image*)image, (int)width, (int)height);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetMaskOffset(Image image, Point offset)
 * JN: void imaqSetMaskOffset(long image, long offset)
 * C: int imaqSetMaskOffset(Image* image, Point offset)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetMaskOffset(JNIEnv* env, jclass , jlong image, jlong offset)
{
    int rv = imaqSetMaskOffset((Image*)image, *((Point*)offset));
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqWriteCustomData(Image image, String key, RawData data, int size)
 * JN: void imaqWriteCustomData(long image, long key, long data, int size)
 * C: int imaqWriteCustomData(Image* image, const char* key, const void* data, unsigned int size)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteCustomData(JNIEnv* env, jclass , jlong image, jlong key, jlong data, jint size)
{
    int rv = imaqWriteCustomData((Image*)image, (const char*)key, (const void*)data, (unsigned int)size);
    if (rv == 0) throwJavaException(env);
}

/*
 * Display functions
 */

/*
 * Image Manipulation functions
 */

/* J: void imaqCopyRect(Image dest, Image source, Rect rect, Point destLoc)
 * JN: void imaqCopyRect(long dest, long source, long rect, long destLoc)
 * C: int imaqCopyRect(Image* dest, const Image* source, Rect rect, Point destLoc)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCopyRect(JNIEnv* env, jclass , jlong dest, jlong source, jlong rect, jlong destLoc)
{
    int rv = imaqCopyRect((Image*)dest, (const Image*)source, *((Rect*)rect), *((Point*)destLoc));
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqDuplicate(Image dest, Image source)
 * JN: void imaqDuplicate(long dest, long source)
 * C: int imaqDuplicate(Image* dest, const Image* source)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDuplicate(JNIEnv* env, jclass , jlong dest, jlong source)
{
    int rv = imaqDuplicate((Image*)dest, (const Image*)source);
    if (rv == 0) throwJavaException(env);
}

/* J: RawData imaqFlatten(Image image, FlattenType type, CompressionType compression, int quality)
 * JN: long imaqFlatten(long image, int type, int compression, int quality, long size)
 * C: void* imaqFlatten(const Image* image, FlattenType type, CompressionType compression, int quality, unsigned int* size)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFlatten(JNIEnv* env, jclass , jlong image, jint type, jint compression, jint quality, jlong size)
{
    void* rv = imaqFlatten((const Image*)image, (FlattenType)type, (CompressionType)compression, (int)quality, (unsigned int*)size);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqFlip(Image dest, Image source, FlipAxis axis)
 * JN: void imaqFlip(long dest, long source, int axis)
 * C: int imaqFlip(Image* dest, const Image* source, FlipAxis axis)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFlip(JNIEnv* env, jclass , jlong dest, jlong source, jint axis)
{
    int rv = imaqFlip((Image*)dest, (const Image*)source, (FlipAxis)axis);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMask(Image dest, Image source, Image mask)
 * JN: void imaqMask(long dest, long source, long mask)
 * C: int imaqMask(Image* dest, const Image* source, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMask(JNIEnv* env, jclass , jlong dest, jlong source, jlong mask)
{
    int rv = imaqMask((Image*)dest, (const Image*)source, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqResample(Image dest, Image source, int newWidth, int newHeight, InterpolationMethod method, Rect rect)
 * JN: void imaqResample(long dest, long source, int newWidth, int newHeight, int method, long rect)
 * C: int imaqResample(Image* dest, const Image* source, int newWidth, int newHeight, InterpolationMethod method, Rect rect)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqResample(JNIEnv* env, jclass , jlong dest, jlong source, jint newWidth, jint newHeight, jint method, jlong rect)
{
    int rv = imaqResample((Image*)dest, (const Image*)source, (int)newWidth, (int)newHeight, (InterpolationMethod)method, *((Rect*)rect));
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqScale(Image dest, Image source, int xScale, int yScale, ScalingMode scaleMode, Rect rect)
 * JN: void imaqScale(long dest, long source, int xScale, int yScale, int scaleMode, long rect)
 * C: int imaqScale(Image* dest, const Image* source, int xScale, int yScale, ScalingMode scaleMode, Rect rect)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqScale(JNIEnv* env, jclass , jlong dest, jlong source, jint xScale, jint yScale, jint scaleMode, jlong rect)
{
    int rv = imaqScale((Image*)dest, (const Image*)source, (int)xScale, (int)yScale, (ScalingMode)scaleMode, *((Rect*)rect));
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqTranspose(Image dest, Image source)
 * JN: void imaqTranspose(long dest, long source)
 * C: int imaqTranspose(Image* dest, const Image* source)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqTranspose(JNIEnv* env, jclass , jlong dest, jlong source)
{
    int rv = imaqTranspose((Image*)dest, (const Image*)source);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqUnflatten(Image image, RawData data, int size)
 * JN: void imaqUnflatten(long image, long data, int size)
 * C: int imaqUnflatten(Image* image, const void* data, unsigned int size)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqUnflatten(JNIEnv* env, jclass , jlong image, jlong data, jint size)
{
    int rv = imaqUnflatten((Image*)image, (const void*)data, (unsigned int)size);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqUnwrapImage(Image dest, Image source, Annulus annulus, RectOrientation orientation, InterpolationMethod method)
 * JN: void imaqUnwrapImage(long dest, long source, long annulus, int orientation, int method)
 * C: int imaqUnwrapImage(Image* dest, const Image* source, Annulus annulus, RectOrientation orientation, InterpolationMethod method)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqUnwrapImage(JNIEnv* env, jclass , jlong dest, jlong source, jlong annulus, jint orientation, jint method)
{
    int rv = imaqUnwrapImage((Image*)dest, (const Image*)source, *((Annulus*)annulus), (RectOrientation)orientation, (InterpolationMethod)method);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqView3D(Image dest, Image source, View3DOptions options)
 * JN: void imaqView3D(long dest, long source, long options)
 * C: int imaqView3D(Image* dest, Image* source, const View3DOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqView3D(JNIEnv* env, jclass , jlong dest, jlong source, jlong options)
{
    int rv = imaqView3D((Image*)dest, (Image*)source, (const View3DOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/*
 * File I/O functions
 */

/* J: void imaqGetFileInfo(String fileName)
 * JN: void imaqGetFileInfo(long fileName, long calibrationUnit, long calibrationX, long calibrationY, long width, long height, long imageType)
 * C: int imaqGetFileInfo(const char* fileName, CalibrationUnit* calibrationUnit, float* calibrationX, float* calibrationY, int* width, int* height, ImageType* imageType)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetFileInfo(JNIEnv* env, jclass , jlong fileName, jlong calibrationUnit, jlong calibrationX, jlong calibrationY, jlong width, jlong height, jlong imageType)
{
    int rv = imaqGetFileInfo((const char*)fileName, (CalibrationUnit*)calibrationUnit, (float*)calibrationX, (float*)calibrationY, (int*)width, (int*)height, (ImageType*)imageType);
    if (rv == 0) throwJavaException(env);
}

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReadFile(JNIEnv* env, jclass , jlong image, jlong fileName, jlong colorTable, jlong numColors)
{
    int rv = imaqReadFile((Image*)image, (const char*)fileName, (RGBValue*)colorTable, (int*)numColors);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqReadVisionFile(Image image, String fileName)
 * JN: void imaqReadVisionFile(long image, long fileName, long colorTable, long numColors)
 * C: int imaqReadVisionFile(Image* image, const char* fileName, RGBValue* colorTable, int* numColors)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReadVisionFile(JNIEnv* env, jclass , jlong image, jlong fileName, jlong colorTable, jlong numColors)
{
    int rv = imaqReadVisionFile((Image*)image, (const char*)fileName, (RGBValue*)colorTable, (int*)numColors);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqWriteBMPFile(Image image, String fileName, int compress, RGBValue colorTable)
 * JN: void imaqWriteBMPFile(long image, long fileName, int compress, long colorTable)
 * C: int imaqWriteBMPFile(const Image* image, const char* fileName, int compress, const RGBValue* colorTable)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteBMPFile(JNIEnv* env, jclass , jlong image, jlong fileName, jint compress, jlong colorTable)
{
    int rv = imaqWriteBMPFile((const Image*)image, (const char*)fileName, (int)compress, (const RGBValue*)colorTable);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqWriteFile(Image image, String fileName, RGBValue colorTable)
 * JN: void imaqWriteFile(long image, long fileName, long colorTable)
 * C: int imaqWriteFile(const Image* image, const char* fileName, const RGBValue* colorTable)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteFile(JNIEnv* env, jclass , jlong image, jlong fileName, jlong colorTable)
{
    int rv = imaqWriteFile((const Image*)image, (const char*)fileName, (const RGBValue*)colorTable);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqWriteJPEGFile(Image image, String fileName, int quality, RawData colorTable)
 * JN: void imaqWriteJPEGFile(long image, long fileName, int quality, long colorTable)
 * C: int imaqWriteJPEGFile(const Image* image, const char* fileName, unsigned int quality, void* colorTable)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteJPEGFile(JNIEnv* env, jclass , jlong image, jlong fileName, jint quality, jlong colorTable)
{
    int rv = imaqWriteJPEGFile((const Image*)image, (const char*)fileName, (unsigned int)quality, (void*)colorTable);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqWritePNGFile2(Image image, String fileName, int compressionSpeed, RGBValue colorTable, int useBitDepth)
 * JN: void imaqWritePNGFile2(long image, long fileName, int compressionSpeed, long colorTable, int useBitDepth)
 * C: int imaqWritePNGFile2(const Image* image, const char* fileName, unsigned int compressionSpeed, const RGBValue* colorTable, int useBitDepth)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWritePNGFile2(JNIEnv* env, jclass , jlong image, jlong fileName, jint compressionSpeed, jlong colorTable, jint useBitDepth)
{
    int rv = imaqWritePNGFile2((const Image*)image, (const char*)fileName, (unsigned int)compressionSpeed, (const RGBValue*)colorTable, (int)useBitDepth);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqWriteTIFFFile(Image image, String fileName, TIFFFileOptions options, RGBValue colorTable)
 * JN: void imaqWriteTIFFFile(long image, long fileName, long options, long colorTable)
 * C: int imaqWriteTIFFFile(const Image* image, const char* fileName, const TIFFFileOptions* options, const RGBValue* colorTable)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteTIFFFile(JNIEnv* env, jclass , jlong image, jlong fileName, jlong options, jlong colorTable)
{
    int rv = imaqWriteTIFFFile((const Image*)image, (const char*)fileName, (const TIFFFileOptions*)options, (const RGBValue*)colorTable);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqWriteVisionFile(Image image, String fileName, RGBValue colorTable)
 * JN: void imaqWriteVisionFile(long image, long fileName, long colorTable)
 * C: int imaqWriteVisionFile(const Image* image, const char* fileName, const RGBValue* colorTable)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteVisionFile(JNIEnv* env, jclass , jlong image, jlong fileName, jlong colorTable)
{
    int rv = imaqWriteVisionFile((const Image*)image, (const char*)fileName, (const RGBValue*)colorTable);
    if (rv == 0) throwJavaException(env);
}

/*
 * Analytic Geometry functions
 */

/* J: void imaqBuildCoordinateSystem(Point points, ReferenceMode mode, AxisOrientation orientation)
 * JN: void imaqBuildCoordinateSystem(long points, int mode, int orientation, long system)
 * C: int imaqBuildCoordinateSystem(const Point* points, ReferenceMode mode, AxisOrientation orientation, CoordinateSystem* system)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqBuildCoordinateSystem(JNIEnv* env, jclass , jlong points, jint mode, jint orientation, jlong system)
{
    int rv = imaqBuildCoordinateSystem((const Point*)points, (ReferenceMode)mode, (AxisOrientation)orientation, (CoordinateSystem*)system);
    if (rv == 0) throwJavaException(env);
}

/* J: BestCircle2 imaqFitCircle2(PointFloat[] points, FitCircleOptions options)
 * JN: long imaqFitCircle2(long points, int numPoints, long options)
 * C: BestCircle2* imaqFitCircle2(const PointFloat* points, int numPoints, const FitCircleOptions* options)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFitCircle2(JNIEnv* env, jclass , jlong points, jint numPoints, jlong options)
{
    BestCircle2* rv = imaqFitCircle2((const PointFloat*)points, (int)numPoints, (const FitCircleOptions*)options);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: BestEllipse2 imaqFitEllipse2(PointFloat[] points, FitEllipseOptions options)
 * JN: long imaqFitEllipse2(long points, int numPoints, long options)
 * C: BestEllipse2* imaqFitEllipse2(const PointFloat* points, int numPoints, const FitEllipseOptions* options)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFitEllipse2(JNIEnv* env, jclass , jlong points, jint numPoints, jlong options)
{
    BestEllipse2* rv = imaqFitEllipse2((const PointFloat*)points, (int)numPoints, (const FitEllipseOptions*)options);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: BestLine imaqFitLine(PointFloat[] points, FitLineOptions options)
 * JN: long imaqFitLine(long points, int numPoints, long options)
 * C: BestLine* imaqFitLine(const PointFloat* points, int numPoints, const FitLineOptions* options)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFitLine(JNIEnv* env, jclass , jlong points, jint numPoints, jlong options)
{
    BestLine* rv = imaqFitLine((const PointFloat*)points, (int)numPoints, (const FitLineOptions*)options);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqGetAngle(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2)
 * JN: void imaqGetAngle(long start1, long end1, long start2, long end2, long angle)
 * C: int imaqGetAngle(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2, float* angle)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetAngle(JNIEnv* env, jclass , jlong start1, jlong end1, jlong start2, jlong end2, jlong angle)
{
    int rv = imaqGetAngle(*((PointFloat*)start1), *((PointFloat*)end1), *((PointFloat*)start2), *((PointFloat*)end2), (float*)angle);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetBisectingLine(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2)
 * JN: void imaqGetBisectingLine(long start1, long end1, long start2, long end2, long bisectStart, long bisectEnd)
 * C: int imaqGetBisectingLine(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2, PointFloat* bisectStart, PointFloat* bisectEnd)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetBisectingLine(JNIEnv* env, jclass , jlong start1, jlong end1, jlong start2, jlong end2, jlong bisectStart, jlong bisectEnd)
{
    int rv = imaqGetBisectingLine(*((PointFloat*)start1), *((PointFloat*)end1), *((PointFloat*)start2), *((PointFloat*)end2), (PointFloat*)bisectStart, (PointFloat*)bisectEnd);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetDistance(PointFloat point1, PointFloat point2)
 * JN: void imaqGetDistance(long point1, long point2, long distance)
 * C: int imaqGetDistance(PointFloat point1, PointFloat point2, float* distance)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetDistance(JNIEnv* env, jclass , jlong point1, jlong point2, jlong distance)
{
    int rv = imaqGetDistance(*((PointFloat*)point1), *((PointFloat*)point2), (float*)distance);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetIntersection(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2)
 * JN: void imaqGetIntersection(long start1, long end1, long start2, long end2, long intersection)
 * C: int imaqGetIntersection(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2, PointFloat* intersection)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetIntersection(JNIEnv* env, jclass , jlong start1, jlong end1, jlong start2, jlong end2, jlong intersection)
{
    int rv = imaqGetIntersection(*((PointFloat*)start1), *((PointFloat*)end1), *((PointFloat*)start2), *((PointFloat*)end2), (PointFloat*)intersection);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetMidLine(PointFloat refLineStart, PointFloat refLineEnd, PointFloat point)
 * JN: void imaqGetMidLine(long refLineStart, long refLineEnd, long point, long midLineStart, long midLineEnd)
 * C: int imaqGetMidLine(PointFloat refLineStart, PointFloat refLineEnd, PointFloat point, PointFloat* midLineStart, PointFloat* midLineEnd)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetMidLine(JNIEnv* env, jclass , jlong refLineStart, jlong refLineEnd, jlong point, jlong midLineStart, jlong midLineEnd)
{
    int rv = imaqGetMidLine(*((PointFloat*)refLineStart), *((PointFloat*)refLineEnd), *((PointFloat*)point), (PointFloat*)midLineStart, (PointFloat*)midLineEnd);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetPerpendicularLine(PointFloat refLineStart, PointFloat refLineEnd, PointFloat point)
 * JN: void imaqGetPerpendicularLine(long refLineStart, long refLineEnd, long point, long perpLineStart, long perpLineEnd, long distance)
 * C: int imaqGetPerpendicularLine(PointFloat refLineStart, PointFloat refLineEnd, PointFloat point, PointFloat* perpLineStart, PointFloat* perpLineEnd, double* distance)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetPerpendicularLine(JNIEnv* env, jclass , jlong refLineStart, jlong refLineEnd, jlong point, jlong perpLineStart, jlong perpLineEnd, jlong distance)
{
    int rv = imaqGetPerpendicularLine(*((PointFloat*)refLineStart), *((PointFloat*)refLineEnd), *((PointFloat*)point), (PointFloat*)perpLineStart, (PointFloat*)perpLineEnd, (double*)distance);
    if (rv == 0) throwJavaException(env);
}

/* J: GetPointsOnContourResult imaqGetPointsOnContour(Image image)
 * JN: long imaqGetPointsOnContour(long image, long numSegments)
 * C: SegmentInfo* imaqGetPointsOnContour(const Image* image, int* numSegments)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetPointsOnContour(JNIEnv* env, jclass , jlong image, jlong numSegments)
{
    SegmentInfo* rv = imaqGetPointsOnContour((const Image*)image, (int*)numSegments);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: GetPointsOnLineResult imaqGetPointsOnLine(Point start, Point end)
 * JN: long imaqGetPointsOnLine(long start, long end, long numPoints)
 * C: Point* imaqGetPointsOnLine(Point start, Point end, int* numPoints)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetPointsOnLine(JNIEnv* env, jclass , jlong start, jlong end, jlong numPoints)
{
    Point* rv = imaqGetPointsOnLine(*((Point*)start), *((Point*)end), (int*)numPoints);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqGetPolygonArea(PointFloat points, int numPoints)
 * JN: void imaqGetPolygonArea(long points, int numPoints, long area)
 * C: int imaqGetPolygonArea(const PointFloat* points, int numPoints, float* area)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetPolygonArea(JNIEnv* env, jclass , jlong points, jint numPoints, jlong area)
{
    int rv = imaqGetPolygonArea((const PointFloat*)points, (int)numPoints, (float*)area);
    if (rv == 0) throwJavaException(env);
}

/* J: InterpolatePointsResult imaqInterpolatePoints(Image image, Point[] points, InterpolationMethod method, int subpixel)
 * JN: long imaqInterpolatePoints(long image, long points, int numPoints, int method, int subpixel, long interpCount)
 * C: float* imaqInterpolatePoints(const Image* image, const Point* points, int numPoints, InterpolationMethod method, int subpixel, int* interpCount)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqInterpolatePoints(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jint method, jint subpixel, jlong interpCount)
{
    float* rv = imaqInterpolatePoints((const Image*)image, (const Point*)points, (int)numPoints, (InterpolationMethod)method, (int)subpixel, (int*)interpCount);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Clipboard functions
 */

/*
 * Border functions
 */

/* J: void imaqFillBorder(Image image, BorderMethod method)
 * JN: void imaqFillBorder(long image, int method)
 * C: int imaqFillBorder(Image* image, BorderMethod method)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFillBorder(JNIEnv* env, jclass , jlong image, jint method)
{
    int rv = imaqFillBorder((Image*)image, (BorderMethod)method);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetBorderSize(Image image)
 * JN: void imaqGetBorderSize(long image, long borderSize)
 * C: int imaqGetBorderSize(const Image* image, int* borderSize)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetBorderSize(JNIEnv* env, jclass , jlong image, jlong borderSize)
{
    int rv = imaqGetBorderSize((const Image*)image, (int*)borderSize);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetBorderSize(Image image, int size)
 * JN: void imaqSetBorderSize(long image, int size)
 * C: int imaqSetBorderSize(Image* image, int size)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetBorderSize(JNIEnv* env, jclass , jlong image, jint size)
{
    int rv = imaqSetBorderSize((Image*)image, (int)size);
    if (rv == 0) throwJavaException(env);
}

/*
 * Image Management functions
 */

/* J: void imaqArrayToImage(Image image, RawData array, int numCols, int numRows)
 * JN: void imaqArrayToImage(long image, long array, int numCols, int numRows)
 * C: int imaqArrayToImage(Image* image, const void* array, int numCols, int numRows)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqArrayToImage(JNIEnv* env, jclass , jlong image, jlong array, jint numCols, jint numRows)
{
    int rv = imaqArrayToImage((Image*)image, (const void*)array, (int)numCols, (int)numRows);
    if (rv == 0) throwJavaException(env);
}

/* J: Image imaqCreateImage(ImageType type, int borderSize)
 * JN: long imaqCreateImage(int type, int borderSize)
 * C: Image* imaqCreateImage(ImageType type, int borderSize)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCreateImage(JNIEnv* env, jclass , jint type, jint borderSize)
{
    Image* rv = imaqCreateImage((ImageType)type, (int)borderSize);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Color Processing functions
 */

/* J: void imaqColorBCGTransform(Image dest, Image source, BCGOptions redOptions, BCGOptions greenOptions, BCGOptions blueOptions, Image mask)
 * JN: void imaqColorBCGTransform(long dest, long source, long redOptions, long greenOptions, long blueOptions, long mask)
 * C: int imaqColorBCGTransform(Image* dest, const Image* source, const BCGOptions* redOptions, const BCGOptions* greenOptions, const BCGOptions* blueOptions, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqColorBCGTransform(JNIEnv* env, jclass , jlong dest, jlong source, jlong redOptions, jlong greenOptions, jlong blueOptions, jlong mask)
{
    int rv = imaqColorBCGTransform((Image*)dest, (const Image*)source, (const BCGOptions*)redOptions, (const BCGOptions*)greenOptions, (const BCGOptions*)blueOptions, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqColorEqualize(Image dest, Image source, int colorEqualization)
 * JN: void imaqColorEqualize(long dest, long source, int colorEqualization)
 * C: int imaqColorEqualize(Image* dest, const Image* source, int colorEqualization)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqColorEqualize(JNIEnv* env, jclass , jlong dest, jlong source, jint colorEqualization)
{
    int rv = imaqColorEqualize((Image*)dest, (const Image*)source, (int)colorEqualization);
    if (rv == 0) throwJavaException(env);
}

/* J: ColorHistogramReport imaqColorHistogram2(Image image, int numClasses, ColorMode mode, CIEXYZValue whiteReference, Image mask)
 * JN: long imaqColorHistogram2(long image, int numClasses, int mode, long whiteReference, long mask)
 * C: ColorHistogramReport* imaqColorHistogram2(Image* image, int numClasses, ColorMode mode, const CIEXYZValue* whiteReference, Image* mask)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqColorHistogram2(JNIEnv* env, jclass , jlong image, jint numClasses, jint mode, jlong whiteReference, jlong mask)
{
    ColorHistogramReport* rv = imaqColorHistogram2((Image*)image, (int)numClasses, (ColorMode)mode, (const CIEXYZValue*)whiteReference, (Image*)mask);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqColorThreshold(Image dest, Image source, int replaceValue, ColorMode mode, Range plane1Range, Range plane2Range, Range plane3Range)
 * JN: void imaqColorThreshold(long dest, long source, int replaceValue, int mode, long plane1Range, long plane2Range, long plane3Range)
 * C: int imaqColorThreshold(Image* dest, const Image* source, int replaceValue, ColorMode mode, const Range* plane1Range, const Range* plane2Range, const Range* plane3Range)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqColorThreshold(JNIEnv* env, jclass , jlong dest, jlong source, jint replaceValue, jint mode, jlong plane1Range, jlong plane2Range, jlong plane3Range)
{
    int rv = imaqColorThreshold((Image*)dest, (const Image*)source, (int)replaceValue, (ColorMode)mode, (const Range*)plane1Range, (const Range*)plane2Range, (const Range*)plane3Range);
    if (rv == 0) throwJavaException(env);
}

/* J: SupervisedColorSegmentationReport imaqSupervisedColorSegmentation(ClassifierSession session, Image labelImage, Image srcImage, ROI roi, ROILabel labelIn, int numLabelIn, int maxDistance, int minIdentificationScore, ColorSegmenationOptions segmentOptions)
 * JN: long imaqSupervisedColorSegmentation(long session, long labelImage, long srcImage, long roi, long labelIn, int numLabelIn, int maxDistance, int minIdentificationScore, long segmentOptions)
 * C: SupervisedColorSegmentationReport* imaqSupervisedColorSegmentation(ClassifierSession* session, Image* labelImage, const Image* srcImage, const ROI* roi, const ROILabel* labelIn, unsigned int numLabelIn, int maxDistance, int minIdentificationScore, const ColorSegmenationOptions* segmentOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqSupervisedColorSegmentation(JNIEnv* env, jclass , jlong session, jlong labelImage, jlong srcImage, jlong roi, jlong labelIn, jint numLabelIn, jint maxDistance, jint minIdentificationScore, jlong segmentOptions)
{
    SupervisedColorSegmentationReport* rv = imaqSupervisedColorSegmentation((ClassifierSession*)session, (Image*)labelImage, (const Image*)srcImage, (const ROI*)roi, (const ROILabel*)labelIn, (unsigned int)numLabelIn, (int)maxDistance, (int)minIdentificationScore, (const ColorSegmenationOptions*)segmentOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqGetColorSegmentationMaxDistance(ClassifierSession session, ColorSegmenationOptions segmentOptions, SegmentationDistanceLevel distLevel)
 * JN: void imaqGetColorSegmentationMaxDistance(long session, long segmentOptions, int distLevel, long maxDistance)
 * C: int imaqGetColorSegmentationMaxDistance(ClassifierSession* session, const ColorSegmenationOptions* segmentOptions, SegmentationDistanceLevel distLevel, int* maxDistance)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetColorSegmentationMaxDistance(JNIEnv* env, jclass , jlong session, jlong segmentOptions, jint distLevel, jlong maxDistance)
{
    int rv = imaqGetColorSegmentationMaxDistance((ClassifierSession*)session, (const ColorSegmenationOptions*)segmentOptions, (SegmentationDistanceLevel)distLevel, (int*)maxDistance);
    if (rv == 0) throwJavaException(env);
}

/*
 * Transform functions
 */

/* J: void imaqBCGTransform(Image dest, Image source, BCGOptions options, Image mask)
 * JN: void imaqBCGTransform(long dest, long source, long options, long mask)
 * C: int imaqBCGTransform(Image* dest, const Image* source, const BCGOptions* options, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqBCGTransform(JNIEnv* env, jclass , jlong dest, jlong source, jlong options, jlong mask)
{
    int rv = imaqBCGTransform((Image*)dest, (const Image*)source, (const BCGOptions*)options, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqEqualize(Image dest, Image source, float min, float max, Image mask)
 * JN: void imaqEqualize(long dest, long source, float min, float max, long mask)
 * C: int imaqEqualize(Image* dest, const Image* source, float min, float max, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqEqualize(JNIEnv* env, jclass , jlong dest, jlong source, jfloat min, jfloat max, jlong mask)
{
    int rv = imaqEqualize((Image*)dest, (const Image*)source, (float)min, (float)max, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqInverse(Image dest, Image source, Image mask)
 * JN: void imaqInverse(long dest, long source, long mask)
 * C: int imaqInverse(Image* dest, const Image* source, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqInverse(JNIEnv* env, jclass , jlong dest, jlong source, jlong mask)
{
    int rv = imaqInverse((Image*)dest, (const Image*)source, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMathTransform(Image dest, Image source, MathTransformMethod method, float rangeMin, float rangeMax, float power, Image mask)
 * JN: void imaqMathTransform(long dest, long source, int method, float rangeMin, float rangeMax, float power, long mask)
 * C: int imaqMathTransform(Image* dest, const Image* source, MathTransformMethod method, float rangeMin, float rangeMax, float power, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMathTransform(JNIEnv* env, jclass , jlong dest, jlong source, jint method, jfloat rangeMin, jfloat rangeMax, jfloat power, jlong mask)
{
    int rv = imaqMathTransform((Image*)dest, (const Image*)source, (MathTransformMethod)method, (float)rangeMin, (float)rangeMax, (float)power, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqWatershedTransform(Image dest, Image source, int connectivity8)
 * JN: void imaqWatershedTransform(long dest, long source, int connectivity8, long zoneCount)
 * C: int imaqWatershedTransform(Image* dest, const Image* source, int connectivity8, int* zoneCount)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWatershedTransform(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8, jlong zoneCount)
{
    int rv = imaqWatershedTransform((Image*)dest, (const Image*)source, (int)connectivity8, (int*)zoneCount);
    if (rv == 0) throwJavaException(env);
}

/*
 * Window Management functions
 */

/*
 * Utilities functions
 */

/* J: void imaqMulticoreOptions(MulticoreOperation operation)
 * JN: void imaqMulticoreOptions(int operation, long customNumCores)
 * C: int imaqMulticoreOptions(MulticoreOperation operation, unsigned int* customNumCores)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMulticoreOptions(JNIEnv* env, jclass , jint operation, jlong customNumCores)
{
    int rv = imaqMulticoreOptions((MulticoreOperation)operation, (unsigned int*)customNumCores);
    if (rv == 0) throwJavaException(env);
}

/*
 * Tool Window functions
 */

/*
 * Meter functions
 */

/* J: MeterArc imaqGetMeterArc(int lightNeedle, MeterArcMode mode, ROI roi, PointFloat base, PointFloat start, PointFloat end)
 * JN: long imaqGetMeterArc(int lightNeedle, int mode, long roi, long base, long start, long end)
 * C: MeterArc* imaqGetMeterArc(int lightNeedle, MeterArcMode mode, const ROI* roi, PointFloat base, PointFloat start, PointFloat end)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetMeterArc(JNIEnv* env, jclass , jint lightNeedle, jint mode, jlong roi, jlong base, jlong start, jlong end)
{
    MeterArc* rv = imaqGetMeterArc((int)lightNeedle, (MeterArcMode)mode, (const ROI*)roi, *((PointFloat*)base), *((PointFloat*)start), *((PointFloat*)end));
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqReadMeter(Image image, MeterArc arcInfo)
 * JN: void imaqReadMeter(long image, long arcInfo, long percentage, long endOfNeedle)
 * C: int imaqReadMeter(const Image* image, const MeterArc* arcInfo, double* percentage, PointFloat* endOfNeedle)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReadMeter(JNIEnv* env, jclass , jlong image, jlong arcInfo, jlong percentage, jlong endOfNeedle)
{
    int rv = imaqReadMeter((const Image*)image, (const MeterArc*)arcInfo, (double*)percentage, (PointFloat*)endOfNeedle);
    if (rv == 0) throwJavaException(env);
}

/*
 * Calibration functions
 */

/* J: void imaqCopyCalibrationInfo2(Image dest, Image source, Point offset)
 * JN: void imaqCopyCalibrationInfo2(long dest, long source, long offset)
 * C: int imaqCopyCalibrationInfo2(Image* dest, Image* source, Point offset)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCopyCalibrationInfo2(JNIEnv* env, jclass , jlong dest, jlong source, jlong offset)
{
    int rv = imaqCopyCalibrationInfo2((Image*)dest, (Image*)source, *((Point*)offset));
    if (rv == 0) throwJavaException(env);
}

/* J: CalibrationInfo imaqGetCalibrationInfo2(Image image)
 * JN: long imaqGetCalibrationInfo2(long image)
 * C: CalibrationInfo* imaqGetCalibrationInfo2(const Image* image)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetCalibrationInfo2(JNIEnv* env, jclass , jlong image)
{
    CalibrationInfo* rv = imaqGetCalibrationInfo2((const Image*)image);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: CalibrationInfo imaqGetCalibrationInfo3(Image image, int isGetErrorMap)
 * JN: long imaqGetCalibrationInfo3(long image, int isGetErrorMap)
 * C: CalibrationInfo* imaqGetCalibrationInfo3(Image* image, unsigned int isGetErrorMap)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetCalibrationInfo3(JNIEnv* env, jclass , jlong image, jint isGetErrorMap)
{
    CalibrationInfo* rv = imaqGetCalibrationInfo3((Image*)image, (unsigned int)isGetErrorMap);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqLearnCalibrationGrid(Image image, ROI roi, LearnCalibrationOptions options, GridDescriptor grid, CoordinateSystem system, RangeFloat range)
 * JN: void imaqLearnCalibrationGrid(long image, long roi, long options, long grid, long system, long range, long quality)
 * C: int imaqLearnCalibrationGrid(Image* image, const ROI* roi, const LearnCalibrationOptions* options, const GridDescriptor* grid, const CoordinateSystem* system, const RangeFloat* range, float* quality)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnCalibrationGrid(JNIEnv* env, jclass , jlong image, jlong roi, jlong options, jlong grid, jlong system, jlong range, jlong quality)
{
    int rv = imaqLearnCalibrationGrid((Image*)image, (const ROI*)roi, (const LearnCalibrationOptions*)options, (const GridDescriptor*)grid, (const CoordinateSystem*)system, (const RangeFloat*)range, (float*)quality);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqLearnCalibrationPoints(Image image, CalibrationPoints points, ROI roi, LearnCalibrationOptions options, GridDescriptor grid, CoordinateSystem system)
 * JN: void imaqLearnCalibrationPoints(long image, long points, long roi, long options, long grid, long system, long quality)
 * C: int imaqLearnCalibrationPoints(Image* image, const CalibrationPoints* points, const ROI* roi, const LearnCalibrationOptions* options, const GridDescriptor* grid, const CoordinateSystem* system, float* quality)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnCalibrationPoints(JNIEnv* env, jclass , jlong image, jlong points, jlong roi, jlong options, jlong grid, jlong system, jlong quality)
{
    int rv = imaqLearnCalibrationPoints((Image*)image, (const CalibrationPoints*)points, (const ROI*)roi, (const LearnCalibrationOptions*)options, (const GridDescriptor*)grid, (const CoordinateSystem*)system, (float*)quality);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetCoordinateSystem(Image image, CoordinateSystem system)
 * JN: void imaqSetCoordinateSystem(long image, long system)
 * C: int imaqSetCoordinateSystem(Image* image, const CoordinateSystem* system)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetCoordinateSystem(JNIEnv* env, jclass , jlong image, jlong system)
{
    int rv = imaqSetCoordinateSystem((Image*)image, (const CoordinateSystem*)system);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetSimpleCalibration(Image image, ScalingMethod method, int learnTable, GridDescriptor grid, CoordinateSystem system)
 * JN: void imaqSetSimpleCalibration(long image, int method, int learnTable, long grid, long system)
 * C: int imaqSetSimpleCalibration(Image* image, ScalingMethod method, int learnTable, const GridDescriptor* grid, const CoordinateSystem* system)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetSimpleCalibration(JNIEnv* env, jclass , jlong image, jint method, jint learnTable, jlong grid, jlong system)
{
    int rv = imaqSetSimpleCalibration((Image*)image, (ScalingMethod)method, (int)learnTable, (const GridDescriptor*)grid, (const CoordinateSystem*)system);
    if (rv == 0) throwJavaException(env);
}

/* J: TransformReport imaqTransformPixelToRealWorld(Image image, PointFloat[] pixelCoordinates)
 * JN: long imaqTransformPixelToRealWorld(long image, long pixelCoordinates, int numCoordinates)
 * C: TransformReport* imaqTransformPixelToRealWorld(const Image* image, const PointFloat* pixelCoordinates, int numCoordinates)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqTransformPixelToRealWorld(JNIEnv* env, jclass , jlong image, jlong pixelCoordinates, jint numCoordinates)
{
    TransformReport* rv = imaqTransformPixelToRealWorld((const Image*)image, (const PointFloat*)pixelCoordinates, (int)numCoordinates);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: TransformReport imaqTransformRealWorldToPixel(Image image, PointFloat[] realWorldCoordinates)
 * JN: long imaqTransformRealWorldToPixel(long image, long realWorldCoordinates, int numCoordinates)
 * C: TransformReport* imaqTransformRealWorldToPixel(const Image* image, const PointFloat* realWorldCoordinates, int numCoordinates)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqTransformRealWorldToPixel(JNIEnv* env, jclass , jlong image, jlong realWorldCoordinates, jint numCoordinates)
{
    TransformReport* rv = imaqTransformRealWorldToPixel((const Image*)image, (const PointFloat*)realWorldCoordinates, (int)numCoordinates);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqSetSimpleCalibration2(Image image, GridDescriptor gridDescriptor)
 * JN: void imaqSetSimpleCalibration2(long image, long gridDescriptor)
 * C: int imaqSetSimpleCalibration2(Image* image, const GridDescriptor* gridDescriptor)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetSimpleCalibration2(JNIEnv* env, jclass , jlong image, jlong gridDescriptor)
{
    int rv = imaqSetSimpleCalibration2((Image*)image, (const GridDescriptor*)gridDescriptor);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqCalibrationSetAxisInfo(Image image)
 * JN: void imaqCalibrationSetAxisInfo(long image, long axisInfo)
 * C: int imaqCalibrationSetAxisInfo(Image* image, CoordinateSystem* axisInfo)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCalibrationSetAxisInfo(JNIEnv* env, jclass , jlong image, jlong axisInfo)
{
    int rv = imaqCalibrationSetAxisInfo((Image*)image, (CoordinateSystem*)axisInfo);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqCalibrationGetThumbnailImage(Image templateImage, Image image, CalibrationThumbnailType type, int index)
 * JN: void imaqCalibrationGetThumbnailImage(long templateImage, long image, int type, int index)
 * C: int imaqCalibrationGetThumbnailImage(Image* templateImage, Image* image, CalibrationThumbnailType type, unsigned int index)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCalibrationGetThumbnailImage(JNIEnv* env, jclass , jlong templateImage, jlong image, jint type, jint index)
{
    int rv = imaqCalibrationGetThumbnailImage((Image*)templateImage, (Image*)image, (CalibrationThumbnailType)type, (unsigned int)index);
    if (rv == 0) throwJavaException(env);
}

/* J: GetCalibrationInfoReport imaqCalibrationGetCalibrationInfo(Image image, int isGetErrorMap)
 * JN: long imaqCalibrationGetCalibrationInfo(long image, int isGetErrorMap)
 * C: GetCalibrationInfoReport* imaqCalibrationGetCalibrationInfo(Image* image, unsigned int isGetErrorMap)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCalibrationGetCalibrationInfo(JNIEnv* env, jclass , jlong image, jint isGetErrorMap)
{
    GetCalibrationInfoReport* rv = imaqCalibrationGetCalibrationInfo((Image*)image, (unsigned int)isGetErrorMap);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: GetCameraParametersReport imaqCalibrationGetCameraParameters(Image templateImage)
 * JN: long imaqCalibrationGetCameraParameters(long templateImage)
 * C: GetCameraParametersReport* imaqCalibrationGetCameraParameters(Image* templateImage)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCalibrationGetCameraParameters(JNIEnv* env, jclass , jlong templateImage)
{
    GetCameraParametersReport* rv = imaqCalibrationGetCameraParameters((Image*)templateImage);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqCalibrationCompactInformation(Image image)
 * JN: void imaqCalibrationCompactInformation(long image)
 * C: int imaqCalibrationCompactInformation(Image* image)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCalibrationCompactInformation(JNIEnv* env, jclass , jlong image)
{
    int rv = imaqCalibrationCompactInformation((Image*)image);
    if (rv == 0) throwJavaException(env);
}

/*
 * Pixel Manipulation functions
 */

/* J: void imaqExtractColorPlanes(Image image, ColorMode mode, Image plane1, Image plane2, Image plane3)
 * JN: void imaqExtractColorPlanes(long image, int mode, long plane1, long plane2, long plane3)
 * C: int imaqExtractColorPlanes(const Image* image, ColorMode mode, Image* plane1, Image* plane2, Image* plane3)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqExtractColorPlanes(JNIEnv* env, jclass , jlong image, jint mode, jlong plane1, jlong plane2, jlong plane3)
{
    int rv = imaqExtractColorPlanes((const Image*)image, (ColorMode)mode, (Image*)plane1, (Image*)plane2, (Image*)plane3);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqExtractComplexPlane(Image dest, Image source, ComplexPlane plane)
 * JN: void imaqExtractComplexPlane(long dest, long source, int plane)
 * C: int imaqExtractComplexPlane(Image* dest, const Image* source, ComplexPlane plane)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqExtractComplexPlane(JNIEnv* env, jclass , jlong dest, jlong source, jint plane)
{
    int rv = imaqExtractComplexPlane((Image*)dest, (const Image*)source, (ComplexPlane)plane);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqReplaceColorPlanes(Image dest, Image source, ColorMode mode, Image plane1, Image plane2, Image plane3)
 * JN: void imaqReplaceColorPlanes(long dest, long source, int mode, long plane1, long plane2, long plane3)
 * C: int imaqReplaceColorPlanes(Image* dest, const Image* source, ColorMode mode, const Image* plane1, const Image* plane2, const Image* plane3)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReplaceColorPlanes(JNIEnv* env, jclass , jlong dest, jlong source, jint mode, jlong plane1, jlong plane2, jlong plane3)
{
    int rv = imaqReplaceColorPlanes((Image*)dest, (const Image*)source, (ColorMode)mode, (const Image*)plane1, (const Image*)plane2, (const Image*)plane3);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqReplaceComplexPlane(Image dest, Image source, Image newValues, ComplexPlane plane)
 * JN: void imaqReplaceComplexPlane(long dest, long source, long newValues, int plane)
 * C: int imaqReplaceComplexPlane(Image* dest, const Image* source, const Image* newValues, ComplexPlane plane)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReplaceComplexPlane(JNIEnv* env, jclass , jlong dest, jlong source, jlong newValues, jint plane)
{
    int rv = imaqReplaceComplexPlane((Image*)dest, (const Image*)source, (const Image*)newValues, (ComplexPlane)plane);
    if (rv == 0) throwJavaException(env);
}

/*
 * Color Matching functions
 */

/* J: ColorInformation imaqLearnColor(Image image, ROI roi, ColorSensitivity sensitivity, int saturation)
 * JN: long imaqLearnColor(long image, long roi, int sensitivity, int saturation)
 * C: ColorInformation* imaqLearnColor(const Image* image, const ROI* roi, ColorSensitivity sensitivity, int saturation)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLearnColor(JNIEnv* env, jclass , jlong image, jlong roi, jint sensitivity, jint saturation)
{
    ColorInformation* rv = imaqLearnColor((const Image*)image, (const ROI*)roi, (ColorSensitivity)sensitivity, (int)saturation);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: MatchColorResult imaqMatchColor(Image image, ColorInformation info, ROI roi)
 * JN: long imaqMatchColor(long image, long info, long roi, long numScores)
 * C: int* imaqMatchColor(const Image* image, const ColorInformation* info, const ROI* roi, int* numScores)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchColor(JNIEnv* env, jclass , jlong image, jlong info, jlong roi, jlong numScores)
{
    int* rv = imaqMatchColor((const Image*)image, (const ColorInformation*)info, (const ROI*)roi, (int*)numScores);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Frequency Domain Analysis functions
 */

/* J: void imaqAttenuate(Image dest, Image source, AttenuateMode highlow)
 * JN: void imaqAttenuate(long dest, long source, int highlow)
 * C: int imaqAttenuate(Image* dest, const Image* source, AttenuateMode highlow)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAttenuate(JNIEnv* env, jclass , jlong dest, jlong source, jint highlow)
{
    int rv = imaqAttenuate((Image*)dest, (const Image*)source, (AttenuateMode)highlow);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqConjugate(Image dest, Image source)
 * JN: void imaqConjugate(long dest, long source)
 * C: int imaqConjugate(Image* dest, const Image* source)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqConjugate(JNIEnv* env, jclass , jlong dest, jlong source)
{
    int rv = imaqConjugate((Image*)dest, (const Image*)source);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqFFT(Image dest, Image source)
 * JN: void imaqFFT(long dest, long source)
 * C: int imaqFFT(Image* dest, const Image* source)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFFT(JNIEnv* env, jclass , jlong dest, jlong source)
{
    int rv = imaqFFT((Image*)dest, (const Image*)source);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqFlipFrequencies(Image dest, Image source)
 * JN: void imaqFlipFrequencies(long dest, long source)
 * C: int imaqFlipFrequencies(Image* dest, const Image* source)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFlipFrequencies(JNIEnv* env, jclass , jlong dest, jlong source)
{
    int rv = imaqFlipFrequencies((Image*)dest, (const Image*)source);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqInverseFFT(Image dest, Image source)
 * JN: void imaqInverseFFT(long dest, long source)
 * C: int imaqInverseFFT(Image* dest, const Image* source)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqInverseFFT(JNIEnv* env, jclass , jlong dest, jlong source)
{
    int rv = imaqInverseFFT((Image*)dest, (const Image*)source);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqTruncate(Image dest, Image source, TruncateMode highlow, float ratioToKeep)
 * JN: void imaqTruncate(long dest, long source, int highlow, float ratioToKeep)
 * C: int imaqTruncate(Image* dest, const Image* source, TruncateMode highlow, float ratioToKeep)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqTruncate(JNIEnv* env, jclass , jlong dest, jlong source, jint highlow, jfloat ratioToKeep)
{
    int rv = imaqTruncate((Image*)dest, (const Image*)source, (TruncateMode)highlow, (float)ratioToKeep);
    if (rv == 0) throwJavaException(env);
}

/*
 * Barcode I/O functions
 */

/* J: void imaqGradeDataMatrixBarcodeAIM(Image image)
 * JN: void imaqGradeDataMatrixBarcodeAIM(long image, long report)
 * C: int imaqGradeDataMatrixBarcodeAIM(const Image* image, AIMGradeReport* report)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGradeDataMatrixBarcodeAIM(JNIEnv* env, jclass , jlong image, jlong report)
{
    int rv = imaqGradeDataMatrixBarcodeAIM((const Image*)image, (AIMGradeReport*)report);
    if (rv == 0) throwJavaException(env);
}

/* J: BarcodeInfo imaqReadBarcode(Image image, BarcodeType type, ROI roi, int validate)
 * JN: long imaqReadBarcode(long image, int type, long roi, int validate)
 * C: BarcodeInfo* imaqReadBarcode(const Image* image, BarcodeType type, const ROI* roi, int validate)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadBarcode(JNIEnv* env, jclass , jlong image, jint type, jlong roi, jint validate)
{
    BarcodeInfo* rv = imaqReadBarcode((const Image*)image, (BarcodeType)type, (const ROI*)roi, (int)validate);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: DataMatrixReport imaqReadDataMatrixBarcode2(Image image, ROI roi, DataMatrixGradingMode prepareForGrading, DataMatrixDescriptionOptions descriptionOptions, DataMatrixSizeOptions sizeOptions, DataMatrixSearchOptions searchOptions)
 * JN: long imaqReadDataMatrixBarcode2(long image, long roi, int prepareForGrading, long descriptionOptions, long sizeOptions, long searchOptions)
 * C: DataMatrixReport* imaqReadDataMatrixBarcode2(Image* image, const ROI* roi, DataMatrixGradingMode prepareForGrading, const DataMatrixDescriptionOptions* descriptionOptions, const DataMatrixSizeOptions* sizeOptions, const DataMatrixSearchOptions* searchOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadDataMatrixBarcode2(JNIEnv* env, jclass , jlong image, jlong roi, jint prepareForGrading, jlong descriptionOptions, jlong sizeOptions, jlong searchOptions)
{
    DataMatrixReport* rv = imaqReadDataMatrixBarcode2((Image*)image, (const ROI*)roi, (DataMatrixGradingMode)prepareForGrading, (const DataMatrixDescriptionOptions*)descriptionOptions, (const DataMatrixSizeOptions*)sizeOptions, (const DataMatrixSearchOptions*)searchOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ReadPDF417BarcodeResult imaqReadPDF417Barcode(Image image, ROI roi, Barcode2DSearchMode searchMode)
 * JN: long imaqReadPDF417Barcode(long image, long roi, int searchMode, long numBarcodes)
 * C: Barcode2DInfo* imaqReadPDF417Barcode(const Image* image, const ROI* roi, Barcode2DSearchMode searchMode, unsigned int* numBarcodes)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadPDF417Barcode(JNIEnv* env, jclass , jlong image, jlong roi, jint searchMode, jlong numBarcodes)
{
    Barcode2DInfo* rv = imaqReadPDF417Barcode((const Image*)image, (const ROI*)roi, (Barcode2DSearchMode)searchMode, (unsigned int*)numBarcodes);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: QRCodeReport imaqReadQRCode(Image image, ROI roi, QRGradingMode reserved, QRCodeDescriptionOptions descriptionOptions, QRCodeSizeOptions sizeOptions, QRCodeSearchOptions searchOptions)
 * JN: long imaqReadQRCode(long image, long roi, int reserved, long descriptionOptions, long sizeOptions, long searchOptions)
 * C: QRCodeReport* imaqReadQRCode(Image* image, const ROI* roi, QRGradingMode reserved, const QRCodeDescriptionOptions* descriptionOptions, const QRCodeSizeOptions* sizeOptions, const QRCodeSearchOptions* searchOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadQRCode(JNIEnv* env, jclass , jlong image, jlong roi, jint reserved, jlong descriptionOptions, jlong sizeOptions, jlong searchOptions)
{
    QRCodeReport* rv = imaqReadQRCode((Image*)image, (const ROI*)roi, (QRGradingMode)reserved, (const QRCodeDescriptionOptions*)descriptionOptions, (const QRCodeSizeOptions*)sizeOptions, (const QRCodeSearchOptions*)searchOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * LCD functions
 */

/* J: void imaqFindLCDSegments(ROI roi, Image image, LCDOptions options)
 * JN: void imaqFindLCDSegments(long roi, long image, long options)
 * C: int imaqFindLCDSegments(ROI* roi, const Image* image, const LCDOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFindLCDSegments(JNIEnv* env, jclass , jlong roi, jlong image, jlong options)
{
    int rv = imaqFindLCDSegments((ROI*)roi, (const Image*)image, (const LCDOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/* J: LCDReport imaqReadLCD(Image image, ROI roi, LCDOptions options)
 * JN: long imaqReadLCD(long image, long roi, long options)
 * C: LCDReport* imaqReadLCD(const Image* image, const ROI* roi, const LCDOptions* options)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadLCD(JNIEnv* env, jclass , jlong image, jlong roi, jlong options)
{
    LCDReport* rv = imaqReadLCD((const Image*)image, (const ROI*)roi, (const LCDOptions*)options);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Shape Matching functions
 */

/* J: MatchShapeResult imaqMatchShape(Image dest, Image source, Image templateImage, int scaleInvariant, int connectivity8, double tolerance)
 * JN: long imaqMatchShape(long dest, long source, long templateImage, int scaleInvariant, int connectivity8, double tolerance, long numMatches)
 * C: ShapeReport* imaqMatchShape(Image* dest, Image* source, const Image* templateImage, int scaleInvariant, int connectivity8, double tolerance, int* numMatches)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchShape(JNIEnv* env, jclass , jlong dest, jlong source, jlong templateImage, jint scaleInvariant, jint connectivity8, jdouble tolerance, jlong numMatches)
{
    ShapeReport* rv = imaqMatchShape((Image*)dest, (Image*)source, (const Image*)templateImage, (int)scaleInvariant, (int)connectivity8, (double)tolerance, (int*)numMatches);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Contours functions
 */

/* J: int imaqAddAnnulusContour(ROI roi, Annulus annulus)
 * JN: int imaqAddAnnulusContour(long roi, long annulus)
 * C: ContourID imaqAddAnnulusContour(ROI* roi, Annulus annulus)
 */

JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddAnnulusContour(JNIEnv* env, jclass , jlong roi, jlong annulus)
{
    ContourID rv = imaqAddAnnulusContour((ROI*)roi, *((Annulus*)annulus));
    
    return (jint)rv;
}

/* J: int imaqAddClosedContour(ROI roi, Point[] points)
 * JN: int imaqAddClosedContour(long roi, long points, int numPoints)
 * C: ContourID imaqAddClosedContour(ROI* roi, const Point* points, int numPoints)
 */

JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddClosedContour(JNIEnv* env, jclass , jlong roi, jlong points, jint numPoints)
{
    ContourID rv = imaqAddClosedContour((ROI*)roi, (const Point*)points, (int)numPoints);
    
    return (jint)rv;
}

/* J: int imaqAddLineContour(ROI roi, Point start, Point end)
 * JN: int imaqAddLineContour(long roi, long start, long end)
 * C: ContourID imaqAddLineContour(ROI* roi, Point start, Point end)
 */

JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddLineContour(JNIEnv* env, jclass , jlong roi, jlong start, jlong end)
{
    ContourID rv = imaqAddLineContour((ROI*)roi, *((Point*)start), *((Point*)end));
    
    return (jint)rv;
}

/* J: int imaqAddOpenContour(ROI roi, Point[] points)
 * JN: int imaqAddOpenContour(long roi, long points, int numPoints)
 * C: ContourID imaqAddOpenContour(ROI* roi, const Point* points, int numPoints)
 */

JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddOpenContour(JNIEnv* env, jclass , jlong roi, jlong points, jint numPoints)
{
    ContourID rv = imaqAddOpenContour((ROI*)roi, (const Point*)points, (int)numPoints);
    
    return (jint)rv;
}

/* J: int imaqAddOvalContour(ROI roi, Rect boundingBox)
 * JN: int imaqAddOvalContour(long roi, long boundingBox)
 * C: ContourID imaqAddOvalContour(ROI* roi, Rect boundingBox)
 */

JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddOvalContour(JNIEnv* env, jclass , jlong roi, jlong boundingBox)
{
    ContourID rv = imaqAddOvalContour((ROI*)roi, *((Rect*)boundingBox));
    
    return (jint)rv;
}

/* J: int imaqAddPointContour(ROI roi, Point point)
 * JN: int imaqAddPointContour(long roi, long point)
 * C: ContourID imaqAddPointContour(ROI* roi, Point point)
 */

JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddPointContour(JNIEnv* env, jclass , jlong roi, jlong point)
{
    ContourID rv = imaqAddPointContour((ROI*)roi, *((Point*)point));
    
    return (jint)rv;
}

/* J: int imaqAddRectContour(ROI roi, Rect rect)
 * JN: int imaqAddRectContour(long roi, long rect)
 * C: ContourID imaqAddRectContour(ROI* roi, Rect rect)
 */

JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddRectContour(JNIEnv* env, jclass , jlong roi, jlong rect)
{
    ContourID rv = imaqAddRectContour((ROI*)roi, *((Rect*)rect));
    
    return (jint)rv;
}

/* J: int imaqAddRotatedRectContour2(ROI roi, RotatedRect rect)
 * JN: int imaqAddRotatedRectContour2(long roi, long rect)
 * C: ContourID imaqAddRotatedRectContour2(ROI* roi, RotatedRect rect)
 */

JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddRotatedRectContour2(JNIEnv* env, jclass , jlong roi, jlong rect)
{
    ContourID rv = imaqAddRotatedRectContour2((ROI*)roi, *((RotatedRect*)rect));
    
    return (jint)rv;
}

/* J: int imaqCopyContour(ROI destRoi, ROI sourceRoi, int id)
 * JN: int imaqCopyContour(long destRoi, long sourceRoi, int id)
 * C: ContourID imaqCopyContour(ROI* destRoi, const ROI* sourceRoi, ContourID id)
 */

JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqCopyContour(JNIEnv* env, jclass , jlong destRoi, jlong sourceRoi, jint id)
{
    ContourID rv = imaqCopyContour((ROI*)destRoi, (const ROI*)sourceRoi, (ContourID)id);
    
    return (jint)rv;
}

/* J: int imaqGetContour(ROI roi, int index)
 * JN: int imaqGetContour(long roi, int index)
 * C: ContourID imaqGetContour(const ROI* roi, unsigned int index)
 */

JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqGetContour(JNIEnv* env, jclass , jlong roi, jint index)
{
    ContourID rv = imaqGetContour((const ROI*)roi, (unsigned int)index);
    
    return (jint)rv;
}

/* J: void imaqGetContourColor(ROI roi, int id)
 * JN: void imaqGetContourColor(long roi, int id, long contourColor)
 * C: int imaqGetContourColor(const ROI* roi, ContourID id, RGBValue* contourColor)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetContourColor(JNIEnv* env, jclass , jlong roi, jint id, jlong contourColor)
{
    int rv = imaqGetContourColor((const ROI*)roi, (ContourID)id, (RGBValue*)contourColor);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetContourCount(ROI roi)
 * JN: void imaqGetContourCount(long roi)
 * C: int imaqGetContourCount(const ROI* roi)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetContourCount(JNIEnv* env, jclass , jlong roi)
{
    int rv = imaqGetContourCount((const ROI*)roi);
    if (rv == 0) throwJavaException(env);
}

/* J: ContourInfo2 imaqGetContourInfo2(ROI roi, int id)
 * JN: long imaqGetContourInfo2(long roi, int id)
 * C: ContourInfo2* imaqGetContourInfo2(const ROI* roi, ContourID id)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetContourInfo2(JNIEnv* env, jclass , jlong roi, jint id)
{
    ContourInfo2* rv = imaqGetContourInfo2((const ROI*)roi, (ContourID)id);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqMoveContour(ROI roi, int id, int deltaX, int deltaY)
 * JN: void imaqMoveContour(long roi, int id, int deltaX, int deltaY)
 * C: int imaqMoveContour(ROI* roi, ContourID id, int deltaX, int deltaY)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMoveContour(JNIEnv* env, jclass , jlong roi, jint id, jint deltaX, jint deltaY)
{
    int rv = imaqMoveContour((ROI*)roi, (ContourID)id, (int)deltaX, (int)deltaY);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqRemoveContour(ROI roi, int id)
 * JN: void imaqRemoveContour(long roi, int id)
 * C: int imaqRemoveContour(ROI* roi, ContourID id)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRemoveContour(JNIEnv* env, jclass , jlong roi, jint id)
{
    int rv = imaqRemoveContour((ROI*)roi, (ContourID)id);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetContourColor(ROI roi, int id, RGBValue color)
 * JN: void imaqSetContourColor(long roi, int id, long color)
 * C: int imaqSetContourColor(ROI* roi, ContourID id, const RGBValue* color)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetContourColor(JNIEnv* env, jclass , jlong roi, jint id, jlong color)
{
    int rv = imaqSetContourColor((ROI*)roi, (ContourID)id, (const RGBValue*)color);
    if (rv == 0) throwJavaException(env);
}

/*
 * Regions of Interest functions
 */

/* J: ROI imaqCreateROI()
 * JN: long imaqCreateROI()
 * C: ROI* imaqCreateROI( void)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCreateROI(JNIEnv* env, jclass )
{
    ROI* rv = imaqCreateROI();
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqGetROIBoundingBox(ROI roi)
 * JN: void imaqGetROIBoundingBox(long roi, long boundingBox)
 * C: int imaqGetROIBoundingBox(const ROI* roi, Rect* boundingBox)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetROIBoundingBox(JNIEnv* env, jclass , jlong roi, jlong boundingBox)
{
    int rv = imaqGetROIBoundingBox((const ROI*)roi, (Rect*)boundingBox);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetROIColor(ROI roi)
 * JN: void imaqGetROIColor(long roi, long roiColor)
 * C: int imaqGetROIColor(const ROI* roi, RGBValue* roiColor)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetROIColor(JNIEnv* env, jclass , jlong roi, jlong roiColor)
{
    int rv = imaqGetROIColor((const ROI*)roi, (RGBValue*)roiColor);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetROIColor(ROI roi, RGBValue color)
 * JN: void imaqSetROIColor(long roi, long color)
 * C: int imaqSetROIColor(ROI* roi, const RGBValue* color)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetROIColor(JNIEnv* env, jclass , jlong roi, jlong color)
{
    int rv = imaqSetROIColor((ROI*)roi, (const RGBValue*)color);
    if (rv == 0) throwJavaException(env);
}

/*
 * Image Analysis functions
 */

/* J: void imaqCentroid(Image image, Image mask)
 * JN: void imaqCentroid(long image, long centroid, long mask)
 * C: int imaqCentroid(const Image* image, PointFloat* centroid, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCentroid(JNIEnv* env, jclass , jlong image, jlong centroid, jlong mask)
{
    int rv = imaqCentroid((const Image*)image, (PointFloat*)centroid, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: ExtractCurvesResult imaqExtractCurves(Image image, ROI roi, CurveOptions curveOptions)
 * JN: long imaqExtractCurves(long image, long roi, long curveOptions, long numCurves)
 * C: Curve* imaqExtractCurves(const Image* image, const ROI* roi, const CurveOptions* curveOptions, unsigned int* numCurves)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqExtractCurves(JNIEnv* env, jclass , jlong image, jlong roi, jlong curveOptions, jlong numCurves)
{
    Curve* rv = imaqExtractCurves((const Image*)image, (const ROI*)roi, (const CurveOptions*)curveOptions, (unsigned int*)numCurves);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: HistogramReport imaqHistogram(Image image, int numClasses, float min, float max, Image mask)
 * JN: long imaqHistogram(long image, int numClasses, float min, float max, long mask)
 * C: HistogramReport* imaqHistogram(const Image* image, int numClasses, float min, float max, const Image* mask)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqHistogram(JNIEnv* env, jclass , jlong image, jint numClasses, jfloat min, jfloat max, jlong mask)
{
    HistogramReport* rv = imaqHistogram((const Image*)image, (int)numClasses, (float)min, (float)max, (const Image*)mask);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: LinearAverages imaqLinearAverages2(Image image, LinearAveragesMode mode, Rect rect)
 * JN: long imaqLinearAverages2(long image, int mode, long rect)
 * C: LinearAverages* imaqLinearAverages2(Image* image, LinearAveragesMode mode, Rect rect)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLinearAverages2(JNIEnv* env, jclass , jlong image, jint mode, jlong rect)
{
    LinearAverages* rv = imaqLinearAverages2((Image*)image, (LinearAveragesMode)mode, *((Rect*)rect));
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: LineProfile imaqLineProfile(Image image, Point start, Point end)
 * JN: long imaqLineProfile(long image, long start, long end)
 * C: LineProfile* imaqLineProfile(const Image* image, Point start, Point end)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLineProfile(JNIEnv* env, jclass , jlong image, jlong start, jlong end)
{
    LineProfile* rv = imaqLineProfile((const Image*)image, *((Point*)start), *((Point*)end));
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: QuantifyReport imaqQuantify(Image image, Image mask)
 * JN: long imaqQuantify(long image, long mask)
 * C: QuantifyReport* imaqQuantify(const Image* image, const Image* mask)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqQuantify(JNIEnv* env, jclass , jlong image, jlong mask)
{
    QuantifyReport* rv = imaqQuantify((const Image*)image, (const Image*)mask);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Threshold functions
 */

/* J: ThresholdData imaqAutoThreshold2(Image dest, Image source, int numClasses, ThresholdMethod method, Image mask)
 * JN: long imaqAutoThreshold2(long dest, long source, int numClasses, int method, long mask)
 * C: ThresholdData* imaqAutoThreshold2(Image* dest, const Image* source, int numClasses, ThresholdMethod method, const Image* mask)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqAutoThreshold2(JNIEnv* env, jclass , jlong dest, jlong source, jint numClasses, jint method, jlong mask)
{
    ThresholdData* rv = imaqAutoThreshold2((Image*)dest, (const Image*)source, (int)numClasses, (ThresholdMethod)method, (const Image*)mask);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqLocalThreshold(Image dest, Image source, int windowWidth, int windowHeight, LocalThresholdMethod method, double deviationWeight, ObjectType type, float replaceValue)
 * JN: void imaqLocalThreshold(long dest, long source, int windowWidth, int windowHeight, int method, double deviationWeight, int type, float replaceValue)
 * C: int imaqLocalThreshold(Image* dest, const Image* source, unsigned int windowWidth, unsigned int windowHeight, LocalThresholdMethod method, double deviationWeight, ObjectType type, float replaceValue)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLocalThreshold(JNIEnv* env, jclass , jlong dest, jlong source, jint windowWidth, jint windowHeight, jint method, jdouble deviationWeight, jint type, jfloat replaceValue)
{
    int rv = imaqLocalThreshold((Image*)dest, (const Image*)source, (unsigned int)windowWidth, (unsigned int)windowHeight, (LocalThresholdMethod)method, (double)deviationWeight, (ObjectType)type, (float)replaceValue);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMagicWand(Image dest, Image source, Point coord, float tolerance, int connectivity8, float replaceValue)
 * JN: void imaqMagicWand(long dest, long source, long coord, float tolerance, int connectivity8, float replaceValue)
 * C: int imaqMagicWand(Image* dest, const Image* source, Point coord, float tolerance, int connectivity8, float replaceValue)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMagicWand(JNIEnv* env, jclass , jlong dest, jlong source, jlong coord, jfloat tolerance, jint connectivity8, jfloat replaceValue)
{
    int rv = imaqMagicWand((Image*)dest, (const Image*)source, *((Point*)coord), (float)tolerance, (int)connectivity8, (float)replaceValue);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMultithreshold(Image dest, Image source, ThresholdData[] ranges)
 * JN: void imaqMultithreshold(long dest, long source, long ranges, int numRanges)
 * C: int imaqMultithreshold(Image* dest, const Image* source, const ThresholdData* ranges, int numRanges)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMultithreshold(JNIEnv* env, jclass , jlong dest, jlong source, jlong ranges, jint numRanges)
{
    int rv = imaqMultithreshold((Image*)dest, (const Image*)source, (const ThresholdData*)ranges, (int)numRanges);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqThreshold(Image dest, Image source, float rangeMin, float rangeMax, int useNewValue, float newValue)
 * JN: void imaqThreshold(long dest, long source, float rangeMin, float rangeMax, int useNewValue, float newValue)
 * C: int imaqThreshold(Image* dest, const Image* source, float rangeMin, float rangeMax, int useNewValue, float newValue)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqThreshold(JNIEnv* env, jclass , jlong dest, jlong source, jfloat rangeMin, jfloat rangeMax, jint useNewValue, jfloat newValue)
{
    int rv = imaqThreshold((Image*)dest, (const Image*)source, (float)rangeMin, (float)rangeMax, (int)useNewValue, (float)newValue);
    if (rv == 0) throwJavaException(env);
}

/*
 * Memory Management functions
 */

/*
 * Pattern Matching functions
 */

/* J: DetectCirclesResult imaqDetectCircles(Image image, CircleDescriptor circleDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi)
 * JN: long imaqDetectCircles(long image, long circleDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned)
 * C: CircleMatch* imaqDetectCircles(const Image* image, const CircleDescriptor* circleDescriptor, const CurveOptions* curveOptions, const ShapeDetectionOptions* shapeDetectionOptions, const ROI* roi, int* numMatchesReturned)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqDetectCircles(JNIEnv* env, jclass , jlong image, jlong circleDescriptor, jlong curveOptions, jlong shapeDetectionOptions, jlong roi, jlong numMatchesReturned)
{
    CircleMatch* rv = imaqDetectCircles((const Image*)image, (const CircleDescriptor*)circleDescriptor, (const CurveOptions*)curveOptions, (const ShapeDetectionOptions*)shapeDetectionOptions, (const ROI*)roi, (int*)numMatchesReturned);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: DetectEllipsesResult imaqDetectEllipses(Image image, EllipseDescriptor ellipseDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi)
 * JN: long imaqDetectEllipses(long image, long ellipseDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned)
 * C: EllipseMatch* imaqDetectEllipses(const Image* image, const EllipseDescriptor* ellipseDescriptor, const CurveOptions* curveOptions, const ShapeDetectionOptions* shapeDetectionOptions, const ROI* roi, int* numMatchesReturned)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqDetectEllipses(JNIEnv* env, jclass , jlong image, jlong ellipseDescriptor, jlong curveOptions, jlong shapeDetectionOptions, jlong roi, jlong numMatchesReturned)
{
    EllipseMatch* rv = imaqDetectEllipses((const Image*)image, (const EllipseDescriptor*)ellipseDescriptor, (const CurveOptions*)curveOptions, (const ShapeDetectionOptions*)shapeDetectionOptions, (const ROI*)roi, (int*)numMatchesReturned);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: DetectLinesResult imaqDetectLines(Image image, LineDescriptor lineDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi)
 * JN: long imaqDetectLines(long image, long lineDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned)
 * C: LineMatch* imaqDetectLines(const Image* image, const LineDescriptor* lineDescriptor, const CurveOptions* curveOptions, const ShapeDetectionOptions* shapeDetectionOptions, const ROI* roi, int* numMatchesReturned)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqDetectLines(JNIEnv* env, jclass , jlong image, jlong lineDescriptor, jlong curveOptions, jlong shapeDetectionOptions, jlong roi, jlong numMatchesReturned)
{
    LineMatch* rv = imaqDetectLines((const Image*)image, (const LineDescriptor*)lineDescriptor, (const CurveOptions*)curveOptions, (const ShapeDetectionOptions*)shapeDetectionOptions, (const ROI*)roi, (int*)numMatchesReturned);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: DetectRectanglesResult imaqDetectRectangles(Image image, RectangleDescriptor rectangleDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi)
 * JN: long imaqDetectRectangles(long image, long rectangleDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned)
 * C: RectangleMatch* imaqDetectRectangles(const Image* image, const RectangleDescriptor* rectangleDescriptor, const CurveOptions* curveOptions, const ShapeDetectionOptions* shapeDetectionOptions, const ROI* roi, int* numMatchesReturned)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqDetectRectangles(JNIEnv* env, jclass , jlong image, jlong rectangleDescriptor, jlong curveOptions, jlong shapeDetectionOptions, jlong roi, jlong numMatchesReturned)
{
    RectangleMatch* rv = imaqDetectRectangles((const Image*)image, (const RectangleDescriptor*)rectangleDescriptor, (const CurveOptions*)curveOptions, (const ShapeDetectionOptions*)shapeDetectionOptions, (const ROI*)roi, (int*)numMatchesReturned);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: GetGeometricFeaturesFromCurvesResult imaqGetGeometricFeaturesFromCurves(Curve[] curves, FeatureType[] featureTypes)
 * JN: long imaqGetGeometricFeaturesFromCurves(long curves, int numCurves, long featureTypes, int numFeatureTypes, long numFeatures)
 * C: FeatureData* imaqGetGeometricFeaturesFromCurves(const Curve* curves, unsigned int numCurves, const FeatureType* featureTypes, unsigned int numFeatureTypes, unsigned int* numFeatures)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetGeometricFeaturesFromCurves(JNIEnv* env, jclass , jlong curves, jint numCurves, jlong featureTypes, jint numFeatureTypes, jlong numFeatures)
{
    FeatureData* rv = imaqGetGeometricFeaturesFromCurves((const Curve*)curves, (unsigned int)numCurves, (const FeatureType*)featureTypes, (unsigned int)numFeatureTypes, (unsigned int*)numFeatures);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: GetGeometricTemplateFeatureInfoResult imaqGetGeometricTemplateFeatureInfo(Image pattern)
 * JN: long imaqGetGeometricTemplateFeatureInfo(long pattern, long numFeatures)
 * C: FeatureData* imaqGetGeometricTemplateFeatureInfo(const Image* pattern, unsigned int* numFeatures)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetGeometricTemplateFeatureInfo(JNIEnv* env, jclass , jlong pattern, jlong numFeatures)
{
    FeatureData* rv = imaqGetGeometricTemplateFeatureInfo((const Image*)pattern, (unsigned int*)numFeatures);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqLearnColorPattern(Image image, LearnColorPatternOptions options)
 * JN: void imaqLearnColorPattern(long image, long options)
 * C: int imaqLearnColorPattern(Image* image, const LearnColorPatternOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnColorPattern(JNIEnv* env, jclass , jlong image, jlong options)
{
    int rv = imaqLearnColorPattern((Image*)image, (const LearnColorPatternOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqLearnGeometricPattern(Image image, PointFloat originOffset, CurveOptions curveOptions, LearnGeometricPatternAdvancedOptions advancedLearnOptions, Image mask)
 * JN: void imaqLearnGeometricPattern(long image, long originOffset, long curveOptions, long advancedLearnOptions, long mask)
 * C: int imaqLearnGeometricPattern(Image* image, PointFloat originOffset, const CurveOptions* curveOptions, const LearnGeometricPatternAdvancedOptions* advancedLearnOptions, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnGeometricPattern(JNIEnv* env, jclass , jlong image, jlong originOffset, jlong curveOptions, jlong advancedLearnOptions, jlong mask)
{
    int rv = imaqLearnGeometricPattern((Image*)image, *((PointFloat*)originOffset), (const CurveOptions*)curveOptions, (const LearnGeometricPatternAdvancedOptions*)advancedLearnOptions, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqLearnPattern3(Image image, LearningMode learningMode, Image mask)
 * JN: void imaqLearnPattern3(long image, int learningMode, long advancedOptions, long mask)
 * C: int imaqLearnPattern3(Image* image, LearningMode learningMode, LearnPatternAdvancedOptions* advancedOptions, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnPattern3(JNIEnv* env, jclass , jlong image, jint learningMode, jlong advancedOptions, jlong mask)
{
    int rv = imaqLearnPattern3((Image*)image, (LearningMode)learningMode, (LearnPatternAdvancedOptions*)advancedOptions, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: MatchColorPatternResult imaqMatchColorPattern(Image image, Image pattern, MatchColorPatternOptions options, Rect searchRect)
 * JN: long imaqMatchColorPattern(long image, long pattern, long options, long searchRect, long numMatches)
 * C: PatternMatch* imaqMatchColorPattern(const Image* image, Image* pattern, const MatchColorPatternOptions* options, Rect searchRect, int* numMatches)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchColorPattern(JNIEnv* env, jclass , jlong image, jlong pattern, jlong options, jlong searchRect, jlong numMatches)
{
    PatternMatch* rv = imaqMatchColorPattern((const Image*)image, (Image*)pattern, (const MatchColorPatternOptions*)options, *((Rect*)searchRect), (int*)numMatches);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: MatchGeometricPattern2Result imaqMatchGeometricPattern2(Image image, Image pattern, CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions, MatchGeometricPatternAdvancedOptions2 advancedMatchOptions, ROI roi)
 * JN: long imaqMatchGeometricPattern2(long image, long pattern, long curveOptions, long matchOptions, long advancedMatchOptions, long roi, long numMatches)
 * C: GeometricPatternMatch2* imaqMatchGeometricPattern2(const Image* image, const Image* pattern, const CurveOptions* curveOptions, const MatchGeometricPatternOptions* matchOptions, const MatchGeometricPatternAdvancedOptions2* advancedMatchOptions, const ROI* roi, int* numMatches)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchGeometricPattern2(JNIEnv* env, jclass , jlong image, jlong pattern, jlong curveOptions, jlong matchOptions, jlong advancedMatchOptions, jlong roi, jlong numMatches)
{
    GeometricPatternMatch2* rv = imaqMatchGeometricPattern2((const Image*)image, (const Image*)pattern, (const CurveOptions*)curveOptions, (const MatchGeometricPatternOptions*)matchOptions, (const MatchGeometricPatternAdvancedOptions2*)advancedMatchOptions, (const ROI*)roi, (int*)numMatches);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: MatchMultipleGeometricPatternsResult imaqMatchMultipleGeometricPatterns(Image image, MultipleGeometricPattern multiplePattern, ROI roi)
 * JN: long imaqMatchMultipleGeometricPatterns(long image, long multiplePattern, long roi, long numMatches)
 * C: GeometricPatternMatch2* imaqMatchMultipleGeometricPatterns(const Image* image, const MultipleGeometricPattern* multiplePattern, const ROI* roi, int* numMatches)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchMultipleGeometricPatterns(JNIEnv* env, jclass , jlong image, jlong multiplePattern, jlong roi, jlong numMatches)
{
    GeometricPatternMatch2* rv = imaqMatchMultipleGeometricPatterns((const Image*)image, (const MultipleGeometricPattern*)multiplePattern, (const ROI*)roi, (int*)numMatches);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: MultipleGeometricPattern imaqReadMultipleGeometricPatternFile(String fileName, String description)
 * JN: long imaqReadMultipleGeometricPatternFile(long fileName, long description)
 * C: MultipleGeometricPattern* imaqReadMultipleGeometricPatternFile(const char* fileName, String255 description)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadMultipleGeometricPatternFile(JNIEnv* env, jclass , jlong fileName, jlong description)
{
    MultipleGeometricPattern* rv = imaqReadMultipleGeometricPatternFile((const char*)fileName, (char *)description);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: RefineMatchesResult imaqRefineMatches(Image image, Image pattern, PatternMatch[] candidatesIn)
 * JN: long imaqRefineMatches(long image, long pattern, long candidatesIn, int numCandidatesIn, long options, long advancedOptions, long numCandidatesOut)
 * C: PatternMatch* imaqRefineMatches(const Image* image, const Image* pattern, const PatternMatch* candidatesIn, int numCandidatesIn, MatchPatternOptions* options, MatchPatternAdvancedOptions* advancedOptions, int* numCandidatesOut)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqRefineMatches(JNIEnv* env, jclass , jlong image, jlong pattern, jlong candidatesIn, jint numCandidatesIn, jlong options, jlong advancedOptions, jlong numCandidatesOut)
{
    PatternMatch* rv = imaqRefineMatches((const Image*)image, (const Image*)pattern, (const PatternMatch*)candidatesIn, (int)numCandidatesIn, (MatchPatternOptions*)options, (MatchPatternAdvancedOptions*)advancedOptions, (int*)numCandidatesOut);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqSetMultipleGeometricPatternsOptions(MultipleGeometricPattern multiplePattern, String label, CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions, MatchGeometricPatternAdvancedOptions2 advancedMatchOptions)
 * JN: void imaqSetMultipleGeometricPatternsOptions(long multiplePattern, long label, long curveOptions, long matchOptions, long advancedMatchOptions)
 * C: int imaqSetMultipleGeometricPatternsOptions(MultipleGeometricPattern* multiplePattern, const char* label, const CurveOptions* curveOptions, const MatchGeometricPatternOptions* matchOptions, const MatchGeometricPatternAdvancedOptions2* advancedMatchOptions)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetMultipleGeometricPatternsOptions(JNIEnv* env, jclass , jlong multiplePattern, jlong label, jlong curveOptions, jlong matchOptions, jlong advancedMatchOptions)
{
    int rv = imaqSetMultipleGeometricPatternsOptions((MultipleGeometricPattern*)multiplePattern, (const char*)label, (const CurveOptions*)curveOptions, (const MatchGeometricPatternOptions*)matchOptions, (const MatchGeometricPatternAdvancedOptions2*)advancedMatchOptions);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqWriteMultipleGeometricPatternFile(MultipleGeometricPattern multiplePattern, String fileName, String description)
 * JN: void imaqWriteMultipleGeometricPatternFile(long multiplePattern, long fileName, long description)
 * C: int imaqWriteMultipleGeometricPatternFile(const MultipleGeometricPattern* multiplePattern, const char* fileName, const char* description)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteMultipleGeometricPatternFile(JNIEnv* env, jclass , jlong multiplePattern, jlong fileName, jlong description)
{
    int rv = imaqWriteMultipleGeometricPatternFile((const MultipleGeometricPattern*)multiplePattern, (const char*)fileName, (const char*)description);
    if (rv == 0) throwJavaException(env);
}

/* J: MatchGeometricPattern3Result imaqMatchGeometricPattern3(Image image, Image pattern, CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions, MatchGeometricPatternAdvancedOptions3 advancedMatchOptions, ROI roi)
 * JN: long imaqMatchGeometricPattern3(long image, long pattern, long curveOptions, long matchOptions, long advancedMatchOptions, long roi, long numMatches)
 * C: GeometricPatternMatch3* imaqMatchGeometricPattern3(const Image* image, const Image* pattern, const CurveOptions* curveOptions, const MatchGeometricPatternOptions* matchOptions, const MatchGeometricPatternAdvancedOptions3* advancedMatchOptions, const ROI* roi, size_t* numMatches)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchGeometricPattern3(JNIEnv* env, jclass , jlong image, jlong pattern, jlong curveOptions, jlong matchOptions, jlong advancedMatchOptions, jlong roi, jlong numMatches)
{
    GeometricPatternMatch3* rv = imaqMatchGeometricPattern3((const Image*)image, (const Image*)pattern, (const CurveOptions*)curveOptions, (const MatchGeometricPatternOptions*)matchOptions, (const MatchGeometricPatternAdvancedOptions3*)advancedMatchOptions, (const ROI*)roi, (size_t*)numMatches);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqLearnGeometricPattern2(Image image, PointFloat originOffset, double angleOffset, CurveOptions curveOptions, LearnGeometricPatternAdvancedOptions2 advancedLearnOptions, Image mask)
 * JN: void imaqLearnGeometricPattern2(long image, long originOffset, double angleOffset, long curveOptions, long advancedLearnOptions, long mask)
 * C: int imaqLearnGeometricPattern2(Image* image, PointFloat originOffset, double angleOffset, const CurveOptions* curveOptions, const LearnGeometricPatternAdvancedOptions2* advancedLearnOptions, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnGeometricPattern2(JNIEnv* env, jclass , jlong image, jlong originOffset, jdouble angleOffset, jlong curveOptions, jlong advancedLearnOptions, jlong mask)
{
    int rv = imaqLearnGeometricPattern2((Image*)image, *((PointFloat*)originOffset), (double)angleOffset, (const CurveOptions*)curveOptions, (const LearnGeometricPatternAdvancedOptions2*)advancedLearnOptions, (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/* J: MatchPattern3Result imaqMatchPattern3(Image image, Image pattern, MatchPatternOptions options, MatchPatternAdvancedOptions advancedOptions, ROI roi)
 * JN: long imaqMatchPattern3(long image, long pattern, long options, long advancedOptions, long roi, long numMatches)
 * C: PatternMatch* imaqMatchPattern3(const Image* image, const Image* pattern, const MatchPatternOptions* options, const MatchPatternAdvancedOptions* advancedOptions, const ROI* roi, int* numMatches)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchPattern3(JNIEnv* env, jclass , jlong image, jlong pattern, jlong options, jlong advancedOptions, jlong roi, jlong numMatches)
{
    PatternMatch* rv = imaqMatchPattern3((const Image*)image, (const Image*)pattern, (const MatchPatternOptions*)options, (const MatchPatternAdvancedOptions*)advancedOptions, (const ROI*)roi, (int*)numMatches);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Overlay functions
 */

/* J: void imaqClearOverlay(Image image, String group)
 * JN: void imaqClearOverlay(long image, long group)
 * C: int imaqClearOverlay(Image* image, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqClearOverlay(JNIEnv* env, jclass , jlong image, jlong group)
{
    int rv = imaqClearOverlay((Image*)image, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqCopyOverlay(Image dest, Image source, String group)
 * JN: void imaqCopyOverlay(long dest, long source, long group)
 * C: int imaqCopyOverlay(Image* dest, const Image* source, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCopyOverlay(JNIEnv* env, jclass , jlong dest, jlong source, jlong group)
{
    int rv = imaqCopyOverlay((Image*)dest, (const Image*)source, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetOverlayProperties(Image image, String group)
 * JN: void imaqGetOverlayProperties(long image, long group, long transformBehaviors)
 * C: int imaqGetOverlayProperties(const Image* image, const char* group, TransformBehaviors* transformBehaviors)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetOverlayProperties(JNIEnv* env, jclass , jlong image, jlong group, jlong transformBehaviors)
{
    int rv = imaqGetOverlayProperties((const Image*)image, (const char*)group, (TransformBehaviors*)transformBehaviors);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMergeOverlay(Image dest, Image source, RGBValue[] palette, String group)
 * JN: void imaqMergeOverlay(long dest, long source, long palette, int numColors, long group)
 * C: int imaqMergeOverlay(Image* dest, const Image* source, const RGBValue* palette, unsigned int numColors, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMergeOverlay(JNIEnv* env, jclass , jlong dest, jlong source, jlong palette, jint numColors, jlong group)
{
    int rv = imaqMergeOverlay((Image*)dest, (const Image*)source, (const RGBValue*)palette, (unsigned int)numColors, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqOverlayArc(Image image, ArcInfo arc, RGBValue color, DrawMode drawMode, String group)
 * JN: void imaqOverlayArc(long image, long arc, long color, int drawMode, long group)
 * C: int imaqOverlayArc(Image* image, const ArcInfo* arc, const RGBValue* color, DrawMode drawMode, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayArc(JNIEnv* env, jclass , jlong image, jlong arc, jlong color, jint drawMode, jlong group)
{
    int rv = imaqOverlayArc((Image*)image, (const ArcInfo*)arc, (const RGBValue*)color, (DrawMode)drawMode, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqOverlayBitmap(Image image, Point destLoc, RGBValue bitmap, int numCols, int numRows, String group)
 * JN: void imaqOverlayBitmap(long image, long destLoc, long bitmap, int numCols, int numRows, long group)
 * C: int imaqOverlayBitmap(Image* image, Point destLoc, const RGBValue* bitmap, unsigned int numCols, unsigned int numRows, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayBitmap(JNIEnv* env, jclass , jlong image, jlong destLoc, jlong bitmap, jint numCols, jint numRows, jlong group)
{
    int rv = imaqOverlayBitmap((Image*)image, *((Point*)destLoc), (const RGBValue*)bitmap, (unsigned int)numCols, (unsigned int)numRows, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqOverlayClosedContour(Image image, Point[] points, RGBValue color, DrawMode drawMode, String group)
 * JN: void imaqOverlayClosedContour(long image, long points, int numPoints, long color, int drawMode, long group)
 * C: int imaqOverlayClosedContour(Image* image, const Point* points, int numPoints, const RGBValue* color, DrawMode drawMode, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayClosedContour(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jlong color, jint drawMode, jlong group)
{
    int rv = imaqOverlayClosedContour((Image*)image, (const Point*)points, (int)numPoints, (const RGBValue*)color, (DrawMode)drawMode, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqOverlayLine(Image image, Point start, Point end, RGBValue color, String group)
 * JN: void imaqOverlayLine(long image, long start, long end, long color, long group)
 * C: int imaqOverlayLine(Image* image, Point start, Point end, const RGBValue* color, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayLine(JNIEnv* env, jclass , jlong image, jlong start, jlong end, jlong color, jlong group)
{
    int rv = imaqOverlayLine((Image*)image, *((Point*)start), *((Point*)end), (const RGBValue*)color, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqOverlayOpenContour(Image image, Point[] points, RGBValue color, String group)
 * JN: void imaqOverlayOpenContour(long image, long points, int numPoints, long color, long group)
 * C: int imaqOverlayOpenContour(Image* image, const Point* points, int numPoints, const RGBValue* color, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayOpenContour(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jlong color, jlong group)
{
    int rv = imaqOverlayOpenContour((Image*)image, (const Point*)points, (int)numPoints, (const RGBValue*)color, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqOverlayOval(Image image, Rect boundingBox, RGBValue color, DrawMode drawMode)
 * JN: void imaqOverlayOval(long image, long boundingBox, long color, int drawMode, long group)
 * C: int imaqOverlayOval(Image* image, Rect boundingBox, const RGBValue* color, DrawMode drawMode, char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayOval(JNIEnv* env, jclass , jlong image, jlong boundingBox, jlong color, jint drawMode, jlong group)
{
    int rv = imaqOverlayOval((Image*)image, *((Rect*)boundingBox), (const RGBValue*)color, (DrawMode)drawMode, (char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqOverlayPoints(Image image, Point[] points, RGBValue[] colors, PointSymbol symbol, UserPointSymbol userSymbol, String group)
 * JN: void imaqOverlayPoints(long image, long points, int numPoints, long colors, int numColors, int symbol, long userSymbol, long group)
 * C: int imaqOverlayPoints(Image* image, const Point* points, int numPoints, const RGBValue* colors, int numColors, PointSymbol symbol, const UserPointSymbol* userSymbol, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayPoints(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jlong colors, jint numColors, jint symbol, jlong userSymbol, jlong group)
{
    int rv = imaqOverlayPoints((Image*)image, (const Point*)points, (int)numPoints, (const RGBValue*)colors, (int)numColors, (PointSymbol)symbol, (const UserPointSymbol*)userSymbol, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqOverlayRect(Image image, Rect rect, RGBValue color, DrawMode drawMode, String group)
 * JN: void imaqOverlayRect(long image, long rect, long color, int drawMode, long group)
 * C: int imaqOverlayRect(Image* image, Rect rect, const RGBValue* color, DrawMode drawMode, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayRect(JNIEnv* env, jclass , jlong image, jlong rect, jlong color, jint drawMode, jlong group)
{
    int rv = imaqOverlayRect((Image*)image, *((Rect*)rect), (const RGBValue*)color, (DrawMode)drawMode, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqOverlayROI(Image image, ROI roi, PointSymbol symbol, UserPointSymbol userSymbol, String group)
 * JN: void imaqOverlayROI(long image, long roi, int symbol, long userSymbol, long group)
 * C: int imaqOverlayROI(Image* image, const ROI* roi, PointSymbol symbol, const UserPointSymbol* userSymbol, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayROI(JNIEnv* env, jclass , jlong image, jlong roi, jint symbol, jlong userSymbol, jlong group)
{
    int rv = imaqOverlayROI((Image*)image, (const ROI*)roi, (PointSymbol)symbol, (const UserPointSymbol*)userSymbol, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqOverlayText(Image image, Point origin, String text, RGBValue color, OverlayTextOptions options, String group)
 * JN: void imaqOverlayText(long image, long origin, long text, long color, long options, long group)
 * C: int imaqOverlayText(Image* image, Point origin, const char* text, const RGBValue* color, const OverlayTextOptions* options, const char* group)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayText(JNIEnv* env, jclass , jlong image, jlong origin, jlong text, jlong color, jlong options, jlong group)
{
    int rv = imaqOverlayText((Image*)image, *((Point*)origin), (const char*)text, (const RGBValue*)color, (const OverlayTextOptions*)options, (const char*)group);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetOverlayProperties(Image image, String group)
 * JN: void imaqSetOverlayProperties(long image, long group, long transformBehaviors)
 * C: int imaqSetOverlayProperties(Image* image, const char* group, TransformBehaviors* transformBehaviors)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetOverlayProperties(JNIEnv* env, jclass , jlong image, jlong group, jlong transformBehaviors)
{
    int rv = imaqSetOverlayProperties((Image*)image, (const char*)group, (TransformBehaviors*)transformBehaviors);
    if (rv == 0) throwJavaException(env);
}

/*
 * OCR functions
 */

/* J: CharSet imaqCreateCharSet()
 * JN: long imaqCreateCharSet()
 * C: CharSet* imaqCreateCharSet( void)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCreateCharSet(JNIEnv* env, jclass )
{
    CharSet* rv = imaqCreateCharSet();
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqDeleteChar(CharSet set, int index)
 * JN: void imaqDeleteChar(long set, int index)
 * C: int imaqDeleteChar(CharSet* set, int index)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDeleteChar(JNIEnv* env, jclass , jlong set, jint index)
{
    int rv = imaqDeleteChar((CharSet*)set, (int)index);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetCharCount(CharSet set)
 * JN: void imaqGetCharCount(long set)
 * C: int imaqGetCharCount(const CharSet* set)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetCharCount(JNIEnv* env, jclass , jlong set)
{
    int rv = imaqGetCharCount((const CharSet*)set);
    if (rv == 0) throwJavaException(env);
}

/* J: CharInfo2 imaqGetCharInfo2(CharSet set, int index)
 * JN: long imaqGetCharInfo2(long set, int index)
 * C: CharInfo2* imaqGetCharInfo2(const CharSet* set, int index)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetCharInfo2(JNIEnv* env, jclass , jlong set, jint index)
{
    CharInfo2* rv = imaqGetCharInfo2((const CharSet*)set, (int)index);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqReadOCRFile(String fileName, CharSet set, String setDescription)
 * JN: void imaqReadOCRFile(long fileName, long set, long setDescription, long readOptions, long processingOptions, long spacingOptions)
 * C: int imaqReadOCRFile(const char* fileName, CharSet* set, String255 setDescription, ReadTextOptions* readOptions, OCRProcessingOptions* processingOptions, OCRSpacingOptions* spacingOptions)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReadOCRFile(JNIEnv* env, jclass , jlong fileName, jlong set, jlong setDescription, jlong readOptions, jlong processingOptions, jlong spacingOptions)
{
    int rv = imaqReadOCRFile((const char*)fileName, (CharSet*)set, (char *)setDescription, (ReadTextOptions*)readOptions, (OCRProcessingOptions*)processingOptions, (OCRSpacingOptions*)spacingOptions);
    if (rv == 0) throwJavaException(env);
}

/* J: ReadTextReport3 imaqReadText3(Image image, CharSet set, ROI roi, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions)
 * JN: long imaqReadText3(long image, long set, long roi, long readOptions, long processingOptions, long spacingOptions)
 * C: ReadTextReport3* imaqReadText3(const Image* image, const CharSet* set, const ROI* roi, const ReadTextOptions* readOptions, const OCRProcessingOptions* processingOptions, const OCRSpacingOptions* spacingOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadText3(JNIEnv* env, jclass , jlong image, jlong set, jlong roi, jlong readOptions, jlong processingOptions, jlong spacingOptions)
{
    ReadTextReport3* rv = imaqReadText3((const Image*)image, (const CharSet*)set, (const ROI*)roi, (const ReadTextOptions*)readOptions, (const OCRProcessingOptions*)processingOptions, (const OCRSpacingOptions*)spacingOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqRenameChar(CharSet set, int index, String newCharValue)
 * JN: void imaqRenameChar(long set, int index, long newCharValue)
 * C: int imaqRenameChar(CharSet* set, int index, const char* newCharValue)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRenameChar(JNIEnv* env, jclass , jlong set, jint index, jlong newCharValue)
{
    int rv = imaqRenameChar((CharSet*)set, (int)index, (const char*)newCharValue);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetReferenceChar(CharSet set, int index, int isReferenceChar)
 * JN: void imaqSetReferenceChar(long set, int index, int isReferenceChar)
 * C: int imaqSetReferenceChar(const CharSet* set, int index, int isReferenceChar)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetReferenceChar(JNIEnv* env, jclass , jlong set, jint index, jint isReferenceChar)
{
    int rv = imaqSetReferenceChar((const CharSet*)set, (int)index, (int)isReferenceChar);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqTrainChars(Image image, CharSet set, int index, String charValue, ROI roi, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions)
 * JN: void imaqTrainChars(long image, long set, int index, long charValue, long roi, long processingOptions, long spacingOptions)
 * C: int imaqTrainChars(const Image* image, CharSet* set, int index, const char* charValue, const ROI* roi, const OCRProcessingOptions* processingOptions, const OCRSpacingOptions* spacingOptions)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqTrainChars(JNIEnv* env, jclass , jlong image, jlong set, jint index, jlong charValue, jlong roi, jlong processingOptions, jlong spacingOptions)
{
    int rv = imaqTrainChars((const Image*)image, (CharSet*)set, (int)index, (const char*)charValue, (const ROI*)roi, (const OCRProcessingOptions*)processingOptions, (const OCRSpacingOptions*)spacingOptions);
    if (rv == 0) throwJavaException(env);
}

/* J: VerifyTextResult imaqVerifyText(Image image, CharSet set, String expectedString, ROI roi)
 * JN: long imaqVerifyText(long image, long set, long expectedString, long roi, long numScores)
 * C: int* imaqVerifyText(const Image* image, const CharSet* set, const char* expectedString, const ROI* roi, int* numScores)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqVerifyText(JNIEnv* env, jclass , jlong image, jlong set, jlong expectedString, jlong roi, jlong numScores)
{
    int* rv = imaqVerifyText((const Image*)image, (const CharSet*)set, (const char*)expectedString, (const ROI*)roi, (int*)numScores);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqWriteOCRFile(String fileName, CharSet set, String setDescription, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions)
 * JN: void imaqWriteOCRFile(long fileName, long set, long setDescription, long readOptions, long processingOptions, long spacingOptions)
 * C: int imaqWriteOCRFile(const char* fileName, const CharSet* set, const char* setDescription, const ReadTextOptions* readOptions, const OCRProcessingOptions* processingOptions, const OCRSpacingOptions* spacingOptions)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteOCRFile(JNIEnv* env, jclass , jlong fileName, jlong set, jlong setDescription, jlong readOptions, jlong processingOptions, jlong spacingOptions)
{
    int rv = imaqWriteOCRFile((const char*)fileName, (const CharSet*)set, (const char*)setDescription, (const ReadTextOptions*)readOptions, (const OCRProcessingOptions*)processingOptions, (const OCRSpacingOptions*)spacingOptions);
    if (rv == 0) throwJavaException(env);
}

/*
 * Geometric Matching functions
 */

/* J: ExtractContourReport imaqExtractContour(Image image, ROI roi, ExtractContourDirection direction, ConnectionConstraint connectionConstraintParams, int numOfConstraints, ExtractContourSelection selection, Image contourImage)
 * JN: long imaqExtractContour(long image, long roi, int direction, long curveParams, long connectionConstraintParams, int numOfConstraints, int selection, long contourImage)
 * C: ExtractContourReport* imaqExtractContour(Image* image, const ROI* roi, ExtractContourDirection direction, CurveParameters* curveParams, const ConnectionConstraint* connectionConstraintParams, unsigned int numOfConstraints, ExtractContourSelection selection, Image* contourImage)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqExtractContour(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jlong curveParams, jlong connectionConstraintParams, jint numOfConstraints, jint selection, jlong contourImage)
{
    ExtractContourReport* rv = imaqExtractContour((Image*)image, (const ROI*)roi, (ExtractContourDirection)direction, (CurveParameters*)curveParams, (const ConnectionConstraint*)connectionConstraintParams, (unsigned int)numOfConstraints, (ExtractContourSelection)selection, (Image*)contourImage);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqContourOverlay(Image image, Image contourImage, ContourOverlaySettings pointsSettings, ContourOverlaySettings eqnSettings, String groupName)
 * JN: void imaqContourOverlay(long image, long contourImage, long pointsSettings, long eqnSettings, long groupName)
 * C: int imaqContourOverlay(Image* image, const Image* contourImage, const ContourOverlaySettings* pointsSettings, const ContourOverlaySettings* eqnSettings, const char* groupName)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqContourOverlay(JNIEnv* env, jclass , jlong image, jlong contourImage, jlong pointsSettings, jlong eqnSettings, jlong groupName)
{
    int rv = imaqContourOverlay((Image*)image, (const Image*)contourImage, (const ContourOverlaySettings*)pointsSettings, (const ContourOverlaySettings*)eqnSettings, (const char*)groupName);
    if (rv == 0) throwJavaException(env);
}

/* J: ContourComputeCurvatureReport imaqContourComputeCurvature(Image contourImage, int kernel)
 * JN: long imaqContourComputeCurvature(long contourImage, int kernel)
 * C: ContourComputeCurvatureReport* imaqContourComputeCurvature(const Image* contourImage, unsigned int kernel)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourComputeCurvature(JNIEnv* env, jclass , jlong contourImage, jint kernel)
{
    ContourComputeCurvatureReport* rv = imaqContourComputeCurvature((const Image*)contourImage, (unsigned int)kernel);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: CurvatureAnalysisReport imaqContourClassifyCurvature(Image contourImage, int kernel, RangeLabel[] curvatureClasses)
 * JN: long imaqContourClassifyCurvature(long contourImage, int kernel, long curvatureClasses, int numCurvatureClasses)
 * C: CurvatureAnalysisReport* imaqContourClassifyCurvature(const Image* contourImage, unsigned int kernel, RangeLabel* curvatureClasses, unsigned int numCurvatureClasses)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourClassifyCurvature(JNIEnv* env, jclass , jlong contourImage, jint kernel, jlong curvatureClasses, jint numCurvatureClasses)
{
    CurvatureAnalysisReport* rv = imaqContourClassifyCurvature((const Image*)contourImage, (unsigned int)kernel, (RangeLabel*)curvatureClasses, (unsigned int)numCurvatureClasses);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ComputeDistancesReport imaqContourComputeDistances(Image targetImage, Image templateImage, SetupMatchPatternData matchSetupData, int smoothingKernel)
 * JN: long imaqContourComputeDistances(long targetImage, long templateImage, long matchSetupData, int smoothingKernel)
 * C: ComputeDistancesReport* imaqContourComputeDistances(const Image* targetImage, const Image* templateImage, const SetupMatchPatternData* matchSetupData, unsigned int smoothingKernel)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourComputeDistances(JNIEnv* env, jclass , jlong targetImage, jlong templateImage, jlong matchSetupData, jint smoothingKernel)
{
    ComputeDistancesReport* rv = imaqContourComputeDistances((const Image*)targetImage, (const Image*)templateImage, (const SetupMatchPatternData*)matchSetupData, (unsigned int)smoothingKernel);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ClassifyDistancesReport imaqContourClassifyDistances(Image targetImage, Image templateImage, SetupMatchPatternData matchSetupData, int smoothingKernel, RangeLabel[] distanceRanges)
 * JN: long imaqContourClassifyDistances(long targetImage, long templateImage, long matchSetupData, int smoothingKernel, long distanceRanges, int numDistanceRanges)
 * C: ClassifyDistancesReport* imaqContourClassifyDistances(const Image* targetImage, const Image* templateImage, const SetupMatchPatternData* matchSetupData, unsigned int smoothingKernel, const RangeLabel* distanceRanges, unsigned int numDistanceRanges)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourClassifyDistances(JNIEnv* env, jclass , jlong targetImage, jlong templateImage, jlong matchSetupData, jint smoothingKernel, jlong distanceRanges, jint numDistanceRanges)
{
    ClassifyDistancesReport* rv = imaqContourClassifyDistances((const Image*)targetImage, (const Image*)templateImage, (const SetupMatchPatternData*)matchSetupData, (unsigned int)smoothingKernel, (const RangeLabel*)distanceRanges, (unsigned int)numDistanceRanges);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ContourInfoReport imaqContourInfo(Image contourImage)
 * JN: long imaqContourInfo(long contourImage)
 * C: ContourInfoReport* imaqContourInfo(const Image* contourImage)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourInfo(JNIEnv* env, jclass , jlong contourImage)
{
    ContourInfoReport* rv = imaqContourInfo((const Image*)contourImage);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: SetupMatchPatternData imaqContourSetupMatchPattern(int enableSubPixelAccuracy, int useLearnCurveParameters, RangeSettingDouble[] rangeSettings)
 * JN: long imaqContourSetupMatchPattern(long matchMode, int enableSubPixelAccuracy, long curveParams, int useLearnCurveParameters, long rangeSettings, int numRangeSettings)
 * C: SetupMatchPatternData* imaqContourSetupMatchPattern(MatchMode* matchMode, unsigned int enableSubPixelAccuracy, CurveParameters* curveParams, unsigned int useLearnCurveParameters, const RangeSettingDouble* rangeSettings, unsigned int numRangeSettings)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourSetupMatchPattern(JNIEnv* env, jclass , jlong matchMode, jint enableSubPixelAccuracy, jlong curveParams, jint useLearnCurveParameters, jlong rangeSettings, jint numRangeSettings)
{
    SetupMatchPatternData* rv = imaqContourSetupMatchPattern((MatchMode*)matchMode, (unsigned int)enableSubPixelAccuracy, (CurveParameters*)curveParams, (unsigned int)useLearnCurveParameters, (const RangeSettingDouble*)rangeSettings, (unsigned int)numRangeSettings);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqContourAdvancedSetupMatchPattern(GeometricAdvancedSetupDataOption[] geometricOptions)
 * JN: void imaqContourAdvancedSetupMatchPattern(long matchSetupData, long geometricOptions, int numGeometricOptions)
 * C: int imaqContourAdvancedSetupMatchPattern(SetupMatchPatternData* matchSetupData, GeometricAdvancedSetupDataOption* geometricOptions, unsigned int numGeometricOptions)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqContourAdvancedSetupMatchPattern(JNIEnv* env, jclass , jlong matchSetupData, jlong geometricOptions, jint numGeometricOptions)
{
    int rv = imaqContourAdvancedSetupMatchPattern((SetupMatchPatternData*)matchSetupData, (GeometricAdvancedSetupDataOption*)geometricOptions, (unsigned int)numGeometricOptions);
    if (rv == 0) throwJavaException(env);
}

/* J: ContourFitLineReport imaqContourFitLine(Image image, double pixelRadius)
 * JN: long imaqContourFitLine(long image, double pixelRadius)
 * C: ContourFitLineReport* imaqContourFitLine(Image* image, double pixelRadius)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourFitLine(JNIEnv* env, jclass , jlong image, jdouble pixelRadius)
{
    ContourFitLineReport* rv = imaqContourFitLine((Image*)image, (double)pixelRadius);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: PartialCircle imaqContourFitCircle(Image image, double pixelRadius, int rejectOutliers)
 * JN: long imaqContourFitCircle(long image, double pixelRadius, int rejectOutliers)
 * C: PartialCircle* imaqContourFitCircle(Image* image, double pixelRadius, int rejectOutliers)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourFitCircle(JNIEnv* env, jclass , jlong image, jdouble pixelRadius, jint rejectOutliers)
{
    PartialCircle* rv = imaqContourFitCircle((Image*)image, (double)pixelRadius, (int)rejectOutliers);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: PartialEllipse imaqContourFitEllipse(Image image, double pixelRadius, int rejectOutliers)
 * JN: long imaqContourFitEllipse(long image, double pixelRadius, int rejectOutliers)
 * C: PartialEllipse* imaqContourFitEllipse(Image* image, double pixelRadius, int rejectOutliers)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourFitEllipse(JNIEnv* env, jclass , jlong image, jdouble pixelRadius, jint rejectOutliers)
{
    PartialEllipse* rv = imaqContourFitEllipse((Image*)image, (double)pixelRadius, (int)rejectOutliers);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ContourFitSplineReport imaqContourFitSpline(Image image, int degree, int numberOfControlPoints)
 * JN: long imaqContourFitSpline(long image, int degree, int numberOfControlPoints)
 * C: ContourFitSplineReport* imaqContourFitSpline(Image* image, int degree, int numberOfControlPoints)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourFitSpline(JNIEnv* env, jclass , jlong image, jint degree, jint numberOfControlPoints)
{
    ContourFitSplineReport* rv = imaqContourFitSpline((Image*)image, (int)degree, (int)numberOfControlPoints);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ContourFitPolynomialReport imaqContourFitPolynomial(Image image, int order)
 * JN: long imaqContourFitPolynomial(long image, int order)
 * C: ContourFitPolynomialReport* imaqContourFitPolynomial(Image* image, int order)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourFitPolynomial(JNIEnv* env, jclass , jlong image, jint order)
{
    ContourFitPolynomialReport* rv = imaqContourFitPolynomial((Image*)image, (int)order);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Edge Detection functions
 */

/* J: FindCircularEdgeReport imaqFindCircularEdge2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, FindCircularEdgeOptions edgeOptions, CircleFitOptions circleFitOptions)
 * JN: long imaqFindCircularEdge2(long image, long roi, long baseSystem, long newSystem, long edgeOptions, long circleFitOptions)
 * C: FindCircularEdgeReport* imaqFindCircularEdge2(Image* image, const ROI* roi, const CoordinateSystem* baseSystem, const CoordinateSystem* newSystem, const FindCircularEdgeOptions* edgeOptions, const CircleFitOptions* circleFitOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFindCircularEdge2(JNIEnv* env, jclass , jlong image, jlong roi, jlong baseSystem, jlong newSystem, jlong edgeOptions, jlong circleFitOptions)
{
    FindCircularEdgeReport* rv = imaqFindCircularEdge2((Image*)image, (const ROI*)roi, (const CoordinateSystem*)baseSystem, (const CoordinateSystem*)newSystem, (const FindCircularEdgeOptions*)edgeOptions, (const CircleFitOptions*)circleFitOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: FindConcentricEdgeReport imaqFindConcentricEdge2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, FindConcentricEdgeOptions edgeOptions, ConcentricEdgeFitOptions concentricEdgeFitOptions)
 * JN: long imaqFindConcentricEdge2(long image, long roi, long baseSystem, long newSystem, long edgeOptions, long concentricEdgeFitOptions)
 * C: FindConcentricEdgeReport* imaqFindConcentricEdge2(Image* image, const ROI* roi, const CoordinateSystem* baseSystem, const CoordinateSystem* newSystem, const FindConcentricEdgeOptions* edgeOptions, const ConcentricEdgeFitOptions* concentricEdgeFitOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFindConcentricEdge2(JNIEnv* env, jclass , jlong image, jlong roi, jlong baseSystem, jlong newSystem, jlong edgeOptions, jlong concentricEdgeFitOptions)
{
    FindConcentricEdgeReport* rv = imaqFindConcentricEdge2((Image*)image, (const ROI*)roi, (const CoordinateSystem*)baseSystem, (const CoordinateSystem*)newSystem, (const FindConcentricEdgeOptions*)edgeOptions, (const ConcentricEdgeFitOptions*)concentricEdgeFitOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Morphology Reconstruction functions
 */

/* J: void imaqGrayMorphologyReconstruct(Image dstImage, Image srcImage, Image markerImage, PointFloat[] points, MorphologyReconstructOperation operation, StructuringElement structuringElement, ROI roi)
 * JN: void imaqGrayMorphologyReconstruct(long dstImage, long srcImage, long markerImage, long points, int numOfPoints, int operation, long structuringElement, long roi)
 * C: int imaqGrayMorphologyReconstruct(Image* dstImage, Image* srcImage, const Image* markerImage, PointFloat* points, int numOfPoints, MorphologyReconstructOperation operation, const StructuringElement* structuringElement, const ROI* roi)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGrayMorphologyReconstruct(JNIEnv* env, jclass , jlong dstImage, jlong srcImage, jlong markerImage, jlong points, jint numOfPoints, jint operation, jlong structuringElement, jlong roi)
{
    int rv = imaqGrayMorphologyReconstruct((Image*)dstImage, (Image*)srcImage, (const Image*)markerImage, (PointFloat*)points, (int)numOfPoints, (MorphologyReconstructOperation)operation, (const StructuringElement*)structuringElement, (const ROI*)roi);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqMorphologyReconstruct(Image dstImage, Image srcImage, Image markerImage, PointFloat[] points, MorphologyReconstructOperation operation, Connectivity connectivity, ROI roi)
 * JN: void imaqMorphologyReconstruct(long dstImage, long srcImage, long markerImage, long points, int numOfPoints, int operation, int connectivity, long roi)
 * C: int imaqMorphologyReconstruct(Image* dstImage, Image* srcImage, const Image* markerImage, PointFloat* points, int numOfPoints, MorphologyReconstructOperation operation, Connectivity connectivity, const ROI* roi)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMorphologyReconstruct(JNIEnv* env, jclass , jlong dstImage, jlong srcImage, jlong markerImage, jlong points, jint numOfPoints, jint operation, jint connectivity, jlong roi)
{
    int rv = imaqMorphologyReconstruct((Image*)dstImage, (Image*)srcImage, (const Image*)markerImage, (PointFloat*)points, (int)numOfPoints, (MorphologyReconstructOperation)operation, (Connectivity)connectivity, (const ROI*)roi);
    if (rv == 0) throwJavaException(env);
}

/*
 * Texture functions
 */

/* J: void imaqDetectTextureDefect(ClassifierSession session, Image destImage, Image srcImage, ROI roi, int initialStepSize, int finalStepSize, short defectPixelValue, double minClassificationScore)
 * JN: void imaqDetectTextureDefect(long session, long destImage, long srcImage, long roi, int initialStepSize, int finalStepSize, short defectPixelValue, double minClassificationScore)
 * C: int imaqDetectTextureDefect(ClassifierSession* session, Image* destImage, const Image* srcImage, const ROI* roi, int initialStepSize, int finalStepSize, unsigned char defectPixelValue, double minClassificationScore)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDetectTextureDefect(JNIEnv* env, jclass , jlong session, jlong destImage, jlong srcImage, jlong roi, jint initialStepSize, jint finalStepSize, jshort defectPixelValue, jdouble minClassificationScore)
{
    int rv = imaqDetectTextureDefect((ClassifierSession*)session, (Image*)destImage, (const Image*)srcImage, (const ROI*)roi, (int)initialStepSize, (int)finalStepSize, (unsigned char)defectPixelValue, (double)minClassificationScore);
    if (rv == 0) throwJavaException(env);
}

/*
 * Regions of Interest Manipulation functions
 */

/* J: ROI imaqMaskToROI(Image mask)
 * JN: long imaqMaskToROI(long mask, long withinLimit)
 * C: ROI* imaqMaskToROI(const Image* mask, int* withinLimit)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMaskToROI(JNIEnv* env, jclass , jlong mask, jlong withinLimit)
{
    ROI* rv = imaqMaskToROI((const Image*)mask, (int*)withinLimit);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ROIProfile imaqROIProfile(Image image, ROI roi)
 * JN: long imaqROIProfile(long image, long roi)
 * C: ROIProfile* imaqROIProfile(const Image* image, const ROI* roi)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqROIProfile(JNIEnv* env, jclass , jlong image, jlong roi)
{
    ROIProfile* rv = imaqROIProfile((const Image*)image, (const ROI*)roi);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqROIToMask(Image mask, ROI roi, int fillValue, Image imageModel)
 * JN: void imaqROIToMask(long mask, long roi, int fillValue, long imageModel, long inSpace)
 * C: int imaqROIToMask(Image* mask, const ROI* roi, int fillValue, const Image* imageModel, int* inSpace)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqROIToMask(JNIEnv* env, jclass , jlong mask, jlong roi, jint fillValue, jlong imageModel, jlong inSpace)
{
    int rv = imaqROIToMask((Image*)mask, (const ROI*)roi, (int)fillValue, (const Image*)imageModel, (int*)inSpace);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqTransformROI2(ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem)
 * JN: void imaqTransformROI2(long roi, long baseSystem, long newSystem)
 * C: int imaqTransformROI2(ROI* roi, const CoordinateSystem* baseSystem, const CoordinateSystem* newSystem)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqTransformROI2(JNIEnv* env, jclass , jlong roi, jlong baseSystem, jlong newSystem)
{
    int rv = imaqTransformROI2((ROI*)roi, (const CoordinateSystem*)baseSystem, (const CoordinateSystem*)newSystem);
    if (rv == 0) throwJavaException(env);
}

/* J: LabelToROIReport imaqLabelToROI(Image image, int[] labelsIn, int maxNumVectors, int isExternelEdges)
 * JN: long imaqLabelToROI(long image, long labelsIn, int numLabelsIn, int maxNumVectors, int isExternelEdges)
 * C: LabelToROIReport* imaqLabelToROI(const Image* image, const unsigned int* labelsIn, unsigned int numLabelsIn, int maxNumVectors, int isExternelEdges)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLabelToROI(JNIEnv* env, jclass , jlong image, jlong labelsIn, jint numLabelsIn, jint maxNumVectors, jint isExternelEdges)
{
    LabelToROIReport* rv = imaqLabelToROI((const Image*)image, (const unsigned int*)labelsIn, (unsigned int)numLabelsIn, (int)maxNumVectors, (int)isExternelEdges);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Morphology functions
 */

/* J: void imaqGrayMorphology(Image dest, Image source, MorphologyMethod method, StructuringElement structuringElement)
 * JN: void imaqGrayMorphology(long dest, long source, int method, long structuringElement)
 * C: int imaqGrayMorphology(Image* dest, Image* source, MorphologyMethod method, const StructuringElement* structuringElement)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGrayMorphology(JNIEnv* env, jclass , jlong dest, jlong source, jint method, jlong structuringElement)
{
    int rv = imaqGrayMorphology((Image*)dest, (Image*)source, (MorphologyMethod)method, (const StructuringElement*)structuringElement);
    if (rv == 0) throwJavaException(env);
}

/*
 * Classification functions
 */

/* J: void imaqAddClassifierSample(Image image, ClassifierSession session, ROI roi, String sampleClass, double[] featureVector)
 * JN: void imaqAddClassifierSample(long image, long session, long roi, long sampleClass, long featureVector, int vectorSize)
 * C: int imaqAddClassifierSample(Image* image, ClassifierSession* session, const ROI* roi, const char* sampleClass, double* featureVector, unsigned int vectorSize)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAddClassifierSample(JNIEnv* env, jclass , jlong image, jlong session, jlong roi, jlong sampleClass, jlong featureVector, jint vectorSize)
{
    int rv = imaqAddClassifierSample((Image*)image, (ClassifierSession*)session, (const ROI*)roi, (const char*)sampleClass, (double*)featureVector, (unsigned int)vectorSize);
    if (rv == 0) throwJavaException(env);
}

/* J: ClassifierReportAdvanced imaqAdvanceClassify(Image image, ClassifierSession session, ROI roi, double[] featureVector)
 * JN: long imaqAdvanceClassify(long image, long session, long roi, long featureVector, int vectorSize)
 * C: ClassifierReportAdvanced* imaqAdvanceClassify(Image* image, const ClassifierSession* session, const ROI* roi, double* featureVector, unsigned int vectorSize)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqAdvanceClassify(JNIEnv* env, jclass , jlong image, jlong session, jlong roi, jlong featureVector, jint vectorSize)
{
    ClassifierReportAdvanced* rv = imaqAdvanceClassify((Image*)image, (const ClassifierSession*)session, (const ROI*)roi, (double*)featureVector, (unsigned int)vectorSize);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ClassifierReport imaqClassify(Image image, ClassifierSession session, ROI roi, double[] featureVector)
 * JN: long imaqClassify(long image, long session, long roi, long featureVector, int vectorSize)
 * C: ClassifierReport* imaqClassify(Image* image, const ClassifierSession* session, const ROI* roi, double* featureVector, unsigned int vectorSize)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqClassify(JNIEnv* env, jclass , jlong image, jlong session, jlong roi, jlong featureVector, jint vectorSize)
{
    ClassifierReport* rv = imaqClassify((Image*)image, (const ClassifierSession*)session, (const ROI*)roi, (double*)featureVector, (unsigned int)vectorSize);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ClassifierSession imaqCreateClassifier(ClassifierType type)
 * JN: long imaqCreateClassifier(int type)
 * C: ClassifierSession* imaqCreateClassifier(ClassifierType type)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCreateClassifier(JNIEnv* env, jclass , jint type)
{
    ClassifierSession* rv = imaqCreateClassifier((ClassifierType)type);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqDeleteClassifierSample(ClassifierSession session, int index)
 * JN: void imaqDeleteClassifierSample(long session, int index)
 * C: int imaqDeleteClassifierSample(ClassifierSession* session, int index)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDeleteClassifierSample(JNIEnv* env, jclass , jlong session, jint index)
{
    int rv = imaqDeleteClassifierSample((ClassifierSession*)session, (int)index);
    if (rv == 0) throwJavaException(env);
}

/* J: ClassifierAccuracyReport imaqGetClassifierAccuracy(ClassifierSession session)
 * JN: long imaqGetClassifierAccuracy(long session)
 * C: ClassifierAccuracyReport* imaqGetClassifierAccuracy(const ClassifierSession* session)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetClassifierAccuracy(JNIEnv* env, jclass , jlong session)
{
    ClassifierAccuracyReport* rv = imaqGetClassifierAccuracy((const ClassifierSession*)session);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ClassifierSampleInfo imaqGetClassifierSampleInfo(ClassifierSession session, int index)
 * JN: long imaqGetClassifierSampleInfo(long session, int index, long numSamples)
 * C: ClassifierSampleInfo* imaqGetClassifierSampleInfo(const ClassifierSession* session, int index, int* numSamples)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetClassifierSampleInfo(JNIEnv* env, jclass , jlong session, jint index, jlong numSamples)
{
    ClassifierSampleInfo* rv = imaqGetClassifierSampleInfo((const ClassifierSession*)session, (int)index, (int*)numSamples);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqGetColorClassifierOptions(ClassifierSession session)
 * JN: void imaqGetColorClassifierOptions(long session, long options)
 * C: int imaqGetColorClassifierOptions(const ClassifierSession* session, ColorOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetColorClassifierOptions(JNIEnv* env, jclass , jlong session, jlong options)
{
    int rv = imaqGetColorClassifierOptions((const ClassifierSession*)session, (ColorOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetNearestNeighborOptions(ClassifierSession session)
 * JN: void imaqGetNearestNeighborOptions(long session, long options)
 * C: int imaqGetNearestNeighborOptions(const ClassifierSession* session, NearestNeighborOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetNearestNeighborOptions(JNIEnv* env, jclass , jlong session, jlong options)
{
    int rv = imaqGetNearestNeighborOptions((const ClassifierSession*)session, (NearestNeighborOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqGetParticleClassifierOptions2(ClassifierSession session)
 * JN: void imaqGetParticleClassifierOptions2(long session, long preprocessingOptions, long options)
 * C: int imaqGetParticleClassifierOptions2(const ClassifierSession* session, ParticleClassifierPreprocessingOptions2* preprocessingOptions, ParticleClassifierOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetParticleClassifierOptions2(JNIEnv* env, jclass , jlong session, jlong preprocessingOptions, jlong options)
{
    int rv = imaqGetParticleClassifierOptions2((const ClassifierSession*)session, (ParticleClassifierPreprocessingOptions2*)preprocessingOptions, (ParticleClassifierOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/* J: ClassifierSession imaqReadClassifierFile(ClassifierSession session, String fileName, ReadClassifierFileMode mode, String description)
 * JN: long imaqReadClassifierFile(long session, long fileName, int mode, long type, long engine, long description)
 * C: ClassifierSession* imaqReadClassifierFile(ClassifierSession* session, const char* fileName, ReadClassifierFileMode mode, ClassifierType* type, ClassifierEngineType* engine, String255 description)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadClassifierFile(JNIEnv* env, jclass , jlong session, jlong fileName, jint mode, jlong type, jlong engine, jlong description)
{
    ClassifierSession* rv = imaqReadClassifierFile((ClassifierSession*)session, (const char*)fileName, (ReadClassifierFileMode)mode, (ClassifierType*)type, (ClassifierEngineType*)engine, (char *)description);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqRelabelClassifierSample(ClassifierSession session, int index, String newClass)
 * JN: void imaqRelabelClassifierSample(long session, int index, long newClass)
 * C: int imaqRelabelClassifierSample(ClassifierSession* session, int index, const char* newClass)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRelabelClassifierSample(JNIEnv* env, jclass , jlong session, jint index, jlong newClass)
{
    int rv = imaqRelabelClassifierSample((ClassifierSession*)session, (int)index, (const char*)newClass);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetParticleClassifierOptions2(ClassifierSession session, ParticleClassifierPreprocessingOptions2 preprocessingOptions, ParticleClassifierOptions options)
 * JN: void imaqSetParticleClassifierOptions2(long session, long preprocessingOptions, long options)
 * C: int imaqSetParticleClassifierOptions2(ClassifierSession* session, const ParticleClassifierPreprocessingOptions2* preprocessingOptions, const ParticleClassifierOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetParticleClassifierOptions2(JNIEnv* env, jclass , jlong session, jlong preprocessingOptions, jlong options)
{
    int rv = imaqSetParticleClassifierOptions2((ClassifierSession*)session, (const ParticleClassifierPreprocessingOptions2*)preprocessingOptions, (const ParticleClassifierOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqSetColorClassifierOptions(ClassifierSession session, ColorOptions options)
 * JN: void imaqSetColorClassifierOptions(long session, long options)
 * C: int imaqSetColorClassifierOptions(ClassifierSession* session, const ColorOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetColorClassifierOptions(JNIEnv* env, jclass , jlong session, jlong options)
{
    int rv = imaqSetColorClassifierOptions((ClassifierSession*)session, (const ColorOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/* J: NearestNeighborTrainingReport imaqTrainNearestNeighborClassifier(ClassifierSession session, NearestNeighborOptions options)
 * JN: long imaqTrainNearestNeighborClassifier(long session, long options)
 * C: NearestNeighborTrainingReport* imaqTrainNearestNeighborClassifier(ClassifierSession* session, const NearestNeighborOptions* options)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqTrainNearestNeighborClassifier(JNIEnv* env, jclass , jlong session, jlong options)
{
    NearestNeighborTrainingReport* rv = imaqTrainNearestNeighborClassifier((ClassifierSession*)session, (const NearestNeighborOptions*)options);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqWriteClassifierFile(ClassifierSession session, String fileName, WriteClassifierFileMode mode, String description)
 * JN: void imaqWriteClassifierFile(long session, long fileName, int mode, long description)
 * C: int imaqWriteClassifierFile(const ClassifierSession* session, const char* fileName, WriteClassifierFileMode mode, const String255 description)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteClassifierFile(JNIEnv* env, jclass , jlong session, jlong fileName, jint mode, jlong description)
{
    int rv = imaqWriteClassifierFile((const ClassifierSession*)session, (const char*)fileName, (WriteClassifierFileMode)mode, (char *)description);
    if (rv == 0) throwJavaException(env);
}

/*
 * Measure Distances functions
 */

/* J: ClampMax2Report imaqClampMax2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, CurveOptions curveSettings, ClampSettings clampSettings, ClampOverlaySettings clampOverlaySettings)
 * JN: long imaqClampMax2(long image, long roi, long baseSystem, long newSystem, long curveSettings, long clampSettings, long clampOverlaySettings)
 * C: ClampMax2Report* imaqClampMax2(Image* image, const ROI* roi, const CoordinateSystem* baseSystem, const CoordinateSystem* newSystem, const CurveOptions* curveSettings, const ClampSettings* clampSettings, const ClampOverlaySettings* clampOverlaySettings)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqClampMax2(JNIEnv* env, jclass , jlong image, jlong roi, jlong baseSystem, jlong newSystem, jlong curveSettings, jlong clampSettings, jlong clampOverlaySettings)
{
    ClampMax2Report* rv = imaqClampMax2((Image*)image, (const ROI*)roi, (const CoordinateSystem*)baseSystem, (const CoordinateSystem*)newSystem, (const CurveOptions*)curveSettings, (const ClampSettings*)clampSettings, (const ClampOverlaySettings*)clampOverlaySettings);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/*
 * Inspection functions
 */

/* J: void imaqCompareGoldenTemplate(Image image, Image goldenTemplate, Image brightDefects, Image darkDefects, InspectionAlignment alignment, InspectionOptions options)
 * JN: void imaqCompareGoldenTemplate(long image, long goldenTemplate, long brightDefects, long darkDefects, long alignment, long options)
 * C: int imaqCompareGoldenTemplate(const Image* image, const Image* goldenTemplate, Image* brightDefects, Image* darkDefects, const InspectionAlignment* alignment, const InspectionOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCompareGoldenTemplate(JNIEnv* env, jclass , jlong image, jlong goldenTemplate, jlong brightDefects, jlong darkDefects, jlong alignment, jlong options)
{
    int rv = imaqCompareGoldenTemplate((const Image*)image, (const Image*)goldenTemplate, (Image*)brightDefects, (Image*)darkDefects, (const InspectionAlignment*)alignment, (const InspectionOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqLearnGoldenTemplate(Image goldenTemplate, PointFloat originOffset, Image mask)
 * JN: void imaqLearnGoldenTemplate(long goldenTemplate, long originOffset, long mask)
 * C: int imaqLearnGoldenTemplate(Image* goldenTemplate, PointFloat originOffset, const Image* mask)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnGoldenTemplate(JNIEnv* env, jclass , jlong goldenTemplate, jlong originOffset, jlong mask)
{
    int rv = imaqLearnGoldenTemplate((Image*)goldenTemplate, *((PointFloat*)originOffset), (const Image*)mask);
    if (rv == 0) throwJavaException(env);
}

/*
 * Obsolete functions
 */

/* J: void imaqGetParticleClassifierOptions(ClassifierSession session)
 * JN: void imaqGetParticleClassifierOptions(long session, long preprocessingOptions, long options)
 * C: int imaqGetParticleClassifierOptions(const ClassifierSession* session, ParticleClassifierPreprocessingOptions* preprocessingOptions, ParticleClassifierOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetParticleClassifierOptions(JNIEnv* env, jclass , jlong session, jlong preprocessingOptions, jlong options)
{
    int rv = imaqGetParticleClassifierOptions((const ClassifierSession*)session, (ParticleClassifierPreprocessingOptions*)preprocessingOptions, (ParticleClassifierOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqParticleFilter3(Image dest, Image source, ParticleFilterCriteria2 criteria, int criteriaCount, ParticleFilterOptions options, ROI roi)
 * JN: void imaqParticleFilter3(long dest, long source, long criteria, int criteriaCount, long options, long roi, long numParticles)
 * C: int imaqParticleFilter3(Image* dest, Image* source, const ParticleFilterCriteria2* criteria, int criteriaCount, const ParticleFilterOptions* options, const ROI* roi, int* numParticles)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqParticleFilter3(JNIEnv* env, jclass , jlong dest, jlong source, jlong criteria, jint criteriaCount, jlong options, jlong roi, jlong numParticles)
{
    int rv = imaqParticleFilter3((Image*)dest, (Image*)source, (const ParticleFilterCriteria2*)criteria, (int)criteriaCount, (const ParticleFilterOptions*)options, (const ROI*)roi, (int*)numParticles);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqLearnPattern2(Image image, LearningMode learningMode)
 * JN: void imaqLearnPattern2(long image, int learningMode, long advancedOptions)
 * C: int imaqLearnPattern2(Image* image, LearningMode learningMode, LearnPatternAdvancedOptions* advancedOptions)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnPattern2(JNIEnv* env, jclass , jlong image, jint learningMode, jlong advancedOptions)
{
    int rv = imaqLearnPattern2((Image*)image, (LearningMode)learningMode, (LearnPatternAdvancedOptions*)advancedOptions);
    if (rv == 0) throwJavaException(env);
}

/* J: void imaqDivide(Image dest, Image sourceA, Image sourceB)
 * JN: void imaqDivide(long dest, long sourceA, long sourceB)
 * C: int imaqDivide(Image* dest, const Image* sourceA, const Image* sourceB)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDivide(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
{
    int rv = imaqDivide((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
    if (rv == 0) throwJavaException(env);
}

/* J: EdgeReport2 imaqEdgeTool3(Image image, ROI roi, EdgeProcess processType, EdgeOptions2 edgeOptions)
 * JN: long imaqEdgeTool3(long image, long roi, int processType, long edgeOptions)
 * C: EdgeReport2* imaqEdgeTool3(const Image* image, const ROI* roi, EdgeProcess processType, const EdgeOptions2* edgeOptions)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqEdgeTool3(JNIEnv* env, jclass , jlong image, jlong roi, jint processType, jlong edgeOptions)
{
    EdgeReport2* rv = imaqEdgeTool3((const Image*)image, (const ROI*)roi, (EdgeProcess)processType, (const EdgeOptions2*)edgeOptions);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: ConcentricRakeReport imaqConcentricRake(Image image, ROI roi, ConcentricRakeDirection direction, EdgeProcess process, RakeOptions options)
 * JN: long imaqConcentricRake(long image, long roi, int direction, int process, long options)
 * C: ConcentricRakeReport* imaqConcentricRake(const Image* image, const ROI* roi, ConcentricRakeDirection direction, EdgeProcess process, const RakeOptions* options)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqConcentricRake(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jlong options)
{
    ConcentricRakeReport* rv = imaqConcentricRake((const Image*)image, (const ROI*)roi, (ConcentricRakeDirection)direction, (EdgeProcess)process, (const RakeOptions*)options);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: SpokeReport imaqSpoke(Image image, ROI roi, SpokeDirection direction, EdgeProcess process, SpokeOptions options)
 * JN: long imaqSpoke(long image, long roi, int direction, int process, long options)
 * C: SpokeReport* imaqSpoke(const Image* image, const ROI* roi, SpokeDirection direction, EdgeProcess process, const SpokeOptions* options)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqSpoke(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jlong options)
{
    SpokeReport* rv = imaqSpoke((const Image*)image, (const ROI*)roi, (SpokeDirection)direction, (EdgeProcess)process, (const SpokeOptions*)options);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: MatchPattern2Result imaqMatchPattern2(Image image, Image pattern, MatchPatternOptions options, MatchPatternAdvancedOptions advancedOptions, Rect searchRect)
 * JN: long imaqMatchPattern2(long image, long pattern, long options, long advancedOptions, long searchRect, long numMatches)
 * C: PatternMatch* imaqMatchPattern2(const Image* image, const Image* pattern, const MatchPatternOptions* options, const MatchPatternAdvancedOptions* advancedOptions, Rect searchRect, int* numMatches)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchPattern2(JNIEnv* env, jclass , jlong image, jlong pattern, jlong options, jlong advancedOptions, jlong searchRect, jlong numMatches)
{
    PatternMatch* rv = imaqMatchPattern2((const Image*)image, (const Image*)pattern, (const MatchPatternOptions*)options, (const MatchPatternAdvancedOptions*)advancedOptions, *((Rect*)searchRect), (int*)numMatches);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void imaqSetParticleClassifierOptions(ClassifierSession session, ParticleClassifierPreprocessingOptions preprocessingOptions, ParticleClassifierOptions options)
 * JN: void imaqSetParticleClassifierOptions(long session, long preprocessingOptions, long options)
 * C: int imaqSetParticleClassifierOptions(ClassifierSession* session, const ParticleClassifierPreprocessingOptions* preprocessingOptions, const ParticleClassifierOptions* options)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetParticleClassifierOptions(JNIEnv* env, jclass , jlong session, jlong preprocessingOptions, jlong options)
{
    int rv = imaqSetParticleClassifierOptions((ClassifierSession*)session, (const ParticleClassifierPreprocessingOptions*)preprocessingOptions, (const ParticleClassifierOptions*)options);
    if (rv == 0) throwJavaException(env);
}

/* J: RakeReport imaqRake(Image image, ROI roi, RakeDirection direction, EdgeProcess process, RakeOptions options)
 * JN: long imaqRake(long image, long roi, int direction, int process, long options)
 * C: RakeReport* imaqRake(const Image* image, const ROI* roi, RakeDirection direction, EdgeProcess process, const RakeOptions* options)
 */

JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqRake(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jlong options)
{
    RakeReport* rv = imaqRake((const Image*)image, (const ROI*)roi, (RakeDirection)direction, (EdgeProcess)process, (const RakeOptions*)options);
    if (!rv) throwJavaException(env);
    return (jlong)rv;
}

/* J: void Priv_ReadJPEGString_C(Image image, byte[] string)
 * JN: void Priv_ReadJPEGString_C(long image, long string, int stringLength)
 * C: int Priv_ReadJPEGString_C(Image* image, const unsigned char* string, unsigned int stringLength)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1Priv_1ReadJPEGString_1C(JNIEnv* env, jclass , jlong image, jlong string, jint stringLength)
{
    int rv = Priv_ReadJPEGString_C((Image*)image, (const unsigned char*)string, (unsigned int)stringLength);
    if (rv == 0) throwJavaException(env);
}

/*
 * Purpose	  : Include file for NI-IMAQdx library support.
 */

/*
 * Bus Type Enumeration
 */

/*
 * Camera Control Mode Enumeration
 */

/*
 * Buffer Number Mode Enumeration
 */

/*
 * Plug n Play Event Enumeration
 */

/*
 * Bayer Pattern Enumeration
 */

/*
 * Bayer Decode Algorithm Enumeration
 */

/*
 * Output Image Types -- Values match Vision Development Module image types
 */

/*
 * Controller Destination Mode Enumeration
 */

/*
 * Attribute Type Enumeration
 */

/*
 * Value Type Enumeration
 */

/*
 * Interface File Flags Enumeration
 */

/*
 * Overwrite Mode Enumeration
 */

/*
 * Incomplete Buffer Mode Enumeration
 */

/*
 * Lost Packet Mode Enumeration
 */

/*
 * Attribute Visibility Enumeration
 */

/*
 * Stream Channel Mode Enumeration
 */

/*
 * Pixel Signedness Enumeration
 */

/*
 * USB Connection Speed Enumeration
 */

/*
 * CVI Structures
 */

/*
 * Camera Information Structure
 */

/*
 * Camera File Structure
 */

/*
 * Attribute Information Structure
 */

/*
 * Enumeration Item Structure
 */

/*
 * Camera Information Structure
 */

/*
 * Attributes
 */

/*
 * Functions
 */

/* J: void IMAQdxSnap(int id, Image image)
 * JN: void IMAQdxSnap(int id, long image)
 * C: IMAQdxError IMAQdxSnap(IMAQdxSession id, Image* image)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxSnap(JNIEnv* env, jclass , jint id, jlong image)
{
    IMAQdxError rv = IMAQdxSnap((IMAQdxSession)id, (Image*)image);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxConfigureGrab(int id)
 * JN: void IMAQdxConfigureGrab(int id)
 * C: IMAQdxError IMAQdxConfigureGrab(IMAQdxSession id)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxConfigureGrab(JNIEnv* env, jclass , jint id)
{
    IMAQdxError rv = IMAQdxConfigureGrab((IMAQdxSession)id);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGrab(int id, Image image, int waitForNextBuffer)
 * JN: void IMAQdxGrab(int id, long image, int waitForNextBuffer, long actualBufferNumber)
 * C: IMAQdxError IMAQdxGrab(IMAQdxSession id, Image* image, bool32 waitForNextBuffer, uInt32* actualBufferNumber)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGrab(JNIEnv* env, jclass , jint id, jlong image, jint waitForNextBuffer, jlong actualBufferNumber)
{
    IMAQdxError rv = IMAQdxGrab((IMAQdxSession)id, (Image*)image, (bool32)waitForNextBuffer, (uInt32*)actualBufferNumber);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxDiscoverEthernetCameras(String address, int timeout)
 * JN: void IMAQdxDiscoverEthernetCameras(long address, int timeout)
 * C: IMAQdxError IMAQdxDiscoverEthernetCameras(const char* address, uInt32 timeout)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxDiscoverEthernetCameras(JNIEnv* env, jclass , jlong address, jint timeout)
{
    IMAQdxError rv = IMAQdxDiscoverEthernetCameras((const char*)address, (uInt32)timeout);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxResetCamera(String name, int resetAll)
 * JN: void IMAQdxResetCamera(long name, int resetAll)
 * C: IMAQdxError IMAQdxResetCamera(const char* name, bool32 resetAll)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxResetCamera(JNIEnv* env, jclass , jlong name, jint resetAll)
{
    IMAQdxError rv = IMAQdxResetCamera((const char*)name, (bool32)resetAll);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxOpenCamera(String name, IMAQdxCameraControlMode mode)
 * JN: void IMAQdxOpenCamera(long name, int mode, long id)
 * C: IMAQdxError IMAQdxOpenCamera(const char* name, IMAQdxCameraControlMode mode, IMAQdxSession* id)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxOpenCamera(JNIEnv* env, jclass , jlong name, jint mode, jlong id)
{
    IMAQdxError rv = IMAQdxOpenCamera((const char*)name, (IMAQdxCameraControlMode)mode, (IMAQdxSession*)id);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxCloseCamera(int id)
 * JN: void IMAQdxCloseCamera(int id)
 * C: IMAQdxError IMAQdxCloseCamera(IMAQdxSession id)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxCloseCamera(JNIEnv* env, jclass , jint id)
{
    IMAQdxError rv = IMAQdxCloseCamera((IMAQdxSession)id);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxConfigureAcquisition(int id, int continuous, int bufferCount)
 * JN: void IMAQdxConfigureAcquisition(int id, int continuous, int bufferCount)
 * C: IMAQdxError IMAQdxConfigureAcquisition(IMAQdxSession id, bool32 continuous, uInt32 bufferCount)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxConfigureAcquisition(JNIEnv* env, jclass , jint id, jint continuous, jint bufferCount)
{
    IMAQdxError rv = IMAQdxConfigureAcquisition((IMAQdxSession)id, (bool32)continuous, (uInt32)bufferCount);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxStartAcquisition(int id)
 * JN: void IMAQdxStartAcquisition(int id)
 * C: IMAQdxError IMAQdxStartAcquisition(IMAQdxSession id)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxStartAcquisition(JNIEnv* env, jclass , jint id)
{
    IMAQdxError rv = IMAQdxStartAcquisition((IMAQdxSession)id);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetImage(int id, Image image, IMAQdxBufferNumberMode mode, int desiredBufferNumber)
 * JN: void IMAQdxGetImage(int id, long image, int mode, int desiredBufferNumber, long actualBufferNumber)
 * C: IMAQdxError IMAQdxGetImage(IMAQdxSession id, Image* image, IMAQdxBufferNumberMode mode, uInt32 desiredBufferNumber, uInt32* actualBufferNumber)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetImage(JNIEnv* env, jclass , jint id, jlong image, jint mode, jint desiredBufferNumber, jlong actualBufferNumber)
{
    IMAQdxError rv = IMAQdxGetImage((IMAQdxSession)id, (Image*)image, (IMAQdxBufferNumberMode)mode, (uInt32)desiredBufferNumber, (uInt32*)actualBufferNumber);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetImageData(JNIEnv* env, jclass , jint id, jlong buffer, jint bufferSize, jint mode, jint desiredBufferNumber)
{
    uInt32 actualBufferNumber;
    IMAQdxError rv = IMAQdxGetImageData((IMAQdxSession)id, (void*)buffer, (uInt32)bufferSize, (IMAQdxBufferNumberMode)mode, (uInt32)desiredBufferNumber, &actualBufferNumber);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
    return (jint)actualBufferNumber;
}

/* J: void IMAQdxStopAcquisition(int id)
 * JN: void IMAQdxStopAcquisition(int id)
 * C: IMAQdxError IMAQdxStopAcquisition(IMAQdxSession id)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxStopAcquisition(JNIEnv* env, jclass , jint id)
{
    IMAQdxError rv = IMAQdxStopAcquisition((IMAQdxSession)id);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxUnconfigureAcquisition(int id)
 * JN: void IMAQdxUnconfigureAcquisition(int id)
 * C: IMAQdxError IMAQdxUnconfigureAcquisition(IMAQdxSession id)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxUnconfigureAcquisition(JNIEnv* env, jclass , jint id)
{
    IMAQdxError rv = IMAQdxUnconfigureAcquisition((IMAQdxSession)id);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxEnumerateVideoModes(JNIEnv* env, jclass , jint id, jlong videoModeArray, jlong count, jlong currentMode)
{
    IMAQdxError rv = IMAQdxEnumerateVideoModes((IMAQdxSession)id, (IMAQdxVideoMode*)videoModeArray, (uInt32*)count, (uInt32*)currentMode);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeType(int id, String name)
 * JN: void IMAQdxGetAttributeType(int id, long name, long type)
 * C: IMAQdxError IMAQdxGetAttributeType(IMAQdxSession id, const char* name, IMAQdxAttributeType* type)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeType(JNIEnv* env, jclass , jint id, jlong name, jlong type)
{
    IMAQdxError rv = IMAQdxGetAttributeType((IMAQdxSession)id, (const char*)name, (IMAQdxAttributeType*)type);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxIsAttributeReadable(int id, String name)
 * JN: void IMAQdxIsAttributeReadable(int id, long name, long readable)
 * C: IMAQdxError IMAQdxIsAttributeReadable(IMAQdxSession id, const char* name, bool32* readable)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxIsAttributeReadable(JNIEnv* env, jclass , jint id, jlong name, jlong readable)
{
    IMAQdxError rv = IMAQdxIsAttributeReadable((IMAQdxSession)id, (const char*)name, (bool32*)readable);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxIsAttributeWritable(int id, String name)
 * JN: void IMAQdxIsAttributeWritable(int id, long name, long writable)
 * C: IMAQdxError IMAQdxIsAttributeWritable(IMAQdxSession id, const char* name, bool32* writable)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxIsAttributeWritable(JNIEnv* env, jclass , jint id, jlong name, jlong writable)
{
    IMAQdxError rv = IMAQdxIsAttributeWritable((IMAQdxSession)id, (const char*)name, (bool32*)writable);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxWriteRegister(int id, int offset, int value)
 * JN: void IMAQdxWriteRegister(int id, int offset, int value)
 * C: IMAQdxError IMAQdxWriteRegister(IMAQdxSession id, uInt32 offset, uInt32 value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxWriteRegister(JNIEnv* env, jclass , jint id, jint offset, jint value)
{
    IMAQdxError rv = IMAQdxWriteRegister((IMAQdxSession)id, (uInt32)offset, (uInt32)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxReadRegister(int id, int offset)
 * JN: void IMAQdxReadRegister(int id, int offset, long value)
 * C: IMAQdxError IMAQdxReadRegister(IMAQdxSession id, uInt32 offset, uInt32* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxReadRegister(JNIEnv* env, jclass , jint id, jint offset, jlong value)
{
    IMAQdxError rv = IMAQdxReadRegister((IMAQdxSession)id, (uInt32)offset, (uInt32*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxWriteAttributes(int id, String filename)
 * JN: void IMAQdxWriteAttributes(int id, long filename)
 * C: IMAQdxError IMAQdxWriteAttributes(IMAQdxSession id, const char* filename)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxWriteAttributes(JNIEnv* env, jclass , jint id, jlong filename)
{
    IMAQdxError rv = IMAQdxWriteAttributes((IMAQdxSession)id, (const char*)filename);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxReadAttributes(int id, String filename)
 * JN: void IMAQdxReadAttributes(int id, long filename)
 * C: IMAQdxError IMAQdxReadAttributes(IMAQdxSession id, const char* filename)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxReadAttributes(JNIEnv* env, jclass , jint id, jlong filename)
{
    IMAQdxError rv = IMAQdxReadAttributes((IMAQdxSession)id, (const char*)filename);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxResetEthernetCameraAddress(String name, String address, String subnet, String gateway, int timeout)
 * JN: void IMAQdxResetEthernetCameraAddress(long name, long address, long subnet, long gateway, int timeout)
 * C: IMAQdxError IMAQdxResetEthernetCameraAddress(const char* name, const char* address, const char* subnet, const char* gateway, uInt32 timeout)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxResetEthernetCameraAddress(JNIEnv* env, jclass , jlong name, jlong address, jlong subnet, jlong gateway, jint timeout)
{
    IMAQdxError rv = IMAQdxResetEthernetCameraAddress((const char*)name, (const char*)address, (const char*)subnet, (const char*)gateway, (uInt32)timeout);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeVisibility(int id, String name)
 * JN: void IMAQdxGetAttributeVisibility(int id, long name, long visibility)
 * C: IMAQdxError IMAQdxGetAttributeVisibility(IMAQdxSession id, const char* name, IMAQdxAttributeVisibility* visibility)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeVisibility(JNIEnv* env, jclass , jint id, jlong name, jlong visibility)
{
    IMAQdxError rv = IMAQdxGetAttributeVisibility((IMAQdxSession)id, (const char*)name, (IMAQdxAttributeVisibility*)visibility);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeU32(int id, String name)
 * JN: void IMAQdxGetAttributeU32(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeU32(IMAQdxSession id, const char* name, uInt32* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeU32(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeU32((IMAQdxSession)id, (const char*)name, (uInt32*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeI64(int id, String name)
 * JN: void IMAQdxGetAttributeI64(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeI64(IMAQdxSession id, const char* name, Int64* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeI64(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeI64((IMAQdxSession)id, (const char*)name, (Int64*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeF64(int id, String name)
 * JN: void IMAQdxGetAttributeF64(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeF64(IMAQdxSession id, const char* name, float64* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeF64(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeF64((IMAQdxSession)id, (const char*)name, (float64*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeString(int id, String name)
 * JN: void IMAQdxGetAttributeString(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeString(IMAQdxSession id, const char* name, char value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeString(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeString((IMAQdxSession)id, (const char*)name, (char*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeEnum(int id, String name)
 * JN: void IMAQdxGetAttributeEnum(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeEnum(IMAQdxSession id, const char* name, IMAQdxEnumItem* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeEnum(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeEnum((IMAQdxSession)id, (const char*)name, (IMAQdxEnumItem*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeBool(int id, String name)
 * JN: void IMAQdxGetAttributeBool(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeBool(IMAQdxSession id, const char* name, bool32* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeBool(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeBool((IMAQdxSession)id, (const char*)name, (bool32*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeMinimumU32(int id, String name)
 * JN: void IMAQdxGetAttributeMinimumU32(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeMinimumU32(IMAQdxSession id, const char* name, uInt32* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeMinimumU32(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeMinimumU32((IMAQdxSession)id, (const char*)name, (uInt32*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeMinimumI64(int id, String name)
 * JN: void IMAQdxGetAttributeMinimumI64(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeMinimumI64(IMAQdxSession id, const char* name, Int64* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeMinimumI64(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeMinimumI64((IMAQdxSession)id, (const char*)name, (Int64*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeMinimumF64(int id, String name)
 * JN: void IMAQdxGetAttributeMinimumF64(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeMinimumF64(IMAQdxSession id, const char* name, float64* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeMinimumF64(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeMinimumF64((IMAQdxSession)id, (const char*)name, (float64*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeMaximumU32(int id, String name)
 * JN: void IMAQdxGetAttributeMaximumU32(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeMaximumU32(IMAQdxSession id, const char* name, uInt32* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeMaximumU32(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeMaximumU32((IMAQdxSession)id, (const char*)name, (uInt32*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeMaximumI64(int id, String name)
 * JN: void IMAQdxGetAttributeMaximumI64(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeMaximumI64(IMAQdxSession id, const char* name, Int64* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeMaximumI64(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeMaximumI64((IMAQdxSession)id, (const char*)name, (Int64*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeMaximumF64(int id, String name)
 * JN: void IMAQdxGetAttributeMaximumF64(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeMaximumF64(IMAQdxSession id, const char* name, float64* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeMaximumF64(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeMaximumF64((IMAQdxSession)id, (const char*)name, (float64*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeIncrementU32(int id, String name)
 * JN: void IMAQdxGetAttributeIncrementU32(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeIncrementU32(IMAQdxSession id, const char* name, uInt32* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeIncrementU32(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeIncrementU32((IMAQdxSession)id, (const char*)name, (uInt32*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeIncrementI64(int id, String name)
 * JN: void IMAQdxGetAttributeIncrementI64(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeIncrementI64(IMAQdxSession id, const char* name, Int64* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeIncrementI64(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeIncrementI64((IMAQdxSession)id, (const char*)name, (Int64*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxGetAttributeIncrementF64(int id, String name)
 * JN: void IMAQdxGetAttributeIncrementF64(int id, long name, long value)
 * C: IMAQdxError IMAQdxGetAttributeIncrementF64(IMAQdxSession id, const char* name, float64* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeIncrementF64(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxGetAttributeIncrementF64((IMAQdxSession)id, (const char*)name, (float64*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxSetAttributeU32(int id, String name, int value)
 * JN: void IMAQdxSetAttributeU32(int id, long name, int value)
 * C: IMAQdxError IMAQdxSetAttributeU32(IMAQdxSession id, const char* name, uInt32 value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxSetAttributeU32(JNIEnv* env, jclass , jint id, jlong name, jint value)
{
    IMAQdxError rv = IMAQdxSetAttributeU32((IMAQdxSession)id, (const char*)name, (uInt32)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxSetAttributeI64(int id, String name, long value)
 * JN: void IMAQdxSetAttributeI64(int id, long name, long value)
 * C: IMAQdxError IMAQdxSetAttributeI64(IMAQdxSession id, const char* name, Int64 value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxSetAttributeI64(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxSetAttributeI64((IMAQdxSession)id, (const char*)name, (Int64)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxSetAttributeF64(int id, String name, double value)
 * JN: void IMAQdxSetAttributeF64(int id, long name, double value)
 * C: IMAQdxError IMAQdxSetAttributeF64(IMAQdxSession id, const char* name, float64 value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxSetAttributeF64(JNIEnv* env, jclass , jint id, jlong name, jdouble value)
{
    IMAQdxError rv = IMAQdxSetAttributeF64((IMAQdxSession)id, (const char*)name, (float64)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxSetAttributeString(int id, String name, String value)
 * JN: void IMAQdxSetAttributeString(int id, long name, long value)
 * C: IMAQdxError IMAQdxSetAttributeString(IMAQdxSession id, const char* name, const char* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxSetAttributeString(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxSetAttributeString((IMAQdxSession)id, (const char*)name, (const char*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxSetAttributeEnum(int id, String name, IMAQdxEnumItem value)
 * JN: void IMAQdxSetAttributeEnum(int id, long name, long value)
 * C: IMAQdxError IMAQdxSetAttributeEnum(IMAQdxSession id, const char* name, const IMAQdxEnumItem* value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxSetAttributeEnum(JNIEnv* env, jclass , jint id, jlong name, jlong value)
{
    IMAQdxError rv = IMAQdxSetAttributeEnum((IMAQdxSession)id, (const char*)name, (const IMAQdxEnumItem*)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}

/* J: void IMAQdxSetAttributeBool(int id, String name, int value)
 * JN: void IMAQdxSetAttributeBool(int id, long name, int value)
 * C: IMAQdxError IMAQdxSetAttributeBool(IMAQdxSession id, const char* name, bool32 value)
 */

JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxSetAttributeBool(JNIEnv* env, jclass , jint id, jlong name, jint value)
{
    IMAQdxError rv = IMAQdxSetAttributeBool((IMAQdxSession)id, (const char*)name, (bool32)value);
    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
}
}

static const char* getErrorText(int err) {
    switch (err) {
        case ERR_3DVISION_INVALID_SESSION_TYPE: return "This 3D vision function cannot be called on this type of 3d vision session.";
        case ERR_ARRAY_SIZE_MISMATCH: return "The array sizes are not compatible.";
        case ERR_AVI_DATA_EXCEEDS_BUFFER_SIZE: return "The data for this frame exceeds the data buffer size specified when creating the AVI file.";
        case ERR_AVI_READ_SESSION_REQUIRED: return "The AVI session is a write session, but this operation requires a read session.";
        case ERR_AVI_SESSION_ALREADY_OPEN: return "This AVI session is already open. You must close it before calling the Create or Open functions.";
        case ERR_AVI_TIMEOUT: return "DirectX has timed out reading or writing the AVI file.  When closing an AVI file, try adding an additional delay.  When reading an AVI file, try reducing CPU and disk load.";
        case ERR_AVI_UNOPENED_SESSION: return "The AVI session has not been opened.";
        case ERR_AVI_VERSION: return "The AVI file was created in a newer version of NI Vision. Upgrade to the latest version of NI Vision to read this AVI file.";
        case ERR_AVI_WRITE_SESSION_REQUIRED: return "The AVI session is a read session, but this operation requires a write session.";
        case ERR_BAD_FILTER_WIDTH: return "The filter width must be odd for the Canny operator.";
        case ERR_BAD_INDEX: return "Invalid handle table index.";
        case ERR_BAD_MEASURE: return "Invalid measure number.";
        case ERR_BAD_PASSWORD: return "Incorrect password.";
        case ERR_BAD_ROI: return "Invalid ROI.";
        case ERR_BAD_ROI_BOX: return "Invalid ROI global rectangle.";
        case ERR_BAD_SAMPLE_INDEX: return "The Sample Index fell outside the range of Samples.";
        case ERR_BARCODE: return "The barcode does not match the type you specified.";
        case ERR_BARCODE_CHECKSUM: return "The decoded barcode information did not pass the checksum test.";
        case ERR_BARCODE_CODABAR: return "The barcode is not a valid Codabar barcode.";
        case ERR_BARCODE_CODE128: return "The barcode is not a valid Code128 barcode.";
        case ERR_BARCODE_CODE128_FNC: return "The FNC value in the Code128 barcode is not located before the first data value.";
        case ERR_BARCODE_CODE128_SET: return "The starting code set in the Code128 barcode is not valid.";
        case ERR_BARCODE_CODE39: return "The barcode is not a valid Code 3 of 9 barcode.";
        case ERR_BARCODE_CODE93: return "The barcode is not a valid Code93 barcode.";
        case ERR_BARCODE_CODE93_SHIFT: return "The Code93 barcode contains invalid shift encoding.";
        case ERR_BARCODE_EAN13: return "The barcode is not a valid EAN13 barcode.";
        case ERR_BARCODE_EAN8: return "The barcode is not a valid EAN8 barcode.";
        case ERR_BARCODE_I25: return "The barcode is not a valid Interleaved 2 of 5 barcode.";
        case ERR_BARCODE_INVALID: return "The image does not represent a valid linear barcode.";
        case ERR_BARCODE_MSI: return "The barcode is not a valid MSI barcode.";
        case ERR_BARCODE_PHARMACODE: return "The barcode is not a valid Pharmacode symbol";
        case ERR_BARCODE_RSSLIMITED: return "The barcode is not a valid RSS Limited symbol";
        case ERR_BARCODE_TYPE: return "The barcode type is invalid.";
        case ERR_BARCODE_UPCA: return "The barcode is not a valid UPCA barcode.";
        case ERR_BOARD_NOT_FOUND: return "Board not found.";
        case ERR_BOARD_NOT_OPEN: return "Board not opened.";
        case ERR_BOTH_MARKER_INPUTS_SUPPLIED: return "Both Marker Image and Points are supplied.";
        case ERR_CALIBRATION_DUPLICATE_REFERENCE_POINT: return "The reference points passed are inconsistent.  At least two similar pixel coordinates correspond to different real-world coordinates.";
        case ERR_CALIBRATION_ERRORMAP: return "The calibration error map cannot be computed.";
        case ERR_CALIBRATION_FAILED_TO_FIND_GRID: return "Unable to automatically detect grid because the image is too distorted.";
        case ERR_CALIBRATION_IMAGE_CORRECTED: return "The operation is invalid in a corrected image.";
        case ERR_CALIBRATION_IMAGE_UNCALIBRATED: return "The source/input image has not been calibrated.";
        case ERR_CALIBRATION_INFO_1: return "Invalid calibration template image.";
        case ERR_CALIBRATION_INFO_2: return "Invalid calibration template image.";
        case ERR_CALIBRATION_INFO_3: return "Invalid calibration template image.";
        case ERR_CALIBRATION_INFO_4: return "Invalid calibration template image.";
        case ERR_CALIBRATION_INFO_5: return "Invalid calibration template image.";
        case ERR_CALIBRATION_INFO_6: return "Invalid calibration template image.";
        case ERR_CALIBRATION_INFO_MICRO_PLANE: return "Invalid calibration template image.";
        case ERR_CALIBRATION_INFO_PERSPECTIVE_PROJECTION: return "Invalid calibration template image.";
        case ERR_CALIBRATION_INFO_SIMPLE_TRANSFORM: return "Invalid calibration template image.";
        case ERR_CALIBRATION_INFO_VERSION: return "Invalid calibration information version.";
        case ERR_CALIBRATION_INSF_POINTS: return "Insufficient number of calibration feature points.";
        case ERR_CALIBRATION_INVALID_ROI: return "The ROI contains an invalid contour type or is not contained in the ROI learned for calibration.";
        case ERR_CALIBRATION_INVALID_SCALING_FACTOR: return "Invalid calibration scaling factor.";
        case ERR_CAMERA_MODEL_NOT_AVAILABLE: return "Camera Model is not learned";
        case ERR_CANNOT_COMPACT_UNTRAINED: return "You may only save a session in compact form if it is trained.";
        case ERR_CANT_DRAW_INTO_VIEWER: return "Unable to draw to viewer. You must have the latest version of the control.";
        case ERR_CANT_RESIZE_EXTERNAL: return "Cannot resize an image in an acquisition buffer.";
        case ERR_CLASSIFIER_CLASSIFY_IMAGE_WITH_CUSTOM_SESSION: return "Custom classifier sessions only classify feature vectors. They do not support classifying images.";
        case ERR_CLASSIFIER_INVALID_ENGINE_TYPE: return "The engine for this classifier session does not support this operation.";
        case ERR_CLASSIFIER_INVALID_SESSION_TYPE: return "This classifier function cannot be called on this type of classifier session.";
        case ERR_CLASSIFIER_SESSION_NOT_TRAINED: return "This classifier session is not trained. You may only call this function on a trained classifier session.";
        case ERR_CLASS_NAME_NOT_FOUND: return "Required Class name is not found in trained labels/Class names";
        case ERR_COLORMODE_REQUIRES_CHANGECOLORSPACE2: return "The specified color mode requires the use of imaqChangeColorSpace2.";
        case ERR_COLOR_IMAGE_REQUIRED: return "The input image must be a color image.";
        case ERR_COLOR_LEARN_SETUP_DATA: return "Invalid color learn setup data.";
        case ERR_COLOR_LEARN_SETUP_DATA_SHAPE: return "Invalid color learn setup data.";
        case ERR_COLOR_MATCH_SETUP_DATA: return "Invalid color match setup data.";
        case ERR_COLOR_MATCH_SETUP_DATA_SHAPE: return "Invalid color match setup data.";
        case ERR_COLOR_ROTATION_REQUIRES_SHAPE_FEATURE: return "Rotation-invariant color pattern matching requires a feature mode including shape.";
        case ERR_COLOR_SPECTRUM_MASK: return "The color mask removes too much color information.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_1: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_2: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_3: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_4: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_5: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_6: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_NOROTATION: return "The color template image does not contain data required for rotation-invariant color matching.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_NOSHAPE: return "The color template image does not contain data required for color matching in shape feature mode.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_NOSHIFT: return "The color template image does not contain data required for shift-invariant color matching.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_NOSPECTRUM: return "The color template image does not contain data required for color matching in color feature mode.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_ROTATION: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_ROTATION_1: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_ROTATION_2: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_ROTATION_3: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_ROTATION_4: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_ROTATION_5: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_SHIFT: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_SHIFT_1: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_DESCRIPTOR_SHIFT_2: return "Invalid color template image.";
        case ERR_COLOR_TEMPLATE_IMAGE_HUE_CONTRAST_TOO_LOW: return "The contrast in the hue plane of the image is too low for learning shape features.";
        case ERR_COLOR_TEMPLATE_IMAGE_LUMINANCE_CONTRAST_TOO_LOW: return "The contrast in the luminance plane of the image is too low to learn shape features.";
        case ERR_COLOR_TEMPLATE_IMAGE_TOO_LARGE: return "The color template image is too large.";
        case ERR_COLOR_TEMPLATE_IMAGE_TOO_SMALL: return "The color template image is too small.";
        case ERR_COMPLEXPLANE_NOT_REAL_OR_IMAGINARY: return "You can perform this operation on a real or an imaginary ComplexPlane only.";
        case ERR_COMPLEX_IMAGE_REQUIRED: return "A complex image is required.";
        case ERR_COMPLEX_PLANE: return "Invalid complex plane.";
        case ERR_COMPLEX_ROOT: return "The roots of the equation are complex.";
        case ERR_COM_INITIALIZE: return "Error initializing COM.";
        case ERR_CONTAINER_CAPACITY_EXCEEDED_INT_MAX: return "The operation would have exceeded the capacity of an internal container, which is limited to 2147483648 unique elements.";
        case ERR_CONTAINER_CAPACITY_EXCEEDED_UINT_MAX: return "The operation would have exceeded the capacity of an internal container, which is limited to 4294967296 unique elements.";
        case ERR_CONTOURID_NOT_FOUND: return "The supplied ContourID did not correlate to a contour inside the ROI.";
        case ERR_CONTOUR_COMPARE_KERNEL: return "Invalid Smoothing Kernel width for contour comparison. Must be zero or an odd positive integer.";
        case ERR_CONTOUR_COMPARE_SINGLE_IMAGE: return "If no template image is provided, the target image must contain both a contour with extracted points and a fitted equation.";
        case ERR_CONTOUR_CONNECT_DUPLICATE: return "Only one range is allowed per curve connection constraint type.";
        case ERR_CONTOUR_CONNECT_TYPE: return "Invalid contour connection constraint type.";
        case ERR_CONTOUR_CURVATURE_KERNEL: return "Invalid kernel width for curvature calculation. Must be an odd value greater than 1.";
        case ERR_CONTOUR_EXTRACT_DIRECTION: return "Invalid Search Direction for contour extraction.";
        case ERR_CONTOUR_EXTRACT_ROI: return "Invalid ROI for contour extraction. The ROI must contain an annulus, rectangle or rotated rectangle.";
        case ERR_CONTOUR_EXTRACT_SELECTION: return "Invalid Contour Selection method for contour extraction.";
        case ERR_CONTOUR_GPM_FAIL: return "Matching failed to align the template and target contours.";
        case ERR_CONTOUR_INDEX_OUT_OF_RANGE: return "The contour index you supplied is larger than the number of contours in the ROI.";
        case ERR_CONTOUR_INVALID: return "Invalid contour image.";
        case ERR_CONTOUR_INVALID_KERNEL_FOR_SMOOTHING: return "Invalid kernel for contour smoothing. Zero indicates no smoothing, otherwise value must be odd.";
        case ERR_CONTOUR_INVALID_REFINEMENTS: return "Invalid number specified for maximum contour refinements.";
        case ERR_CONTOUR_LINE_INVALID: return "The contour line fit is invalid. Line segment start and stop must differ.";
        case ERR_CONTOUR_MATCH_STR_NOT_APPLICABLE: return "In order to use contour matching, you must provide a template image that has been trained with IMAQ Learn Contour Pattern";
        case ERR_CONTOUR_NO_CURVES: return "No curves were found in the image.";
        case ERR_CONTOUR_OPENING_NEWER_VERSION: return "The contour you tried to open was created with a newer version of NI Vision. Upgrade to the latest version of NI Vision to read this file.";
        case ERR_CONTOUR_TEMPLATE_IMAGE_INVALID: return "The template image must be trained with IMAQ Learn Contour Pattern or be the same size as the target image.";
        case ERR_COORDSYS_NOT_FOUND: return "The coordinate system could not be found on this image.";
        case ERR_COORD_SYS_FIRST_AXIS: return "Unable to fit a line for the primary axis.";
        case ERR_COORD_SYS_SECOND_AXIS: return "Unable to fit a line for the secondary axis.";
        case ERR_COST_LABEL_NOT_FOUND: return "Label name is not found in added samples";
        case ERR_CREATE_WINDOW: return "Unable to create window.";
        case ERR_CURVE_EXTRACTION_MODE_MUST_BE_SAME: return "You must specify the same curve extraction mode for all the templates you want to match.";
        case ERR_CUSTOMDATA_INVALID_KEY: return "They custom data key you supplied is invalid. The only valid character values are decimal 32-126 and 161-255. There must also be no repeated, leading, or trailing spaces.";
        case ERR_CUSTOMDATA_INVALID_SIZE: return "The size you specified is out of the valid range.";
        case ERR_CUSTOMDATA_KEY_NOT_FOUND: return "The key you specified cannot be found in the image.";
        case ERR_DATA_CORRUPTED: return "The data is corrupted and cannot be read.";
        case ERR_DATA_VERSION: return "The data was stored with a newer version of NI Vision. Upgrade to the latest version of NI Vision to read this data.";
        case ERR_DEPRECATED_FUNCTION: return "This backwards-compatibility function can not be used with this session. Use newer, supported functions instead.";
        case ERR_DESCRIPTION_TOO_LONG: return "The description must be <= 255 characters.";
        case ERR_DIRECTX: return "An internal DirectX error has occurred.  Try upgrading to the latest version of DirectX.";
        case ERR_DIRECTX_CERTIFICATION_FAILURE: return "A software key is restricting the use of this compression filter.";
        case ERR_DIRECTX_DLL_NOT_FOUND: return "Quartz.dll not found.  Install DirectX 8.1 or later.";
        case ERR_DIRECTX_ENUMERATE_FILTERS: return "DirectX is unable to enumerate the compression filters. This is caused by a third-party compression filter that is either improperly installed or is preventing itself from being enumerated. Remove any recently installed compression filters and try again.";
        case ERR_DIRECTX_INCOMPATIBLE_COMPRESSION_FILTER: return "Incompatible compression filter.";
        case ERR_DIRECTX_INVALID_FILTER_QUALITY: return "The filter quality you provided is invalid. Valid quality values range from -1 to 1000.";
        case ERR_DIRECTX_NOT_FOUND: return "DirectX is required for this feature.  Please install the latest version..";
        case ERR_DIRECTX_NO_FILTER: return "An appropriate DirectX filter to process this file could not be found.  Install the filter that was used to create this AVI. Upgrading to the latest version of DirectX may correct this error.  NI Vision requires DirectX 8.1 or higher.";
        case ERR_DIRECTX_UNKNOWN_COMPRESSION_FILTER: return "Unknown compression filter.";
        case ERR_DISPATCH_STATUS_CONFLICT: return "You are attempting to set the same algorithm to dispatch and to not dispatch. Remove one of the conflicting settings.";
        case ERR_DIV_BY_ZERO: return "Cannot divide by zero.";
        case ERR_DLL_FUNCTION_NOT_FOUND: return "DLL function not found.";
        case ERR_DLL_NOT_FOUND: return "DLL not found.";
        case ERR_DRAWTEXT_COLOR_MUST_BE_GRAYSCALE: return "Set the foreground and background text colors to grayscale to draw on a U8 image.";
        case ERR_DRIVER: return "Cannot access NI-IMAQ driver.";
        case ERR_DUPLICATE_LABEL: return "Duplicate labels are not allowed.";
        case ERR_DUPLICATE_TRANSFORM_TYPE: return "Found a duplicate transform type in the properties array. Each properties array may only contain one behavior for each transform type.";
        case ERR_EDGE_FILTER_SIZE_MUST_BE_SAME: return "You must specify the same edge filter size for all the templates you want to match.";
        case ERR_ENABLE_CALIBRATION_SUPPORT_MUST_BE_SAME: return "You must specify the same value for the enable calibration support advanced match option for all templates you want to match.";
        case ERR_EVEN_WINDOW_SIZE: return "The window size must be odd for the Canny operator.";
        case ERR_EXCEEDED_SVM_MAX_ITERATION: return "SVM training exceeded maximim Iteration limit";
        case ERR_EXTERNAL_ALIGNMENT: return "The external buffer must be aligned on a 4-byte boundary. The line width and border pixels must be 4-byte aligned, as well.";
        case ERR_EXTERNAL_NOT_SUPPORTED: return "This operation is not supported for images in an acquisition buffer.";
        case ERR_EXTRAINFO_VERSION: return "The image was created in a newer version of NI Vision. Upgrade to the latest version of NI Vision to use this image.";
        case ERR_FILE_ARGERR: return "Invalid parameter.";
        case ERR_FILE_COLOR_TABLE: return "Invalid color table.";
        case ERR_FILE_EOF: return "Premature end of file.";
        case ERR_FILE_FILENAME_NULL: return "You must pass a valid file name. Do not pass in NULL.";
        case ERR_FILE_FILE_HEADER: return "Invalid file header.";
        case ERR_FILE_FILE_TYPE: return "Invalid file type.";
        case ERR_FILE_FORMAT: return "Invalid file format.";
        case ERR_FILE_GET_INFO: return "Could not read Vision info from file.";
        case ERR_FILE_INVALID_DATA_TYPE: return "NI Vision does not support the file data type you specified.";
        case ERR_FILE_INVALID_TYPE: return "NI Vision does not support the file type you specified.";
        case ERR_FILE_IO_ERR: return "File I/O error.";
        case ERR_FILE_NOT_FOUND: return "File not found.";
        case ERR_FILE_NO_SPACE: return "Disk full.";
        case ERR_FILE_OPEN: return "File is already open for writing.";
        case ERR_FILE_OPERATION: return "Invalid file operation.";
        case ERR_FILE_PERMISSION: return "File access denied.";
        case ERR_FILE_READ: return "Unable to read data.";
        case ERR_FILE_TOO_MANY_OPEN: return "Too many files open.";
        case ERR_FILE_WRITE: return "Unable to write data.";
        case ERR_FIND_COORDSYS_MORE_THAN_ONE_EDGE: return "When searching for a coordinate system, the number of lines to fit must be 1.";
        case ERR_FONT_FILE_FORMAT: return "Invalid font file format.";
        case ERR_FONT_FILE_NOT_FOUND: return "Font file not found.";
        case ERR_GHT_INVALID_MAXIMUM_LEARN_ANGLE_VALUE: return "The maximum rotation angle value specifed during learning of the template is not supported.";
        case ERR_GHT_INVALID_MAXIMUM_LEARN_SCALE_FACTOR: return "The maximum scale factor specifed during learning of the template is not supported.";
        case ERR_GHT_INVALID_MINIMUM_LEARN_ANGLE_VALUE: return "The minimum rotation angle value specifed during learning of the template is not supported.";
        case ERR_GHT_INVALID_MINIMUM_LEARN_SCALE_FACTOR: return "The minimum scale factor specifed during learning of the template is not supported.";
        case ERR_GHT_INVALID_USE_ALL_CURVES_VALUE: return "The use all curves advanced option specified during learn is not supported";
        case ERR_GIP_RANGE: return "An internal error occurred while attempting to access an invalid coordinate on an image.";
        case ERR_GRADING_INFORMATION_NOT_FOUND: return "The source image does not contain grading information. You must prepare the source image for grading when reading the Data Matrix, and you cannot change the contents of the source image between reading and grading the Data Matrix.";
        case ERR_HARDWARE_DOESNT_SUPPORT_NONTEARING: return "Your hardware is not supported by DirectX and cannot be put into NonTearing mode.";
        case ERR_HEAP_TRASHED: return "An internal memory error occurred.";
        case ERR_IGNORE_COLOR_SPECTRUM_SET: return "The ignore color spectra array is invalid.";
        case ERR_IMAGES_NOT_DIFF: return "The source image and destination image must be different.";
        case ERR_IMAGE_CONTAINS_NAN_VALUES: return "Float image contains NaN values";
        case ERR_IMAGE_SIZE_MISMATCH: return "The two input image sizes are different";
        case ERR_IMAGE_SMALLER_THAN_BORDER: return "Your image must be larger than its border size for this operation.";
        case ERR_IMAGE_TOO_SMALL: return "The image is not large enough for the operation.";
        case ERR_IMAQ_QR_DIMENSION_INVALID: return "Invalid Dimensions.";
        case ERR_INCOMPATIBLE_CLASSIFIER_TYPES: return "The session you read from file must be the same type as the session you passed in.";
        case ERR_INCOMPATIBLE_MARKER_IMAGE_SIZE: return "Source Image and Marker Image should be of same size.";
        case ERR_INCOMP_MATRIX_SIZE: return "The number of pixel and real-world coordinates must be equal.";
        case ERR_INCOMP_SIZE: return "Incompatible image size.";
        case ERR_INCOMP_TYPE: return "Incompatible image type.";
        case ERR_INEFFICIENT_POINTS: return "You supplied an inefficient set of points to match the minimum score.";
        case ERR_INFO_NOT_FOUND: return "You must provide information about the subimage within the browser.";
        case ERR_INIT: return "Initialization error.";
        case ERR_INSF_POINTS: return "You supplied an insufficient number of points to perform this operation.";
        case ERR_INSUFFICIENT_BUFFER_SIZE: return "The buffer that was passed in is not big enough to hold all of the data.";
        case ERR_INTERNAL: return "Internal error.";
        case ERR_INVALID_2D_BARCODE_CELL_SHAPE: return "Invalid 2-D barcode cell shape.";
        case ERR_INVALID_2D_BARCODE_CONTRAST: return "Invalid 2-D barcode contrast.";
        case ERR_INVALID_2D_BARCODE_CONTRAST_FOR_ROI: return "When using a region of interest that is not a rectangle, you must specify the contrast mode of the barcode as either black on white or white on black.";
        case ERR_INVALID_2D_BARCODE_SEARCH_MODE: return "NI Vision does not support the search mode you provided.";
        case ERR_INVALID_2D_BARCODE_SHAPE: return "Invalid 2-D barcode shape.";
        case ERR_INVALID_2D_BARCODE_SUBTYPE: return "Invalid 2-D barcode Data Matrix subtype.";
        case ERR_INVALID_2D_BARCODE_TYPE: return "Invalid 2-D barcode type.";
        case ERR_INVALID_3DDIRECTION: return "NI Vision does not support the 3DDirection value you supplied.";
        case ERR_INVALID_3DPLANE: return "NI Vision does not support the 3DPlane value you supplied.";
        case ERR_INVALID_3DVISION_SESSION: return "Not a valid 3D Vision session.";
        case ERR_INVALID_ACTION: return "The function does not support the requested action.";
        case ERR_INVALID_ALIGNMENT: return "The supplied scale is invalid for your template.";
        case ERR_INVALID_ANGLE_RANGE_FOR_STRAIGHT_EDGE: return "Angle range value should be equal to or greater than zero.";
        case ERR_INVALID_ANGLE_TOL_FOR_STRAIGHT_EDGE: return "The angle tolerance should be equal to or greater than 0.001.";
        case ERR_INVALID_ASPECT_RATIO: return "Invalid aspect ratio. Valid aspect ratios must be greater than or equal to zero.";
        case ERR_INVALID_AVI_SESSION: return "Invalid AVI session.";
        case ERR_INVALID_AXIS_ORIENTATION: return "NI Vision does not support the axis orientation you supplied.";
        case ERR_INVALID_BARCODETYPE: return "NI Vision does not support the BarcodeType value you supplied.";
        case ERR_INVALID_BIT_DEPTH: return "NI Vision does not support the bit depth you supplied for the image you supplied.";
        case ERR_INVALID_BORDER: return "Invalid image border.";
        case ERR_INVALID_BORDERMETHOD: return "NI Vision does not support the BorderMethod value you supplied.";
        case ERR_INVALID_BORDER_INTEGRITY: return "Invalid border integrity. Valid values range from 0 to 100.";
        case ERR_INVALID_BORDER_SIZE: return "Invalid border size. Acceptable values range from 0 to 50.";
        case ERR_INVALID_BROWSER_IMAGE: return "Invalid browser image.";
        case ERR_INVALID_BUTTON_LABEL: return "Invalid button label.";
        case ERR_INVALID_CALIBRATION_METHOD: return "Invalid calibration method requested";
        case ERR_INVALID_CALIBRATION_MODE: return "NI Vision does not support the calibration mode you supplied.";
        case ERR_INVALID_CALIBRATION_ROI_MODE: return "NI Vision does not support the calibration ROI mode you supplied.";
        case ERR_INVALID_CALIBRATION_UNIT: return "NI Vision does not support the calibration unit you supplied.";
        case ERR_INVALID_CELL_FILL_TYPE: return "Invalid cell fill type.";
        case ERR_INVALID_CELL_FILTER_MODE: return "Invalid cell filter mode.";
        case ERR_INVALID_CELL_SAMPLE_SIZE: return "Invalid cell sample size.";
        case ERR_INVALID_CLASSIFIER_SESSION: return "Not a valid classifier session.";
        case ERR_INVALID_CLASSIFIER_TYPE: return "You requested an invalid classifier type.";
        case ERR_INVALID_COLORSENSITIVITY: return "NI Vision does not support the ColorSensitivity value you supplied.";
        case ERR_INVALID_COLOR_IGNORE_MODE: return "Invalid color ignore mode.";
        case ERR_INVALID_COLOR_MODE: return "NI Vision does not support the color mode you specified.";
        case ERR_INVALID_COLOR_RESOLUTION: return "Invalid Color Resolution for the Color Classifier";
        case ERR_INVALID_COLOR_SPECTRUM: return "The color spectrum array you provided has an invalid number of elements or contains an element set to not-a-number (NaN).";
        case ERR_INVALID_COLOR_WEIGHT: return "Invalid color weight. Acceptable values range from 0 to 1000.";
        case ERR_INVALID_COLUMN_STEP: return "Invalid column step. Valid range is 1 to 255.";
        case ERR_INVALID_COMPAREFUNCTION: return "NI Vision does not support the CompareFunction value you supplied.";
        case ERR_INVALID_COMPLEXPLANE: return "NI Vision does not support the ComplexPlane value you supplied.";
        case ERR_INVALID_COMPRESSION_RATIO: return "The compression ratio must be greater than or equal to 1.";
        case ERR_INVALID_COMPRESSION_TYPE: return "Invalid compression type.";
        case ERR_INVALID_CONCENTRIC_RAKE_DIRECTION: return "Invalid concentric rake direction.";
        case ERR_INVALID_CONTRAST: return "Invalid contrast value. Valid contrast values range from 0 to 255.";
        case ERR_INVALID_CONTRAST_REVERSAL_MODE: return "The contrast reversal mode specified during matching is invalid.";
        case ERR_INVALID_CONTRAST_THRESHOLD: return "Invalid contrast threshold. The threshold value must be greater than 0.";
        case ERR_INVALID_CONVERSIONSTYLE: return "NI Vision does not support the Conversion Method value you supplied.";
        case ERR_INVALID_COOCCURRENCE_LEVEL: return "The coOccurrence Level must lie between 1 and the maximum pixel value of an image (255 for U8 image)";
        case ERR_INVALID_CURVE_EXTRACTION_MODE: return "Invalid curve extraction mode.";
        case ERR_INVALID_CUSTOM_SAMPLE: return "The size of the feature vector in the custom sample must match the size of those you have already added.";
        case ERR_INVALID_DEMODULATION_MODE: return "Invalid demodulation mode.";
        case ERR_INVALID_DETECTION_MODE: return "Invalid detection mode.";
        case ERR_INVALID_DISTANCE: return "Invalid Color Segmentation Distance";
        case ERR_INVALID_DISTANCE_LEVEL: return "Invalid Color Segmentation distance level";
        case ERR_INVALID_DISTANCE_METRIC: return "You requested an invalid distance metric.";
        case ERR_INVALID_DISTORTION_MODEL: return "Invalid distortion model type";
        case ERR_INVALID_DRAWMODE: return "NI Vision does not support the DrawMode value you supplied.";
        case ERR_INVALID_DRAWMODE_FOR_LINE: return "imaqDrawLineOnImage does not support the DrawMode value you supplied.";
        case ERR_INVALID_ECC_TYPE: return "Invalid ECC type.";
        case ERR_INVALID_EDGE_DIR: return "You supplied an invalid edge direction in the Canny operator.";
        case ERR_INVALID_EDGE_FILTER_SIZE: return "Invalid edge filter size.";
        case ERR_INVALID_EDGE_POLARITY_SEARCH_MODE: return "Invalid edge polarity search mode.";
        case ERR_INVALID_EDGE_PROCESS: return "Invalid edge process.";
        case ERR_INVALID_EDGE_THICKNESS: return "Edge Thickness to Ignore must be greater than zero.";
        case ERR_INVALID_EDGE_THRESHOLD: return "Invalid edge threshold. Valid values range from 1 to 360.";
        case ERR_INVALID_ENERGY: return "Minimum Energy should lie between 0 and 100";
        case ERR_INVALID_FEATURE_MODE: return "Invalid feature mode.";
        case ERR_INVALID_FILL_STYLE: return "The fill style for the window background is invalid.";
        case ERR_INVALID_FINAL_STEP_SIZE: return "The final step size must be lesser than the initial step size";
        case ERR_INVALID_FLIPAXIS: return "NI Vision does not support the axis of symmetry you supplied.";
        case ERR_INVALID_FONTCOLOR: return "NI Vision does not support the FontColor value you supplied.";
        case ERR_INVALID_FRAMES_PER_SECOND: return "The frames per second in an AVI must be greater than zero.";
        case ERR_INVALID_FRAME_NUMBER: return "Invalid frame number.";
        case ERR_INVALID_FUNCTION: return "Unsupported function.";
        case ERR_INVALID_GAUSS_FILTER_TYPE: return "The specified Gaussian filter type is not supported.";
        case ERR_INVALID_GAUSS_SIGMA_VALUE: return "The sigma value specified for the Gaussian filter is too small.";
        case ERR_INVALID_GEOMETRIC_FEATURE_TYPE: return "The geometric feature type specified is invalid.";
        case ERR_INVALID_GEOMETRIC_MATCHING_TEMPLATE: return "Invalid geometric matching template image.";
        case ERR_INVALID_GRADING_MODE: return "Invalid grading mode.";
        case ERR_INVALID_HATCH_STYLE: return "The hatch style for the window background is invalid.";
        case ERR_INVALID_HORN_SCHUNCK_LAMBDA: return "Invalid smoothing parameter in Horn Schunck operation.";
        case ERR_INVALID_HORN_SCHUNCK_TYPE: return "Invalid stopping criteria type for Horn Schunck optical flow.";
        case ERR_INVALID_ICONS_PER_LINE: return "NI Vision does not support less than one icon per line.";
        case ERR_INVALID_IDENTIFICATION_SCORE: return "Invalid Identification score. Must be between 0-1000.";
        case ERR_INVALID_IMAGE_TYPE: return "Invalid image type.";
        case ERR_INVALID_INITIAL_MATCH_LIST_LENGTH: return "Invalid initial match list length. Values must be integers greater than 5.";
        case ERR_INVALID_INSPECTION_TEMPLATE: return "Invalid golden template.";
        case ERR_INVALID_INTERPOLATIONMETHOD: return "NI Vision does not support the InterpolationMethod value you supplied.";
        case ERR_INVALID_INTERPOLATIONMETHOD_FOR_ROTATE: return "imaqRotate does not support the InterpolationMethod value you supplied.";
        case ERR_INVALID_INTERPOLATIONMETHOD_FOR_UNWRAP: return "UnwrapImage does not support the interpolation method value you supplied.  Valid interpolation methods are zero order and bilinear.";
        case ERR_INVALID_INTERPOLATIONMETHOD_INTERPOLATEPOINTS: return "imaqInterpolatePoints does not support the InterpolationMethod value you supplied.";
        case ERR_INVALID_KERNEL_CODE: return "Invalid kernel code.";
        case ERR_INVALID_KERNEL_SIZE: return "The Kernel size must be smaller than the image size.";
        case ERR_INVALID_KERNEL_SIZE_FOR_EDGE_DETECTION: return "Invalid kernel size for edge detection. The minimum kernel size is 3, the maximum kernel size is 1073741823 and the kernel size must be odd.";
        case ERR_INVALID_KNN_METHOD: return "You requested an invalid Nearest Neighbor classifier method.";
        case ERR_INVALID_LEARN_GEOMETRIC_PATTERN_SETUP_DATA: return "Invalid learn geometric pattern setup data.";
        case ERR_INVALID_LEARN_MODE: return "Invalid learn mode.";
        case ERR_INVALID_LENGTH: return "The length of the edge detection line must be greater than zero.";
        case ERR_INVALID_LIMITS: return "The limits you supplied are not valid.";
        case ERR_INVALID_LINE: return "The line you provided contains two identical points, or one of the coordinate locations for the line is not a number (NaN).";
        case ERR_INVALID_LINEAR_AVERAGE_MODE: return "Invalid linear average mode.";
        case ERR_INVALID_LINEGAUGEMETHOD: return "Invalid line gauge method.";
        case ERR_INVALID_LKP_KERNEL: return "The kernel must be symmetric  with non-zero coefficients and of odd size";
        case ERR_INVALID_LUCAS_KANADE_WINDOW_SIZE: return "Both dimensions of the window size should be odd, greater than 2 and less than 16.";
        case ERR_INVALID_MATCHFACTOR: return "The function does not support the matchFactor that you specified.";
        case ERR_INVALID_MATCH_CONSTRAINT_TYPE: return "You specified an invalid value for the match constraint value of the  range settings.";
        case ERR_INVALID_MATCH_GEOMETRIC_PATTERN_SETUP_DATA: return "Invalid match geometric pattern setup data.";
        case ERR_INVALID_MATCH_MODE: return "Invalid match mode.";
        case ERR_INVALID_MATHTRANSFORMMETHOD: return "NI Vision does not support the MathTransformMethod value you supplied.";
        case ERR_INVALID_MATRIX_MIRROR_MODE: return "Invalid matrix mirror mode.";
        case ERR_INVALID_MATRIX_POLARITY: return "Invalid matrix polarity.";
        case ERR_INVALID_MATRIX_SIZE_RANGE: return "The maximum Data Matrix barcode size must be equal to or greater than the minimum Data Matrix barcode size.";
        case ERR_INVALID_MATRIX_TYPE: return "The type of matrix supplied to the function is not supported.";
        case ERR_INVALID_MAXIMUM_END_POINT_GAP: return "Invalid maximum end point gap. Valid values range from 0 to 32767.";
        case ERR_INVALID_MAXIMUM_FEATURES_LEARNED: return "Invalid maximum number of features learn. Values must be integers greater than zero.";
        case ERR_INVALID_MAXIMUM_FEATURES_PER_MATCH: return "Invalid maximum number of features used per match. Values must be integers greater than or equal to zero.";
        case ERR_INVALID_MAXIMUM_PIXEL_DISTANCE_FROM_LINE: return "Invalid maximum pixel distance from line. Values must be positive real numbers.";
        case ERR_INVALID_MAXPOINTS: return "The function does not support the maximum number of points that you specified.";
        case ERR_INVALID_MAX_ITERATIONS: return "Invalid maximum number of iterations. Maximum number of iterations must be greater than zero.";
        case ERR_INVALID_MAX_MATCH_OVERLAP: return "Invalid max match overlap.  Values must be between -1 and 100.";
        case ERR_INVALID_MAX_WAVELET_TRANSFORM_LEVEL: return "Invalid maximum wavelet transform level.  Valid values range from 0 to 255.";
        case ERR_INVALID_MEASURE_PARTICLES_CALIBRATION_MODE: return "Invalid measure particles calibration mode.";
        case ERR_INVALID_METAFILE_HANDLE: return "Invalid metafile handle.";
        case ERR_INVALID_METERARCMODE: return "NI Vision does not support the MeterArcMode value you supplied.";
        case ERR_INVALID_MINIMUM_CURVE_LENGTH: return "Invalid minimum length. Valid values must be greater than or equal to zero.";
        case ERR_INVALID_MINIMUM_FEATURES_TO_MATCH: return "Invalid minimum number of features used for matching. Values must be integers greater than zero.";
        case ERR_INVALID_MINIMUM_FEATURE_ASPECT_RATIO: return "Invalid aspect ratio for rectangular features. Values must be positive real numbers in the range 0.01 to 1.0.";
        case ERR_INVALID_MINIMUM_FEATURE_LENGTH: return "Invalid minimum length for linear features. Values must be integers greater than 0.";
        case ERR_INVALID_MINIMUM_FEATURE_RADIUS: return "Invalid minimum radius for circular features. Values must be integers greater than 0.";
        case ERR_INVALID_MINIMUM_FEATURE_STRENGTH: return "Invalid minimum strength for features. Values must be positive real numbers.";
        case ERR_INVALID_MINIMUM_RECTANGLE_DIMENSION: return "Invalid minimum rectangle dimension. Values must be integers greater than 0.";
        case ERR_INVALID_MIN_COVERAGE_FOR_STRAIGHT_EDGE: return "Minimum coverage value should be greater than zero.";
        case ERR_INVALID_MIN_MATCH_SCORE: return "Invalid minimum match score. Acceptable values range from 0 to 1000.";
        case ERR_INVALID_MIN_MATCH_SEPARATION_ANGLE: return "Invalid minimum match separation angle.  Values must be between -1 and 360.";
        case ERR_INVALID_MIN_MATCH_SEPARATION_DISTANCE: return "Invalid minimum match separation distance.  Values must be greater than or equal to -1.";
        case ERR_INVALID_MIN_MATCH_SEPARATION_SCALE: return "Invalid minimum match separation scale.  Values must be greater than or equal to -1.";
        case ERR_INVALID_MORPHOLOGICAL_OPERATION: return "Invalid Morphological Operation.";
        case ERR_INVALID_MORPHOLOGYMETHOD: return "NI Vision does not support the MorphologyMethod value you supplied.";
        case ERR_INVALID_MULTIPLE_GEOMETRIC_TEMPLATE: return "Invalid multiple geometric template.";
        case ERR_INVALID_NIBLACK_DEVIATION_FACTOR: return "The deviation factor for Niblack local threshold must be between 0 and 1.";
        case ERR_INVALID_NORMALIZATION_METHOD: return "You must provide a valid normalization method.";
        case ERR_INVALID_NUMBER_OF_FEATURES_RANGE: return "The minimum number of features must be less than or equal to the maximum number of features.";
        case ERR_INVALID_NUMBER_OF_LABELS: return "You supplied an invalid number of labels.";
        case ERR_INVALID_NUMBER_OF_MATCH_OPTIONS: return "You supplied an invalid number of match options.";
        case ERR_INVALID_NUM_MATCHES_REQUESTED: return "Invalid number of matches requested. You must request a minimum of one match.";
        case ERR_INVALID_NUM_OF_CLASSES: return "Invalid number of classes for auto threshold. Acceptable values range from 2 to 256.";
        case ERR_INVALID_OCCLUSION_RANGE: return "Invalid occlusion range. Valid values for the bounds range from 0 to 100 and the upper bound must be greater than or equal to the lower bound.";
        case ERR_INVALID_OFFSET: return "The offset you specified must be size 2.";
        case ERR_INVALID_OPERATION_ON_COMPACT_CALIBRATION_ATTEMPTED: return "This calibration is compact. Re-Learning calibration and retrieving thumbnails are not possible with this calibration";
        case ERR_INVALID_OPERATION_ON_COMPACT_SESSION_ATTEMPTED: return "This classifier session is compact. Only the Classify and Dispose functions may be called on a compact classifier session.";
        case ERR_INVALID_OPTICAL_FLOW_TERMINATION_CRITERIA_TYPE: return "An invalid termination criteria was specified for the optical flow computation.";
        case ERR_INVALID_OUTLINEMETHOD: return "NI Vision does not support the OutlineMethod value you supplied.";
        case ERR_INVALID_PALETTE_TYPE: return "NI Vision does not support the PaletteType value you supplied.";
        case ERR_INVALID_PARTICLEINFOMODE: return "NI Vision does not support the ParticleInfoMode value you supplied.";
        case ERR_INVALID_PARTICLE_AREA: return "Invalid Color Segmenation Particle Area";
        case ERR_INVALID_PARTICLE_CLASSIFIER_THRESHOLD_TYPE: return "Invalid particle classifier threshold type.";
        case ERR_INVALID_PARTICLE_INFO: return "The image has invalid particle information.  Call imaqCountParticles on the image to create particle information.";
        case ERR_INVALID_PARTICLE_NUMBER: return "Invalid particle number.";
        case ERR_INVALID_PARTICLE_OPTIONS: return "The sum of Scale Dependence and Symmetry Dependence must be less than 1000.";
        case ERR_INVALID_PARTICLE_PARAMETER_VALUE: return "You entered an invalid selection in the particle parameter.";
        case ERR_INVALID_PARTICLE_TYPE: return "You requested an invalid particle type.";
        case ERR_INVALID_POINTSYMBOL: return "Invalid point symbol.";
        case ERR_INVALID_POLYNOMIAL_MODEL_K_COUNT: return "Invalid number of K values";
        case ERR_INVALID_PROCESS_TYPE_FOR_EDGE_DETECTION: return "Invalid process type for edge detection.";
        case ERR_INVALID_PYRAMID_LEVEL: return "The pyramid level specified cannot be negative";
        case ERR_INVALID_QUALITY: return "The quality you provided is invalid. Valid quality values range from -1 to 1000.";
        case ERR_INVALID_QUANTIZATION_STEP_SIZE: return "The quantization step size must be greater than or equal to 0.";
        case ERR_INVALID_RAKE_DIRECTION: return "Invalid rake direction.";
        case ERR_INVALID_RANGE: return "The range you supplied is invalid.";
        case ERR_INVALID_RECT: return "NI Vision does not support rectangles with negative widths or negative heights.";
        case ERR_INVALID_REFERENCEMODE: return "NI Vision does not support the ReferenceMode value you supplied.";
        case ERR_INVALID_REGISTRATION_METHOD: return "You provided an invalid registration method.";
        case ERR_INVALID_ROTATION_MODE: return "Invalid rotation mode.";
        case ERR_INVALID_ROTATION_RANGE: return "Invalid roation angle range. The upper bound must be greater than or equal to the lower bound.";
        case ERR_INVALID_ROUNDING_MODE: return "NI Vision does not support the RoundingMode value you supplied.";
        case ERR_INVALID_ROW_STEP: return "Invalid row step. Valid range is 1 to 255.";
        case ERR_INVALID_SCALE: return "Scale must be greater than zero.";
        case ERR_INVALID_SCALE_RANGE: return "Invalid scale range. Values for the lower bound must be a positive real numbers and the upper bound must be greater than or equal to the lower bound.";
        case ERR_INVALID_SCALINGMODE: return "NI Vision does not support the ScalingMode value you supplied.";
        case ERR_INVALID_SCALING_METHOD: return "NI Vision does not support the scaling method you provided.";
        case ERR_INVALID_SCAN_DIRECTION: return "Invalid scan direction.";
        case ERR_INVALID_SEARCH_MODE_FOR_STRAIGHT_EDGE: return "Invalid search mode for detecting straight edges";
        case ERR_INVALID_SEARCH_STRATEGY: return "Invalid search strategy.";
        case ERR_INVALID_SEARCH_VECTOR_WIDTH: return "Invalid search vector width. The width must be an odd number greater than zero.";
        case ERR_INVALID_SHAPEMODE: return "NI Vision does not support the ShapeMode value you supplied.";
        case ERR_INVALID_SHAPE_DESCRIPTOR: return "The passed shape descriptor is invalid.";
        case ERR_INVALID_SIZETYPE: return "NI Vision does not support the SizeType value you supplied.";
        case ERR_INVALID_SKELETONMETHOD: return "NI Vision does not support the SkeletonMethod value you supplied.";
        case ERR_INVALID_SKELETONMODE: return "The Skeleton mode you specified is invalid.";
        case ERR_INVALID_SPOKE_DIRECTION: return "Invalid spoke direction.";
        case ERR_INVALID_STEEPNESS: return "Invalid steepness.";
        case ERR_INVALID_STEP_SIZE: return "Step size must be greater than zero and less than Image size";
        case ERR_INVALID_STEREO_BLOCKMATCHING_FILTERTYPE: return "You have specified an invalid filter type for block matching.";
        case ERR_INVALID_STEREO_BLOCKMATCHING_NUMDISPARITIES: return "The specifed value for number of disparities is invalid.";
        case ERR_INVALID_STEREO_BLOCKMATCHING_PREFILTER_CAP: return "The specified value for the filter cap for block matching is invalid.";
        case ERR_INVALID_STEREO_BLOCKMATCHING_PREFILTER_SIZE: return "The specified prefilter size for block matching is invalid.";
        case ERR_INVALID_STEREO_BLOCKMATCHING_PREFILTER_TYPE: return "The specified prefilter type for block matching is invalid.";
        case ERR_INVALID_STEREO_BLOCKMATCHING_WINDOW_SIZE: return "The specified window size for block matching is invalid.";
        case ERR_INVALID_STEREO_CAMERA_POSITION: return "You have requested results at an invalid camera position in the stereo setup.";
        case ERR_INVALID_SUBPIXEL_DIVISIONS: return "Invalid subpixel divisions.";
        case ERR_INVALID_SUBPIXEL_ITERATIONS: return "Invalid number of subpixel iterations. Values must be integers greater 10.";
        case ERR_INVALID_SUBPIXEL_TOLERANCE: return "Invalid subpixel tolerance. Values must be positive real numbers.";
        case ERR_INVALID_SUBPIX_TYPE: return "NI Vision does not support the interpolation type you supplied.";
        case ERR_INVALID_SUBSAMPLING_RATIO: return "Invalid subsampling ratio.";
        case ERR_INVALID_SVM_KERNEL: return "Invalid SVM kernel type";
        case ERR_INVALID_SVM_PARAMETER: return "Invalid SVM Parameter";
        case ERR_INVALID_SVM_TYPE: return "Invalid SVM model type";
        case ERR_INVALID_TETRAGON: return "The input tetragon must have four points. The points are specified clockwise starting with the top left point.";
        case ERR_INVALID_TEXTALIGNMENT: return "NI Vision does not support the TextAlignment value you supplied.";
        case ERR_INVALID_TEXTORIENTATION: return "NI Vision does not support the text orientation value you supplied.";
        case ERR_INVALID_TEXTURE_FEATURE: return "Requested for invalid texture feature";
        case ERR_INVALID_TEXTURE_LABEL: return "The classification label must be texture or defect for texture defect classifier";
        case ERR_INVALID_THRESHOLDMETHOD: return "NI Vision does not support the threshold method value you supplied.";
        case ERR_INVALID_THRESHOLD_PERCENTAGE: return "Invalid threshold percentage. Valid values range from 0 to 100.";
        case ERR_INVALID_THUMBNAIL_INDEX: return "Supplied thumbnail index is invalid";
        case ERR_INVALID_TOLERANCE: return "The tolerance parameter must be greater than or equal to 0.";
        case ERR_INVALID_TOOL: return "NI Vision does not support the Tool value you supplied.";
        case ERR_INVALID_TYPE_OF_FLATTEN: return "Invalid type of flatten.";
        case ERR_INVALID_USE_OF_COMPACT_SESSION_FILE: return "You can not use a compact classification file with read options other than Read All.";
        case ERR_INVALID_VERTICAL_TEXT_ALIGNMENT: return "NI Vision does not support the VerticalTextAlignment value you supplied.";
        case ERR_INVALID_VIDEO_BLIT: return "RT Video Out does not support displaying the supplied image type at the selected color depth.";
        case ERR_INVALID_VIDEO_MODE: return "Invalid video mode.";
        case ERR_INVALID_VISION_INFO: return "NI Vision does not support the vision information type you supplied.";
        case ERR_INVALID_WAVELET_SUBBAND: return "Request for invalid wavelet subBand";
        case ERR_INVALID_WAVELET_TRANSFORM_MODE: return "Invalid wavelet transform mode.";
        case ERR_INVALID_WAVELET_TYPE: return "The wavelet type is invalid";
        case ERR_INVALID_WIDTH: return "Invalid pixel width.";
        case ERR_INVALID_WINDOW_SIZE: return "The size of each dimension of the window must be greater than 2 and less than or equal to the size of the image in the corresponding dimension.";
        case ERR_INVALID_WINDOW_THREAD_POLICY: return "NI Vision does not support the WindowThreadPolicy value you supplied.";
        case ERR_IO_ERROR: return "I/O error.";
        case ERR_JPEG2000_LOSSLESS_WITH_FLOATING_POINT: return "Lossless compression cannot be used with the floating point wavelet transform mode. Either set the wavelet transform mode to integer, or use lossy compression.";
        case ERR_JPEG2000_UNSUPPORTED_MULTIPLE_LAYERS: return "NI Vision does not support reading JPEG2000 files with more than one layer.";
        case ERR_K_TOO_HIGH: return "The k parameter must be <= the number of samples in each class.";
        case ERR_K_TOO_LOW: return "The k parameter must be greater than two.";
        case ERR_LABEL_NOT_FOUND: return "Cannot find a label that matches the one you specified.";
        case ERR_LABEL_TOO_LONG: return "Labels must be <= 255 characters.";
        case ERR_LAB_VERSION: return "The version of LabVIEW or BridgeVIEW you are running does not support this operation.";
        case ERR_LCD_BAD_MATCH: return "The LCD does not form a known digit.";
        case ERR_LCD_CALIBRATE: return "The input image does not seem to be a valid LCD or LED calibration image.";
        case ERR_LCD_NOT_NUMERIC: return "LCD image is not a number.";
        case ERR_LCD_NO_SEGMENTS: return "No lit segment.";
        case ERR_LEARN_SETUP_DATA: return "Invalid learn setup data.";
        case ERR_LINEAR_COEFF: return "The linear equations are not independent.";
        case ERR_LINES_PARALLEL: return "You specified parallel lines for the meter ROI.";
        case ERR_LKP_NULL_PYRAMID: return "The pyramid levels where not properly allocated.";
        case ERR_MARKER_INFORMATION_NOT_SUPPLIED: return "Marker image and points are not supplied";
        case ERR_MASK_NOT_TEMPLATE_SIZE: return "The mask must be the same size as the template.";
        case ERR_MASK_OUTSIDE_IMAGE: return "When the mask's offset was applied, the mask was entirely outside of the image.";
        case ERR_MATCHFACTOR_OBSOLETE: return "matchFactor has been obsoleted. Instead, set the initialMatchListLength and matchListReductionFactor in the MatchPatternAdvancedOptions structure.";
        case ERR_MATCH_SETUP_DATA: return "Invalid match setup data.";
        case ERR_MATRIX_SIZE: return "Invalid matrix size in the structuring element.";
        case ERR_MEMORY_ERROR: return "Memory error.";
        case ERR_MULTICORE_INVALID_ARGUMENT: return "You have given Multicore Options an invalid argument.";
        case ERR_MULTICORE_OPERATION: return "The operation you have given Multicore Options is invalid. Please see the available enumeration values for Multicore Operation.";
        case ERR_NEED_FULL_VERSION: return "The function requires an NI Vision 5.0 Advanced license.";
        case ERR_NIOCR_BOOLEAN_VALUE_FOR_INTEGER_ATTRIBUTE: return "Boolean values are not valid for this attribute. Enter an integer value.";
        case ERR_NIOCR_BOOLEAN_VALUE_FOR_STRING_ATTRIBUTE: return "String values are not valid for this attribute. Enter a Boolean value.";
        case ERR_NIOCR_CHARACTER_SET_DESCRIPTION_TOO_LONG: return "The character set description must be <=255 characters.";
        case ERR_NIOCR_CHARACTER_VALUE_CANNOT_BE_EMPTYSTRING: return "The character value must not be an empty string.";
        case ERR_NIOCR_CHARACTER_VALUE_TOO_LONG: return "Character values must be <=255 characters.";
        case ERR_NIOCR_GET_ONLY_ATTRIBUTE: return "This attribute is read-only.";
        case ERR_NIOCR_INTEGER_VALUE_FOR_BOOLEAN_ATTRIBUTE: return "This attribute requires a Boolean value.";
        case ERR_NIOCR_INTEGER_VALUE_FOR_STRING_ATTRIBUTE: return "You must specify characters for a string. A string cannot contain integers.";
        case ERR_NIOCR_INVALID_ACCEPTANCE_LEVEL: return "The acceptance level is outside the valid range of  0 to 1000.";
        case ERR_NIOCR_INVALID_ASPECT_RATIO: return "Invalid aspect ratio value. The aspect ratio must be zero or >= 100.";
        case ERR_NIOCR_INVALID_ATTRIBUTE: return "Invalid attribute.";
        case ERR_NIOCR_INVALID_BOUNDING_RECT_HEIGHT_RANGE: return "The minimum character bounding rectangle height must be less than the maximum character bounding rectangle height.";
        case ERR_NIOCR_INVALID_BOUNDING_RECT_WIDTH_RANGE: return "The minimum character bounding rectangle width must be less than the maximum character bounding rectangle width.";
        case ERR_NIOCR_INVALID_CHARACTER_INDEX: return "Invalid character index.";
        case ERR_NIOCR_INVALID_CHARACTER_SET_FILE: return "Invalid or corrupt character set file.";
        case ERR_NIOCR_INVALID_CHARACTER_SET_FILE_VERSION: return "The character set file was created by a newer version of NI Vision. Upgrade to the latest version of NI Vision to read the character set file.";
        case ERR_NIOCR_INVALID_CHARACTER_SIZE: return "Invalid character size. Character size must be >= 1.";
        case ERR_NIOCR_INVALID_CHARACTER_SIZE_RANGE: return "The minimum character size must be less than the maximum character size.";
        case ERR_NIOCR_INVALID_CHARACTER_VALUE: return "A character cannot have an ASCII value of 255.";
        case ERR_NIOCR_INVALID_HIGH_THRESHOLD_VALUE: return "Invalid high threshold value. Valid threshold values range from 0 to 255.";
        case ERR_NIOCR_INVALID_LOWER_THRESHOLD_LIMIT: return "Invalid lower threshold limit. Valid lower threshold limits range from 0 to 255.";
        case ERR_NIOCR_INVALID_LOW_THRESHOLD_VALUE: return "Invalid low threshold value. Valid threshold values range from 0 to 255.";
        case ERR_NIOCR_INVALID_MAX_HORIZ_ELEMENT_SPACING: return "Invalid maximum horizontal element spacing value. Maximum horizontal element spacing must be >= 0.";
        case ERR_NIOCR_INVALID_MAX_VERT_ELEMENT_SPACING: return "Invalid maximum vertical element spacing value. Maximum vertical element spacing must be >= 0.";
        case ERR_NIOCR_INVALID_MIN_BOUNDING_RECT_HEIGHT: return "Invalid minimum bounding rectangle height. The minimum bounding rectangle height must be >= 1.";
        case ERR_NIOCR_INVALID_MIN_BOUNDING_RECT_WIDTH: return "Invalid minimum bounding rectangle width. Minimum bounding rectangle width must be >= 1.";
        case ERR_NIOCR_INVALID_MIN_CHAR_SPACING: return "Invalid minimum character spacing value. Character spacing must be >= 1 pixel.";
        case ERR_NIOCR_INVALID_NUMBER_OF_BLOCKS: return "Invalid number of blocks. Number of blocks must be >= 4 and <= 50.";
        case ERR_NIOCR_INVALID_NUMBER_OF_CHARACTERS: return "The number of characters in the character value must match the number of objects in the image.";
        case ERR_NIOCR_INVALID_NUMBER_OF_EROSIONS: return "Invalid number of erosions. The number of erosions must be >= 0.";
        case ERR_NIOCR_INVALID_NUMBER_OF_OBJECTS_TO_VERIFY: return "The number of objects found does not match the number of expected characters or patterns to verify.";
        case ERR_NIOCR_INVALID_NUMBER_OF_VALID_CHARACTER_POSITIONS: return "Invalid number of character positions. Valid values range from 0 to 255.";
        case ERR_NIOCR_INVALID_OBJECT_INDEX: return "Invalid object index.";
        case ERR_NIOCR_INVALID_PREDEFINED_CHARACTER: return "Invalid predefined character value.";
        case ERR_NIOCR_INVALID_READ_OPTION: return "Invalid read option.";
        case ERR_NIOCR_INVALID_READ_RESOLUTION: return "Invalid read resolution.";
        case ERR_NIOCR_INVALID_READ_STRATEGY: return "Invalid read strategy.";
        case ERR_NIOCR_INVALID_SPACING_RANGE: return "The maximum horizontal element spacing value must not exceed the minimum character spacing value.";
        case ERR_NIOCR_INVALID_SUBSTITUTION_CHARACTER: return "Invalid substitution character. Valid substitution characters are ASCII values that range from 1 to 254.";
        case ERR_NIOCR_INVALID_THRESHOLD_LIMITS: return "The lower threshold limit must be less than the upper threshold limit.";
        case ERR_NIOCR_INVALID_THRESHOLD_MODE: return "Invalid threshold mode value.";
        case ERR_NIOCR_INVALID_THRESHOLD_RANGE: return "The low threshold must be less than the high threshold.";
        case ERR_NIOCR_INVALID_UPPER_THRESHOLD_LIMIT: return "Invalid upper threshold limit. Valid upper threshold limits range from 0 to 255.";
        case ERR_NIOCR_MUST_BE_SINGLE_CHARACTER: return "Requires a single-character string.";
        case ERR_NIOCR_NOT_A_VALID_CHARACTER_SET: return "Not a valid character set.";
        case ERR_NIOCR_NOT_A_VALID_SESSION: return "Not a valid OCR session.";
        case ERR_NIOCR_RENAME_REFCHAR: return "A trained OCR character cannot be renamed while it is a reference character.";
        case ERR_NIOCR_STRING_VALUE_FOR_BOOLEAN_ATTRIBUTE: return "String values are invalid for this attribute. Enter a boolean value.";
        case ERR_NIOCR_STRING_VALUE_FOR_INTEGER_ATTRIBUTE: return "This attribute requires integer values.";
        case ERR_NIOCR_UNLICENSED: return "This copy of NI OCR is unlicensed.";
        case ERR_NOT_AN_OBJECT: return "Not an object.";
        case ERR_NOT_ENOUGH_REGIONS: return "You specified a viewer that does not contain enough regions.";
        case ERR_NOT_ENOUGH_TEMPLATE_FEATURES: return "The template does not contain enough features for geometric matching.";
        case ERR_NOT_ENOUGH_TEMPLATE_FEATURES_1: return "The template does not contain enough features for geometric matching.";
        case ERR_NOT_IMAGE: return "Not an image.";
        case ERR_NOT_RECT_OR_ROTATED_RECT: return "The ROI must only have either a single Rectangle contour or a single Rotated Rectangle contour.";
        case ERR_NO_CLAMP_FOUND: return "No valid clamp was found with the current configuration";
        case ERR_NO_CLAMP_WITHIN_ANGLE_RANGE: return "Supplied angle range for clamp is insufficient";
        case ERR_NO_DEST_IMAGE: return "You must provide a destination image.";
        case ERR_NO_LABEL: return "You must pass in a label.";
        case ERR_NO_PARTICLE: return "The image yielded no particles.";
        case ERR_NO_SAMPLES: return "This operation cannot be performed because you have not added any samples.";
        case ERR_NO_SUPPORT_VECTOR_FOUND: return "No Support Vector is found at SVM training";
        case ERR_NO_TEMPLATE_TO_LEARN: return "Need at least one template to learn.";
        case ERR_NO_VIDEO_DRIVER: return "No video driver is installed.";
        case ERR_NULL_POINTER: return "Null pointer.";
        case ERR_NUMBER_CLASS: return "Invalid number of classes.";
        case ERR_NUMBER_LABEL_LIMIT_EXCEEDED: return "Number of Labels exceeded limit of label Image type";
        case ERR_NUMBER_OF_PALETTE_COLORS: return "The color palette must have exactly 0 or 256 entries.";
        case ERR_OCR_ADD_WORD_FAILED: return "The supplied word could not be added to the user dictionary.";
        case ERR_OCR_BAD_TEXT_TEMPLATE: return "The supplied text template contains nonstandard characters that cannot be generated by OCR.";
        case ERR_OCR_BAD_USER_DICTIONARY: return "The provided filename is not valid user dictionary filename.";
        case ERR_OCR_BIN_DIR_NOT_FOUND: return "The system could not locate the OCR binary directory required for OCR initialization.";
        case ERR_OCR_CANNOT_MATCH_TEXT_TEMPLATE: return "At least one character in the text template was of a lexical class that did not match the supplied character reports.";
        case ERR_OCR_CHAR_REPORT_CORRUPTED: return "One of the character reports is no longer usable by the system.";
        case ERR_OCR_CORRECTION_FAILED: return "The OCR engine failed during the correction stage.";
        case ERR_OCR_INI_FILE_NOT_FOUND: return "The system could not locate the initialization file required for OCR initialization.";
        case ERR_OCR_INVALID_AUTOCORRECTIONMODE: return "NI Vision does not support the AutoCorrectionMode value you supplied.";
        case ERR_OCR_INVALID_AUTOORIENTMODE: return "NI Vision does not support the AutoOrientMode value you supplied.";
        case ERR_OCR_INVALID_CHARACTERPREFERENCE: return "NI Vision does not support the CharacterPreference value you supplied.";
        case ERR_OCR_INVALID_CHARACTERSET: return "NI Vision does not support the CharacterSet value you supplied.";
        case ERR_OCR_INVALID_CHARACTERTYPE: return "NI Vision does not support the CharacterType value you supplied.";
        case ERR_OCR_INVALID_CONTRASTMODE: return "NI Vision does not support the ContrastMode value you supplied.";
        case ERR_OCR_INVALID_CORRECTIONLEVEL: return "NI Vision does not support the CorrectionLevel value you supplied.";
        case ERR_OCR_INVALID_CORRECTIONMODE: return "NI Vision does not support the CorrectionMethod value you supplied.";
        case ERR_OCR_INVALID_LANGUAGE: return "NI Vision does not support the Language value you supplied.";
        case ERR_OCR_INVALID_MAXPOINTSIZE: return "NI Vision does not support the maximum point size you supplied.  Valid values range from 4 to 72.";
        case ERR_OCR_INVALID_OUTPUTDELIMITER: return "NI Vision does not support the OutputDelimiter value you supplied.";
        case ERR_OCR_INVALID_PARAMETER: return "One of the parameters supplied to the OCR function that generated this error is invalid.";
        case ERR_OCR_INVALID_RECOGNITIONMODE: return "NI Vision does not support the RecognitionMode value you supplied.";
        case ERR_OCR_INVALID_TOLERANCE: return "NI Vision does not support the tolerance value you supplied.  Valid values are non-negative.";
        case ERR_OCR_LIB_INIT: return "The OCR library cannot be initialized correctly.";
        case ERR_OCR_LOAD_LIBRARY: return "There was a failure when loading one of the internal OCR engine or LabView libraries.";
        case ERR_OCR_NO_TEXT_FOUND: return "The OCR engine could not find any text in the supplied region.";
        case ERR_OCR_ORIENT_DETECT_FAILED: return "The OCR attempted to detected the text orientation and failed.";
        case ERR_OCR_PREPROCESSING_FAILED: return "The OCR engine failed during the preprocessing stage.";
        case ERR_OCR_RECOGNITION_FAILED: return "The OCR engine failed during the recognition stage.";
        case ERR_OCR_REGION_TOO_SMALL: return "The OCR region provided was too small to have contained any characters.";
        case ERR_OCR_SKEW_DETECT_FAILED: return "The OCR attempted to detected the text skew and failed.";
        case ERR_OCR_TEMPLATE_WRONG_SIZE: return "The size of the template string must match the size of the string you are trying to correct.";
        case ERR_OCR_WTS_DIR_NOT_FOUND: return "The system could not locate the OCR weights directory required for OCR initialization.";
        case ERR_OPENING_NEWER_3DVISION_SESSION: return "The 3D vision session you tried to open was created with a newer version of NI Vision. Upgrade to the latest version of NI Vision to read this file.";
        case ERR_OPENING_NEWER_AIM_GRADING_DATA: return "The AIM grading data attached to the image you tried to open was created with a newer version of NI Vision. Upgrade to the latest version of NI Vision to read this file.";
        case ERR_OPENING_NEWER_CLASSIFIER_SESSION: return "The classifier session you tried to open was created with a newer version of NI Vision. Upgrade to the latest version of NI Vision to read this file.";
        case ERR_OPENING_NEWER_GEOMETRIC_MATCHING_TEMPLATE: return "The geometric matching template you tried to open was created with a newer version of NI Vision. Upgrade to the latest version of NI Vision to read this file.";
        case ERR_OPENING_NEWER_INSPECTION_TEMPLATE: return "The golden template you tried to open was created with a newer version of NI Vision. Upgrade to the latest version of NI Vision to read this file.";
        case ERR_OPENING_NEWER_MULTIPLE_GEOMETRIC_TEMPLATE: return "The multiple geometric matching template you tried to open was created with a newer version of NI Vision. Upgrade to the latest version of NI Vision to read this file.";
        case ERR_OUT_OF_MEMORY: return "Not enough memory for requested operation.";
        case ERR_OVERLAY_EXTRAINFO_OPENING_NEW_VERSION: return "The overlay information you tried to open was created with a newer version of NI Vision. Upgrade to the latest version of NI Vision to read this file.";
        case ERR_OVERLAY_GROUP_NOT_FOUND: return "Overlay Group Not Found.";
        case ERR_PALETTE_NOT_SUPPORTED: return "Only 8-bit images support the use of palettes.  Either do not use a palette, or convert your image to an 8-bit image before using a palette.";
        case ERR_PARTICLE: return "Invalid particle.";
        case ERR_POINTS_ARE_COLLINEAR: return "Do not supply collinear points for this operation.";
        case ERR_PRECISION_NOT_GTR_THAN_0: return "The precision parameter must be greater than 0.";
        case ERR_PROP_NODE_WRITE_NOT_SUPPORTED: return "The Image Display control does not support writing this property node.";
        case ERR_PROTECTION: return "Protection error.";
        case ERR_QR_DETECTION_MODE: return "The data stream that was demodulated could not be read because the mode was not detected.";
        case ERR_QR_DETECTION_MODELTYPE: return "Couldn't determine the correct model of the QR code.";
        case ERR_QR_DETECTION_VERSION: return "Couldn't determine the correct version of the QR code.";
        case ERR_QR_INVALID_BARCODE: return "The barcode that was read contains invalid parameters.";
        case ERR_QR_INVALID_READ: return "Invalid read of the QR code.";
        case ERR_REQUIRES_WIN2000_OR_NEWER: return "The function requires the operating system to be Microsoft Windows 2000 or newer.";
        case ERR_RESERVED_MUST_BE_NULL: return "You must pass NULL for the reserved parameter.";
        case ERR_ROI_HAS_OPEN_CONTOURS: return "The ROI you passed in may only contain closed contours.";
        case ERR_ROI_NOT_2_LINES: return "The ROI you passed into imaqGetMeterArc must consist of two lines.";
        case ERR_ROI_NOT_ANNULUS: return "The ROI must only have a single Annulus contour.";
        case ERR_ROI_NOT_LINE: return "The ROI must only have a single Line contour.";
        case ERR_ROI_NOT_POINT: return "The ROI must only have a single Point contour.";
        case ERR_ROI_NOT_POINTS: return "The ROI must only have Point contours.";
        case ERR_ROI_NOT_POLYGON: return "ROI is not a polygon.";
        case ERR_ROI_NOT_RECT: return "The ROI must only have a single Rectangle contour.";
        case ERR_ROLLBACK_DELETE_TIMER: return "No initialized timed environment is available to close.";
        case ERR_ROLLBACK_INIT_TIMER: return "The timed environment could not be initialized.";
        case ERR_ROLLBACK_NOT_SUPPORTED: return "The function is not supported when a time limit is active.";
        case ERR_ROLLBACK_RESIZE: return "The results of the operation exceeded the size limits on the output data arrays.";
        case ERR_ROLLBACK_RESOURCE_CANNOT_UNLOCK: return "A resource conflict occurred in the timed environment. Two processes cannot manage the same resource and be time bounded.";
        case ERR_ROLLBACK_RESOURCE_CONFLICT_1: return "An image created before a time limit is started cannot be resized while a time limit is active.";
        case ERR_ROLLBACK_RESOURCE_CONFLICT_2: return "An image with pattern matching, calibration, or overlay information cannot be manipulated while a time limit is active.";
        case ERR_ROLLBACK_RESOURCE_CONFLICT_3: return "An image being modified by one process cannot be requested by another process while a time limit is active.";
        case ERR_ROLLBACK_RESOURCE_ENABLED: return "Multiple timed environments are not supported.";
        case ERR_ROLLBACK_RESOURCE_LOCKED: return "A resource conflict occurred in the timed environment. Two processes cannot access the same resource and be time bounded.";
        case ERR_ROLLBACK_RESOURCE_NON_EMPTY_INITIALIZE: return "Multiple timed environments are not supported.";
        case ERR_ROLLBACK_RESOURCE_OUT_OF_MEMORY: return "Not enough reserved memory in the timed environment for the requested operation.";
        case ERR_ROLLBACK_RESOURCE_REINITIALIZE: return "The timed environment is already initialized.";
        case ERR_ROLLBACK_RESOURCE_UNINITIALIZED_ENABLE: return "A time limit cannot be started until the timed environment is initialized.";
        case ERR_ROLLBACK_START_TIMER: return "A time limit could not be set.";
        case ERR_ROLLBACK_STOP_TIMER: return "No time limit is available to stop.";
        case ERR_ROLLBACK_TIMEOUT: return "The time limit has expired.";
        case ERR_ROLLBACK_UNBOUNDED_INTERFACE: return "During timed execution, you must use the preallocated version of this operation.";
        case ERR_ROTATION_ANGLE_RANGE_TOO_LARGE: return "At least one range in the array of rotation angle ranges exceeds 360 degrees.";
        case ERR_RPC_BIND: return "Unable to establish network connection.";
        case ERR_RPC_EXECUTE: return "Unable to display remote image on network connection.";
        case ERR_RPC_EXECUTE_IVB: return "Unable to establish network connection with remote system.";
        case ERR_SAME_WAVELET_BANDS_SELECTED: return "Same Wavelet band is selected multiple times";
        case ERR_SATURATION_THRESHOLD_OUT_OF_RANGE: return "The value of the saturation threshold must be from 0 to 255.";
        case ERR_SHAPEMATCH_BADIMAGEDATA: return "Shape Match requires the image to contain only pixel values of 0 or 1.";
        case ERR_SHAPEMATCH_BADTEMPLATE: return "The template you supplied for ShapeMatch contains no shape information.";
        case ERR_SMOOTH_CONTOURS_MUST_BE_SAME: return "You must specify the same value for the smooth contours advanced match option for all templates you want to match.";
        case ERR_SUCCESS: return "No error.";
        case ERR_SYSTEM_ERROR: return "System error.";
        case ERR_TEMPLATEDESCRIPTOR_LEARNSETUPDATA: return "Invalid template descriptor.";
        case ERR_TEMPLATEDESCRIPTOR_ROTATION_SEARCHSTRATEGY: return "The template descriptor does not contain data required for the requested search strategy in rotation-invariant matching.";
        case ERR_TEMPLATEIMAGE_EDGEINFO: return "The template image does not contain enough edge information for the sample size(s) requested.";
        case ERR_TEMPLATEIMAGE_NOCIRCLE: return "The template image does not contain enough information for learning the aggressive search strategy.";
        case ERR_TEMPLATE_DESCRIPTOR: return "Invalid template descriptor.";
        case ERR_TEMPLATE_DESCRIPTOR_1: return "Invalid template descriptor.";
        case ERR_TEMPLATE_DESCRIPTOR_2: return "Invalid template descriptor.";
        case ERR_TEMPLATE_DESCRIPTOR_3: return "Invalid template descriptor.";
        case ERR_TEMPLATE_DESCRIPTOR_4: return "The template descriptor was created with a newer version of NI Vision. Upgrade to the latest version of NI Vision to use this template.";
        case ERR_TEMPLATE_DESCRIPTOR_NOROTATION: return "The template descriptor does not contain data required for rotation-invariant matching.";
        case ERR_TEMPLATE_DESCRIPTOR_NOSCALE: return "The template descriptor does not contain data required for scale-invariant matching.";
        case ERR_TEMPLATE_DESCRIPTOR_NOSHIFT: return "The template descriptor does not contain data required for shift-invariant matching.";
        case ERR_TEMPLATE_DESCRIPTOR_ROTATION: return "Invalid template descriptor.";
        case ERR_TEMPLATE_DESCRIPTOR_ROTATION_1: return "Invalid template descriptor.";
        case ERR_TEMPLATE_DESCRIPTOR_SHIFT: return "Invalid template descriptor.";
        case ERR_TEMPLATE_DESCRIPTOR_SHIFT_1: return "Invalid template descriptor.";
        case ERR_TEMPLATE_EMPTY: return "The template image is empty.";
        case ERR_TEMPLATE_IMAGE_CONTRAST_TOO_LOW: return "The template image does not contain enough contrast.";
        case ERR_TEMPLATE_IMAGE_TOO_LARGE: return "The template image is too large.";
        case ERR_TEMPLATE_IMAGE_TOO_SMALL: return "The template image is too small.";
        case ERR_TEMPLATE_NOT_LEARNED: return "You supplied a template that was not learned.";
        case ERR_THREAD_COULD_NOT_INITIALIZE: return "Could not execute the function in the separate thread because the thread could not initialize.";
        case ERR_THREAD_INITIALIZING: return "Could not execute the function in the separate thread because the thread has not completed initialization.";
        case ERR_TIMEOUT: return "Trigger timeout.";
        case ERR_TIME_BOUNDED_EXECUTION_NOT_SUPPORTED: return "NI Vision no longer supports time-bounded execution.";
        case ERR_TOO_MANY_3DVISION_SESSIONS: return "There are too many 3D vision sessions open.  You must close a session before you can open another one.";
        case ERR_TOO_MANY_AVI_SESSIONS: return "There are too many AVI sessions open.  You must close a session before you can open another one.";
        case ERR_TOO_MANY_CLASSIFICATION_SESSIONS: return "There are too many classification sessions open.  You must close a session before you can open another one.";
        case ERR_TOO_MANY_CONTOURS: return "The ROI contains too many contours.";
        case ERR_TOO_MANY_CURVES: return "Too many curves extracted from image. Raise the edge threshold or reduce the ROI.";
        case ERR_TOO_MANY_OCCLUSION_RANGES: return "You can specify only one occlusion range.";
        case ERR_TOO_MANY_OCR_SESSIONS: return "There are too many OCR sessions open.  You must close a session before you can open another one.";
        case ERR_TOO_MANY_PARTICLES: return "The image has too many particles for this process.";
        case ERR_TOO_MANY_ROTATION_ANGLE_RANGES: return "The array of rotation angle ranges contains too many ranges.";
        case ERR_TOO_MANY_SCALE_RANGES: return "You can specify only one scale range.";
        case ERR_TOO_MANY_ZONES: return "The number of zones found exceeded the capacity of the algorithm.";
        case ERR_TRIG_TIMEOUT: return "Trigger timeout.";
        case ERR_UNDEF_POINT: return "You specified a point that lies outside the image.";
        case ERR_UNINIT: return "NI Vision did not initialize properly.";
        case ERR_UNKNOWN_ALGORITHM: return "You specified the dispatch status of an unknown algorithm.";
        case ERR_UNREGISTERED: return "Unlicensed copy of NI Vision.";
        case ERR_UNSUPPORTED_2D_BARCODE_SEARCH_MODE: return "NI Vision does not support the search mode you provided for the type of 2D barcode for which you are searching.";
        case ERR_UNSUPPORTED_COLOR_MODE: return "This function does not currently support the color mode you specified.";
        case ERR_UNSUPPORTED_JPEG2000_COLORSPACE_METHOD: return "NI Vision does not support reading JPEG2000 files with this colorspace method.";
        case ERR_VALUE_NOT_IN_ENUM: return "Value not in enumeration.";
        case ERR_WINDOW_ID: return "Invalid window ID.";
        case ERR_WRITE_FILE_NOT_SUPPORTED: return "Writing files is not supported on this device.";
        case ERR_WRONG_REGION_TYPE: return "You selected a region that is not of the right type.";
        case IMAQdxErrorAsyncRead: return "Unable to perform asychronous register read.";
        case IMAQdxErrorAsyncWrite: return "Unable to perform asychronous register write.";
        case IMAQdxErrorAttributeNotReadable: return "Unable to get attribute.";
        case IMAQdxErrorAttributeNotSettable: return "Unable to set attribute.";
        case IMAQdxErrorAttributeNotSupported: return "Attribute not supported by the camera.";
        case IMAQdxErrorAttributeOutOfRange: return "Attribute value is out of range.";
        case IMAQdxErrorBayerPixelFormatNotSelected: return "This operation requires that the camera has a Bayer pixel format selected.";
        case IMAQdxErrorBufferHasLostPackets: return "The requested buffer has lost packets and the user requested an error to be generated.";
        case IMAQdxErrorBufferIncompleteData: return "The requested buffer has incomplete data and the user requested an error to be generated.";
        case IMAQdxErrorBufferListEmpty: return "Buffer list is empty. Add one or more buffers.";
        case IMAQdxErrorBufferListLocked: return "Buffer list is already locked. Reconfigure acquisition and try again.";
        case IMAQdxErrorBufferListNotLocked: return "No buffer list. Reconfigure acquisition and try again.";
        case IMAQdxErrorBufferNotAvailable: return "Requested buffer is unavailable.";
        case IMAQdxErrorBusReset: return "Bus reset occurred during a transaction.";
        case IMAQdxErrorCameraAcquisitionConfigFailed: return "The camera returned an error starting the acquisition.";
        case IMAQdxErrorCameraClosePending: return "The camera still has outstanding references and will be closed when these operations complete.";
        case IMAQdxErrorCameraConfigurationHasChanged: return "The camera did not return an image of the correct type it was configured for previously.";
        case IMAQdxErrorCameraInUse: return "Camera is already in use.";
        case IMAQdxErrorCameraInvalidAuthentication: return "The camera is configured with password authentication and either the user name and password were not configured or they are incorrect.";
        case IMAQdxErrorCameraMulticastNotAvailable: return "Unable to configure the system for multicast support.";
        case IMAQdxErrorCameraNotConfiguredForListener: return "The camera is not configured properly to support a listener.";
        case IMAQdxErrorCameraNotFound: return "Camera not found";
        case IMAQdxErrorCameraNotInitialized: return "Camera is not initialized.";
        case IMAQdxErrorCameraNotRunning: return "No acquisition in progress.";
        case IMAQdxErrorCameraPropertyInvalid: return "The value for an invalid camera property was requested.";
        case IMAQdxErrorCameraRemoved: return "Camera has been removed.";
        case IMAQdxErrorCameraRunning: return "Acquisition in progress.";
        case IMAQdxErrorCameraUnreachable: return "Unable to connect to the camera.";
        case IMAQdxErrorCorruptedImageReceived: return "The camera returned a corrupted image.";
        case IMAQdxErrorDLLNotFound: return "The DLL could not be found.";
        case IMAQdxErrorFileAccess: return "Unable to read/write to file.";
        case IMAQdxErrorFirmwareUpdateNeeded: return "The acquisition hardware needs a firmware update before it can be used.";
        case IMAQdxErrorFirmwareUpdateRebootNeeded: return "The firmware on the acquisition hardware has been updated and the system must be rebooted before use.";
        case IMAQdxErrorFormat7Parameters: return "For format 7: The combination of speed, image position, image size, and color coding is incorrect.";
        case IMAQdxErrorFunctionNotFound: return "The function could not be found.";
        case IMAQdxErrorGenICamError: return "Unknown Genicam error.";
        case IMAQdxErrorGiGEVisionError: return "Unknown GiGE Vision error.";
        case IMAQdxErrorGuard: return "None";
        case IMAQdxErrorHighPerformanceNotSupported: return "High performance acquisition is not supported on the specified network interface. Connect the camera to a network interface running the high performance driver.";
        case IMAQdxErrorInterfaceNotRenamed: return "Unable to rename interface. Invalid or duplicate name specified.";
        case IMAQdxErrorInternal: return "Internal error";
        case IMAQdxErrorInvalidAddress: return "Invalid address";
        case IMAQdxErrorInvalidAttributeType: return "The attribute type is not compatible with the passed variable type.";
        case IMAQdxErrorInvalidCameraFile: return "Invalid camera file.";
        case IMAQdxErrorInvalidCameraURLString: return "Camera has malformed URL string.";
        case IMAQdxErrorInvalidDeviceType: return "Invalid device type";
        case IMAQdxErrorInvalidInterface: return "Invalid camera session";
        case IMAQdxErrorInvalidParameter: return "Invalid parameter";
        case IMAQdxErrorInvalidPointer: return "Invalid pointer";
        case IMAQdxErrorInvalidRegistryKey: return "Invalid registry key";
        case IMAQdxErrorInvalidU3VUSBDescriptor: return "The camera has a USB descriptor that is incompatible with the USB3 Vision specification.";
        case IMAQdxErrorInvalidXML: return "Unable to load camera's XML file.";
        case IMAQdxErrorJumboFramesNotEnabled: return "Jumbo frames are not enabled on the host.  Maximum packet size is 1500 bytes.";
        case IMAQdxErrorKernelDriverUnavailable: return "Unable to attach to the kernel mode driver.";
        case IMAQdxErrorLicenseNotActivated: return "License not activated.";
        case IMAQdxErrorLightingCurrentOutOfRange: return "The requested current level from the lighting controller is not possible.";
        case IMAQdxErrorNetworkError: return "Unknown network error.";
        case IMAQdxErrorNoSupportedVideoModes: return "The camera does not have any video modes which are supported.";
        case IMAQdxErrorNotImplemented: return "Not implemented";
        case IMAQdxErrorPixelFormatDecoderUnavailable: return "No decoder available for selected pixel format.";
        case IMAQdxErrorResourcesAllocated: return "Transfer engine resources already allocated. Reconfigure acquisition and try again.";
        case IMAQdxErrorResourcesUnavailable: return "Insufficient transfer engine resources.";
        case IMAQdxErrorSoftwareFault: return "An unexpected software error occurred.";
        case IMAQdxErrorSoftwareTriggerOverrun: return "Software trigger overrun.";
        case IMAQdxErrorSystemMemoryFull: return "Not enough memory";
        case IMAQdxErrorTestPacketNotReceived: return "The system did not receive a test packet from the camera. The packet size may be too large for the network configuration or a firewall may be enabled.";
        case IMAQdxErrorTimeout: return "Timeout.";
        case IMAQdxErrorU3VControlInterfaceError: return "There was an error from the control interface of the USB3 Vision camera.";
        case IMAQdxErrorU3VEventInterfaceError: return "There was an error from the event interface of the USB3 Vision camera.";
        case IMAQdxErrorU3VInsufficientPower: return "The USB3 Vision camera requires more current than can be supplied by the USB port in use.";
        case IMAQdxErrorU3VInvalidControlInterface: return "The USB3 Vision control interface is not implemented or is invalid on this camera.";
        case IMAQdxErrorU3VInvalidEventInterface: return "The USB3 Vision event interface is not implemented or is invalid on this camera.";
        case IMAQdxErrorU3VInvalidMaxCurrent: return "The U3V_MaximumCurrentUSB20_mA registry value is not valid for the connected USB3 Vision camera.";
        case IMAQdxErrorU3VInvalidStreamInterface: return "The USB3 Vision stream interface is not implemented or is invalid on this camera.";
        case IMAQdxErrorU3VStreamInterfaceError: return "There was an error from the stream interface of the USB3 Vision camera.";
        case IMAQdxErrorU3VUnsupportedConnectionSpeed: return "The USB connection speed is not supported by the camera.  Check whether the camera is plugged into a USB 2.0 port instead of a USB 3.0 port.  If so, verify that the camera supports this use case.";
        case IMAQdxErrorUSB3VisionError: return "Unknown USB3 Vision error.";
        case IMAQdxErrorUnknownHTTPError: return "The camera returned an unknown HTTP error.";
        default: return "Unknown error";
    }
}
